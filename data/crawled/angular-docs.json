[
  {
    "title": "Angular",
    "url": "https://v17.angular.io/guide/component-overview",
    "category": "angular",
    "content": "Angular components overviewlink Contents PrerequisitesCreating a componentCreating a component using the Angular CLICreating a component manuallySpecifying a component's CSS selectorDefining a component's templateDeclaring a component's stylesCreating a component manuallyNext steps Components are the main building blocks for Angular applications. Each component consists of: An HTML template that declares what renders on the page A TypeScript class that defines behavior A CSS selector that defines how the component is used in a template Optionally, CSS styles applied to the template This topic describes how to create and configure an Angular component. To view or download the example code used in this topic, see the live example / download example. Prerequisiteslink To create a component, verify that you have met the following prerequisites: Install the Angular CLI. Create an Angular workspace with initial application. If you don't have a project, create one using ng new project-name, where project-name is the name of your Angular application. Creating a componentlink The best way to create a component is with the Angular CLI. You can also create a component manually. Creating a component using the Angular CLIlink To create a component using the Angular CLI: From a terminal window, navigate to the directory containing your application. Run the ng generate component component-name command, where component-name is the name of your new component. By default, this command creates the following: A directory named after the component A component file, component-name.component.ts A template file, component-name.component.html A CSS file, component-name.component.css A testing specification file, component-name.component.spec.ts Where component-name is the name of your component. You can change how ng generate component creates new components. For more information, see ng generate component in the Angular CLI documentation. Creating a component manuallylink Although the Angular CLI is the best way to create an Angular component, you can also create a component manually. This section describes how to create the core component file within an existing Angular project. To create a new component manually: Navigate to your Angular project directory. Create a new file, component-name.component.ts. At the top of the file, add the following import statement. content_copy import { Component } from '@angular/core'; After the import statement, add a @Component decorator. content_copy @Component({ }) Choose a CSS selector for the component. content_copy @Component({ selector: 'app-component-overview', }) For more information on choosing a selector, see Specifying a component's selector. Define the HTML template that the component uses to display information. In most cases, this template is a separate HTML file. content_copy @Component({ selector: 'app-component-overview', templateUrl: './component-overview.component.html', }) For more information on defining a component's template, see Defining a component's template. Select the styles for the component's template. In most cases, you define the styles for your component's template in a separate file. content_copy @Component({ selector: 'app-component-overview', templateUrl: './component-overview.component.html', styleUrls: ['./component-overview.component.css'] }) Add a class statement that includes the code for the component. content_copy export class ComponentOverviewComponent { } Specifying a component's CSS selectorlink Every component requires a CSS selector. A selector instructs Angular to instantiate this component wherever it finds the corresponding tag in template HTML. For example, consider a component hello-world.component.ts that defines its selector as app-hello-world. This selector instructs Angular to instantiate this component any time the tag app-hello-world appears in a template. Specify a component's selector by adding a selector property to the @Component decorator. content_copy @Component({ selector: 'app-component-overview', }) Defining a component's templatelink A template is a block of HTML that tells Angular how to render the component in your application. Define a template for your component in one of two ways: by referencing an external file, or directly within the component. To define a template as an external file, add a templateUrl property to the @Component decorator. content_copy @Component({ selector: 'app-component-overview', templateUrl: './component-overview.component.html', }) To define a template within the component, add a template property to the @Component decorator that contains the HTML you want to use. content_copy @Component({ selector: 'app-component-overview', template: 'h1Hello World!/h1', }) If you want your template to span multiple lines, use backticks (). For example: content_copy @Component({ selector: 'app-component-overview', template:  h1Hello World!/h1 pThis template definition spans multiple lines./p  }) An Angular component requires a template defined using template or templateUrl. You cannot have both properties in a component. Declaring a component's styleslink Declare component styles used for its template in one of two ways: By referencing an external file, or directly within the component. To declare the styles for a component in a separate file, add a styleUrls property to the @Component decorator. content_copy @Component({ selector: 'app-component-overview', templateUrl: './component-overview.component.html', styleUrls: ['./component-overview.component.css'] }) To declare the styles within the component, add a styles property to the @Component decorator that contains the styles you want to use. content_copy @Component({ selector: 'app-component-overview', template: 'h1Hello World!/h1', styles: ['h1 { font-weight: normal; }'] }) The styles property takes an array of strings that contain the CSS rule declarations. Creating a component manuallylink Our recommendation is to make components standalone using the standalone: true flag in the @Component decorator. content_copy @Component({ selector: 'app-component-overview', template: 'h1Hello World!/h1', styles: ['h1 { font-weight: normal; }'], standalone: true }) However, in the case of working with a NgModule based application, the component needs to be added to the proper @NgModule. To embed a component in a module, embed it in the array of declarations found in the @NgModule decorator. content_copy // Your component path import {ComponentOverviewComponent} from './component-overview.component'; @NgModule({ declarations: [ // Existing Components ComponentOverviewComponent ] // Rest of the Module Content }) With these steps completed, your Angular component is ready for integration and use within your application. Next stepslink For an architectural overview of components, see Introduction to components and templates For additional options to use when creating a component, see Component in the API Reference For more information on styling components, see Component styles For more information on templates, see Template syntax Last reviewed on Sat Jul 29 2023",
    "headings": [
      {
        "level": 1,
        "text": "Angular components overviewlink",
        "id": "angular-components-overview"
      },
      {
        "level": 2,
        "text": "Prerequisiteslink",
        "id": "prerequisites"
      },
      {
        "level": 2,
        "text": "Creating a componentlink",
        "id": "creating-a-component"
      },
      {
        "level": 2,
        "text": "Specifying a component's CSS selectorlink",
        "id": "specifying-a-components-css-selector"
      },
      {
        "level": 2,
        "text": "Defining a component's templatelink",
        "id": "defining-a-components-template"
      },
      {
        "level": 2,
        "text": "Declaring a component's styleslink",
        "id": "declaring-a-components-styles"
      },
      {
        "level": 2,
        "text": "Next stepslink",
        "id": "next-steps"
      },
      {
        "level": 3,
        "text": "Creating a component using the Angular CLIlink",
        "id": "creating-a-component-using-the-angular-cli"
      },
      {
        "level": 3,
        "text": "Creating a component manuallylink",
        "id": "creating-a-component-manually"
      },
      {
        "level": 3,
        "text": "Creating a component manuallylink",
        "id": "creating-a-component-manually-1"
      }
    ],
    "codeBlocks": [
      {
        "language": "text",
        "code": "ng new <project-name>"
      },
      {
        "language": "text",
        "code": "<project-name>"
      },
      {
        "language": "text",
        "code": "ng generate component <component-name>"
      },
      {
        "language": "text",
        "code": "<component-name>"
      },
      {
        "language": "text",
        "code": "<component-name>.component.ts"
      },
      {
        "language": "text",
        "code": "<component-name>.component.html"
      },
      {
        "language": "text",
        "code": "<component-name>.component.css"
      },
      {
        "language": "text",
        "code": "<component-name>.component.spec.ts"
      },
      {
        "language": "text",
        "code": "<component-name>"
      },
      {
        "language": "text",
        "code": "ng generate component"
      },
      {
        "language": "text",
        "code": "<component-name>.component.ts"
      },
      {
        "language": "text",
        "code": "content_copy\n      \n      import { Component } from '@angular/core';"
      },
      {
        "language": "text",
        "code": "import { Component } from '@angular/core';"
      },
      {
        "language": "text",
        "code": "content_copy\n      \n      @Component({\n})"
      },
      {
        "language": "text",
        "code": "@Component({\n})"
      },
      {
        "language": "text",
        "code": "content_copy\n      \n      @Component({\n  selector: 'app-component-overview',\n})"
      },
      {
        "language": "text",
        "code": "@Component({\n  selector: 'app-component-overview',\n})"
      },
      {
        "language": "text",
        "code": "content_copy\n      \n      @Component({\n  selector: 'app-component-overview',\n  templateUrl: './component-overview.component.html',\n})"
      },
      {
        "language": "text",
        "code": "@Component({\n  selector: 'app-component-overview',\n  templateUrl: './component-overview.component.html',\n})"
      },
      {
        "language": "text",
        "code": "content_copy\n      \n      @Component({\n  selector: 'app-component-overview',\n  templateUrl: './component-overview.component.html',\n  styleUrls: ['./component-overview.component.css']\n})"
      },
      {
        "language": "text",
        "code": "@Component({\n  selector: 'app-component-overview',\n  templateUrl: './component-overview.component.html',\n  styleUrls: ['./component-overview.component.css']\n})"
      },
      {
        "language": "text",
        "code": "content_copy\n      \n      export class ComponentOverviewComponent {\n\n}"
      },
      {
        "language": "text",
        "code": "export class ComponentOverviewComponent {\n\n}"
      },
      {
        "language": "text",
        "code": "hello-world.component.ts"
      },
      {
        "language": "text",
        "code": "app-hello-world"
      },
      {
        "language": "text",
        "code": "<app-hello-world>"
      },
      {
        "language": "text",
        "code": "content_copy\n      \n      @Component({\n  selector: 'app-component-overview',\n})"
      },
      {
        "language": "text",
        "code": "@Component({\n  selector: 'app-component-overview',\n})"
      },
      {
        "language": "text",
        "code": "templateUrl"
      },
      {
        "language": "text",
        "code": "content_copy\n      \n      @Component({\n  selector: 'app-component-overview',\n  templateUrl: './component-overview.component.html',\n})"
      },
      {
        "language": "text",
        "code": "@Component({\n  selector: 'app-component-overview',\n  templateUrl: './component-overview.component.html',\n})"
      },
      {
        "language": "text",
        "code": "content_copy\n      \n      @Component({\n  selector: 'app-component-overview',\n  template: '<h1>Hello World!</h1>',\n})"
      },
      {
        "language": "text",
        "code": "@Component({\n  selector: 'app-component-overview',\n  template: '<h1>Hello World!</h1>',\n})"
      },
      {
        "language": "text",
        "code": "content_copy\n      \n      @Component({\n  selector: 'app-component-overview',\n  template: `\n    <h1>Hello World!</h1>\n    <p>This template definition spans multiple lines.</p>\n  `\n})"
      },
      {
        "language": "text",
        "code": "@Component({\n  selector: 'app-component-overview',\n  template: `\n    <h1>Hello World!</h1>\n    <p>This template definition spans multiple lines.</p>\n  `\n})"
      },
      {
        "language": "text",
        "code": "templateUrl"
      },
      {
        "language": "text",
        "code": "content_copy\n      \n      @Component({\n  selector: 'app-component-overview',\n  templateUrl: './component-overview.component.html',\n  styleUrls: ['./component-overview.component.css']\n})"
      },
      {
        "language": "text",
        "code": "@Component({\n  selector: 'app-component-overview',\n  templateUrl: './component-overview.component.html',\n  styleUrls: ['./component-overview.component.css']\n})"
      },
      {
        "language": "text",
        "code": "content_copy\n      \n      @Component({\n  selector: 'app-component-overview',\n  template: '<h1>Hello World!</h1>',\n  styles: ['h1 { font-weight: normal; }']\n})"
      },
      {
        "language": "text",
        "code": "@Component({\n  selector: 'app-component-overview',\n  template: '<h1>Hello World!</h1>',\n  styles: ['h1 { font-weight: normal; }']\n})"
      },
      {
        "language": "text",
        "code": "standalone: true"
      },
      {
        "language": "text",
        "code": "content_copy\n      \n      @Component({\n  selector: 'app-component-overview',\n  template: '<h1>Hello World!</h1>',\n  styles: ['h1 { font-weight: normal; }'],\n  standalone: true\n})"
      },
      {
        "language": "text",
        "code": "@Component({\n  selector: 'app-component-overview',\n  template: '<h1>Hello World!</h1>',\n  styles: ['h1 { font-weight: normal; }'],\n  standalone: true\n})"
      },
      {
        "language": "text",
        "code": "content_copy\n      \n      // Your component path\nimport {ComponentOverviewComponent} from './component-overview.component';\n\n@NgModule({\n  declarations: [\n    // Existing Components\n   ComponentOverviewComponent\n  ]\n  // Rest of the Module Content\n})"
      },
      {
        "language": "text",
        "code": "// Your component path\nimport {ComponentOverviewComponent} from './component-overview.component';\n\n@NgModule({\n  declarations: [\n    // Existing Components\n   ComponentOverviewComponent\n  ]\n  // Rest of the Module Content\n})"
      }
    ],
    "links": [
      {
        "text": "link",
        "href": "guide/component-overview#angular-components-overview"
      },
      {
        "text": "Prerequisites",
        "href": "guide/component-overview#prerequisites"
      },
      {
        "text": "Creating a component",
        "href": "guide/component-overview#creating-a-component"
      },
      {
        "text": "Creating a component using the Angular CLI",
        "href": "guide/component-overview#creating-a-component-using-the-angular-cli"
      },
      {
        "text": "Creating a component manually",
        "href": "guide/component-overview#creating-a-component-manually"
      },
      {
        "text": "Specifying a component's CSS selector",
        "href": "guide/component-overview#specifying-a-components-css-selector"
      },
      {
        "text": "Defining a component's template",
        "href": "guide/component-overview#defining-a-components-template"
      },
      {
        "text": "Declaring a component's styles",
        "href": "guide/component-overview#declaring-a-components-styles"
      },
      {
        "text": "Creating a component manually",
        "href": "guide/component-overview#creating-a-component-manually-1"
      },
      {
        "text": "Next steps",
        "href": "guide/component-overview#next-steps"
      },
      {
        "text": "live example",
        "href": "generated/live-examples/component-overview/stackblitz.html"
      },
      {
        "text": "download example",
        "href": "generated/zips/component-overview/component-overview.zip"
      },
      {
        "text": "link",
        "href": "guide/component-overview#prerequisites"
      },
      {
        "text": "Install the Angular CLI.",
        "href": "guide/setup-local#install-the-angular-cli"
      },
      {
        "text": "Create an Angular workspace",
        "href": "guide/setup-local#create-a-workspace-and-initial-application"
      },
      {
        "text": "link",
        "href": "guide/component-overview#creating-a-component"
      },
      {
        "text": "link",
        "href": "guide/component-overview#creating-a-component-using-the-angular-cli"
      },
      {
        "text": "ng generate component",
        "href": "cli/generate#component-command"
      },
      {
        "text": "link",
        "href": "guide/component-overview#creating-a-component-manually"
      },
      {
        "text": "Component",
        "href": "api/core/Component"
      },
      {
        "text": "Component",
        "href": "api/core/Component"
      },
      {
        "text": "Component",
        "href": "api/core/Component"
      },
      {
        "text": "Component",
        "href": "api/core/Component"
      },
      {
        "text": "Specifying a component's selector",
        "href": "guide/component-overview#specifying-a-components-css-selector"
      },
      {
        "text": "Component",
        "href": "api/core/Component"
      },
      {
        "text": "Defining a component's template",
        "href": "guide/component-overview#defining-a-components-template"
      },
      {
        "text": "Component",
        "href": "api/core/Component"
      },
      {
        "text": "link",
        "href": "guide/component-overview#specifying-a-components-css-selector"
      },
      {
        "text": "Component",
        "href": "api/core/Component"
      },
      {
        "text": "Component",
        "href": "api/core/Component"
      },
      {
        "text": "link",
        "href": "guide/component-overview#defining-a-components-template"
      },
      {
        "text": "Component",
        "href": "api/core/Component"
      },
      {
        "text": "Component",
        "href": "api/core/Component"
      },
      {
        "text": "Component",
        "href": "api/core/Component"
      },
      {
        "text": "Component",
        "href": "api/core/Component"
      },
      {
        "text": "Component",
        "href": "api/core/Component"
      },
      {
        "text": "multiple",
        "href": "api/forms/SelectMultipleControlValueAccessor"
      },
      {
        "text": "link",
        "href": "guide/component-overview#declaring-a-components-styles"
      },
      {
        "text": "Component",
        "href": "api/core/Component"
      },
      {
        "text": "Component",
        "href": "api/core/Component"
      },
      {
        "text": "Component",
        "href": "api/core/Component"
      },
      {
        "text": "Component",
        "href": "api/core/Component"
      },
      {
        "text": "link",
        "href": "guide/component-overview#creating-a-component-manually-1"
      },
      {
        "text": "Component",
        "href": "api/core/Component"
      },
      {
        "text": "Component",
        "href": "api/core/Component"
      },
      {
        "text": "NgModule",
        "href": "api/core/NgModule"
      },
      {
        "text": "NgModule",
        "href": "api/core/NgModule"
      },
      {
        "text": "NgModule",
        "href": "api/core/NgModule"
      },
      {
        "text": "NgModule",
        "href": "api/core/NgModule"
      },
      {
        "text": "link",
        "href": "guide/component-overview#next-steps"
      },
      {
        "text": "Introduction to components and templates",
        "href": "guide/architecture-components"
      },
      {
        "text": "Component",
        "href": "api/core/Component"
      },
      {
        "text": "Component styles",
        "href": "guide/component-styles"
      },
      {
        "text": "Template syntax",
        "href": "guide/template-syntax"
      }
    ],
    "meta": {
      "description": "",
      "keywords": ""
    },
    "summary": "Angular components overviewlink Contents PrerequisitesCreating a componentCreating a component using the Angular CLICreating a component manuallySpecifying a component's CSS selectorDefining a compone...",
    "tags": [
      "react",
      "angular",
      "typescript",
      "css",
      "html",
      "node",
      "vite",
      "component",
      "creating",
      "manuallylink"
    ],
    "id": "angular-componentoverview-part-1",
    "quality": 90
  },
  {
    "title": "Angular",
    "url": "https://v17.angular.io/guide/template-syntax",
    "category": "angular",
    "content": "Template syntaxlink Contents PrerequisitesEmpower your HTMLMore on template syntax In Angular, a template is a chunk of HTML. Use special syntax within a template to build on many of Angular's features. Prerequisiteslink Before learning template syntax, you should be familiar with the following: Angular concepts JavaScript HTML CSS Each Angular template in your application is a section of HTML to include as a part of the page that the browser displays. An Angular HTML template renders a view, or user interface, in the browser, just like regular HTML, but with a lot more functionality. When you generate an Angular application with the Angular CLI, the app.component.html file is the default template containing placeholder HTML. The template syntax guides show you how to control the UX/UI by coordinating data between the class and the template. Most of the Template Syntax guides have dedicated working example applications that demonstrate the individual topic of each guide. To see all of them working together in one application, see the comprehensive Template Syntax Live Code / download example. Empower your HTMLlink Extend the HTML vocabulary of your applications with special Angular syntax in your templates. For example, Angular helps you get and set DOM (Document Object Model) values dynamically with features such as built-in template functions, variables, event listening, and data binding. Almost all HTML syntax is valid template syntax. However, because an Angular template is part of an overall webpage, and not the entire page, you don't need to include elements such as html, body, or base, and can focus exclusively on the part of the page you are developing. To eliminate the risk of script injection attacks, Angular does not support the script element in templates. Angular ignores the script tag and outputs a warning to the browser console. For more information, see the Security page. More on template syntaxlink You might also be interested in the following: Topics Details Interpolation Learn how to use interpolation and expressions in HTML. Template statements Respond to events in your templates. Binding syntax Use binding to coordinate values in your application. Property binding Set properties of target elements or directive @Input() decorators. Attribute, class, and style bindings Set the value of attributes, classes, and styles. Event binding Listen for events and your HTML. Two-way binding Share data between a class and its template. Built-in directives Listen to and modify the behavior and layout of HTML. Template reference variables Use special variables to reference a DOM element within a template. Inputs and Outputs Share data between the parent context and child directives or components Template expression operators Learn about the pipe operator (), and protect against null or undefined values in your HTML. SVG in templates Dynamically generate interactive graphics. Last reviewed on Mon Feb 28 2022",
    "headings": [
      {
        "level": 1,
        "text": "Template syntaxlink",
        "id": "template-syntax"
      },
      {
        "level": 2,
        "text": "Prerequisiteslink",
        "id": "prerequisites"
      },
      {
        "level": 2,
        "text": "Empower your HTMLlink",
        "id": "empower-your-html"
      },
      {
        "level": 2,
        "text": "More on template syntaxlink",
        "id": "more-on-template-syntax"
      }
    ],
    "codeBlocks": [
      {
        "language": "text",
        "code": "app.component.html"
      }
    ],
    "links": [
      {
        "text": "link",
        "href": "guide/template-syntax#template-syntax"
      },
      {
        "text": "Prerequisites",
        "href": "guide/template-syntax#prerequisites"
      },
      {
        "text": "Empower your HTML",
        "href": "guide/template-syntax#empower-your-html"
      },
      {
        "text": "More on template syntax",
        "href": "guide/template-syntax#more-on-template-syntax"
      },
      {
        "text": "link",
        "href": "guide/template-syntax#prerequisites"
      },
      {
        "text": "Angular concepts",
        "href": "guide/architecture"
      },
      {
        "text": "Template Syntax Live Code",
        "href": "generated/live-examples/template-syntax/stackblitz.html"
      },
      {
        "text": "download example",
        "href": "generated/zips/template-syntax/template-syntax.zip"
      },
      {
        "text": "link",
        "href": "guide/template-syntax#empower-your-html"
      },
      {
        "text": "Security",
        "href": "guide/security"
      },
      {
        "text": "link",
        "href": "guide/template-syntax#more-on-template-syntax"
      },
      {
        "text": "Interpolation",
        "href": "guide/interpolation"
      },
      {
        "text": "Template statements",
        "href": "guide/template-statements"
      },
      {
        "text": "Binding syntax",
        "href": "guide/binding-syntax"
      },
      {
        "text": "Property binding",
        "href": "guide/property-binding"
      },
      {
        "text": "Input",
        "href": "api/core/Input"
      },
      {
        "text": "Attribute, class, and style bindings",
        "href": "guide/attribute-binding"
      },
      {
        "text": "Event binding",
        "href": "guide/event-binding"
      },
      {
        "text": "Two-way binding",
        "href": "guide/two-way-binding"
      },
      {
        "text": "Built-in directives",
        "href": "guide/built-in-directives"
      },
      {
        "text": "Template reference variables",
        "href": "guide/template-reference-variables"
      },
      {
        "text": "Inputs and Outputs",
        "href": "guide/inputs-outputs"
      },
      {
        "text": "Template expression operators",
        "href": "guide/template-expression-operators"
      },
      {
        "text": "SVG in templates",
        "href": "guide/svg-in-templates"
      }
    ],
    "meta": {
      "description": "",
      "keywords": ""
    },
    "summary": "Template syntaxlink Contents PrerequisitesEmpower your HTMLMore on template syntax In Angular, a template is a chunk of HTML. Use special syntax within a template to build on many of Angular's features",
    "tags": [
      "react",
      "vue",
      "angular",
      "javascript",
      "typescript",
      "css",
      "html",
      "vite",
      "template",
      "syntaxlink"
    ],
    "id": "angular-templatesyntax-part-1",
    "quality": 90
  },
  {
    "title": "Angular",
    "url": "https://v17.angular.io/guide/lifecycle-hooks",
    "category": "angular",
    "content": "Component Lifecyclelink Contents PrerequisitesResponding to lifecycle eventsLifecycle event sequenceLifecycle example setInitializing a component or directiveCleaning up on instance destructionngOnDestroyDestroyReftakeUntilDestroyedReading and writing the DOMOne-time initializationHandling synchronizationGeneral examplesSequence and frequency of all lifecycle eventsUse directives to watch the DOMUse component and directive hooks togetherUsing change detection hooksResponding to view changesResponding to projected content changesDefining custom change detection A component instance has a lifecycle that starts when Angular instantiates the component class and renders the component view along with its child views. The lifecycle continues with change detection, as Angular checks to see when data-bound properties change, and updates both the view and the component instance as needed. The lifecycle ends when Angular destroys the component instance and removes its rendered template from the DOM. Directives have a similar lifecycle, as Angular creates, updates, and destroys instances in the course of execution. Your application can use lifecycle hook methods to tap into key events in the lifecycle of a component or directive to initialize new instances, initiate change detection when needed, respond to updates during change detection, and clean up before deletion of instances. Prerequisiteslink Before working with lifecycle hooks, you should have a basic understanding of the following: TypeScript programming Angular app-design fundamentals, as described in Angular Concepts Responding to lifecycle eventslink Respond to events in the lifecycle of a component or directive by implementing one or more of the lifecycle hook interfaces in the Angular core library. The hooks give you the opportunity to act on a component or directive instance at the appropriate moment, as Angular creates, updates, or destroys that instance. Each interface defines the prototype for a single hook method, whose name is the interface name prefixed with ng. For example, the OnInit interface has a hook method named ngOnInit(). If you implement this method in your component or directive class, Angular calls it shortly after checking the input properties for that component or directive for the first time. content_copy @Directive({selector: '[appPeekABoo]'}) export class PeekABooDirective implements OnInit { constructor(private logger: LoggerService) { } // implement OnInit's ngOnInit method ngOnInit() { this.logIt('OnInit'); } logIt(msg: string) { this.logger.log(#${nextId++} ${msg}); } } You don't have to implement all (or any) of the lifecycle hooks, just the ones you need. Lifecycle event sequencelink After your application instantiates a component or directive by calling its constructor, Angular calls the hook methods you have implemented at the appropriate point in the lifecycle of that instance. Angular executes hook methods in the following sequence. Use them to perform the following kinds of operations. Hook method Purpose Timing ngOnChanges() Respond when Angular sets or resets data-bound input properties. The method receives a SimpleChanges object of current and previous property values. NOTE: This happens frequently, so any operation you perform here impacts performance significantly. See details in Using change detection hooks in this document. Called before ngOnInit() (if the component has bound inputs) and whenever one or more data-bound input properties change. NOTE: If your component has no inputs or you use it without providing any inputs, the framework will not call ngOnChanges(). ngOnInit() Initialize the directive or component after Angular first displays the data-bound properties and sets the directive or component's input properties. See details in Initializing a component or directive in this document. Called once, after the first ngOnChanges(). ngOnInit() is still called even when ngOnChanges() is not (which is the case when there are no template-bound inputs). ngDoCheck() Detect and act upon changes that Angular can't or won't detect on its own. See details and example in Defining custom change detection in this document. Called immediately after ngOnChanges() on every change detection run, and immediately after ngOnInit() on the first run. ngAfterContentInit() Respond after Angular projects external content into the component's view, or into the view that a directive is in. See details and example in Responding to changes in content in this document. Called once after the first ngDoCheck(). ngAfterContentChecked() Respond after Angular checks the content projected into the directive or component. See details and example in Responding to projected content changes in this document. Called after ngAfterContentInit() and every subsequent ngDoCheck(). ngAfterViewInit() Respond after Angular initializes the component's views and child views, or the view that contains the directive. See details and example in Responding to view changes in this document. Called once after the first ngAfterContentChecked(). ngAfterViewChecked() Respond after Angular checks the component's views and child views, or the view that contains the directive. Called after the ngAfterViewInit() and every subsequent ngAfterContentChecked(). ngOnDestroy() Cleanup just before Angular destroys the directive or component. Unsubscribe Observables and detach event handlers to avoid memory leaks. See details in Cleaning up on instance destruction in this document. Called immediately before Angular destroys the directive or component. Lifecycle example setlink The live example / download example demonstrates the use of lifecycle hooks through a series of exercises presented as components under the control of the root AppComponent. In each case a parent component serves as a test rig for a child component that illustrates one or more of the lifecycle hook methods. The following table lists the exercises with brief descriptions. The sample code is also used to illustrate specific tasks in the following sections. Component Details Peek-a-boo Demonstrates every lifecycle hook. Each hook method writes to the on-screen log. Spy Shows how to use lifecycle hooks with a custom directive. The SpyDirective implements the ngOnInit() and ngOnDestroy() hooks, and uses them to watch and report when an element goes in or out of the current view. OnChanges Demonstrates how Angular calls the ngOnChanges() hook every time one of the component input properties changes, and shows how to interpret the changes object passed to the hook method. DoCheck Implements the ngDoCheck() method with custom change detection. Watch the hook post changes to a log to see how often Angular calls this hook. AfterView Shows what Angular means by a view. Demonstrates the ngAfterViewInit() and ngAfterViewChecked() hooks. AfterContent Shows how to project external content into a component and how to distinguish projected content from a component's view children. Demonstrates the ngAfterContentInit() and ngAfterContentChecked() hooks. Counter Demonstrates a combination of a component and a directive, each with its own hooks. Initializing a component or directivelink Use the ngOnInit() method to perform the following initialization tasks. Initialization tasks Details Perform complex initializations outside of the constructor Components should be cheap and safe to construct. You should not, for example, fetch data in a component constructor. You shouldn't worry that a new component will try to contact a remote server when created under test or before you decide to display it. An ngOnInit() is a good place for a component to fetch its initial data. For an example, see the Tour of Heroes tutorial. Set up the component after Angular sets the input properties Constructors should do no more than set the initial local variables to simple values. Keep in mind that a directive's data-bound input properties are not set until after construction. If you need to initialize the directive based on those properties, set them when ngOnInit() runs. The ngOnChanges() method is your first opportunity to access those properties. Angular calls ngOnChanges() before ngOnInit(), but also many times after that. It only calls ngOnInit() once. Cleaning up on instance destructionlink Angular provides several ways to clean up when an instance is destroyed. ngOnDestroylink You can put cleanup logic in ngOnDestroy(), the logic that must run before Angular destroys the directive. This is the place to free resources that won't be garbage-collected automatically. You risk memory leaks if you neglect to do so. Unsubscribe from Observables and DOM events Stop interval timers Unregister all callbacks that the directive registered with global or application services The ngOnDestroy() method is also the time to notify another part of the application that the component is going away. DestroyReflink In addition to ngOnDestroy(), you can inject Angular's DestroyRef and register callback functions to be called when the enclosing context is destroyed. This can be useful for building reusable utilities that require cleanup. Register a callback with the DestroyRef: content_copy @Component(...) class Counter { count = 0; constructor() { // Start a timer to increment the counter every second. const id = setInterval(() = this.count++, 1000); // Stop the timer when the component is destroyed. const destroyRef = inject(DestroyRef); destroyRef.onDestroy(() = clearInterval(id)); } } Like ngOnDestroy, DestroyRef works in any Angular service, directive, component, or pipe. takeUntilDestroyedlink takeUntilDestroyed is available for developer preview. It's ready for you to try, but it might change before it is stable. When using RxJS Observables in components or directives, you may want to complete any observables when the component or directive is destroyed. Angular's @angular/core/rxjs-interop package provides an operator, takeUntilDestroyed, to simplify this common task: content_copy data$ = http.get('...').pipe(takeUntilDestroyed()); By default, takeUntilDestroyed must be called in an injection context so that it can access DestroyRef. If an injection context isn't available, you can explicitly provide a DestroyRef. Reading and writing the DOMlink Sometimes it's necessary to use browser-only APIs to manually read or write the DOM. This can be challenging to do with the lifecycle events above, as they will also run during server-side rendering and pre-rendering. For this purpose, Angular provides afterRender and afterNextRender. These functions can be used unconditionally, but will only have an effect on the browser. Both functions accept a callback that will run after the next change detection cycle (including any nested cycles) has completed. afterRender and afterNextRender are available for developer preview. They are ready for you to try, but they might change before they are stable. Function Purpose Timing afterNextRender Perform one-time initialization, or observe a single, specific change to the DOM. As a rule of thumb, you should use afterRender instead if you need to manually read or write any layout data such as size or location. See details in One-time initialization in this document. Once after the next change detection cycle. afterRender Synchronize state with the DOM. See details in Handling synchronization in this document. After every change detection cycle that follows. One-time initializationlink Generally, you will want to use afterNextRender to perform any one-time initialization, such as for a third-party library, or for browser-only APIs. content_copy @Component({ selector: 'my-chart-cmp', template: div #chart{{ ... }}/div, }) export class MyChartCmp { @ViewChild('chart') chartRef: ElementRef; chart: MyChartnull; constructor() { afterNextRender(() = { this.chart = new MyChart(this.chartRef.nativeElement); }, {phase: AfterRenderPhase.Write}); } } Instead of attempting to recreate their behaviors with afterRender, you should prefer to use built-in browser APIs like ResizeObserver and IntersectionObserver wherever possible. You can use afterNextRender to safely initialize such APIs on the browser only. content_copy @Component({ selector: 'my-cmp', template: span #content{{ ... }}/span, }) export class MyComponent { resizeObserver: ResizeObservernull = null; @ViewChild('content') contentRef: ElementRef; constructor() { afterNextRender(() = { this.resizeObserver = new ResizeObserver(() = { console.log('Content was resized'); }); this.resizeObserver.observe(this.contentRef.nativeElement); }, {phase: AfterRenderPhase.Write}); } ngOnDestroy() { this.resizeObserver?.disconnect(); this.resizeObserver = null; } } As a rule of thumb, afterNextRender should be used to observe discrete changes to the DOM, such as element creation or deletion. For manually reading or writing data that tends to change frequently, such as size or location, you should generally prefer to use afterRender instead. Handling synchronizationlink As an escape hatch for when the browser does not provide a better API to do so, you can use afterRender to perform any additional read or writes to the DOM every time Angular finishes mutating it. content_copy @Component({ selector: 'my-cmp', template: span #content{{ ... }}/span, }) export class MyComponent { @ViewChild('content') contentRef: ElementRef; constructor() { afterRender(() = { const elem = this.contentRef.nativeElement; console.log(content position: (${elem.offsetLeft}, ${elem.offsetTop})); }, {phase: AfterRenderPhase.Read}); } } General exampleslink The following examples demonstrate the call sequence and relative frequency of the various lifecycle events, and how the hooks can be used separately or together for components and directives. Sequence and frequency of all lifecycle eventslink To show how Angular calls the hooks in the expected order, the PeekABooComponent demonstrates all of the hooks in one component. In practice you would rarely, if ever, implement all of the interfaces the way this demo does. The following snapshot reflects the state of the log after the user clicked the Create button and then the Destroy button. The sequence of log messages follows the prescribed hook calling order: Hook order Log message 1 OnChanges 2 OnInit 3 DoCheck 4 AfterContentInit 5 AfterContentChecked 6 AfterViewInit 7 AfterViewChecked 8 DoCheck 9 AfterContentChecked 10 AfterViewChecked 11 OnDestroy Notice that the log confirms that input properties (the name property in this case) have no assigned values at construction. The input properties are available to the onInit() method for further initialization. Had the user clicked the Update Hero button, the log would show another OnChanges and two more triplets of DoCheck, AfterContentChecked, and AfterViewChecked. Notice that these three hooks fire often, so it is important to keep their logic as lean as possible. Use directives to watch the DOMlink The Spy example demonstrates how to use the hook method for directives as well as components. The SpyDirective implements two hooks, ngOnInit() and ngOnDestroy(), to discover when a watched element is in the current view. This template applies the SpyDirective to a div in the ngFor hero repeater managed by the parent SpyComponent. The example does not perform any initialization or clean-up. It just tracks the appearance and disappearance of an element in the view by recording when the directive itself is instantiated and destroyed. A spy directive like this can provide insight into a DOM object that you cannot change directly. You can't access the implementation of a built-in div, or modify a third party component. You do have the option to watch these elements with a directive. The directive defines ngOnInit() and ngOnDestroy() hooks that log messages to the parent using an injected LoggerService. content_copy let nextId = 1; // Spy on any element to which it is applied. // Usage: div appSpy.../div @Directive({selector: '[appSpy]'}) export class SpyDirective implements OnInit, OnDestroy { private id = nextId++; constructor(private logger: LoggerService) { } ngOnInit() { this.logger.log(Spy #${this.id} onInit); } ngOnDestroy() { this.logger.log(Spy #${this.id} onDestroy); } } Apply the spy to any built-in or component element, and see that it is initialized and destroyed at the same time as that element. Here it is attached to the repeated hero p: content_copy p *ngFor=\"let hero of heroes\" appSpy {{hero}} /p Each spy's creation and destruction marks the appearance and disappearance of the attached hero p with an entry in the Hook Log. Adding a hero results in a new hero p. The spy's ngOnInit() logs that event. The Reset button clears the heroes list. Angular removes all hero p elements from the DOM and destroys their spy directives at the same time. The spy's ngOnDestroy() method reports its last moments. Use component and directive hooks togetherlink In this example, a CounterComponent uses the ngOnChanges() method to log a change every time the parent component increments its input counter property. This example applies the SpyDirective from the previous example to the CounterComponent log, to watch the creation and destruction of log entries. Using change detection hookslink Angular calls the ngOnChanges() method of a component or directive whenever it detects changes to the input properties. The onChanges example demonstrates this by monitoring the OnChanges() hook. content_copy ngOnChanges(changes: SimpleChanges) { for (const propName in changes) { const chng = changes[propName]; const cur = JSON.stringify(chng.currentValue); const prev = JSON.stringify(chng.previousValue); this.changeLog.push(${propName}: currentValue = ${cur}, previousValue = ${prev}); } } The ngOnChanges() method takes an object that maps each changed property name to a SimpleChange object holding the current and previous property values. This hook iterates over the changed properties and logs them. The example component, OnChangesComponent, has two input properties: hero and power. content_copy @Input() hero!: Hero; @Input() power = ''; The host OnChangesParentComponent binds to them as follows. content_copy on-changes [hero]=\"hero\" [power]=\"power\"/on-changes Here's the sample in action as the user makes changes. The log entries appear as the string value of the power property changes. Notice, however, that the ngOnChanges() method does not catch changes to hero.name. This is because Angular calls the hook only when the value of the input property changes. In this case, hero is the input property, and the value of the hero property is the reference to the hero object. The object reference did not change when the value of its own name property changed. Responding to view changeslink As Angular traverses the view hierarchy during change detection, it needs to be sure that a change in a child does not attempt to cause a change in its own parent. Such a change would not be rendered properly, because of how unidirectional data flow works. If you need to make a change that inverts the expected data flow, you must trigger a new change detection cycle to allow that change to be rendered. The examples illustrate how to make such changes safely. The AfterView sample explores the AfterViewInit() and AfterViewChecked() hooks that Angular calls after it creates a component's child views. Here's a child view that displays a hero's name in an input: content_copy @Component({ selector: 'app-child-view', template:  label for=\"hero-name\"Hero name: /label input type=\"text\" id=\"hero-name\" [(ngModel)]=\"hero\"  }) export class ChildViewComponent { hero = 'Magneta'; } The AfterViewComponent displays this child view within its template: content_copy template:  divchild view begins/div app-child-view/app-child-view divchild view ends/div  The following hooks take action based on changing values within the child view, which can only be reached by querying for the child view using the property decorated with @ViewChild. content_copy export class AfterViewComponent implements AfterViewChecked, AfterViewInit { private prevHero = ''; // Query for a VIEW child of type ChildViewComponent @ViewChild(ChildViewComponent) viewChild!: ChildViewComponent; ngAfterViewInit() { // viewChild is set after the view has been initialized this.logIt('AfterViewInit'); this.doSomething(); } ngAfterViewChecked() { // viewChild is updated after the view has been checked if (this.prevHero === this.viewChild.hero) { this.logIt('AfterViewChecked (no change)'); } else { this.prevHero = this.viewChild.hero; this.logIt('AfterViewChecked'); this.doSomething(); } } // ... } Wait before updating the viewlink In this example, the doSomething() method updates the screen when the hero name exceeds 10 characters, but waits a tick before updating comment. content_copy // This surrogate for real business logic sets the comment private doSomething() { const c = this.viewChild.hero.length  10 ? \"That's a long name\" : ''; if (c !== this.comment) { // Wait a tick because the component's view has already been checked this.logger.tick_then(() = this.comment = c); } } Both the AfterViewInit() and AfterViewChecked() hooks fire after the component's view is composed. If you modify the code so that the hook updates the component's data-bound comment property immediately, you can see that Angular throws an error. The LoggerService.tick_then() statement postpones the log update for one turn of the browser's JavaScript cycle, which triggers a new change-detection cycle. Write lean hook methods to avoid performance problemslink When you run the AfterView sample, notice how frequently Angular calls AfterViewChecked() - often when there are no changes of interest. Be careful about how much logic or computation you put into one of these methods. Responding to projected content changeslink Content projection is a way to import HTML content from outside the component and insert that content into the component's template in a designated spot. Identify content projection in a template by looking for the following constructs. HTML between component element tags The presence of ng-content tags in the component's template AngularJS developers know this technique as transclusion. The AfterContent sample explores the AfterContentInit() and AfterContentChecked() hooks that Angular calls after Angular projects external content into the component. Consider this variation on the previous AfterView example. This time, instead of including the child view within the template, it imports the content from the AfterContentComponent hook's parent. The following is the parent's template. content_copy after-content app-child/app-child /after-content Notice that the app-child tag is tucked between the after-content tags. Never put content between a component's element tags unless you intend to project that content into the component. Now look at the component's template. content_copy template:  divprojected content begins/div ng-content/ng-content divprojected content ends/div  The ng-content tag is a placeholder for the external content. It tells Angular where to insert that content. In this case, the projected content is the app-child from the parent. Using AfterContent hookslink AfterContent hooks are similar to the AfterView hooks. The key difference is in the child component. The AfterView hooks concern ViewChildren, the child components whose element tags appear within the component's template The AfterContent hooks concern ContentChildren, the child components that Angular projected into the component The following AfterContent hooks take action based on changing values in a content child, which can only be reached by querying for them using the property decorated with @ContentChild. content_copy export class AfterContentComponent implements AfterContentChecked, AfterContentInit { private prevHero = ''; comment = ''; // Query for a CONTENT child of type ChildComponent @ContentChild(ChildComponent) contentChild!: ChildComponent; ngAfterContentInit() { // contentChild is set after the content has been initialized this.logIt('AfterContentInit'); this.doSomething(); } ngAfterContentChecked() { // contentChild is updated after the content has been checked if (this.prevHero === this.contentChild.hero) { this.logIt('AfterContentChecked (no change)'); } else { this.prevHero = this.contentChild.hero; this.logIt('AfterContentChecked'); this.doSomething(); } } // ... } This component's doSomething() method updates the component's data-bound comment property immediately. There's no need to delay the update to ensure proper rendering. Angular calls both AfterContent hooks before calling either of the AfterView hooks. Angular completes composition of the projected content before finishing the composition of this component's view. There is a small window between the AfterContent... and AfterView... hooks that lets you modify the host view. Defining custom change detectionlink To monitor changes that occur where ngOnChanges() won't catch them, implement your own change check, as shown in the DoCheck example. This example shows how to use the ngDoCheck() hook to detect and act upon changes that Angular doesn't catch on its own. The DoCheck sample extends the OnChanges sample with the following ngDoCheck() hook: content_copy ngDoCheck() { if (this.hero.name !== this.oldHeroName) { this.changeDetected = true; this.changeLog.push(DoCheck: Hero name changed to \"${this.hero.name}\" from \"${this.oldHeroName}\"); this.oldHeroName = this.hero.name; } if (this.power !== this.oldPower) { this.changeDetected = true; this.changeLog.push(DoCheck: Power changed to \"${this.power}\" from \"${this.oldPower}\"); this.oldPower = this.power; } if (this.changeDetected) { this.noChangeCount = 0; } else { // log that hook was called when there was no relevant change. const count = this.noChangeCount += 1; const noChangeMsg = DoCheck called ${count}x when no change to hero or power; if (count === 1) { // add new \"no change\" message this.changeLog.push(noChangeMsg); } else { // update last \"no change\" message this.changeLog[this.changeLog.length - 1] = noChangeMsg; } } this.changeDetected = false; } This code inspects certain values of interest, capturing and comparing their current state against previous values. It writes a special message to the log when there are no substantive changes to the hero or the power so you can see how often DoCheck() is called. The results are illuminating. While the ngDoCheck() hook can detect when the hero's name has changed, it is an expensive hook. This hook is called with enormous frequency after every change detection cycle no matter where the change occurred. It's called over twenty times in this example before the user can do anything. Most of these initial checks are triggered by Angular's first rendering of unrelated data elsewhere on the page. Just moving the cursor into another input triggers a call. Relatively few calls reveal actual changes to pertinent data. If you use this hook, your implementation must be extremely lightweight or the user experience suffers. Last reviewed on Mon Feb 28 2022",
    "headings": [
      {
        "level": 1,
        "text": "Component Lifecyclelink",
        "id": "component-lifecycle"
      },
      {
        "level": 2,
        "text": "Prerequisiteslink",
        "id": "prerequisites"
      },
      {
        "level": 2,
        "text": "Responding to lifecycle eventslink",
        "id": "responding-to-lifecycle-events"
      },
      {
        "level": 2,
        "text": "Initializing a component or directivelink",
        "id": "initializing-a-component-or-directive"
      },
      {
        "level": 2,
        "text": "Cleaning up on instance destructionlink",
        "id": "cleaning-up-on-instance-destruction"
      },
      {
        "level": 2,
        "text": "Reading and writing the DOMlink",
        "id": "reading-and-writing-the-dom"
      },
      {
        "level": 2,
        "text": "General exampleslink",
        "id": "general-examples"
      },
      {
        "level": 2,
        "text": "Using change detection hookslink",
        "id": "using-change-detection-hooks"
      },
      {
        "level": 2,
        "text": "Defining custom change detectionlink",
        "id": "defining-custom-change-detection"
      },
      {
        "level": 3,
        "text": "Lifecycle event sequencelink",
        "id": "lifecycle-event-sequence"
      },
      {
        "level": 3,
        "text": "Lifecycle example setlink",
        "id": "lifecycle-example-set"
      },
      {
        "level": 3,
        "text": "ngOnDestroylink",
        "id": "ngondestroy"
      },
      {
        "level": 3,
        "text": "DestroyReflink",
        "id": "destroyref"
      },
      {
        "level": 3,
        "text": "takeUntilDestroyedlink",
        "id": "takeuntildestroyed"
      },
      {
        "level": 3,
        "text": "One-time initializationlink",
        "id": "one-time-initialization"
      },
      {
        "level": 3,
        "text": "Handling synchronizationlink",
        "id": "handling-synchronization"
      },
      {
        "level": 3,
        "text": "Sequence and frequency of all lifecycle eventslink",
        "id": "sequence-and-frequency-of-all-lifecycle-events"
      },
      {
        "level": 3,
        "text": "Use directives to watch the DOMlink",
        "id": "use-directives-to-watch-the-dom"
      },
      {
        "level": 3,
        "text": "Use component and directive hooks togetherlink",
        "id": "use-component-and-directive-hooks-together"
      },
      {
        "level": 3,
        "text": "Responding to view changeslink",
        "id": "responding-to-view-changes"
      },
      {
        "level": 3,
        "text": "Responding to projected content changeslink",
        "id": "responding-to-projected-content-changes"
      },
      {
        "level": 4,
        "text": "Wait before updating the viewlink",
        "id": "wait-before-updating-the-view"
      },
      {
        "level": 4,
        "text": "Write lean hook methods to avoid performance problemslink",
        "id": "write-lean-hook-methods-to-avoid-performance-problems"
      },
      {
        "level": 4,
        "text": "Using AfterContent hookslink",
        "id": "using-aftercontent-hooks"
      }
    ],
    "codeBlocks": [
      {
        "language": "text",
        "code": "ngOnDestroy"
      },
      {
        "language": "text",
        "code": "takeUntilDestroyed"
      },
      {
        "language": "text",
        "code": "content_copy\n      \n      @Directive({selector: '[appPeekABoo]'})\nexport class PeekABooDirective implements OnInit {\n  constructor(private logger: LoggerService) { }\n\n  // implement OnInit's `ngOnInit` method\n  ngOnInit() {\n    this.logIt('OnInit');\n  }\n\n  logIt(msg: string) {\n    this.logger.log(`#${nextId++} ${msg}`);\n  }\n}"
      },
      {
        "language": "text",
        "code": "@Directive({selector: '[appPeekABoo]'})\nexport class PeekABooDirective implements OnInit {\n  constructor(private logger: LoggerService) { }\n\n  // implement OnInit's `ngOnInit` method\n  ngOnInit() {\n    this.logIt('OnInit');\n  }\n\n  logIt(msg: string) {\n    this.logger.log(`#${nextId++} ${msg}`);\n  }\n}"
      },
      {
        "language": "text",
        "code": "ngOnChanges()"
      },
      {
        "language": "text",
        "code": "SimpleChanges"
      },
      {
        "language": "text",
        "code": "ngOnChanges()"
      },
      {
        "language": "text",
        "code": "ngOnChanges()"
      },
      {
        "language": "text",
        "code": "ngOnChanges()"
      },
      {
        "language": "text",
        "code": "ngDoCheck()"
      },
      {
        "language": "text",
        "code": "ngOnChanges()"
      },
      {
        "language": "text",
        "code": "ngAfterContentInit()"
      },
      {
        "language": "text",
        "code": "ngDoCheck()"
      },
      {
        "language": "text",
        "code": "ngAfterContentChecked()"
      },
      {
        "language": "text",
        "code": "ngAfterContentInit()"
      },
      {
        "language": "text",
        "code": "ngDoCheck()"
      },
      {
        "language": "text",
        "code": "ngAfterViewInit()"
      },
      {
        "language": "text",
        "code": "ngAfterContentChecked()"
      },
      {
        "language": "text",
        "code": "ngAfterViewChecked()"
      },
      {
        "language": "text",
        "code": "ngAfterViewInit()"
      },
      {
        "language": "text",
        "code": "ngAfterContentChecked()"
      },
      {
        "language": "text",
        "code": "ngOnDestroy()"
      },
      {
        "language": "text",
        "code": "AppComponent"
      },
      {
        "language": "text",
        "code": "SpyDirective"
      },
      {
        "language": "text",
        "code": "ngOnDestroy()"
      },
      {
        "language": "text",
        "code": "ngOnChanges()"
      },
      {
        "language": "text",
        "code": "ngDoCheck()"
      },
      {
        "language": "text",
        "code": "ngAfterViewInit()"
      },
      {
        "language": "text",
        "code": "ngAfterViewChecked()"
      },
      {
        "language": "text",
        "code": "ngAfterContentInit()"
      },
      {
        "language": "text",
        "code": "ngAfterContentChecked()"
      },
      {
        "language": "text",
        "code": "ngOnChanges()"
      },
      {
        "language": "text",
        "code": "ngOnChanges()"
      },
      {
        "language": "text",
        "code": "ngOnDestroy"
      },
      {
        "language": "text",
        "code": "ngOnDestroy()"
      },
      {
        "language": "text",
        "code": "ngOnDestroy()"
      },
      {
        "language": "text",
        "code": "ngOnDestroy()"
      },
      {
        "language": "text",
        "code": "content_copy\n      \n      @Component(...)\nclass Counter {\n  count = 0;\n  constructor() {\n    // Start a timer to increment the counter every second.\n    const id = setInterval(() => this.count++, 1000);\n\n    // Stop the timer when the component is destroyed.\n    const destroyRef = inject(DestroyRef);\n    destroyRef.onDestroy(() => clearInterval(id));\n  }\n}"
      },
      {
        "language": "text",
        "code": "@Component(...)\nclass Counter {\n  count = 0;\n  constructor() {\n    // Start a timer to increment the counter every second.\n    const id = setInterval(() => this.count++, 1000);\n\n    // Stop the timer when the component is destroyed.\n    const destroyRef = inject(DestroyRef);\n    destroyRef.onDestroy(() => clearInterval(id));\n  }\n}"
      },
      {
        "language": "text",
        "code": "ngOnDestroy"
      },
      {
        "language": "text",
        "code": "takeUntilDestroyed"
      },
      {
        "language": "text",
        "code": "takeUntilDestroyed"
      },
      {
        "language": "text",
        "code": "@angular/core/rxjs-interop"
      },
      {
        "language": "text",
        "code": "takeUntilDestroyed"
      },
      {
        "language": "text",
        "code": "content_copy\n      \n      data$ = http.get('...').pipe(takeUntilDestroyed());"
      },
      {
        "language": "text",
        "code": "data$ = http.get('...').pipe(takeUntilDestroyed());"
      },
      {
        "language": "text",
        "code": "takeUntilDestroyed"
      },
      {
        "language": "text",
        "code": "afterRender"
      },
      {
        "language": "text",
        "code": "afterNextRender"
      },
      {
        "language": "text",
        "code": "afterRender"
      },
      {
        "language": "text",
        "code": "afterNextRender"
      },
      {
        "language": "text",
        "code": "afterNextRender"
      },
      {
        "language": "text",
        "code": "afterRender"
      },
      {
        "language": "text",
        "code": "afterRender"
      },
      {
        "language": "text",
        "code": "afterNextRender"
      },
      {
        "language": "text",
        "code": "content_copy\n      \n      @Component({\n  selector: 'my-chart-cmp',\n  template: `<div #chart>{{ ... }}</div>`,\n})\nexport class MyChartCmp {\n  @ViewChild('chart') chartRef: ElementRef;\n  chart: MyChart|null;\n\n  constructor() {\n    afterNextRender(() => {\n      this.chart = new MyChart(this.chartRef.nativeElement);\n    }, {phase: AfterRenderPhase.Write});\n  }\n}"
      },
      {
        "language": "text",
        "code": "@Component({\n  selector: 'my-chart-cmp',\n  template: `<div #chart>{{ ... }}</div>`,\n})\nexport class MyChartCmp {\n  @ViewChild('chart') chartRef: ElementRef;\n  chart: MyChart|null;\n\n  constructor() {\n    afterNextRender(() => {\n      this.chart = new MyChart(this.chartRef.nativeElement);\n    }, {phase: AfterRenderPhase.Write});\n  }\n}"
      },
      {
        "language": "text",
        "code": "afterRender"
      },
      {
        "language": "text",
        "code": "ResizeObserver"
      },
      {
        "language": "text",
        "code": "IntersectionObserver"
      },
      {
        "language": "text",
        "code": "afterNextRender"
      },
      {
        "language": "text",
        "code": "content_copy\n      \n      @Component({\n  selector: 'my-cmp',\n  template: `<span #content>{{ ... }}</span>`,\n})\nexport class MyComponent {\n  resizeObserver: ResizeObserver|null = null;\n  @ViewChild('content') contentRef: ElementRef;\n\n  constructor() {\n    afterNextRender(() => {\n      this.resizeObserver = new ResizeObserver(() => {\n        console.log('Content was resized');\n      });\n\n      this.resizeObserver.observe(this.contentRef.nativeElement);\n    }, {phase: AfterRenderPhase.Write});\n  }\n\n  ngOnDestroy() {\n    this.resizeObserver?.disconnect();\n    this.resizeObserver = null;\n  }\n}"
      },
      {
        "language": "text",
        "code": "@Component({\n  selector: 'my-cmp',\n  template: `<span #content>{{ ... }}</span>`,\n})\nexport class MyComponent {\n  resizeObserver: ResizeObserver|null = null;\n  @ViewChild('content') contentRef: ElementRef;\n\n  constructor() {\n    afterNextRender(() => {\n      this.resizeObserver = new ResizeObserver(() => {\n        console.log('Content was resized');\n      });\n\n      this.resizeObserver.observe(this.contentRef.nativeElement);\n    }, {phase: AfterRenderPhase.Write});\n  }\n\n  ngOnDestroy() {\n    this.resizeObserver?.disconnect();\n    this.resizeObserver = null;\n  }\n}"
      },
      {
        "language": "text",
        "code": "afterNextRender"
      },
      {
        "language": "text",
        "code": "afterRender"
      },
      {
        "language": "text",
        "code": "afterRender"
      },
      {
        "language": "text",
        "code": "content_copy\n      \n      @Component({\n  selector: 'my-cmp',\n  template: `<span #content>{{ ... }}</span>`,\n})\nexport class MyComponent {\n  @ViewChild('content') contentRef: ElementRef;\n\n  constructor() {\n    afterRender(() => {\n      const elem = this.contentRef.nativeElement;\n      console.log(`content position: (${elem.offsetLeft}, ${elem.offsetTop})`);\n    }, {phase: AfterRenderPhase.Read});\n  }\n}"
      },
      {
        "language": "text",
        "code": "@Component({\n  selector: 'my-cmp',\n  template: `<span #content>{{ ... }}</span>`,\n})\nexport class MyComponent {\n  @ViewChild('content') contentRef: ElementRef;\n\n  constructor() {\n    afterRender(() => {\n      const elem = this.contentRef.nativeElement;\n      console.log(`content position: (${elem.offsetLeft}, ${elem.offsetTop})`);\n    }, {phase: AfterRenderPhase.Read});\n  }\n}"
      },
      {
        "language": "text",
        "code": "PeekABooComponent"
      },
      {
        "language": "text",
        "code": "AfterContentInit"
      },
      {
        "language": "text",
        "code": "AfterContentChecked"
      },
      {
        "language": "text",
        "code": "AfterViewInit"
      },
      {
        "language": "text",
        "code": "AfterViewChecked"
      },
      {
        "language": "text",
        "code": "AfterContentChecked"
      },
      {
        "language": "text",
        "code": "AfterViewChecked"
      },
      {
        "language": "text",
        "code": "AfterContentChecked"
      },
      {
        "language": "text",
        "code": "AfterViewChecked"
      },
      {
        "language": "text",
        "code": "SpyDirective"
      },
      {
        "language": "text",
        "code": "ngOnDestroy()"
      },
      {
        "language": "text",
        "code": "SpyDirective"
      },
      {
        "language": "text",
        "code": "SpyComponent"
      },
      {
        "language": "text",
        "code": "ngOnDestroy()"
      },
      {
        "language": "text",
        "code": "LoggerService"
      },
      {
        "language": "text",
        "code": "content_copy\n      \n      let nextId = 1;\n\n// Spy on any element to which it is applied.\n// Usage: <div appSpy>...</div>\n@Directive({selector: '[appSpy]'})\nexport class SpyDirective implements OnInit, OnDestroy {\n  private id = nextId++;\n\n  constructor(private logger: LoggerService) { }\n\n  ngOnInit() {\n    this.logger.log(`Spy #${this.id} onInit`);\n  }\n\n  ngOnDestroy() {\n    this.logger.log(`Spy #${this.id} onDestroy`);\n  }\n}"
      },
      {
        "language": "text",
        "code": "let nextId = 1;\n\n// Spy on any element to which it is applied.\n// Usage: <div appSpy>...</div>\n@Directive({selector: '[appSpy]'})\nexport class SpyDirective implements OnInit, OnDestroy {\n  private id = nextId++;\n\n  constructor(private logger: LoggerService) { }\n\n  ngOnInit() {\n    this.logger.log(`Spy #${this.id} onInit`);\n  }\n\n  ngOnDestroy() {\n    this.logger.log(`Spy #${this.id} onDestroy`);\n  }\n}"
      },
      {
        "language": "text",
        "code": "content_copy\n      \n      <p *ngFor=\"let hero of heroes\" appSpy>\n  {{hero}}\n</p>"
      },
      {
        "language": "text",
        "code": "<p *ngFor=\"let hero of heroes\" appSpy>\n  {{hero}}\n</p>"
      },
      {
        "language": "text",
        "code": "ngOnDestroy()"
      },
      {
        "language": "text",
        "code": "CounterComponent"
      },
      {
        "language": "text",
        "code": "ngOnChanges()"
      },
      {
        "language": "text",
        "code": "SpyDirective"
      },
      {
        "language": "text",
        "code": "CounterComponent"
      },
      {
        "language": "text",
        "code": "ngOnChanges()"
      },
      {
        "language": "text",
        "code": "OnChanges()"
      },
      {
        "language": "text",
        "code": "content_copy\n      \n      ngOnChanges(changes: SimpleChanges) {\n  for (const propName in changes) {\n    const chng = changes[propName];\n    const cur  = JSON.stringify(chng.currentValue);\n    const prev = JSON.stringify(chng.previousValue);\n    this.changeLog.push(`${propName}: currentValue = ${cur}, previousValue = ${prev}`);\n  }\n}"
      },
      {
        "language": "text",
        "code": "ngOnChanges(changes: SimpleChanges) {\n  for (const propName in changes) {\n    const chng = changes[propName];\n    const cur  = JSON.stringify(chng.currentValue);\n    const prev = JSON.stringify(chng.previousValue);\n    this.changeLog.push(`${propName}: currentValue = ${cur}, previousValue = ${prev}`);\n  }\n}"
      },
      {
        "language": "text",
        "code": "ngOnChanges()"
      },
      {
        "language": "text",
        "code": "OnChangesComponent"
      },
      {
        "language": "text",
        "code": "content_copy\n      \n      @Input() hero!: Hero;\n@Input() power = '';"
      },
      {
        "language": "text",
        "code": "@Input() hero!: Hero;\n@Input() power = '';"
      },
      {
        "language": "text",
        "code": "OnChangesParentComponent"
      },
      {
        "language": "text",
        "code": "content_copy\n      \n      <on-changes [hero]=\"hero\" [power]=\"power\"></on-changes>"
      },
      {
        "language": "text",
        "code": "<on-changes [hero]=\"hero\" [power]=\"power\"></on-changes>"
      },
      {
        "language": "text",
        "code": "ngOnChanges()"
      },
      {
        "language": "text",
        "code": "AfterViewInit()"
      },
      {
        "language": "text",
        "code": "AfterViewChecked()"
      },
      {
        "language": "text",
        "code": "content_copy\n      \n      @Component({\n  selector: 'app-child-view',\n  template: `\n    <label for=\"hero-name\">Hero name: </label>\n    <input type=\"text\" id=\"hero-name\" [(ngModel)]=\"hero\">\n  `\n})\nexport class ChildViewComponent {\n  hero = 'Magneta';\n}"
      },
      {
        "language": "text",
        "code": "@Component({\n  selector: 'app-child-view',\n  template: `\n    <label for=\"hero-name\">Hero name: </label>\n    <input type=\"text\" id=\"hero-name\" [(ngModel)]=\"hero\">\n  `\n})\nexport class ChildViewComponent {\n  hero = 'Magneta';\n}"
      },
      {
        "language": "text",
        "code": "AfterViewComponent"
      },
      {
        "language": "text",
        "code": "content_copy\n      \n      template: `\n  <div>child view begins</div>\n    <app-child-view></app-child-view>\n  <div>child view ends</div>\n`"
      },
      {
        "language": "text",
        "code": "template: `\n  <div>child view begins</div>\n    <app-child-view></app-child-view>\n  <div>child view ends</div>\n`"
      },
      {
        "language": "text",
        "code": "content_copy\n      \n      export class AfterViewComponent implements  AfterViewChecked, AfterViewInit {\n  private prevHero = '';\n\n  // Query for a VIEW child of type `ChildViewComponent`\n  @ViewChild(ChildViewComponent) viewChild!: ChildViewComponent;\n\n  ngAfterViewInit() {\n    // viewChild is set after the view has been initialized\n    this.logIt('AfterViewInit');\n    this.doSomething();\n  }\n\n  ngAfterViewChecked() {\n    // viewChild is updated after the view has been checked\n    if (this.prevHero === this.viewChild.hero) {\n      this.logIt('AfterViewChecked (no change)');\n    } else {\n      this.prevHero = this.viewChild.hero;\n      this.logIt('AfterViewChecked');\n      this.doSomething();\n    }\n  }\n  // ...\n}"
      },
      {
        "language": "text",
        "code": "export class AfterViewComponent implements  AfterViewChecked, AfterViewInit {\n  private prevHero = '';\n\n  // Query for a VIEW child of type `ChildViewComponent`\n  @ViewChild(ChildViewComponent) viewChild!: ChildViewComponent;\n\n  ngAfterViewInit() {\n    // viewChild is set after the view has been initialized\n    this.logIt('AfterViewInit');\n    this.doSomething();\n  }\n\n  ngAfterViewChecked() {\n    // viewChild is updated after the view has been checked\n    if (this.prevHero === this.viewChild.hero) {\n      this.logIt('AfterViewChecked (no change)');\n    } else {\n      this.prevHero = this.viewChild.hero;\n      this.logIt('AfterViewChecked');\n      this.doSomething();\n    }\n  }\n  // ...\n}"
      },
      {
        "language": "text",
        "code": "doSomething()"
      },
      {
        "language": "text",
        "code": "content_copy\n      \n      // This surrogate for real business logic sets the `comment`\nprivate doSomething() {\n  const c = this.viewChild.hero.length > 10 ? \"That's a long name\" : '';\n  if (c !== this.comment) {\n    // Wait a tick because the component's view has already been checked\n    this.logger.tick_then(() => this.comment = c);\n  }\n}"
      },
      {
        "language": "text",
        "code": "// This surrogate for real business logic sets the `comment`\nprivate doSomething() {\n  const c = this.viewChild.hero.length > 10 ? \"That's a long name\" : '';\n  if (c !== this.comment) {\n    // Wait a tick because the component's view has already been checked\n    this.logger.tick_then(() => this.comment = c);\n  }\n}"
      },
      {
        "language": "text",
        "code": "AfterViewInit()"
      },
      {
        "language": "text",
        "code": "AfterViewChecked()"
      },
      {
        "language": "text",
        "code": "LoggerService.tick_then()"
      },
      {
        "language": "text",
        "code": "AfterViewChecked()"
      },
      {
        "language": "text",
        "code": "<ng-content>"
      },
      {
        "language": "text",
        "code": "AfterContentInit()"
      },
      {
        "language": "text",
        "code": "AfterContentChecked()"
      },
      {
        "language": "text",
        "code": "AfterContentComponent"
      },
      {
        "language": "text",
        "code": "content_copy\n      \n      `<after-content>\n  <app-child></app-child>\n</after-content>`"
      },
      {
        "language": "text",
        "code": "`<after-content>\n  <app-child></app-child>\n</after-content>`"
      },
      {
        "language": "text",
        "code": "<app-child>"
      },
      {
        "language": "text",
        "code": "<after-content>"
      },
      {
        "language": "text",
        "code": "content_copy\n      \n      template: `\n  <div>projected content begins</div>\n    <ng-content></ng-content>\n  <div>projected content ends</div>\n`"
      },
      {
        "language": "text",
        "code": "template: `\n  <div>projected content begins</div>\n    <ng-content></ng-content>\n  <div>projected content ends</div>\n`"
      },
      {
        "language": "text",
        "code": "<ng-content>"
      },
      {
        "language": "text",
        "code": "<app-child>"
      },
      {
        "language": "text",
        "code": "ViewChildren"
      },
      {
        "language": "text",
        "code": "ContentChildren"
      },
      {
        "language": "text",
        "code": "content_copy\n      \n      export class AfterContentComponent implements AfterContentChecked, AfterContentInit {\n  private prevHero = '';\n  comment = '';\n\n  // Query for a CONTENT child of type `ChildComponent`\n  @ContentChild(ChildComponent) contentChild!: ChildComponent;\n\n  ngAfterContentInit() {\n    // contentChild is set after the content has been initialized\n    this.logIt('AfterContentInit');\n    this.doSomething();\n  }\n\n  ngAfterContentChecked() {\n    // contentChild is updated after the content has been checked\n    if (this.prevHero === this.contentChild.hero) {\n      this.logIt('AfterContentChecked (no change)');\n    } else {\n      this.prevHero = this.contentChild.hero;\n      this.logIt('AfterContentChecked');\n      this.doSomething();\n    }\n  }\n  // ...\n}"
      },
      {
        "language": "text",
        "code": "export class AfterContentComponent implements AfterContentChecked, AfterContentInit {\n  private prevHero = '';\n  comment = '';\n\n  // Query for a CONTENT child of type `ChildComponent`\n  @ContentChild(ChildComponent) contentChild!: ChildComponent;\n\n  ngAfterContentInit() {\n    // contentChild is set after the content has been initialized\n    this.logIt('AfterContentInit');\n    this.doSomething();\n  }\n\n  ngAfterContentChecked() {\n    // contentChild is updated after the content has been checked\n    if (this.prevHero === this.contentChild.hero) {\n      this.logIt('AfterContentChecked (no change)');\n    } else {\n      this.prevHero = this.contentChild.hero;\n      this.logIt('AfterContentChecked');\n      this.doSomething();\n    }\n  }\n  // ...\n}"
      },
      {
        "language": "text",
        "code": "doSomething()"
      },
      {
        "language": "text",
        "code": "AfterContent..."
      },
      {
        "language": "text",
        "code": "AfterView..."
      },
      {
        "language": "text",
        "code": "ngOnChanges()"
      },
      {
        "language": "text",
        "code": "ngDoCheck()"
      },
      {
        "language": "text",
        "code": "ngDoCheck()"
      },
      {
        "language": "text",
        "code": "content_copy\n      \n      ngDoCheck() {\n\n  if (this.hero.name !== this.oldHeroName) {\n    this.changeDetected = true;\n    this.changeLog.push(`DoCheck: Hero name changed to \"${this.hero.name}\" from \"${this.oldHeroName}\"`);\n    this.oldHeroName = this.hero.name;\n  }\n\n  if (this.power !== this.oldPower) {\n    this.changeDetected = true;\n    this.changeLog.push(`DoCheck: Power changed to \"${this.power}\" from \"${this.oldPower}\"`);\n    this.oldPower = this.power;\n  }\n\n  if (this.changeDetected) {\n      this.noChangeCount = 0;\n  } else {\n      // log that hook was called when there was no relevant change.\n      const count = this.noChangeCount += 1;\n      const noChangeMsg = `DoCheck called ${count}x when no change to hero or power`;\n      if (count === 1) {\n        // add new \"no change\" message\n        this.changeLog.push(noChangeMsg);\n      } else {\n        // update last \"no change\" message\n        this.changeLog[this.changeLog.length - 1] = noChangeMsg;\n      }\n  }\n\n  this.changeDetected = false;\n}"
      },
      {
        "language": "text",
        "code": "ngDoCheck() {\n\n  if (this.hero.name !== this.oldHeroName) {\n    this.changeDetected = true;\n    this.changeLog.push(`DoCheck: Hero name changed to \"${this.hero.name}\" from \"${this.oldHeroName}\"`);\n    this.oldHeroName = this.hero.name;\n  }\n\n  if (this.power !== this.oldPower) {\n    this.changeDetected = true;\n    this.changeLog.push(`DoCheck: Power changed to \"${this.power}\" from \"${this.oldPower}\"`);\n    this.oldPower = this.power;\n  }\n\n  if (this.changeDetected) {\n      this.noChangeCount = 0;\n  } else {\n      // log that hook was called when there was no relevant change.\n      const count = this.noChangeCount += 1;\n      const noChangeMsg = `DoCheck called ${count}x when no change to hero or power`;\n      if (count === 1) {\n        // add new \"no change\" message\n        this.changeLog.push(noChangeMsg);\n      } else {\n        // update last \"no change\" message\n        this.changeLog[this.changeLog.length - 1] = noChangeMsg;\n      }\n  }\n\n  this.changeDetected = false;\n}"
      },
      {
        "language": "text",
        "code": "ngDoCheck()"
      }
    ],
    "links": [
      {
        "text": "link",
        "href": "guide/lifecycle-hooks#component-lifecycle"
      },
      {
        "text": "Prerequisites",
        "href": "guide/lifecycle-hooks#prerequisites"
      },
      {
        "text": "Responding to lifecycle events",
        "href": "guide/lifecycle-hooks#responding-to-lifecycle-events"
      },
      {
        "text": "Lifecycle event sequence",
        "href": "guide/lifecycle-hooks#lifecycle-event-sequence"
      },
      {
        "text": "Lifecycle example set",
        "href": "guide/lifecycle-hooks#lifecycle-example-set"
      },
      {
        "text": "Initializing a component or directive",
        "href": "guide/lifecycle-hooks#initializing-a-component-or-directive"
      },
      {
        "text": "Cleaning up on instance destruction",
        "href": "guide/lifecycle-hooks#cleaning-up-on-instance-destruction"
      },
      {
        "text": "ngOnDestroy",
        "href": "guide/lifecycle-hooks#ngondestroy"
      },
      {
        "text": "DestroyRef",
        "href": "guide/lifecycle-hooks#destroyref"
      },
      {
        "text": "takeUntilDestroyed",
        "href": "guide/lifecycle-hooks#takeuntildestroyed"
      },
      {
        "text": "Reading and writing the DOM",
        "href": "guide/lifecycle-hooks#reading-and-writing-the-dom"
      },
      {
        "text": "One-time initialization",
        "href": "guide/lifecycle-hooks#one-time-initialization"
      },
      {
        "text": "Handling synchronization",
        "href": "guide/lifecycle-hooks#handling-synchronization"
      },
      {
        "text": "General examples",
        "href": "guide/lifecycle-hooks#general-examples"
      },
      {
        "text": "Sequence and frequency of all lifecycle events",
        "href": "guide/lifecycle-hooks#sequence-and-frequency-of-all-lifecycle-events"
      },
      {
        "text": "Use directives to watch the DOM",
        "href": "guide/lifecycle-hooks#use-directives-to-watch-the-dom"
      },
      {
        "text": "Use component and directive hooks together",
        "href": "guide/lifecycle-hooks#use-component-and-directive-hooks-together"
      },
      {
        "text": "Using change detection hooks",
        "href": "guide/lifecycle-hooks#using-change-detection-hooks"
      },
      {
        "text": "Responding to view changes",
        "href": "guide/lifecycle-hooks#responding-to-view-changes"
      },
      {
        "text": "Responding to projected content changes",
        "href": "guide/lifecycle-hooks#responding-to-projected-content-changes"
      },
      {
        "text": "Defining custom change detection",
        "href": "guide/lifecycle-hooks#defining-custom-change-detection"
      },
      {
        "text": "lifecycle hook methods",
        "href": "guide/glossary#lifecycle-hook"
      },
      {
        "text": "link",
        "href": "guide/lifecycle-hooks#prerequisites"
      },
      {
        "text": "TypeScript programming",
        "href": "https://www.typescriptlang.org"
      },
      {
        "text": "Angular Concepts",
        "href": "guide/architecture"
      },
      {
        "text": "link",
        "href": "guide/lifecycle-hooks#responding-to-lifecycle-events"
      },
      {
        "text": "OnInit",
        "href": "api/core/OnInit"
      },
      {
        "text": "Directive",
        "href": "api/core/Directive"
      },
      {
        "text": "OnInit",
        "href": "api/core/OnInit"
      },
      {
        "text": "OnInit",
        "href": "api/core/OnInit"
      },
      {
        "text": "OnInit",
        "href": "api/core/OnInit"
      },
      {
        "text": "link",
        "href": "guide/lifecycle-hooks#lifecycle-event-sequence"
      },
      {
        "text": "SimpleChanges",
        "href": "api/core/SimpleChanges"
      },
      {
        "text": "Using change detection hooks",
        "href": "guide/lifecycle-hooks#onchanges"
      },
      {
        "text": "Initializing a component or directive",
        "href": "guide/lifecycle-hooks#oninit"
      },
      {
        "text": "Defining custom change detection",
        "href": "guide/lifecycle-hooks#docheck"
      },
      {
        "text": "Responding to changes in content",
        "href": "guide/lifecycle-hooks#aftercontent"
      },
      {
        "text": "Responding to projected content changes",
        "href": "guide/lifecycle-hooks#aftercontent"
      },
      {
        "text": "Responding to view changes",
        "href": "guide/lifecycle-hooks#afterview"
      },
      {
        "text": "Cleaning up on instance destruction",
        "href": "guide/lifecycle-hooks#ondestroy"
      },
      {
        "text": "link",
        "href": "guide/lifecycle-hooks#lifecycle-example-set"
      },
      {
        "text": "live example",
        "href": "generated/live-examples/lifecycle-hooks/stackblitz.html"
      },
      {
        "text": "download example",
        "href": "generated/zips/lifecycle-hooks/lifecycle-hooks.zip"
      },
      {
        "text": "Peek-a-boo",
        "href": "guide/lifecycle-hooks#peek-a-boo"
      },
      {
        "text": "Spy",
        "href": "guide/lifecycle-hooks#spy"
      },
      {
        "text": "OnChanges",
        "href": "guide/lifecycle-hooks#onchanges"
      },
      {
        "text": "DoCheck",
        "href": "guide/lifecycle-hooks#docheck"
      },
      {
        "text": "AfterView",
        "href": "guide/lifecycle-hooks#afterview"
      },
      {
        "text": "view",
        "href": "guide/glossary#view"
      },
      {
        "text": "AfterContent",
        "href": "guide/lifecycle-hooks#aftercontent"
      },
      {
        "text": "Counter",
        "href": "guide/lifecycle-hooks#counter"
      },
      {
        "text": "link",
        "href": "guide/lifecycle-hooks#initializing-a-component-or-directive"
      },
      {
        "text": "Tour of Heroes tutorial",
        "href": "tutorial/tour-of-heroes/toh-pt4#oninit"
      },
      {
        "text": "link",
        "href": "guide/lifecycle-hooks#cleaning-up-on-instance-destruction"
      },
      {
        "text": "link",
        "href": "guide/lifecycle-hooks#ngondestroy"
      },
      {
        "text": "link",
        "href": "guide/lifecycle-hooks#destroyref"
      },
      {
        "text": "DestroyRef",
        "href": "api/core/DestroyRef"
      },
      {
        "text": "DestroyRef",
        "href": "api/core/DestroyRef"
      },
      {
        "text": "Component",
        "href": "api/core/Component"
      },
      {
        "text": "DestroyRef",
        "href": "api/core/DestroyRef"
      },
      {
        "text": "DestroyRef",
        "href": "api/core/DestroyRef"
      },
      {
        "text": "takeUntilDestroyed",
        "href": "api/core/rxjs-interop/takeUntilDestroyed"
      },
      {
        "text": "link",
        "href": "guide/lifecycle-hooks#takeuntildestroyed"
      },
      {
        "text": "takeUntilDestroyed",
        "href": "api/core/rxjs-interop/takeUntilDestroyed"
      },
      {
        "text": "developer preview",
        "href": "/guide/releases#developer-preview"
      },
      {
        "text": "rxjs-interop",
        "href": "api/core/rxjs-interop"
      },
      {
        "text": "takeUntilDestroyed",
        "href": "api/core/rxjs-interop/takeUntilDestroyed"
      },
      {
        "text": "takeUntilDestroyed",
        "href": "api/core/rxjs-interop/takeUntilDestroyed"
      },
      {
        "text": "takeUntilDestroyed",
        "href": "api/core/rxjs-interop/takeUntilDestroyed"
      },
      {
        "text": "injection context",
        "href": "/guide/dependency-injection-context"
      },
      {
        "text": "DestroyRef",
        "href": "api/core/DestroyRef"
      },
      {
        "text": "DestroyRef",
        "href": "api/core/DestroyRef"
      },
      {
        "text": "link",
        "href": "guide/lifecycle-hooks#reading-and-writing-the-dom"
      },
      {
        "text": "lifecycle events",
        "href": "guide/lifecycle-hooks#lifecycle-event-sequence"
      },
      {
        "text": "server-side rendering and pre-rendering",
        "href": "guide/glossary#server-side-rendering"
      },
      {
        "text": "afterRender",
        "href": "api/core/afterRender"
      },
      {
        "text": "afterNextRender",
        "href": "api/core/afterNextRender"
      },
      {
        "text": "change detection",
        "href": "/guide/glossary#change-detection"
      },
      {
        "text": "afterRender",
        "href": "api/core/afterRender"
      },
      {
        "text": "afterNextRender",
        "href": "api/core/afterNextRender"
      },
      {
        "text": "developer preview",
        "href": "/guide/releases#developer-preview"
      },
      {
        "text": "afterNextRender",
        "href": "api/core/afterNextRender"
      },
      {
        "text": "afterRender",
        "href": "api/core/afterRender"
      },
      {
        "text": "One-time initialization",
        "href": "guide/lifecycle-hooks#one-time-initialization"
      },
      {
        "text": "afterRender",
        "href": "api/core/afterRender"
      },
      {
        "text": "Handling synchronization",
        "href": "guide/lifecycle-hooks#handling-synchronization"
      },
      {
        "text": "link",
        "href": "guide/lifecycle-hooks#one-time-initialization"
      },
      {
        "text": "afterNextRender",
        "href": "api/core/afterNextRender"
      },
      {
        "text": "Component",
        "href": "api/core/Component"
      },
      {
        "text": "ViewChild",
        "href": "api/core/ViewChild"
      },
      {
        "text": "ElementRef",
        "href": "api/core/ElementRef"
      },
      {
        "text": "afterNextRender",
        "href": "api/core/afterNextRender"
      },
      {
        "text": "AfterRenderPhase.Write",
        "href": "api/core/AfterRenderPhase#Write"
      },
      {
        "text": "afterRender",
        "href": "api/core/afterRender"
      },
      {
        "text": "afterNextRender",
        "href": "api/core/afterNextRender"
      },
      {
        "text": "Component",
        "href": "api/core/Component"
      },
      {
        "text": "ViewChild",
        "href": "api/core/ViewChild"
      },
      {
        "text": "ElementRef",
        "href": "api/core/ElementRef"
      },
      {
        "text": "afterNextRender",
        "href": "api/core/afterNextRender"
      },
      {
        "text": "AfterRenderPhase.Write",
        "href": "api/core/AfterRenderPhase#Write"
      },
      {
        "text": "afterNextRender",
        "href": "api/core/afterNextRender"
      },
      {
        "text": "afterRender",
        "href": "api/core/afterRender"
      },
      {
        "text": "link",
        "href": "guide/lifecycle-hooks#handling-synchronization"
      },
      {
        "text": "afterRender",
        "href": "api/core/afterRender"
      },
      {
        "text": "Component",
        "href": "api/core/Component"
      },
      {
        "text": "ViewChild",
        "href": "api/core/ViewChild"
      },
      {
        "text": "ElementRef",
        "href": "api/core/ElementRef"
      },
      {
        "text": "afterRender",
        "href": "api/core/afterRender"
      },
      {
        "text": "AfterRenderPhase.Read",
        "href": "api/core/AfterRenderPhase#Read"
      },
      {
        "text": "link",
        "href": "guide/lifecycle-hooks#general-examples"
      },
      {
        "text": "link",
        "href": "guide/lifecycle-hooks#sequence-and-frequency-of-all-lifecycle-events"
      },
      {
        "text": "OnChanges",
        "href": "api/core/OnChanges"
      },
      {
        "text": "OnInit",
        "href": "api/core/OnInit"
      },
      {
        "text": "DoCheck",
        "href": "api/core/DoCheck"
      },
      {
        "text": "AfterContentInit",
        "href": "api/core/AfterContentInit"
      },
      {
        "text": "AfterContentChecked",
        "href": "api/core/AfterContentChecked"
      },
      {
        "text": "AfterViewInit",
        "href": "api/core/AfterViewInit"
      },
      {
        "text": "AfterViewChecked",
        "href": "api/core/AfterViewChecked"
      },
      {
        "text": "DoCheck",
        "href": "api/core/DoCheck"
      },
      {
        "text": "AfterContentChecked",
        "href": "api/core/AfterContentChecked"
      },
      {
        "text": "AfterViewChecked",
        "href": "api/core/AfterViewChecked"
      },
      {
        "text": "OnDestroy",
        "href": "api/core/OnDestroy"
      },
      {
        "text": "OnChanges",
        "href": "api/core/OnChanges"
      },
      {
        "text": "DoCheck",
        "href": "api/core/DoCheck"
      },
      {
        "text": "AfterContentChecked",
        "href": "api/core/AfterContentChecked"
      },
      {
        "text": "AfterViewChecked",
        "href": "api/core/AfterViewChecked"
      },
      {
        "text": "link",
        "href": "guide/lifecycle-hooks#use-directives-to-watch-the-dom"
      },
      {
        "text": "ngFor",
        "href": "api/common/NgFor"
      },
      {
        "text": "Directive",
        "href": "api/core/Directive"
      },
      {
        "text": "OnInit",
        "href": "api/core/OnInit"
      },
      {
        "text": "OnDestroy",
        "href": "api/core/OnDestroy"
      },
      {
        "text": "ngFor",
        "href": "api/common/NgFor"
      },
      {
        "text": "link",
        "href": "guide/lifecycle-hooks#use-component-and-directive-hooks-together"
      },
      {
        "text": "link",
        "href": "guide/lifecycle-hooks#using-change-detection-hooks"
      },
      {
        "text": "OnChanges",
        "href": "api/core/OnChanges"
      },
      {
        "text": "SimpleChanges",
        "href": "api/core/SimpleChanges"
      },
      {
        "text": "SimpleChange",
        "href": "api/core/SimpleChange"
      },
      {
        "text": "Input",
        "href": "api/core/Input"
      },
      {
        "text": "Input",
        "href": "api/core/Input"
      },
      {
        "text": "link",
        "href": "guide/lifecycle-hooks#responding-to-view-changes"
      },
      {
        "text": "view hierarchy",
        "href": "guide/glossary#view-hierarchy"
      },
      {
        "text": "unidirectional data flow",
        "href": "guide/glossary#unidirectional-data-flow"
      },
      {
        "text": "AfterViewInit",
        "href": "api/core/AfterViewInit"
      },
      {
        "text": "AfterViewChecked",
        "href": "api/core/AfterViewChecked"
      },
      {
        "text": "Component",
        "href": "api/core/Component"
      },
      {
        "text": "ngModel",
        "href": "api/forms/NgModel"
      },
      {
        "text": "@ViewChild",
        "href": "api/core/ViewChild"
      },
      {
        "text": "AfterViewChecked",
        "href": "api/core/AfterViewChecked"
      },
      {
        "text": "AfterViewInit",
        "href": "api/core/AfterViewInit"
      },
      {
        "text": "Query",
        "href": "api/core/Query"
      },
      {
        "text": "ViewChild",
        "href": "api/core/ViewChild"
      },
      {
        "text": "viewChild",
        "href": "api/core/viewChild"
      },
      {
        "text": "viewChild",
        "href": "api/core/viewChild"
      },
      {
        "text": "AfterViewInit",
        "href": "api/core/AfterViewInit"
      },
      {
        "text": "viewChild",
        "href": "api/core/viewChild"
      },
      {
        "text": "AfterViewChecked",
        "href": "api/core/AfterViewChecked"
      },
      {
        "text": "AfterViewChecked",
        "href": "api/core/AfterViewChecked"
      },
      {
        "text": "link",
        "href": "guide/lifecycle-hooks#wait-before-updating-the-view"
      },
      {
        "text": "tick",
        "href": "api/core/testing/tick"
      },
      {
        "text": "AfterViewInit",
        "href": "api/core/AfterViewInit"
      },
      {
        "text": "AfterViewChecked",
        "href": "api/core/AfterViewChecked"
      },
      {
        "text": "link",
        "href": "guide/lifecycle-hooks#write-lean-hook-methods-to-avoid-performance-problems"
      },
      {
        "text": "AfterViewChecked",
        "href": "api/core/AfterViewChecked"
      },
      {
        "text": "link",
        "href": "guide/lifecycle-hooks#responding-to-projected-content-changes"
      },
      {
        "text": "<ng-content>",
        "href": "api/core/ng-content"
      },
      {
        "text": "AfterContentInit",
        "href": "api/core/AfterContentInit"
      },
      {
        "text": "AfterContentChecked",
        "href": "api/core/AfterContentChecked"
      },
      {
        "text": "previous AfterView",
        "href": "guide/lifecycle-hooks#afterview"
      },
      {
        "text": "<ng-content>",
        "href": "api/core/ng-content"
      },
      {
        "text": "link",
        "href": "guide/lifecycle-hooks#using-aftercontent-hooks"
      },
      {
        "text": "ViewChildren",
        "href": "api/core/ViewChildren"
      },
      {
        "text": "ContentChildren",
        "href": "api/core/ContentChildren"
      },
      {
        "text": "@ContentChild",
        "href": "api/core/ContentChild"
      },
      {
        "text": "AfterContentChecked",
        "href": "api/core/AfterContentChecked"
      },
      {
        "text": "AfterContentInit",
        "href": "api/core/AfterContentInit"
      },
      {
        "text": "Query",
        "href": "api/core/Query"
      },
      {
        "text": "ContentChild",
        "href": "api/core/ContentChild"
      },
      {
        "text": "contentChild",
        "href": "api/core/contentChild"
      },
      {
        "text": "contentChild",
        "href": "api/core/contentChild"
      },
      {
        "text": "AfterContentInit",
        "href": "api/core/AfterContentInit"
      },
      {
        "text": "contentChild",
        "href": "api/core/contentChild"
      },
      {
        "text": "AfterContentChecked",
        "href": "api/core/AfterContentChecked"
      },
      {
        "text": "AfterContentChecked",
        "href": "api/core/AfterContentChecked"
      },
      {
        "text": "delay the update to ensure proper rendering",
        "href": "guide/lifecycle-hooks#wait-a-tick"
      },
      {
        "text": "link",
        "href": "guide/lifecycle-hooks#defining-custom-change-detection"
      },
      {
        "text": "DoCheck",
        "href": "api/core/DoCheck"
      },
      {
        "text": "DoCheck",
        "href": "api/core/DoCheck"
      },
      {
        "text": "DoCheck",
        "href": "api/core/DoCheck"
      },
      {
        "text": "DoCheck",
        "href": "api/core/DoCheck"
      }
    ],
    "meta": {
      "description": "",
      "keywords": ""
    },
    "summary": "Component Lifecyclelink Contents PrerequisitesResponding to lifecycle eventsLifecycle event sequenceLifecycle example setInitializing a component or directiveCleaning up on instance destructionngOnDes...",
    "tags": [
      "react",
      "vue",
      "angular",
      "javascript",
      "typescript",
      "html",
      "node",
      "vite",
      "lifecycle",
      "component"
    ],
    "id": "angular-lifecyclehooks-part-1",
    "quality": 90
  },
  {
    "title": "Angular",
    "url": "https://v17.angular.io/guide/component-interaction",
    "category": "angular",
    "content": "Component interactionlink Contents Pass data from parent to child with input bindingTest it for Pass data from parent to child with input bindingIntercept input property changes with a setterTest it for Intercept input property changes with a setterIntercept input property changes with ngOnChanges()Test it for Intercept input property changes with ngOnChanges()Parent listens for child eventTest it for Parent listens for child eventParent interacts with child using local variableTest it for Parent interacts with child using local variableParent calls an @ViewChild()Test it for Parent calls an @ViewChild()Parent and children communicate using a serviceTest it for Parent and children communicate using a service This cookbook contains recipes for common component communication scenarios in which two or more components share information. See the live example / download example. Pass data from parent to child with input bindinglink HeroChildComponent has two input properties, typically adorned with @Input() decorator. content_copy import { Component, Input } from '@angular/core'; import { Hero } from './hero'; @Component({ selector: 'app-hero-child', template:  h3{{hero.name}} says:/h3 pI, {{hero.name}}, am at your service, {{masterName}}./p  }) export class HeroChildComponent { @Input() hero!: Hero; @Input('master') masterName = ''; } The second @Input aliases the child component property name masterName as 'master'. The HeroParentComponent nests the child HeroChildComponent inside an *ngFor repeater, binding its master string property to the child's master alias, and each iteration's hero instance to the child's hero property. content_copy import { Component } from '@angular/core'; import { HEROES } from './hero'; @Component({ selector: 'app-hero-parent', template:  h2{{master}} controls {{heroes.length}} heroes/h2 app-hero-child *ngFor=\"let hero of heroes\" [hero]=\"hero\" [master]=\"master\" /app-hero-child  }) export class HeroParentComponent { heroes = HEROES; master = 'Master'; } The running application displays three heroes: Test it for Pass data from parent to child with input bindinglink E2E test that all children were instantiated and displayed as expected: content_copy // ... const heroNames = ['Dr. IQ', 'Magneta', 'Bombasto']; const masterName = 'Master'; it('should pass properties to children properly', async () = { const parent = element(by.tagName('app-hero-parent')); const heroes = parent.all(by.tagName('app-hero-child')); for (let i = 0; i  heroNames.length; i++) { const childTitle = await heroes.get(i).element(by.tagName('h3')).getText(); const childDetail = await heroes.get(i).element(by.tagName('p')).getText(); expect(childTitle).toEqual(heroNames[i] + ' says:'); expect(childDetail).toContain(masterName); } }); // ... Back to top Intercept input property changes with a setterlink Use an input property setter to intercept and act upon a value from the parent. The setter of the name input property in the child NameChildComponent trims the whitespace from a name and replaces an empty value with default text. content_copy import { Component, Input } from '@angular/core'; @Component({ selector: 'app-name-child', template: 'h3\"{{name}}\"/h3' }) export class NameChildComponent { @Input() get name(): string { return this._name; } set name(name: string) { this._name = (name && name.trim())  'no name set'; } private _name = ''; } Here's the NameParentComponent demonstrating name variations including a name with all spaces: content_copy import { Component } from '@angular/core'; @Component({ selector: 'app-name-parent', template:  h2Master controls {{names.length}} names/h2 app-name-child *ngFor=\"let name of names\" [name]=\"name\"/app-name-child  }) export class NameParentComponent { // Displays 'Dr. IQ', 'no name set', 'Bombasto' names = ['Dr. IQ', ' ', ' Bombasto ']; } Test it for Intercept input property changes with a setterlink E2E tests of input property setter with empty and non-empty names: content_copy // ... it('should display trimmed, non-empty names', async () = { const nonEmptyNameIndex = 0; const nonEmptyName = '\"Dr. IQ\"'; const parent = element(by.tagName('app-name-parent')); const hero = parent.all(by.tagName('app-name-child')).get(nonEmptyNameIndex); const displayName = await hero.element(by.tagName('h3')).getText(); expect(displayName).toEqual(nonEmptyName); }); it('should replace empty name with default name', async () = { const emptyNameIndex = 1; const defaultName = '\"no name set\"'; const parent = element(by.tagName('app-name-parent')); const hero = parent.all(by.tagName('app-name-child')).get(emptyNameIndex); const displayName = await hero.element(by.tagName('h3')).getText(); expect(displayName).toEqual(defaultName); }); // ... Back to top Intercept input property changes with ngOnChanges()link Detect and act upon changes to input property values with the ngOnChanges() method of the OnChanges lifecycle hook interface. You might prefer this approach to the property setter when watching multiple, interacting input properties. Learn about ngOnChanges() in the Lifecycle Hooks chapter. This VersionChildComponent detects changes to the major and minor input properties and composes a log message reporting these changes: content_copy import { Component, Input, OnChanges, SimpleChanges } from '@angular/core'; @Component({ selector: 'app-version-child', template:  h3Version {{major}}.{{minor}}/h3 h4Change log:/h4 ul li *ngFor=\"let change of changeLog\"{{change}}/li /ul  }) export class VersionChildComponent implements OnChanges { @Input() major = 0; @Input() minor = 0; changeLog: string[] = []; ngOnChanges(changes: SimpleChanges) { const log: string[] = []; for (const propName in changes) { const changedProp = changes[propName]; const to = JSON.stringify(changedProp.currentValue); if (changedProp.isFirstChange()) { log.push(Initial value of ${propName} set to ${to}); } else { const from = JSON.stringify(changedProp.previousValue); log.push(${propName} changed from ${from} to ${to}); } } this.changeLog.push(log.join(', ')); } } The VersionParentComponent supplies the minor and major values and binds buttons to methods that change them. content_copy import { Component } from '@angular/core'; @Component({ selector: 'app-version-parent', template:  h2Source code version/h2 button type=\"button\" (click)=\"newMinor()\"New minor version/button button type=\"button\" (click)=\"newMajor()\"New major version/button app-version-child [major]=\"major\" [minor]=\"minor\"/app-version-child  }) export class VersionParentComponent { major = 1; minor = 23; newMinor() { this.minor++; } newMajor() { this.major++; this.minor = 0; } } Here's the output of a button-pushing sequence: Test it for Intercept input property changes with ngOnChanges()link Test that both input properties are set initially and that button clicks trigger the expected ngOnChanges calls and values: content_copy // ... // Test must all execute in this exact order it('should set expected initial values', async () = { const actual = await getActual(); const initialLabel = 'Version 1.23'; const initialLog = 'Initial value of major set to 1, Initial value of minor set to 23'; expect(actual.label).toBe(initialLabel); expect(actual.count).toBe(1); expect(await actual.logs.get(0).getText()).toBe(initialLog); }); it(\"should set expected values after clicking 'Minor' twice\", async () = { const repoTag = element(by.tagName('app-version-parent')); const newMinorButton = repoTag.all(by.tagName('button')).get(0); await newMinorButton.click(); await newMinorButton.click(); const actual = await getActual(); const labelAfter2Minor = 'Version 1.25'; const logAfter2Minor = 'minor changed from 24 to 25'; expect(actual.label).toBe(labelAfter2Minor); expect(actual.count).toBe(3); expect(await actual.logs.get(2).getText()).toBe(logAfter2Minor); }); it(\"should set expected values after clicking 'Major' once\", async () = { const repoTag = element(by.tagName('app-version-parent')); const newMajorButton = repoTag.all(by.tagName('button')).get(1); await newMajorButton.click(); const actual = await getActual(); const labelAfterMajor = 'Version 2.0'; const logAfterMajor = 'major changed from 1 to 2, minor changed from 23 to 0'; expect(actual.label).toBe(labelAfterMajor); expect(actual.count).toBe(2); expect(await actual.logs.get(1).getText()).toBe(logAfterMajor); }); async function getActual() { const versionTag = element(by.tagName('app-version-child')); const label = await versionTag.element(by.tagName('h3')).getText(); const ul = versionTag.element((by.tagName('ul'))); const logs = ul.all(by.tagName('li')); return { label, logs, count: await logs.count(), }; } // ... Back to top Parent listens for child eventlink The child component exposes an EventEmitter property with which it emits events when something happens. The parent binds to that event property and reacts to those events. The child's EventEmitter property is an output property, typically adorned with an @Output() decorator as seen in this VoterComponent: content_copy import { Component, EventEmitter, Input, Output } from '@angular/core'; @Component({ selector: 'app-voter', template:  h4{{name}}/h4 button type=\"button\" (click)=\"vote(true)\" [disabled]=\"didVote\"Agree/button button type=\"button\" (click)=\"vote(false)\" [disabled]=\"didVote\"Disagree/button  }) export class VoterComponent { @Input() name = ''; @Output() voted = new EventEmitterboolean(); didVote = false; vote(agreed: boolean) { this.voted.emit(agreed); this.didVote = true; } } Clicking a button triggers emission of a true or false, the boolean payload. The parent VoteTakerComponent binds an event handler called onVoted() that responds to the child event payload $event and updates a counter. content_copy import { Component } from '@angular/core'; @Component({ selector: 'app-vote-taker', template:  h2Should mankind colonize the Universe?/h2 h3Agree: {{agreed}}, Disagree: {{disagreed}}/h3 app-voter *ngFor=\"let voter of voters\" [name]=\"voter\" (voted)=\"onVoted($event)\" /app-voter  }) export class VoteTakerComponent { agreed = 0; disagreed = 0; voters = ['Dr. IQ', 'Celeritas', 'Bombasto']; onVoted(agreed: boolean) { if (agreed) { this.agreed++; } else { this.disagreed++; } } } The framework passes the event argument represented by $event to the handler method, and the method processes it: Test it for Parent listens for child eventlink Test that clicking the Agree and Disagree buttons update the appropriate counters: content_copy // ... it('should not emit the event initially', async () = { const voteLabel = element(by.tagName('app-vote-taker')).element(by.tagName('h3')); expect(await voteLabel.getText()).toBe('Agree: 0, Disagree: 0'); }); it('should process Agree vote', async () = { const voteLabel = element(by.tagName('app-vote-taker')).element(by.tagName('h3')); const agreeButton1 = element.all(by.tagName('app-voter')).get(0) .all(by.tagName('button')).get(0); await agreeButton1.click(); expect(await voteLabel.getText()).toBe('Agree: 1, Disagree: 0'); }); it('should process Disagree vote', async () = { const voteLabel = element(by.tagName('app-vote-taker')).element(by.tagName('h3')); const agreeButton1 = element.all(by.tagName('app-voter')).get(1) .all(by.tagName('button')).get(1); await agreeButton1.click(); expect(await voteLabel.getText()).toBe('Agree: 0, Disagree: 1'); }); // ... Back to top Parent interacts with child using local variablelink A parent component cannot use data binding to read child properties or invoke child methods. Do both by creating a template reference variable for the child element and then reference that variable within the parent template as seen in the following example. The following is a child CountdownTimerComponent that repeatedly counts down to zero and launches a rocket. The start and stop methods control the clock and a countdown status message displays in its own template. content_copy import { Component, OnDestroy } from '@angular/core'; @Component({ selector: 'app-countdown-timer', template: 'p{{message}}/p' }) export class CountdownTimerComponent implements OnDestroy { message = ''; seconds = 11; ngOnDestroy() { this.clearTimer?.(); } start() { this.countDown(); } stop() { this.clearTimer?.(); this.message = Holding at T-${this.seconds} seconds; } private clearTimer: VoidFunction  undefined; private countDown() { this.clearTimer?.(); const interval = setInterval(() = { this.seconds -= 1; if (this.seconds === 0) { this.message = 'Blast off!'; } else { if (this.seconds  0) { this.seconds = 10; } // reset this.message = T-${this.seconds} seconds and counting; } }, 1000); this.clearTimer = () = clearInterval(interval); } } The CountdownLocalVarParentComponent that hosts the timer component is as follows: content_copy import { Component } from '@angular/core'; import { CountdownTimerComponent } from './countdown-timer.component'; @Component({ selector: 'app-countdown-parent-lv', template:  h3Countdown to Liftoff (via local variable)/h3 button type=\"button\" (click)=\"timer.start()\"Start/button button type=\"button\" (click)=\"timer.stop()\"Stop/button div class=\"seconds\"{{timer.seconds}}/div app-countdown-timer #timer/app-countdown-timer , styleUrls: ['../assets/demo.css'] }) export class CountdownLocalVarParentComponent { } The parent component cannot data bind to the child's start and stop methods nor to its seconds property. Place a local variable, #timer, on the tag app-countdown-timer representing the child component. That gives you a reference to the child component and the ability to access any of its properties or methods from within the parent template. This example wires parent buttons to the child's start and stop and uses interpolation to display the child's seconds property. Here, the parent and child are working together. Test it for Parent interacts with child using local variablelink Test that the seconds displayed in the parent template match the seconds displayed in the child's status message. Test also that clicking the Stop button pauses the countdown timer: content_copy // ... // The tests trigger periodic asynchronous operations (via setInterval()), which will prevent // the app from stabilizing. See https://angular.io/api/core/ApplicationRef#is-stable-examples // for more details. // To allow the tests to complete, we will disable automatically waiting for the Angular app to // stabilize. beforeEach(() = browser.waitForAngularEnabled(false)); afterEach(() = browser.waitForAngularEnabled(true)); it('timer and parent seconds should match', async () = { const parent = element(by.tagName(parentTag)); const startButton = parent.element(by.buttonText('Start')); const seconds = parent.element(by.className('seconds')); const timer = parent.element(by.tagName('app-countdown-timer')); await startButton.click(); // Wait for app-countdown-timer to be populated with any text. await browser.wait(() = timer.getText(), 2000); expect(await timer.getText()).toContain(await seconds.getText()); }); it('should stop the countdown', async () = { const parent = element(by.tagName(parentTag)); const startButton = parent.element(by.buttonText('Start')); const stopButton = parent.element(by.buttonText('Stop')); const timer = parent.element(by.tagName('app-countdown-timer')); await startButton.click(); expect(await timer.getText()).not.toContain('Holding'); await stopButton.click(); expect(await timer.getText()).toContain('Holding'); }); // ... Back to top Parent calls an @ViewChild()link The local variable approach is straightforward. But it is limited because the parent-child wiring must be done entirely within the parent template. The parent component itself has no access to the child. You can't use the local variable technique if the parent component's class relies on the child component's class. The parent-child relationship of the components is not established within each component's respective class with the local variable technique. Because the class instances are not connected to one another, the parent class cannot access the child class properties and methods. When the parent component class requires that kind of access, inject the child component into the parent as a ViewChild. The following example illustrates this technique with the same Countdown Timer example. Neither its appearance nor its behavior changes. The child CountdownTimerComponent is the same as well. The switch from the local variable to the ViewChild technique is solely for the purpose of demonstration. Here is the parent, CountdownViewChildParentComponent: content_copy import { AfterViewInit, ViewChild } from '@angular/core'; import { Component } from '@angular/core'; import { CountdownTimerComponent } from './countdown-timer.component'; @Component({ selector: 'app-countdown-parent-vc', template:  h3Countdown to Liftoff (via ViewChild)/h3 button type=\"button\" (click)=\"start()\"Start/button button type=\"button\" (click)=\"stop()\"Stop/button div class=\"seconds\"{{ seconds() }}/div app-countdown-timer/app-countdown-timer , styleUrls: ['../assets/demo.css'] }) export class CountdownViewChildParentComponent implements AfterViewInit { @ViewChild(CountdownTimerComponent) private timerComponent!: CountdownTimerComponent; seconds() { return 0; } ngAfterViewInit() { // Redefine seconds() to get from the CountdownTimerComponent.seconds ... // but wait a tick first to avoid one-time devMode // unidirectional-data-flow-violation error setTimeout(() = this.seconds = () = this.timerComponent.seconds, 0); } start() { this.timerComponent.start(); } stop() { this.timerComponent.stop(); } } It takes a bit more work to get the child view into the parent component class. First, you have to import references to the ViewChild decorator and the AfterViewInit lifecycle hook. Next, inject the child CountdownTimerComponent into the private timerComponent property using the @ViewChild property decoration. The #timer local variable is gone from the component metadata. Instead, bind the buttons to the parent component's own start and stop methods and present the ticking seconds in an interpolation around the parent component's seconds method. These methods access the injected timer component directly. The ngAfterViewInit() lifecycle hook is an important wrinkle. The timer component isn't available until after Angular displays the parent view. So it displays 0 seconds initially. Then Angular calls the ngAfterViewInit lifecycle hook at which time it is too late to update the parent view's display of the countdown seconds. Angular's unidirectional data flow rule prevents updating the parent view's in the same cycle. The application must wait one turn before it can display the seconds. Use setTimeout() to wait one tick and then revise the seconds() method so that it takes future values from the timer component. Test it for Parent calls an @ViewChild()link Use the same countdown timer tests as before. Back to top Parent and children communicate using a servicelink A parent component and its children share a service whose interface enables bidirectional communication within the family. The scope of the service instance is the parent component and its children. Components outside this component subtree have no access to the service or their communications. This MissionService connects the MissionControlComponent to multiple AstronautComponent children. content_copy import { Injectable } from '@angular/core'; import { Subject } from 'rxjs'; @Injectable() export class MissionService { // Observable string sources private missionAnnouncedSource = new Subjectstring(); private missionConfirmedSource = new Subjectstring(); // Observable string streams missionAnnounced$ = this.missionAnnouncedSource.asObservable(); missionConfirmed$ = this.missionConfirmedSource.asObservable(); // Service message commands announceMission(mission: string) { this.missionAnnouncedSource.next(mission); } confirmMission(astronaut: string) { this.missionConfirmedSource.next(astronaut); } } The MissionControlComponent both provides the instance of the service that it shares with its children (through the providers metadata array) and injects that instance into itself through its constructor: content_copy import { Component } from '@angular/core'; import { MissionService } from './mission.service'; @Component({ selector: 'app-mission-control', template:  h2Mission Control/h2 button type=\"button\" (click)=\"announce()\"Announce mission/button app-astronaut *ngFor=\"let astronaut of astronauts\" [astronaut]=\"astronaut\" /app-astronaut h3History/h3 ul li *ngFor=\"let event of history\"{{event}}/li /ul , providers: [MissionService] }) export class MissionControlComponent { astronauts = ['Lovell', 'Swigert', 'Haise']; history: string[] = []; missions = ['Fly to the moon!', 'Fly to mars!', 'Fly to Vegas!']; nextMission = 0; constructor(private missionService: MissionService) { missionService.missionConfirmed$.subscribe( astronaut = { this.history.push(${astronaut} confirmed the mission); }); } announce() { const mission = this.missions[this.nextMission++]; this.missionService.announceMission(mission); this.history.push(Mission \"${mission}\" announced); if (this.nextMission = this.missions.length) { this.nextMission = 0; } } } The AstronautComponent also injects the service in its constructor. Each AstronautComponent is a child of the MissionControlComponent and therefore receives its parent's service instance: content_copy import { Component, Input, OnDestroy } from '@angular/core'; import { MissionService } from './mission.service'; import { Subscription } from 'rxjs'; @Component({ selector: 'app-astronaut', template:  p {{astronaut}}: strong{{mission}}/strong button type=\"button\" (click)=\"confirm()\" [disabled]=\"!announced  confirmed\" Confirm /button /p  }) export class AstronautComponent implements OnDestroy { @Input() astronaut = ''; mission = 'no mission announced'; confirmed = false; announced = false; subscription: Subscription; constructor(private missionService: MissionService) { this.subscription = missionService.missionAnnounced$.subscribe( mission = { this.mission = mission; this.announced = true; this.confirmed = false; }); } confirm() { this.confirmed = true; this.missionService.confirmMission(this.astronaut); } ngOnDestroy() { // prevent memory leak when component destroyed this.subscription.unsubscribe(); } } Notice that this example captures the subscription and unsubscribe() when the AstronautComponent is destroyed. This is a memory-leak guard step. There is no actual risk in this application because the lifetime of a AstronautComponent is the same as the lifetime of the application itself. That would not always be true in a more complex application. You don't add this guard to the MissionControlComponent because, as the parent, it controls the lifetime of the MissionService. The History log demonstrates that messages travel in both directions between the parent MissionControlComponent and the AstronautComponent children, facilitated by the service: Test it for Parent and children communicate using a servicelink Tests click buttons of both the parent MissionControlComponent and the AstronautComponent children and verify that the history meets expectations: content_copy // ... it('should announce a mission', async () = { const missionControl = element(by.tagName('app-mission-control')); const announceButton = missionControl.all(by.tagName('button')).get(0); const history = missionControl.all(by.tagName('li')); await announceButton.click(); expect(await history.count()).toBe(1); expect(await history.get(0).getText()).toMatch(/Mission.* announced/); }); it('should confirm the mission by Lovell', async () = { await testConfirmMission(1, 'Lovell'); }); it('should confirm the mission by Haise', async () = { await testConfirmMission(3, 'Haise'); }); it('should confirm the mission by Swigert', async () = { await testConfirmMission(2, 'Swigert'); }); async function testConfirmMission(buttonIndex: number, astronaut: string) { const missionControl = element(by.tagName('app-mission-control')); const announceButton = missionControl.all(by.tagName('button')).get(0); const confirmButton = missionControl.all(by.tagName('button')).get(buttonIndex); const history = missionControl.all(by.tagName('li')); await announceButton.click(); await confirmButton.click(); expect(await history.count()).toBe(2); expect(await history.get(1).getText()).toBe(${astronaut} confirmed the mission); } // ... Back to top Last reviewed on Mon Feb 28 2022",
    "headings": [
      {
        "level": 1,
        "text": "Component interactionlink",
        "id": "component-interaction"
      },
      {
        "level": 2,
        "text": "Pass data from parent to child with input bindinglink",
        "id": "pass-data-from-parent-to-child-with-input-binding"
      },
      {
        "level": 2,
        "text": "Intercept input property changes with a setterlink",
        "id": "intercept-input-property-changes-with-a-setter"
      },
      {
        "level": 2,
        "text": "Intercept input property changes with ngOnChanges()link",
        "id": "intercept-input-property-changes-with-ngonchanges"
      },
      {
        "level": 2,
        "text": "Parent listens for child eventlink",
        "id": "parent-listens-for-child-event"
      },
      {
        "level": 2,
        "text": "Parent interacts with child using local variablelink",
        "id": "parent-interacts-with-child-using-local-variable"
      },
      {
        "level": 2,
        "text": "Parent calls an @ViewChild()link",
        "id": "parent-calls-an-viewchild"
      },
      {
        "level": 2,
        "text": "Parent and children communicate using a servicelink",
        "id": "parent-and-children-communicate-using-a-service"
      },
      {
        "level": 3,
        "text": "Test it for Pass data from parent to child with input bindinglink",
        "id": "test-it-for-pass-data-from-parent-to-child-with-input-binding"
      },
      {
        "level": 3,
        "text": "Test it for Intercept input property changes with a setterlink",
        "id": "test-it-for-intercept-input-property-changes-with-a-setter"
      },
      {
        "level": 3,
        "text": "Test it for Intercept input property changes with ngOnChanges()link",
        "id": "test-it-for-intercept-input-property-changes-with-ngonchanges"
      },
      {
        "level": 3,
        "text": "Test it for Parent listens for child eventlink",
        "id": "test-it-for-parent-listens-for-child-event"
      },
      {
        "level": 3,
        "text": "Test it for Parent interacts with child using local variablelink",
        "id": "test-it-for-parent-interacts-with-child-using-local-variable"
      },
      {
        "level": 3,
        "text": "Test it for Parent calls an @ViewChild()link",
        "id": "test-it-for-parent-calls-an-viewchild"
      },
      {
        "level": 3,
        "text": "Test it for Parent and children communicate using a servicelink",
        "id": "test-it-for-parent-and-children-communicate-using-a-service"
      }
    ],
    "codeBlocks": [
      {
        "language": "text",
        "code": "ngOnChanges()"
      },
      {
        "language": "text",
        "code": "ngOnChanges()"
      },
      {
        "language": "text",
        "code": "@ViewChild()"
      },
      {
        "language": "text",
        "code": "@ViewChild()"
      },
      {
        "language": "text",
        "code": "HeroChildComponent"
      },
      {
        "language": "text",
        "code": "content_copy\n      \n      import { Component, Input } from '@angular/core';\n\nimport { Hero } from './hero';\n\n@Component({\n  selector: 'app-hero-child',\n  template: `\n    <h3>{{hero.name}} says:</h3>\n    <p>I, {{hero.name}}, am at your service, {{masterName}}.</p>\n  `\n})\nexport class HeroChildComponent {\n  @Input() hero!: Hero;\n  @Input('master') masterName = '';\n}"
      },
      {
        "language": "text",
        "code": "import { Component, Input } from '@angular/core';\n\nimport { Hero } from './hero';\n\n@Component({\n  selector: 'app-hero-child',\n  template: `\n    <h3>{{hero.name}} says:</h3>\n    <p>I, {{hero.name}}, am at your service, {{masterName}}.</p>\n  `\n})\nexport class HeroChildComponent {\n  @Input() hero!: Hero;\n  @Input('master') masterName = '';\n}"
      },
      {
        "language": "text",
        "code": "HeroParentComponent"
      },
      {
        "language": "text",
        "code": "HeroChildComponent"
      },
      {
        "language": "text",
        "code": "content_copy\n      \n      import { Component } from '@angular/core';\n\nimport { HEROES } from './hero';\n\n@Component({\n  selector: 'app-hero-parent',\n  template: `\n    <h2>{{master}} controls {{heroes.length}} heroes</h2>\n\n    <app-hero-child\n      *ngFor=\"let hero of heroes\"\n      [hero]=\"hero\"\n      [master]=\"master\">\n    </app-hero-child>\n  `\n})\nexport class HeroParentComponent {\n  heroes = HEROES;\n  master = 'Master';\n}"
      },
      {
        "language": "text",
        "code": "import { Component } from '@angular/core';\n\nimport { HEROES } from './hero';\n\n@Component({\n  selector: 'app-hero-parent',\n  template: `\n    <h2>{{master}} controls {{heroes.length}} heroes</h2>\n\n    <app-hero-child\n      *ngFor=\"let hero of heroes\"\n      [hero]=\"hero\"\n      [master]=\"master\">\n    </app-hero-child>\n  `\n})\nexport class HeroParentComponent {\n  heroes = HEROES;\n  master = 'Master';\n}"
      },
      {
        "language": "text",
        "code": "content_copy\n      \n      // ...\nconst heroNames = ['Dr. IQ', 'Magneta', 'Bombasto'];\nconst masterName = 'Master';\n\nit('should pass properties to children properly', async () => {\n  const parent = element(by.tagName('app-hero-parent'));\n  const heroes = parent.all(by.tagName('app-hero-child'));\n\n  for (let i = 0; i < heroNames.length; i++) {\n    const childTitle = await heroes.get(i).element(by.tagName('h3')).getText();\n    const childDetail = await heroes.get(i).element(by.tagName('p')).getText();\n    expect(childTitle).toEqual(heroNames[i] + ' says:');\n    expect(childDetail).toContain(masterName);\n  }\n});\n// ..."
      },
      {
        "language": "text",
        "code": "// ...\nconst heroNames = ['Dr. IQ', 'Magneta', 'Bombasto'];\nconst masterName = 'Master';\n\nit('should pass properties to children properly', async () => {\n  const parent = element(by.tagName('app-hero-parent'));\n  const heroes = parent.all(by.tagName('app-hero-child'));\n\n  for (let i = 0; i < heroNames.length; i++) {\n    const childTitle = await heroes.get(i).element(by.tagName('h3')).getText();\n    const childDetail = await heroes.get(i).element(by.tagName('p')).getText();\n    expect(childTitle).toEqual(heroNames[i] + ' says:');\n    expect(childDetail).toContain(masterName);\n  }\n});\n// ..."
      },
      {
        "language": "text",
        "code": "NameChildComponent"
      },
      {
        "language": "text",
        "code": "content_copy\n      \n      import { Component, Input } from '@angular/core';\n\n@Component({\n  selector: 'app-name-child',\n  template: '<h3>\"{{name}}\"</h3>'\n})\nexport class NameChildComponent {\n  @Input()\n  get name(): string { return this._name; }\n  set name(name: string) {\n    this._name = (name && name.trim()) || '<no name set>';\n  }\n  private _name = '';\n}"
      },
      {
        "language": "text",
        "code": "import { Component, Input } from '@angular/core';\n\n@Component({\n  selector: 'app-name-child',\n  template: '<h3>\"{{name}}\"</h3>'\n})\nexport class NameChildComponent {\n  @Input()\n  get name(): string { return this._name; }\n  set name(name: string) {\n    this._name = (name && name.trim()) || '<no name set>';\n  }\n  private _name = '';\n}"
      },
      {
        "language": "text",
        "code": "NameParentComponent"
      },
      {
        "language": "text",
        "code": "content_copy\n      \n      import { Component } from '@angular/core';\n\n@Component({\n  selector: 'app-name-parent',\n  template: `\n    <h2>Master controls {{names.length}} names</h2>\n\n    <app-name-child *ngFor=\"let name of names\" [name]=\"name\"></app-name-child>\n  `\n})\nexport class NameParentComponent {\n  // Displays 'Dr. IQ', '<no name set>', 'Bombasto'\n  names = ['Dr. IQ', '   ', '  Bombasto  '];\n}"
      },
      {
        "language": "text",
        "code": "import { Component } from '@angular/core';\n\n@Component({\n  selector: 'app-name-parent',\n  template: `\n    <h2>Master controls {{names.length}} names</h2>\n\n    <app-name-child *ngFor=\"let name of names\" [name]=\"name\"></app-name-child>\n  `\n})\nexport class NameParentComponent {\n  // Displays 'Dr. IQ', '<no name set>', 'Bombasto'\n  names = ['Dr. IQ', '   ', '  Bombasto  '];\n}"
      },
      {
        "language": "text",
        "code": "content_copy\n      \n      // ...\nit('should display trimmed, non-empty names', async () => {\n  const nonEmptyNameIndex = 0;\n  const nonEmptyName = '\"Dr. IQ\"';\n  const parent = element(by.tagName('app-name-parent'));\n  const hero = parent.all(by.tagName('app-name-child')).get(nonEmptyNameIndex);\n\n  const displayName = await hero.element(by.tagName('h3')).getText();\n  expect(displayName).toEqual(nonEmptyName);\n});\n\nit('should replace empty name with default name', async () => {\n  const emptyNameIndex = 1;\n  const defaultName = '\"<no name set>\"';\n  const parent = element(by.tagName('app-name-parent'));\n  const hero = parent.all(by.tagName('app-name-child')).get(emptyNameIndex);\n\n  const displayName = await hero.element(by.tagName('h3')).getText();\n  expect(displayName).toEqual(defaultName);\n});\n// ..."
      },
      {
        "language": "text",
        "code": "// ...\nit('should display trimmed, non-empty names', async () => {\n  const nonEmptyNameIndex = 0;\n  const nonEmptyName = '\"Dr. IQ\"';\n  const parent = element(by.tagName('app-name-parent'));\n  const hero = parent.all(by.tagName('app-name-child')).get(nonEmptyNameIndex);\n\n  const displayName = await hero.element(by.tagName('h3')).getText();\n  expect(displayName).toEqual(nonEmptyName);\n});\n\nit('should replace empty name with default name', async () => {\n  const emptyNameIndex = 1;\n  const defaultName = '\"<no name set>\"';\n  const parent = element(by.tagName('app-name-parent'));\n  const hero = parent.all(by.tagName('app-name-child')).get(emptyNameIndex);\n\n  const displayName = await hero.element(by.tagName('h3')).getText();\n  expect(displayName).toEqual(defaultName);\n});\n// ..."
      },
      {
        "language": "text",
        "code": "ngOnChanges()"
      },
      {
        "language": "text",
        "code": "ngOnChanges()"
      },
      {
        "language": "text",
        "code": "ngOnChanges()"
      },
      {
        "language": "text",
        "code": "VersionChildComponent"
      },
      {
        "language": "text",
        "code": "content_copy\n      \n      import { Component, Input, OnChanges, SimpleChanges } from '@angular/core';\n\n@Component({\n  selector: 'app-version-child',\n  template: `\n    <h3>Version {{major}}.{{minor}}</h3>\n    <h4>Change log:</h4>\n    <ul>\n      <li *ngFor=\"let change of changeLog\">{{change}}</li>\n    </ul>\n  `\n})\nexport class VersionChildComponent implements OnChanges {\n  @Input() major = 0;\n  @Input() minor = 0;\n  changeLog: string[] = [];\n\n  ngOnChanges(changes: SimpleChanges) {\n    const log: string[] = [];\n    for (const propName in changes) {\n      const changedProp = changes[propName];\n      const to = JSON.stringify(changedProp.currentValue);\n      if (changedProp.isFirstChange()) {\n        log.push(`Initial value of ${propName} set to ${to}`);\n      } else {\n        const from = JSON.stringify(changedProp.previousValue);\n        log.push(`${propName} changed from ${from} to ${to}`);\n      }\n    }\n    this.changeLog.push(log.join(', '));\n  }\n}"
      },
      {
        "language": "text",
        "code": "import { Component, Input, OnChanges, SimpleChanges } from '@angular/core';\n\n@Component({\n  selector: 'app-version-child',\n  template: `\n    <h3>Version {{major}}.{{minor}}</h3>\n    <h4>Change log:</h4>\n    <ul>\n      <li *ngFor=\"let change of changeLog\">{{change}}</li>\n    </ul>\n  `\n})\nexport class VersionChildComponent implements OnChanges {\n  @Input() major = 0;\n  @Input() minor = 0;\n  changeLog: string[] = [];\n\n  ngOnChanges(changes: SimpleChanges) {\n    const log: string[] = [];\n    for (const propName in changes) {\n      const changedProp = changes[propName];\n      const to = JSON.stringify(changedProp.currentValue);\n      if (changedProp.isFirstChange()) {\n        log.push(`Initial value of ${propName} set to ${to}`);\n      } else {\n        const from = JSON.stringify(changedProp.previousValue);\n        log.push(`${propName} changed from ${from} to ${to}`);\n      }\n    }\n    this.changeLog.push(log.join(', '));\n  }\n}"
      },
      {
        "language": "text",
        "code": "VersionParentComponent"
      },
      {
        "language": "text",
        "code": "content_copy\n      \n      import { Component } from '@angular/core';\n\n@Component({\n  selector: 'app-version-parent',\n  template: `\n    <h2>Source code version</h2>\n    <button type=\"button\" (click)=\"newMinor()\">New minor version</button>\n    <button type=\"button\" (click)=\"newMajor()\">New major version</button>\n    <app-version-child [major]=\"major\" [minor]=\"minor\"></app-version-child>\n  `\n})\nexport class VersionParentComponent {\n  major = 1;\n  minor = 23;\n\n  newMinor() {\n    this.minor++;\n  }\n\n  newMajor() {\n    this.major++;\n    this.minor = 0;\n  }\n}"
      },
      {
        "language": "text",
        "code": "import { Component } from '@angular/core';\n\n@Component({\n  selector: 'app-version-parent',\n  template: `\n    <h2>Source code version</h2>\n    <button type=\"button\" (click)=\"newMinor()\">New minor version</button>\n    <button type=\"button\" (click)=\"newMajor()\">New major version</button>\n    <app-version-child [major]=\"major\" [minor]=\"minor\"></app-version-child>\n  `\n})\nexport class VersionParentComponent {\n  major = 1;\n  minor = 23;\n\n  newMinor() {\n    this.minor++;\n  }\n\n  newMajor() {\n    this.major++;\n    this.minor = 0;\n  }\n}"
      },
      {
        "language": "text",
        "code": "ngOnChanges()"
      },
      {
        "language": "text",
        "code": "ngOnChanges"
      },
      {
        "language": "text",
        "code": "content_copy\n      \n      // ...\n// Test must all execute in this exact order\nit('should set expected initial values', async () => {\n  const actual = await getActual();\n\n  const initialLabel = 'Version 1.23';\n  const initialLog = 'Initial value of major set to 1, Initial value of minor set to 23';\n\n  expect(actual.label).toBe(initialLabel);\n  expect(actual.count).toBe(1);\n  expect(await actual.logs.get(0).getText()).toBe(initialLog);\n});\n\nit(\"should set expected values after clicking 'Minor' twice\", async () => {\n  const repoTag = element(by.tagName('app-version-parent'));\n  const newMinorButton = repoTag.all(by.tagName('button')).get(0);\n\n  await newMinorButton.click();\n  await newMinorButton.click();\n\n  const actual = await getActual();\n\n  const labelAfter2Minor = 'Version 1.25';\n  const logAfter2Minor = 'minor changed from 24 to 25';\n\n  expect(actual.label).toBe(labelAfter2Minor);\n  expect(actual.count).toBe(3);\n  expect(await actual.logs.get(2).getText()).toBe(logAfter2Minor);\n});\n\nit(\"should set expected values after clicking 'Major' once\", async () => {\n  const repoTag = element(by.tagName('app-version-parent'));\n  const newMajorButton = repoTag.all(by.tagName('button')).get(1);\n\n  await newMajorButton.click();\n  const actual = await getActual();\n\n  const labelAfterMajor = 'Version 2.0';\n  const logAfterMajor = 'major changed from 1 to 2, minor changed from 23 to 0';\n\n  expect(actual.label).toBe(labelAfterMajor);\n  expect(actual.count).toBe(2);\n  expect(await actual.logs.get(1).getText()).toBe(logAfterMajor);\n});\n\nasync function getActual() {\n  const versionTag = element(by.tagName('app-version-child'));\n  const label = await versionTag.element(by.tagName('h3')).getText();\n  const ul = versionTag.element((by.tagName('ul')));\n  const logs = ul.all(by.tagName('li'));\n\n  return {\n    label,\n    logs,\n    count: await logs.count(),\n  };\n}\n// ..."
      },
      {
        "language": "text",
        "code": "// ...\n// Test must all execute in this exact order\nit('should set expected initial values', async () => {\n  const actual = await getActual();\n\n  const initialLabel = 'Version 1.23';\n  const initialLog = 'Initial value of major set to 1, Initial value of minor set to 23';\n\n  expect(actual.label).toBe(initialLabel);\n  expect(actual.count).toBe(1);\n  expect(await actual.logs.get(0).getText()).toBe(initialLog);\n});\n\nit(\"should set expected values after clicking 'Minor' twice\", async () => {\n  const repoTag = element(by.tagName('app-version-parent'));\n  const newMinorButton = repoTag.all(by.tagName('button')).get(0);\n\n  await newMinorButton.click();\n  await newMinorButton.click();\n\n  const actual = await getActual();\n\n  const labelAfter2Minor = 'Version 1.25';\n  const logAfter2Minor = 'minor changed from 24 to 25';\n\n  expect(actual.label).toBe(labelAfter2Minor);\n  expect(actual.count).toBe(3);\n  expect(await actual.logs.get(2).getText()).toBe(logAfter2Minor);\n});\n\nit(\"should set expected values after clicking 'Major' once\", async () => {\n  const repoTag = element(by.tagName('app-version-parent'));\n  const newMajorButton = repoTag.all(by.tagName('button')).get(1);\n\n  await newMajorButton.click();\n  const actual = await getActual();\n\n  const labelAfterMajor = 'Version 2.0';\n  const logAfterMajor = 'major changed from 1 to 2, minor changed from 23 to 0';\n\n  expect(actual.label).toBe(labelAfterMajor);\n  expect(actual.count).toBe(2);\n  expect(await actual.logs.get(1).getText()).toBe(logAfterMajor);\n});\n\nasync function getActual() {\n  const versionTag = element(by.tagName('app-version-child'));\n  const label = await versionTag.element(by.tagName('h3')).getText();\n  const ul = versionTag.element((by.tagName('ul')));\n  const logs = ul.all(by.tagName('li'));\n\n  return {\n    label,\n    logs,\n    count: await logs.count(),\n  };\n}\n// ..."
      },
      {
        "language": "text",
        "code": "EventEmitter"
      },
      {
        "language": "text",
        "code": "EventEmitter"
      },
      {
        "language": "text",
        "code": "VoterComponent"
      },
      {
        "language": "text",
        "code": "content_copy\n      \n      import { Component, EventEmitter, Input, Output } from '@angular/core';\n\n@Component({\n  selector: 'app-voter',\n  template: `\n    <h4>{{name}}</h4>\n    <button type=\"button\" (click)=\"vote(true)\"  [disabled]=\"didVote\">Agree</button>\n    <button type=\"button\" (click)=\"vote(false)\" [disabled]=\"didVote\">Disagree</button>\n  `\n})\nexport class VoterComponent {\n  @Input()  name = '';\n  @Output() voted = new EventEmitter<boolean>();\n  didVote = false;\n\n  vote(agreed: boolean) {\n    this.voted.emit(agreed);\n    this.didVote = true;\n  }\n}"
      },
      {
        "language": "text",
        "code": "import { Component, EventEmitter, Input, Output } from '@angular/core';\n\n@Component({\n  selector: 'app-voter',\n  template: `\n    <h4>{{name}}</h4>\n    <button type=\"button\" (click)=\"vote(true)\"  [disabled]=\"didVote\">Agree</button>\n    <button type=\"button\" (click)=\"vote(false)\" [disabled]=\"didVote\">Disagree</button>\n  `\n})\nexport class VoterComponent {\n  @Input()  name = '';\n  @Output() voted = new EventEmitter<boolean>();\n  didVote = false;\n\n  vote(agreed: boolean) {\n    this.voted.emit(agreed);\n    this.didVote = true;\n  }\n}"
      },
      {
        "language": "text",
        "code": "VoteTakerComponent"
      },
      {
        "language": "text",
        "code": "content_copy\n      \n      import { Component } from '@angular/core';\n\n@Component({\n  selector: 'app-vote-taker',\n  template: `\n    <h2>Should mankind colonize the Universe?</h2>\n    <h3>Agree: {{agreed}}, Disagree: {{disagreed}}</h3>\n\n    <app-voter\n      *ngFor=\"let voter of voters\"\n      [name]=\"voter\"\n      (voted)=\"onVoted($event)\">\n    </app-voter>\n  `\n})\nexport class VoteTakerComponent {\n  agreed = 0;\n  disagreed = 0;\n  voters = ['Dr. IQ', 'Celeritas', 'Bombasto'];\n\n  onVoted(agreed: boolean) {\n    if (agreed) {\n      this.agreed++;\n    } else {\n      this.disagreed++;\n    }\n  }\n}"
      },
      {
        "language": "text",
        "code": "import { Component } from '@angular/core';\n\n@Component({\n  selector: 'app-vote-taker',\n  template: `\n    <h2>Should mankind colonize the Universe?</h2>\n    <h3>Agree: {{agreed}}, Disagree: {{disagreed}}</h3>\n\n    <app-voter\n      *ngFor=\"let voter of voters\"\n      [name]=\"voter\"\n      (voted)=\"onVoted($event)\">\n    </app-voter>\n  `\n})\nexport class VoteTakerComponent {\n  agreed = 0;\n  disagreed = 0;\n  voters = ['Dr. IQ', 'Celeritas', 'Bombasto'];\n\n  onVoted(agreed: boolean) {\n    if (agreed) {\n      this.agreed++;\n    } else {\n      this.disagreed++;\n    }\n  }\n}"
      },
      {
        "language": "text",
        "code": "content_copy\n      \n      // ...\nit('should not emit the event initially', async () => {\n  const voteLabel = element(by.tagName('app-vote-taker')).element(by.tagName('h3'));\n  expect(await voteLabel.getText()).toBe('Agree: 0, Disagree: 0');\n});\n\nit('should process Agree vote', async () => {\n  const voteLabel = element(by.tagName('app-vote-taker')).element(by.tagName('h3'));\n  const agreeButton1 = element.all(by.tagName('app-voter')).get(0)\n    .all(by.tagName('button')).get(0);\n\n  await agreeButton1.click();\n\n  expect(await voteLabel.getText()).toBe('Agree: 1, Disagree: 0');\n});\n\nit('should process Disagree vote', async () => {\n  const voteLabel = element(by.tagName('app-vote-taker')).element(by.tagName('h3'));\n  const agreeButton1 = element.all(by.tagName('app-voter')).get(1)\n    .all(by.tagName('button')).get(1);\n\n  await agreeButton1.click();\n\n  expect(await voteLabel.getText()).toBe('Agree: 0, Disagree: 1');\n});\n// ..."
      },
      {
        "language": "text",
        "code": "// ...\nit('should not emit the event initially', async () => {\n  const voteLabel = element(by.tagName('app-vote-taker')).element(by.tagName('h3'));\n  expect(await voteLabel.getText()).toBe('Agree: 0, Disagree: 0');\n});\n\nit('should process Agree vote', async () => {\n  const voteLabel = element(by.tagName('app-vote-taker')).element(by.tagName('h3'));\n  const agreeButton1 = element.all(by.tagName('app-voter')).get(0)\n    .all(by.tagName('button')).get(0);\n\n  await agreeButton1.click();\n\n  expect(await voteLabel.getText()).toBe('Agree: 1, Disagree: 0');\n});\n\nit('should process Disagree vote', async () => {\n  const voteLabel = element(by.tagName('app-vote-taker')).element(by.tagName('h3'));\n  const agreeButton1 = element.all(by.tagName('app-voter')).get(1)\n    .all(by.tagName('button')).get(1);\n\n  await agreeButton1.click();\n\n  expect(await voteLabel.getText()).toBe('Agree: 0, Disagree: 1');\n});\n// ..."
      },
      {
        "language": "text",
        "code": "CountdownTimerComponent"
      },
      {
        "language": "text",
        "code": "content_copy\n      \n      import { Component, OnDestroy } from '@angular/core';\n\n@Component({\n  selector: 'app-countdown-timer',\n  template: '<p>{{message}}</p>'\n})\nexport class CountdownTimerComponent implements OnDestroy {\n  message = '';\n  seconds = 11;\n\n  ngOnDestroy() { this.clearTimer?.(); }\n\n  start() { this.countDown(); }\n  stop()  {\n    this.clearTimer?.();\n    this.message = `Holding at T-${this.seconds} seconds`;\n  }\n\n  private clearTimer: VoidFunction | undefined;\n\n  private countDown() {\n    this.clearTimer?.();\n    const interval = setInterval(() => {\n      this.seconds -= 1;\n      if (this.seconds === 0) {\n        this.message = 'Blast off!';\n      } else {\n        if (this.seconds < 0) { this.seconds = 10; } // reset\n        this.message = `T-${this.seconds} seconds and counting`;\n      }\n    }, 1000);\n    this.clearTimer = () => clearInterval(interval);\n  }\n}"
      },
      {
        "language": "text",
        "code": "import { Component, OnDestroy } from '@angular/core';\n\n@Component({\n  selector: 'app-countdown-timer',\n  template: '<p>{{message}}</p>'\n})\nexport class CountdownTimerComponent implements OnDestroy {\n  message = '';\n  seconds = 11;\n\n  ngOnDestroy() { this.clearTimer?.(); }\n\n  start() { this.countDown(); }\n  stop()  {\n    this.clearTimer?.();\n    this.message = `Holding at T-${this.seconds} seconds`;\n  }\n\n  private clearTimer: VoidFunction | undefined;\n\n  private countDown() {\n    this.clearTimer?.();\n    const interval = setInterval(() => {\n      this.seconds -= 1;\n      if (this.seconds === 0) {\n        this.message = 'Blast off!';\n      } else {\n        if (this.seconds < 0) { this.seconds = 10; } // reset\n        this.message = `T-${this.seconds} seconds and counting`;\n      }\n    }, 1000);\n    this.clearTimer = () => clearInterval(interval);\n  }\n}"
      },
      {
        "language": "text",
        "code": "CountdownLocalVarParentComponent"
      },
      {
        "language": "text",
        "code": "content_copy\n      \n      import { Component } from '@angular/core';\nimport { CountdownTimerComponent } from './countdown-timer.component';\n\n@Component({\n  selector: 'app-countdown-parent-lv',\n  template: `\n    <h3>Countdown to Liftoff (via local variable)</h3>\n    <button type=\"button\" (click)=\"timer.start()\">Start</button>\n    <button type=\"button\" (click)=\"timer.stop()\">Stop</button>\n    <div class=\"seconds\">{{timer.seconds}}</div>\n    <app-countdown-timer #timer></app-countdown-timer>\n  `,\n  styleUrls: ['../assets/demo.css']\n})\nexport class CountdownLocalVarParentComponent { }"
      },
      {
        "language": "text",
        "code": "import { Component } from '@angular/core';\nimport { CountdownTimerComponent } from './countdown-timer.component';\n\n@Component({\n  selector: 'app-countdown-parent-lv',\n  template: `\n    <h3>Countdown to Liftoff (via local variable)</h3>\n    <button type=\"button\" (click)=\"timer.start()\">Start</button>\n    <button type=\"button\" (click)=\"timer.stop()\">Stop</button>\n    <div class=\"seconds\">{{timer.seconds}}</div>\n    <app-countdown-timer #timer></app-countdown-timer>\n  `,\n  styleUrls: ['../assets/demo.css']\n})\nexport class CountdownLocalVarParentComponent { }"
      },
      {
        "language": "text",
        "code": "<app-countdown-timer>"
      },
      {
        "language": "text",
        "code": "content_copy\n      \n      // ...\n// The tests trigger periodic asynchronous operations (via `setInterval()`), which will prevent\n// the app from stabilizing. See https://angular.io/api/core/ApplicationRef#is-stable-examples\n// for more details.\n// To allow the tests to complete, we will disable automatically waiting for the Angular app to\n// stabilize.\nbeforeEach(() => browser.waitForAngularEnabled(false));\nafterEach(() => browser.waitForAngularEnabled(true));\n\nit('timer and parent seconds should match', async () => {\n  const parent = element(by.tagName(parentTag));\n  const startButton = parent.element(by.buttonText('Start'));\n  const seconds = parent.element(by.className('seconds'));\n  const timer = parent.element(by.tagName('app-countdown-timer'));\n\n  await startButton.click();\n\n  // Wait for `<app-countdown-timer>` to be populated with any text.\n  await browser.wait(() => timer.getText(), 2000);\n\n  expect(await timer.getText()).toContain(await seconds.getText());\n});\n\nit('should stop the countdown', async () => {\n  const parent = element(by.tagName(parentTag));\n  const startButton = parent.element(by.buttonText('Start'));\n  const stopButton = parent.element(by.buttonText('Stop'));\n  const timer = parent.element(by.tagName('app-countdown-timer'));\n\n  await startButton.click();\n  expect(await timer.getText()).not.toContain('Holding');\n\n  await stopButton.click();\n  expect(await timer.getText()).toContain('Holding');\n});\n// ..."
      },
      {
        "language": "text",
        "code": "// ...\n// The tests trigger periodic asynchronous operations (via `setInterval()`), which will prevent\n// the app from stabilizing. See https://angular.io/api/core/ApplicationRef#is-stable-examples\n// for more details.\n// To allow the tests to complete, we will disable automatically waiting for the Angular app to\n// stabilize.\nbeforeEach(() => browser.waitForAngularEnabled(false));\nafterEach(() => browser.waitForAngularEnabled(true));\n\nit('timer and parent seconds should match', async () => {\n  const parent = element(by.tagName(parentTag));\n  const startButton = parent.element(by.buttonText('Start'));\n  const seconds = parent.element(by.className('seconds'));\n  const timer = parent.element(by.tagName('app-countdown-timer'));\n\n  await startButton.click();\n\n  // Wait for `<app-countdown-timer>` to be populated with any text.\n  await browser.wait(() => timer.getText(), 2000);\n\n  expect(await timer.getText()).toContain(await seconds.getText());\n});\n\nit('should stop the countdown', async () => {\n  const parent = element(by.tagName(parentTag));\n  const startButton = parent.element(by.buttonText('Start'));\n  const stopButton = parent.element(by.buttonText('Stop'));\n  const timer = parent.element(by.tagName('app-countdown-timer'));\n\n  await startButton.click();\n  expect(await timer.getText()).not.toContain('Holding');\n\n  await stopButton.click();\n  expect(await timer.getText()).toContain('Holding');\n});\n// ..."
      },
      {
        "language": "text",
        "code": "@ViewChild()"
      },
      {
        "language": "text",
        "code": "CountdownViewChildParentComponent"
      },
      {
        "language": "text",
        "code": "content_copy\n      \n      import { AfterViewInit, ViewChild } from '@angular/core';\nimport { Component } from '@angular/core';\nimport { CountdownTimerComponent } from './countdown-timer.component';\n\n@Component({\n  selector: 'app-countdown-parent-vc',\n  template: `\n    <h3>Countdown to Liftoff (via ViewChild)</h3>\n    <button type=\"button\" (click)=\"start()\">Start</button>\n    <button type=\"button\" (click)=\"stop()\">Stop</button>\n    <div class=\"seconds\">{{ seconds() }}</div>\n    <app-countdown-timer></app-countdown-timer>\n  `,\n  styleUrls: ['../assets/demo.css']\n})\nexport class CountdownViewChildParentComponent implements AfterViewInit {\n\n  @ViewChild(CountdownTimerComponent)\n  private timerComponent!: CountdownTimerComponent;\n\n  seconds() { return 0; }\n\n  ngAfterViewInit() {\n    // Redefine `seconds()` to get from the `CountdownTimerComponent.seconds` ...\n    // but wait a tick first to avoid one-time devMode\n    // unidirectional-data-flow-violation error\n    setTimeout(() => this.seconds = () => this.timerComponent.seconds, 0);\n  }\n\n  start() { this.timerComponent.start(); }\n  stop() { this.timerComponent.stop(); }\n}"
      },
      {
        "language": "text",
        "code": "import { AfterViewInit, ViewChild } from '@angular/core';\nimport { Component } from '@angular/core';\nimport { CountdownTimerComponent } from './countdown-timer.component';\n\n@Component({\n  selector: 'app-countdown-parent-vc',\n  template: `\n    <h3>Countdown to Liftoff (via ViewChild)</h3>\n    <button type=\"button\" (click)=\"start()\">Start</button>\n    <button type=\"button\" (click)=\"stop()\">Stop</button>\n    <div class=\"seconds\">{{ seconds() }}</div>\n    <app-countdown-timer></app-countdown-timer>\n  `,\n  styleUrls: ['../assets/demo.css']\n})\nexport class CountdownViewChildParentComponent implements AfterViewInit {\n\n  @ViewChild(CountdownTimerComponent)\n  private timerComponent!: CountdownTimerComponent;\n\n  seconds() { return 0; }\n\n  ngAfterViewInit() {\n    // Redefine `seconds()` to get from the `CountdownTimerComponent.seconds` ...\n    // but wait a tick first to avoid one-time devMode\n    // unidirectional-data-flow-violation error\n    setTimeout(() => this.seconds = () => this.timerComponent.seconds, 0);\n  }\n\n  start() { this.timerComponent.start(); }\n  stop() { this.timerComponent.stop(); }\n}"
      },
      {
        "language": "text",
        "code": "AfterViewInit"
      },
      {
        "language": "text",
        "code": "CountdownTimerComponent"
      },
      {
        "language": "text",
        "code": "timerComponent"
      },
      {
        "language": "text",
        "code": "ngAfterViewInit()"
      },
      {
        "language": "text",
        "code": "ngAfterViewInit"
      },
      {
        "language": "text",
        "code": "setTimeout()"
      },
      {
        "language": "text",
        "code": "@ViewChild()"
      },
      {
        "language": "text",
        "code": "MissionService"
      },
      {
        "language": "text",
        "code": "MissionControlComponent"
      },
      {
        "language": "text",
        "code": "AstronautComponent"
      },
      {
        "language": "text",
        "code": "content_copy\n      \n      import { Injectable } from '@angular/core';\nimport { Subject } from 'rxjs';\n\n@Injectable()\nexport class MissionService {\n\n  // Observable string sources\n  private missionAnnouncedSource = new Subject<string>();\n  private missionConfirmedSource = new Subject<string>();\n\n  // Observable string streams\n  missionAnnounced$ = this.missionAnnouncedSource.asObservable();\n  missionConfirmed$ = this.missionConfirmedSource.asObservable();\n\n  // Service message commands\n  announceMission(mission: string) {\n    this.missionAnnouncedSource.next(mission);\n  }\n\n  confirmMission(astronaut: string) {\n    this.missionConfirmedSource.next(astronaut);\n  }\n}"
      },
      {
        "language": "text",
        "code": "import { Injectable } from '@angular/core';\nimport { Subject } from 'rxjs';\n\n@Injectable()\nexport class MissionService {\n\n  // Observable string sources\n  private missionAnnouncedSource = new Subject<string>();\n  private missionConfirmedSource = new Subject<string>();\n\n  // Observable string streams\n  missionAnnounced$ = this.missionAnnouncedSource.asObservable();\n  missionConfirmed$ = this.missionConfirmedSource.asObservable();\n\n  // Service message commands\n  announceMission(mission: string) {\n    this.missionAnnouncedSource.next(mission);\n  }\n\n  confirmMission(astronaut: string) {\n    this.missionConfirmedSource.next(astronaut);\n  }\n}"
      },
      {
        "language": "text",
        "code": "MissionControlComponent"
      },
      {
        "language": "text",
        "code": "content_copy\n      \n      import { Component } from '@angular/core';\n\nimport { MissionService } from './mission.service';\n\n@Component({\n  selector: 'app-mission-control',\n  template: `\n    <h2>Mission Control</h2>\n    <button type=\"button\" (click)=\"announce()\">Announce mission</button>\n\n    <app-astronaut\n      *ngFor=\"let astronaut of astronauts\"\n      [astronaut]=\"astronaut\">\n    </app-astronaut>\n\n    <h3>History</h3>\n    <ul>\n      <li *ngFor=\"let event of history\">{{event}}</li>\n    </ul>\n  `,\n  providers: [MissionService]\n})\nexport class MissionControlComponent {\n  astronauts = ['Lovell', 'Swigert', 'Haise'];\n  history: string[] = [];\n  missions = ['Fly to the moon!',\n              'Fly to mars!',\n              'Fly to Vegas!'];\n  nextMission = 0;\n\n  constructor(private missionService: MissionService) {\n    missionService.missionConfirmed$.subscribe(\n      astronaut => {\n        this.history.push(`${astronaut} confirmed the mission`);\n      });\n  }\n\n  announce() {\n    const mission = this.missions[this.nextMission++];\n    this.missionService.announceMission(mission);\n    this.history.push(`Mission \"${mission}\" announced`);\n    if (this.nextMission >= this.missions.length) { this.nextMission = 0; }\n  }\n}"
      },
      {
        "language": "text",
        "code": "import { Component } from '@angular/core';\n\nimport { MissionService } from './mission.service';\n\n@Component({\n  selector: 'app-mission-control',\n  template: `\n    <h2>Mission Control</h2>\n    <button type=\"button\" (click)=\"announce()\">Announce mission</button>\n\n    <app-astronaut\n      *ngFor=\"let astronaut of astronauts\"\n      [astronaut]=\"astronaut\">\n    </app-astronaut>\n\n    <h3>History</h3>\n    <ul>\n      <li *ngFor=\"let event of history\">{{event}}</li>\n    </ul>\n  `,\n  providers: [MissionService]\n})\nexport class MissionControlComponent {\n  astronauts = ['Lovell', 'Swigert', 'Haise'];\n  history: string[] = [];\n  missions = ['Fly to the moon!',\n              'Fly to mars!',\n              'Fly to Vegas!'];\n  nextMission = 0;\n\n  constructor(private missionService: MissionService) {\n    missionService.missionConfirmed$.subscribe(\n      astronaut => {\n        this.history.push(`${astronaut} confirmed the mission`);\n      });\n  }\n\n  announce() {\n    const mission = this.missions[this.nextMission++];\n    this.missionService.announceMission(mission);\n    this.history.push(`Mission \"${mission}\" announced`);\n    if (this.nextMission >= this.missions.length) { this.nextMission = 0; }\n  }\n}"
      },
      {
        "language": "text",
        "code": "AstronautComponent"
      },
      {
        "language": "text",
        "code": "AstronautComponent"
      },
      {
        "language": "text",
        "code": "MissionControlComponent"
      },
      {
        "language": "text",
        "code": "content_copy\n      \n      import { Component, Input, OnDestroy } from '@angular/core';\n\nimport { MissionService } from './mission.service';\nimport { Subscription } from 'rxjs';\n\n@Component({\n  selector: 'app-astronaut',\n  template: `\n    <p>\n      {{astronaut}}: <strong>{{mission}}</strong>\n      <button\n        type=\"button\"\n        (click)=\"confirm()\"\n        [disabled]=\"!announced || confirmed\">\n        Confirm\n      </button>\n    </p>\n  `\n})\nexport class AstronautComponent implements OnDestroy {\n  @Input() astronaut = '';\n  mission = '<no mission announced>';\n  confirmed = false;\n  announced = false;\n  subscription: Subscription;\n\n  constructor(private missionService: MissionService) {\n    this.subscription = missionService.missionAnnounced$.subscribe(\n      mission => {\n        this.mission = mission;\n        this.announced = true;\n        this.confirmed = false;\n    });\n  }\n\n  confirm() {\n    this.confirmed = true;\n    this.missionService.confirmMission(this.astronaut);\n  }\n\n  ngOnDestroy() {\n    // prevent memory leak when component destroyed\n    this.subscription.unsubscribe();\n  }\n}"
      },
      {
        "language": "text",
        "code": "import { Component, Input, OnDestroy } from '@angular/core';\n\nimport { MissionService } from './mission.service';\nimport { Subscription } from 'rxjs';\n\n@Component({\n  selector: 'app-astronaut',\n  template: `\n    <p>\n      {{astronaut}}: <strong>{{mission}}</strong>\n      <button\n        type=\"button\"\n        (click)=\"confirm()\"\n        [disabled]=\"!announced || confirmed\">\n        Confirm\n      </button>\n    </p>\n  `\n})\nexport class AstronautComponent implements OnDestroy {\n  @Input() astronaut = '';\n  mission = '<no mission announced>';\n  confirmed = false;\n  announced = false;\n  subscription: Subscription;\n\n  constructor(private missionService: MissionService) {\n    this.subscription = missionService.missionAnnounced$.subscribe(\n      mission => {\n        this.mission = mission;\n        this.announced = true;\n        this.confirmed = false;\n    });\n  }\n\n  confirm() {\n    this.confirmed = true;\n    this.missionService.confirmMission(this.astronaut);\n  }\n\n  ngOnDestroy() {\n    // prevent memory leak when component destroyed\n    this.subscription.unsubscribe();\n  }\n}"
      },
      {
        "language": "text",
        "code": "subscription"
      },
      {
        "language": "text",
        "code": "unsubscribe()"
      },
      {
        "language": "text",
        "code": "AstronautComponent"
      },
      {
        "language": "text",
        "code": "AstronautComponent"
      },
      {
        "language": "text",
        "code": "MissionControlComponent"
      },
      {
        "language": "text",
        "code": "MissionService"
      },
      {
        "language": "text",
        "code": "MissionControlComponent"
      },
      {
        "language": "text",
        "code": "AstronautComponent"
      },
      {
        "language": "text",
        "code": "MissionControlComponent"
      },
      {
        "language": "text",
        "code": "AstronautComponent"
      },
      {
        "language": "text",
        "code": "content_copy\n      \n      // ...\nit('should announce a mission', async () => {\n  const missionControl = element(by.tagName('app-mission-control'));\n  const announceButton = missionControl.all(by.tagName('button')).get(0);\n  const history = missionControl.all(by.tagName('li'));\n\n  await announceButton.click();\n\n  expect(await history.count()).toBe(1);\n  expect(await history.get(0).getText()).toMatch(/Mission.* announced/);\n});\n\nit('should confirm the mission by Lovell', async () => {\n  await testConfirmMission(1, 'Lovell');\n});\n\nit('should confirm the mission by Haise', async () => {\n  await testConfirmMission(3, 'Haise');\n});\n\nit('should confirm the mission by Swigert', async () => {\n  await testConfirmMission(2, 'Swigert');\n});\n\nasync function testConfirmMission(buttonIndex: number, astronaut: string) {\n  const missionControl = element(by.tagName('app-mission-control'));\n  const announceButton = missionControl.all(by.tagName('button')).get(0);\n  const confirmButton = missionControl.all(by.tagName('button')).get(buttonIndex);\n  const history = missionControl.all(by.tagName('li'));\n\n  await announceButton.click();\n  await confirmButton.click();\n\n  expect(await history.count()).toBe(2);\n  expect(await history.get(1).getText()).toBe(`${astronaut} confirmed the mission`);\n}\n// ..."
      },
      {
        "language": "text",
        "code": "// ...\nit('should announce a mission', async () => {\n  const missionControl = element(by.tagName('app-mission-control'));\n  const announceButton = missionControl.all(by.tagName('button')).get(0);\n  const history = missionControl.all(by.tagName('li'));\n\n  await announceButton.click();\n\n  expect(await history.count()).toBe(1);\n  expect(await history.get(0).getText()).toMatch(/Mission.* announced/);\n});\n\nit('should confirm the mission by Lovell', async () => {\n  await testConfirmMission(1, 'Lovell');\n});\n\nit('should confirm the mission by Haise', async () => {\n  await testConfirmMission(3, 'Haise');\n});\n\nit('should confirm the mission by Swigert', async () => {\n  await testConfirmMission(2, 'Swigert');\n});\n\nasync function testConfirmMission(buttonIndex: number, astronaut: string) {\n  const missionControl = element(by.tagName('app-mission-control'));\n  const announceButton = missionControl.all(by.tagName('button')).get(0);\n  const confirmButton = missionControl.all(by.tagName('button')).get(buttonIndex);\n  const history = missionControl.all(by.tagName('li'));\n\n  await announceButton.click();\n  await confirmButton.click();\n\n  expect(await history.count()).toBe(2);\n  expect(await history.get(1).getText()).toBe(`${astronaut} confirmed the mission`);\n}\n// ..."
      }
    ],
    "links": [
      {
        "text": "link",
        "href": "guide/component-interaction#component-interaction"
      },
      {
        "text": "Pass data from parent to child with input binding",
        "href": "guide/component-interaction#pass-data-from-parent-to-child-with-input-binding"
      },
      {
        "text": "Test it for Pass data from parent to child with input binding",
        "href": "guide/component-interaction#test-it-for-pass-data-from-parent-to-child-with-input-binding"
      },
      {
        "text": "Intercept input property changes with a setter",
        "href": "guide/component-interaction#intercept-input-property-changes-with-a-setter"
      },
      {
        "text": "Test it for Intercept input property changes with a setter",
        "href": "guide/component-interaction#test-it-for-intercept-input-property-changes-with-a-setter"
      },
      {
        "text": "Intercept input property changes with ngOnChanges()",
        "href": "guide/component-interaction#intercept-input-property-changes-with-ngonchanges"
      },
      {
        "text": "Test it for Intercept input property changes with ngOnChanges()",
        "href": "guide/component-interaction#test-it-for-intercept-input-property-changes-with-ngonchanges"
      },
      {
        "text": "Parent listens for child event",
        "href": "guide/component-interaction#parent-listens-for-child-event"
      },
      {
        "text": "Test it for Parent listens for child event",
        "href": "guide/component-interaction#test-it-for-parent-listens-for-child-event"
      },
      {
        "text": "Parent interacts with child using local variable",
        "href": "guide/component-interaction#parent-interacts-with-child-using-local-variable"
      },
      {
        "text": "Test it for Parent interacts with child using local variable",
        "href": "guide/component-interaction#test-it-for-parent-interacts-with-child-using-local-variable"
      },
      {
        "text": "Parent calls an @ViewChild()",
        "href": "guide/component-interaction#parent-calls-an-viewchild"
      },
      {
        "text": "Test it for Parent calls an @ViewChild()",
        "href": "guide/component-interaction#test-it-for-parent-calls-an-viewchild"
      },
      {
        "text": "Parent and children communicate using a service",
        "href": "guide/component-interaction#parent-and-children-communicate-using-a-service"
      },
      {
        "text": "Test it for Parent and children communicate using a service",
        "href": "guide/component-interaction#test-it-for-parent-and-children-communicate-using-a-service"
      },
      {
        "text": "live example",
        "href": "generated/live-examples/component-interaction/stackblitz.html"
      },
      {
        "text": "download example",
        "href": "generated/zips/component-interaction/component-interaction.zip"
      },
      {
        "text": "link",
        "href": "guide/component-interaction#pass-data-from-parent-to-child-with-input-binding"
      },
      {
        "text": "@Input() decorator",
        "href": "guide/inputs-outputs#input"
      },
      {
        "text": "Component",
        "href": "api/core/Component"
      },
      {
        "text": "Input",
        "href": "api/core/Input"
      },
      {
        "text": "Component",
        "href": "api/core/Component"
      },
      {
        "text": "Input",
        "href": "api/core/Input"
      },
      {
        "text": "Input",
        "href": "api/core/Input"
      },
      {
        "text": "Input",
        "href": "api/core/Input"
      },
      {
        "text": "ngFor",
        "href": "api/common/NgFor"
      },
      {
        "text": "Component",
        "href": "api/core/Component"
      },
      {
        "text": "Component",
        "href": "api/core/Component"
      },
      {
        "text": "ngFor",
        "href": "api/common/NgFor"
      },
      {
        "text": "link",
        "href": "guide/component-interaction#test-it-for-pass-data-from-parent-to-child-with-input-binding"
      },
      {
        "text": "async",
        "href": "api/platform-browser/animations/async"
      },
      {
        "text": "Back to top",
        "href": "guide/component-interaction#top"
      },
      {
        "text": "link",
        "href": "guide/component-interaction#intercept-input-property-changes-with-a-setter"
      },
      {
        "text": "Component",
        "href": "api/core/Component"
      },
      {
        "text": "Input",
        "href": "api/core/Input"
      },
      {
        "text": "Component",
        "href": "api/core/Component"
      },
      {
        "text": "Input",
        "href": "api/core/Input"
      },
      {
        "text": "Component",
        "href": "api/core/Component"
      },
      {
        "text": "Component",
        "href": "api/core/Component"
      },
      {
        "text": "ngFor",
        "href": "api/common/NgFor"
      },
      {
        "text": "link",
        "href": "guide/component-interaction#test-it-for-intercept-input-property-changes-with-a-setter"
      },
      {
        "text": "async",
        "href": "api/platform-browser/animations/async"
      },
      {
        "text": "async",
        "href": "api/platform-browser/animations/async"
      },
      {
        "text": "Back to top",
        "href": "guide/component-interaction#top"
      },
      {
        "text": "link",
        "href": "guide/component-interaction#intercept-input-property-changes-with-ngonchanges"
      },
      {
        "text": "OnChanges",
        "href": "api/core/OnChanges"
      },
      {
        "text": "Lifecycle Hooks",
        "href": "guide/lifecycle-hooks"
      },
      {
        "text": "Component",
        "href": "api/core/Component"
      },
      {
        "text": "Input",
        "href": "api/core/Input"
      },
      {
        "text": "OnChanges",
        "href": "api/core/OnChanges"
      },
      {
        "text": "SimpleChanges",
        "href": "api/core/SimpleChanges"
      },
      {
        "text": "Component",
        "href": "api/core/Component"
      },
      {
        "text": "Version",
        "href": "api/core/Version"
      },
      {
        "text": "ngFor",
        "href": "api/common/NgFor"
      },
      {
        "text": "OnChanges",
        "href": "api/core/OnChanges"
      },
      {
        "text": "Input",
        "href": "api/core/Input"
      },
      {
        "text": "Input",
        "href": "api/core/Input"
      },
      {
        "text": "SimpleChanges",
        "href": "api/core/SimpleChanges"
      },
      {
        "text": "Component",
        "href": "api/core/Component"
      },
      {
        "text": "Component",
        "href": "api/core/Component"
      },
      {
        "text": "link",
        "href": "guide/component-interaction#test-it-for-intercept-input-property-changes-with-ngonchanges"
      },
      {
        "text": "async",
        "href": "api/platform-browser/animations/async"
      },
      {
        "text": "Version",
        "href": "api/core/Version"
      },
      {
        "text": "async",
        "href": "api/platform-browser/animations/async"
      },
      {
        "text": "Version",
        "href": "api/core/Version"
      },
      {
        "text": "async",
        "href": "api/platform-browser/animations/async"
      },
      {
        "text": "Version",
        "href": "api/core/Version"
      },
      {
        "text": "async",
        "href": "api/platform-browser/animations/async"
      },
      {
        "text": "Back to top",
        "href": "guide/component-interaction#top"
      },
      {
        "text": "link",
        "href": "guide/component-interaction#parent-listens-for-child-event"
      },
      {
        "text": "EventEmitter",
        "href": "api/core/EventEmitter"
      },
      {
        "text": "EventEmitter",
        "href": "api/core/EventEmitter"
      },
      {
        "text": "@Output() decorator",
        "href": "guide/inputs-outputs#output"
      },
      {
        "text": "Component",
        "href": "api/core/Component"
      },
      {
        "text": "EventEmitter",
        "href": "api/core/EventEmitter"
      },
      {
        "text": "Input",
        "href": "api/core/Input"
      },
      {
        "text": "Output",
        "href": "api/core/Output"
      },
      {
        "text": "Component",
        "href": "api/core/Component"
      },
      {
        "text": "Input",
        "href": "api/core/Input"
      },
      {
        "text": "Output",
        "href": "api/core/Output"
      },
      {
        "text": "EventEmitter",
        "href": "api/core/EventEmitter"
      },
      {
        "text": "Component",
        "href": "api/core/Component"
      },
      {
        "text": "Component",
        "href": "api/core/Component"
      },
      {
        "text": "ngFor",
        "href": "api/common/NgFor"
      },
      {
        "text": "link",
        "href": "guide/component-interaction#test-it-for-parent-listens-for-child-event"
      },
      {
        "text": "async",
        "href": "api/platform-browser/animations/async"
      },
      {
        "text": "async",
        "href": "api/platform-browser/animations/async"
      },
      {
        "text": "async",
        "href": "api/platform-browser/animations/async"
      },
      {
        "text": "Back to top",
        "href": "guide/component-interaction#top"
      },
      {
        "text": "link",
        "href": "guide/component-interaction#parent-interacts-with-child-using-local-variable"
      },
      {
        "text": "Component",
        "href": "api/core/Component"
      },
      {
        "text": "OnDestroy",
        "href": "api/core/OnDestroy"
      },
      {
        "text": "Component",
        "href": "api/core/Component"
      },
      {
        "text": "OnDestroy",
        "href": "api/core/OnDestroy"
      },
      {
        "text": "Component",
        "href": "api/core/Component"
      },
      {
        "text": "Component",
        "href": "api/core/Component"
      },
      {
        "text": "link",
        "href": "guide/component-interaction#test-it-for-parent-interacts-with-child-using-local-variable"
      },
      {
        "text": "trigger",
        "href": "api/animations/trigger"
      },
      {
        "text": "ApplicationRef",
        "href": "api/core/ApplicationRef"
      },
      {
        "text": "async",
        "href": "api/platform-browser/animations/async"
      },
      {
        "text": "async",
        "href": "api/platform-browser/animations/async"
      },
      {
        "text": "Back to top",
        "href": "guide/component-interaction#top"
      },
      {
        "text": "ViewChild",
        "href": "api/core/ViewChild"
      },
      {
        "text": "link",
        "href": "guide/component-interaction#parent-calls-an-viewchild"
      },
      {
        "text": "Countdown Timer",
        "href": "guide/component-interaction#countdown-timer-example"
      },
      {
        "text": "CountdownTimerComponent",
        "href": "guide/component-interaction#countdown-timer-example"
      },
      {
        "text": "AfterViewInit",
        "href": "api/core/AfterViewInit"
      },
      {
        "text": "ViewChild",
        "href": "api/core/ViewChild"
      },
      {
        "text": "Component",
        "href": "api/core/Component"
      },
      {
        "text": "Component",
        "href": "api/core/Component"
      },
      {
        "text": "ViewChild",
        "href": "api/core/ViewChild"
      },
      {
        "text": "AfterViewInit",
        "href": "api/core/AfterViewInit"
      },
      {
        "text": "ViewChild",
        "href": "api/core/ViewChild"
      },
      {
        "text": "tick",
        "href": "api/core/testing/tick"
      },
      {
        "text": "ViewChild",
        "href": "api/core/ViewChild"
      },
      {
        "text": "AfterViewInit",
        "href": "api/core/AfterViewInit"
      },
      {
        "text": "ViewChild",
        "href": "api/core/ViewChild"
      },
      {
        "text": "ViewChild",
        "href": "api/core/ViewChild"
      },
      {
        "text": "link",
        "href": "guide/component-interaction#test-it-for-parent-calls-an-viewchild"
      },
      {
        "text": "the same countdown timer tests",
        "href": "guide/component-interaction#countdown-tests"
      },
      {
        "text": "Back to top",
        "href": "guide/component-interaction#top"
      },
      {
        "text": "link",
        "href": "guide/component-interaction#parent-and-children-communicate-using-a-service"
      },
      {
        "text": "Injectable",
        "href": "api/core/Injectable"
      },
      {
        "text": "Injectable",
        "href": "api/core/Injectable"
      },
      {
        "text": "Component",
        "href": "api/core/Component"
      },
      {
        "text": "Component",
        "href": "api/core/Component"
      },
      {
        "text": "ngFor",
        "href": "api/common/NgFor"
      },
      {
        "text": "ngFor",
        "href": "api/common/NgFor"
      },
      {
        "text": "Component",
        "href": "api/core/Component"
      },
      {
        "text": "Input",
        "href": "api/core/Input"
      },
      {
        "text": "OnDestroy",
        "href": "api/core/OnDestroy"
      },
      {
        "text": "Component",
        "href": "api/core/Component"
      },
      {
        "text": "OnDestroy",
        "href": "api/core/OnDestroy"
      },
      {
        "text": "Input",
        "href": "api/core/Input"
      },
      {
        "text": "link",
        "href": "guide/component-interaction#test-it-for-parent-and-children-communicate-using-a-service"
      },
      {
        "text": "async",
        "href": "api/platform-browser/animations/async"
      },
      {
        "text": "async",
        "href": "api/platform-browser/animations/async"
      },
      {
        "text": "async",
        "href": "api/platform-browser/animations/async"
      },
      {
        "text": "async",
        "href": "api/platform-browser/animations/async"
      },
      {
        "text": "async",
        "href": "api/platform-browser/animations/async"
      },
      {
        "text": "Back to top",
        "href": "guide/component-interaction#top"
      }
    ],
    "meta": {
      "description": "",
      "keywords": ""
    },
    "summary": "Component interactionlink Contents Pass data from parent to child with input bindingTest it for Pass data from parent to child with input bindingIntercept input property changes with a setterTest it f...",
    "tags": [
      "react",
      "angular",
      "javascript",
      "typescript",
      "css",
      "html",
      "vite",
      "parent",
      "test",
      "child"
    ],
    "id": "angular-componentinteraction-part-1",
    "quality": 90
  },
  {
    "title": "Angular",
    "url": "https://v17.angular.io/guide/dependency-injection",
    "category": "angular",
    "content": "Understanding dependency injectionlink Contents Providing dependencyInjecting a dependencyWhat's next Dependency injection, or DI, is one of the fundamental concepts in Angular. DI is wired into the Angular framework and allows classes with Angular decorators, such as Components, Directives, Pipes, and Injectables, to configure dependencies that they need. Two main roles exist in the DI system: dependency consumer and dependency provider. Angular facilitates the interaction between dependency consumers and dependency providers using an abstraction called Injector. When a dependency is requested, the injector checks its registry to see if there is an instance already available there. If not, a new instance is created and stored in the registry. Angular creates an application-wide injector (also known as \"root\" injector) during the application bootstrap process, as well as any other injectors as needed. In most cases you don't need to manually create injectors, but you should know that there is a layer that connects providers and consumers. This topic covers basic scenarios of how a class can act as a dependency. Angular also allows you to use functions, objects, primitive types such as string or Boolean, or any other types as dependencies. For more information, see Dependency providers. Providing dependencylink Imagine there is a class called HeroService that needs to act as a dependency in a component. The first step is to add the @Injectable decorator to show that the class can be injected. content_copy @Injectable() class HeroService {} The next step is to make it available in the DI by providing it. A dependency can be provided in multiple places: At the Component level, using the providers field of the @Component decorator. In this case the HeroService becomes available to all instances of this component and other components and directives used in the template. For example: content_copy @Component({ standalone: true, selector: 'hero-list', template: '...', providers: [HeroService] }) class HeroListComponent {} When you register a provider at the component level, you get a new instance of the service with each new instance of that component. Use the providers field of the ApplicationConfig object passed to the bootstrapApplication function to provide a service or other Injectable at the application level. In this scenario, the HeroService is available to all components, directives, and pipes declared in this NgModule or other NgModule which is within the same ModuleInjector applicable for this NgModule. When you register a provider in the ApplicationConfig, the same instance of a service is available to all applicable components, directives and pipes. For NgModule based applications, use the providers field of the @NgModule decorator to provide a service or other Injectable available at the application level. To understand all edge-cases, see Hierarchical injectors. For example: content_copy export const appConfig: ApplicationConfig = { providers: [ { provide: HeroService }, ] }; Then, in main.ts: content_copy bootstrapApplication(AppComponent, appConfig) At the application root level, which allows injecting it into other classes in the application. This can be done by adding the providedIn: 'root' field to the @Injectable decorator: content_copy @Injectable({ providedIn: 'root' }) class HeroService {} When you provide the service at the root level, Angular creates a single, shared instance of the HeroService and injects it into any class that asks for it. Registering the provider in the @Injectable metadata also allows Angular to optimize an app by removing the service from the compiled application if it isn't used, a process known as tree-shaking. Injecting a dependencylink The most common way to inject a dependency is to declare it in a class constructor. When Angular creates a new instance of a component, directive, or pipe class, it determines which services or other dependencies that class needs by looking at the constructor parameter types. For example, if the HeroListComponent needs the HeroService, the constructor can look like this: content_copy @Component({  }) class HeroListComponent { constructor(private service: HeroService) {} } Another option is to use the inject method: content_copy @Component({  }) class HeroListComponent { private service = inject(HeroService); } When Angular discovers that a component depends on a service, it first checks if the injector has any existing instances of that service. If a requested service instance doesn't yet exist, the injector creates one using the registered provider, and adds it to the injector before returning the service to Angular. When all requested services have been resolved and returned, Angular can call the component's constructor with those services as arguments. What's nextlink Creating and injecting services Dependency Injection in Action Last reviewed on Tue Aug 29 2023",
    "headings": [
      {
        "level": 1,
        "text": "Understanding dependency injectionlink",
        "id": "understanding-dependency-injection"
      },
      {
        "level": 2,
        "text": "Providing dependencylink",
        "id": "providing-dependency"
      },
      {
        "level": 2,
        "text": "Injecting a dependencylink",
        "id": "injecting-a-dependency"
      },
      {
        "level": 2,
        "text": "What's nextlink",
        "id": "whats-next"
      }
    ],
    "codeBlocks": [
      {
        "language": "text",
        "code": "content_copy\n      \n      @Injectable()\nclass HeroService {}"
      },
      {
        "language": "text",
        "code": "@Injectable()\nclass HeroService {}"
      },
      {
        "language": "text",
        "code": "HeroService"
      },
      {
        "language": "text",
        "code": "content_copy\n      \n      @Component({\n  standalone: true,\n  selector: 'hero-list',\n  template: '...',\n  providers: [HeroService]\n})\nclass HeroListComponent {}"
      },
      {
        "language": "text",
        "code": "@Component({\n  standalone: true,\n  selector: 'hero-list',\n  template: '...',\n  providers: [HeroService]\n})\nclass HeroListComponent {}"
      },
      {
        "language": "text",
        "code": "ApplicationConfig"
      },
      {
        "language": "text",
        "code": "bootstrapApplication"
      },
      {
        "language": "text",
        "code": "HeroService"
      },
      {
        "language": "text",
        "code": "ApplicationConfig"
      },
      {
        "language": "text",
        "code": "content_copy\n      \n      export const appConfig: ApplicationConfig = {\n    providers: [\n      { provide: HeroService },\n    ]\n};"
      },
      {
        "language": "text",
        "code": "export const appConfig: ApplicationConfig = {\n    providers: [\n      { provide: HeroService },\n    ]\n};"
      },
      {
        "language": "text",
        "code": "content_copy\n      \n      bootstrapApplication(AppComponent, appConfig)"
      },
      {
        "language": "text",
        "code": "bootstrapApplication(AppComponent, appConfig)"
      },
      {
        "language": "text",
        "code": "providedIn: 'root'"
      },
      {
        "language": "text",
        "code": "@Injectable"
      },
      {
        "language": "text",
        "code": "content_copy\n      \n      @Injectable({\n  providedIn: 'root'\n})\nclass HeroService {}"
      },
      {
        "language": "text",
        "code": "@Injectable({\n  providedIn: 'root'\n})\nclass HeroService {}"
      },
      {
        "language": "text",
        "code": "HeroService"
      },
      {
        "language": "text",
        "code": "@Injectable"
      },
      {
        "language": "text",
        "code": "HeroListComponent"
      },
      {
        "language": "text",
        "code": "HeroService"
      },
      {
        "language": "text",
        "code": "content_copy\n      \n      @Component({  })\nclass HeroListComponent {\n  constructor(private service: HeroService) {}\n}"
      },
      {
        "language": "text",
        "code": "@Component({  })\nclass HeroListComponent {\n  constructor(private service: HeroService) {}\n}"
      },
      {
        "language": "text",
        "code": "content_copy\n      \n      @Component({  })\nclass HeroListComponent {\n  private service = inject(HeroService);\n}"
      },
      {
        "language": "text",
        "code": "@Component({  })\nclass HeroListComponent {\n  private service = inject(HeroService);\n}"
      }
    ],
    "links": [
      {
        "text": "link",
        "href": "guide/dependency-injection#understanding-dependency-injection"
      },
      {
        "text": "Providing dependency",
        "href": "guide/dependency-injection#providing-dependency"
      },
      {
        "text": "Injecting a dependency",
        "href": "guide/dependency-injection#injecting-a-dependency"
      },
      {
        "text": "What's next",
        "href": "guide/dependency-injection#whats-next"
      },
      {
        "text": "Injector",
        "href": "guide/glossary#injector"
      },
      {
        "text": "Dependency providers",
        "href": "guide/dependency-injection-providers"
      },
      {
        "text": "link",
        "href": "guide/dependency-injection#providing-dependency"
      },
      {
        "text": "Injectable",
        "href": "api/core/Injectable"
      },
      {
        "text": "Component",
        "href": "api/core/Component"
      },
      {
        "text": "Component",
        "href": "api/core/Component"
      },
      {
        "text": "ApplicationConfig",
        "href": "api/core/ApplicationConfig"
      },
      {
        "text": "bootstrapApplication",
        "href": "api/platform-browser/bootstrapApplication"
      },
      {
        "text": "Injectable",
        "href": "api/core/Injectable"
      },
      {
        "text": "ApplicationConfig",
        "href": "api/core/ApplicationConfig"
      },
      {
        "text": "NgModule",
        "href": "api/core/NgModule"
      },
      {
        "text": "NgModule",
        "href": "api/core/NgModule"
      },
      {
        "text": "Injectable",
        "href": "api/core/Injectable"
      },
      {
        "text": "Hierarchical injectors",
        "href": "guide/hierarchical-dependency-injection"
      },
      {
        "text": "ApplicationConfig",
        "href": "api/core/ApplicationConfig"
      },
      {
        "text": "bootstrapApplication",
        "href": "api/platform-browser/bootstrapApplication"
      },
      {
        "text": "Injectable",
        "href": "api/core/Injectable"
      },
      {
        "text": "Injectable",
        "href": "api/core/Injectable"
      },
      {
        "text": "Injectable",
        "href": "api/core/Injectable"
      },
      {
        "text": "link",
        "href": "guide/dependency-injection#injecting-a-dependency"
      },
      {
        "text": "Component",
        "href": "api/core/Component"
      },
      {
        "text": "inject",
        "href": "api/core/inject"
      },
      {
        "text": "Component",
        "href": "api/core/Component"
      },
      {
        "text": "link",
        "href": "guide/dependency-injection#whats-next"
      },
      {
        "text": "Creating and injecting services",
        "href": "guide/creating-injectable-service"
      },
      {
        "text": "Dependency Injection in Action",
        "href": "guide/dependency-injection-in-action"
      }
    ],
    "meta": {
      "description": "",
      "keywords": ""
    },
    "summary": "Understanding dependency injectionlink Contents Providing dependencyInjecting a dependencyWhat's next Dependency injection, or DI, is one of the fundamental concepts in Angular",
    "tags": [
      "react",
      "vue",
      "angular",
      "javascript",
      "typescript",
      "html",
      "node",
      "dependencylink",
      "understanding",
      "dependency"
    ],
    "id": "angular-dependencyinjection-part-1",
    "quality": 90
  },
  {
    "title": "Angular",
    "url": "https://v17.angular.io/guide/creating-injectable-service",
    "category": "angular",
    "content": "Creating an injectable servicelink Contents Service examplesCreating an injectable serviceInjecting servicesInjecting services in other servicesWhat's next Service is a broad category encompassing any value, function, or feature that an application needs. A service is typically a class with a narrow, well-defined purpose. A component is one type of class that can use DI. Angular distinguishes components from services to increase modularity and reusability. By separating a component's view-related features from other kinds of processing, you can make your component classes lean and efficient. Ideally, a component's job is to enable the user experience and nothing more. A component should present properties and methods for data binding, to mediate between the view (rendered by the template) and the application logic (which often includes some notion of a model). A component can delegate certain tasks to services, such as fetching data from the server, validating user input, or logging directly to the console. By defining such processing tasks in an injectable service class, you make those tasks available to any component. You can also make your application more adaptable by injecting different providers of the same kind of service, as appropriate in different circumstances. Angular does not enforce these principles. Angular helps you follow these principles by making it easy to factor your application logic into services and make those services available to components through DI. Service exampleslink Here's an example of a service class that logs to the browser console. content_copy export class Logger { log(msg: any) { console.log(msg); } error(msg: any) { console.error(msg); } warn(msg: any) { console.warn(msg); } } Services can depend on other services. For example, here's a HeroService that depends on the Logger service, and also uses BackendService to get heroes. That service in turn might depend on the HttpClient service to fetch heroes asynchronously from a server. content_copy export class HeroService { private heroes: Hero[] = []; constructor( private backend: BackendService, private logger: Logger) { } getHeroes() { this.backend.getAll(Hero).then( (heroes: Hero[]) = { this.logger.log(Fetched ${heroes.length} heroes.); this.heroes.push(...heroes); // fill cache }); return this.heroes; } } Creating an injectable servicelink Angular CLI provides a command to create a new service. In the following example, you add a new service to your application, which was created earlier with the ng new command. To generate a new HeroService class in the src/app/heroes folder, follow these steps: Run this Angular CLI command: content_copy ng generate service heroes/hero This command creates the following default HeroService. content_copy import { Injectable } from '@angular/core'; @Injectable({ providedIn: 'root', }) export class HeroService { } The @Injectable() decorator specifies that Angular can use this class in the DI system. The metadata, providedIn: 'root', means that the HeroService is visible throughout the application. Add a getHeroes() method that returns the heroes from mock.heroes.ts to get the hero mock data: content_copy import { Injectable } from '@angular/core'; import { HEROES } from './mock-heroes'; @Injectable({ // declares that this service should be created // by the root application injector. providedIn: 'root', }) export class HeroService { getHeroes() { return HEROES; } } For clarity and maintainability, it is recommended that you define components and services in separate files. Injecting serviceslink To inject a service as a dependency into a component, you can use component's constructor() and supply a constructor argument with the dependency type. The following example specifies the HeroService in the HeroListComponent constructor. The type of the heroService is HeroService. Angular recognizes the HeroService as a dependency, since that class was previously annotated with the @Injectable decorator. content_copy constructor(heroService: HeroService) Injecting services in other serviceslink When a service depends on another service, follow the same pattern as injecting into a component. In the following example HeroService depends on a Logger service to report its activities. First, import the Logger service. Next, inject the Logger service in the HeroService constructor() by specifying private logger: Logger. Here, the constructor() specifies a type of Logger and stores the instance of Logger in a private field called logger. The following code tabs feature the Logger service and two versions of HeroService. The first version of HeroService does not depend on the Logger service. The revised second version does depend on Logger service. src/app/heroes/hero.service (v2)src/app/heroes/hero.service (v1)src/app/logger.service content_copy import { Injectable } from '@angular/core'; import { HEROES } from './mock-heroes'; import { Logger } from '../logger.service'; @Injectable({ providedIn: 'root', }) export class HeroService { constructor(private logger: Logger) { } getHeroes() { this.logger.log('Getting heroes ...'); return HEROES; } } In this example, the getHeroes() method uses the Logger service by logging a message when fetching heroes. What's nextlink How to configure dependencies in DI How to use InjectionTokens to provide and inject values other than services/classes Dependency Injection in Action Last reviewed on Tue Aug 02 2022",
    "headings": [
      {
        "level": 1,
        "text": "Creating an injectable servicelink",
        "id": "creating-an-injectable-service"
      },
      {
        "level": 2,
        "text": "Service exampleslink",
        "id": "service-examples"
      },
      {
        "level": 2,
        "text": "Creating an injectable servicelink",
        "id": "creating-an-injectable-service-1"
      },
      {
        "level": 2,
        "text": "Injecting serviceslink",
        "id": "injecting-services"
      },
      {
        "level": 2,
        "text": "Injecting services in other serviceslink",
        "id": "injecting-services-in-other-services"
      },
      {
        "level": 2,
        "text": "What's nextlink",
        "id": "whats-next"
      }
    ],
    "codeBlocks": [
      {
        "language": "text",
        "code": "content_copy\n      \n      export class Logger {\n  log(msg: any)   { console.log(msg); }\n  error(msg: any) { console.error(msg); }\n  warn(msg: any)  { console.warn(msg); }\n}"
      },
      {
        "language": "text",
        "code": "export class Logger {\n  log(msg: any)   { console.log(msg); }\n  error(msg: any) { console.error(msg); }\n  warn(msg: any)  { console.warn(msg); }\n}"
      },
      {
        "language": "text",
        "code": "HeroService"
      },
      {
        "language": "text",
        "code": "BackendService"
      },
      {
        "language": "text",
        "code": "content_copy\n      \n      export class HeroService {\n  private heroes: Hero[] = [];\n\n  constructor(\n    private backend: BackendService,\n    private logger: Logger) { }\n\n  getHeroes() {\n    this.backend.getAll(Hero).then( (heroes: Hero[]) => {\n      this.logger.log(`Fetched ${heroes.length} heroes.`);\n      this.heroes.push(...heroes); // fill cache\n    });\n    return this.heroes;\n  }\n}"
      },
      {
        "language": "text",
        "code": "export class HeroService {\n  private heroes: Hero[] = [];\n\n  constructor(\n    private backend: BackendService,\n    private logger: Logger) { }\n\n  getHeroes() {\n    this.backend.getAll(Hero).then( (heroes: Hero[]) => {\n      this.logger.log(`Fetched ${heroes.length} heroes.`);\n      this.heroes.push(...heroes); // fill cache\n    });\n    return this.heroes;\n  }\n}"
      },
      {
        "language": "text",
        "code": "HeroService"
      },
      {
        "language": "text",
        "code": "src/app/heroes"
      },
      {
        "language": "text",
        "code": "content_copy\n      \n      ng generate service heroes/hero"
      },
      {
        "language": "text",
        "code": "ng generate service heroes/hero"
      },
      {
        "language": "text",
        "code": "HeroService"
      },
      {
        "language": "text",
        "code": "content_copy\n      \n      import { Injectable } from '@angular/core';\n\n@Injectable({\n  providedIn: 'root',\n})\nexport class HeroService {\n\n}"
      },
      {
        "language": "text",
        "code": "import { Injectable } from '@angular/core';\n\n@Injectable({\n  providedIn: 'root',\n})\nexport class HeroService {\n\n}"
      },
      {
        "language": "text",
        "code": "@Injectable()"
      },
      {
        "language": "text",
        "code": "providedIn: 'root'"
      },
      {
        "language": "text",
        "code": "HeroService"
      },
      {
        "language": "text",
        "code": "getHeroes()"
      },
      {
        "language": "text",
        "code": "mock.heroes.ts"
      },
      {
        "language": "text",
        "code": "content_copy\n      \n      import { Injectable } from '@angular/core';\nimport { HEROES } from './mock-heroes';\n\n@Injectable({\n  // declares that this service should be created\n  // by the root application injector.\n  providedIn: 'root',\n})\nexport class HeroService {\n  getHeroes() { return HEROES; }\n}"
      },
      {
        "language": "text",
        "code": "import { Injectable } from '@angular/core';\nimport { HEROES } from './mock-heroes';\n\n@Injectable({\n  // declares that this service should be created\n  // by the root application injector.\n  providedIn: 'root',\n})\nexport class HeroService {\n  getHeroes() { return HEROES; }\n}"
      },
      {
        "language": "text",
        "code": "constructor()"
      },
      {
        "language": "text",
        "code": "HeroService"
      },
      {
        "language": "text",
        "code": "HeroListComponent"
      },
      {
        "language": "text",
        "code": "heroService"
      },
      {
        "language": "text",
        "code": "HeroService"
      },
      {
        "language": "text",
        "code": "HeroService"
      },
      {
        "language": "text",
        "code": "@Injectable"
      },
      {
        "language": "text",
        "code": "content_copy\n      \n      constructor(heroService: HeroService)"
      },
      {
        "language": "text",
        "code": "constructor(heroService: HeroService)"
      },
      {
        "language": "text",
        "code": "HeroService"
      },
      {
        "language": "text",
        "code": "HeroService"
      },
      {
        "language": "text",
        "code": "constructor()"
      },
      {
        "language": "text",
        "code": "private logger: Logger"
      },
      {
        "language": "text",
        "code": "constructor()"
      },
      {
        "language": "text",
        "code": "HeroService"
      },
      {
        "language": "text",
        "code": "HeroService"
      },
      {
        "language": "text",
        "code": "content_copy\n      \n      import { Injectable } from '@angular/core';\nimport { HEROES } from './mock-heroes';\nimport { Logger } from '../logger.service';\n\n@Injectable({\n  providedIn: 'root',\n})\nexport class HeroService {\n\n  constructor(private logger: Logger) {  }\n\n  getHeroes() {\n    this.logger.log('Getting heroes ...');\n    return HEROES;\n  }\n}"
      },
      {
        "language": "text",
        "code": "import { Injectable } from '@angular/core';\nimport { HEROES } from './mock-heroes';\nimport { Logger } from '../logger.service';\n\n@Injectable({\n  providedIn: 'root',\n})\nexport class HeroService {\n\n  constructor(private logger: Logger) {  }\n\n  getHeroes() {\n    this.logger.log('Getting heroes ...');\n    return HEROES;\n  }\n}"
      },
      {
        "language": "text",
        "code": "getHeroes()"
      },
      {
        "language": "text",
        "code": "InjectionTokens"
      }
    ],
    "links": [
      {
        "text": "link",
        "href": "guide/creating-injectable-service#creating-an-injectable-service"
      },
      {
        "text": "Service examples",
        "href": "guide/creating-injectable-service#service-examples"
      },
      {
        "text": "Creating an injectable service",
        "href": "guide/creating-injectable-service#creating-an-injectable-service-1"
      },
      {
        "text": "Injecting services",
        "href": "guide/creating-injectable-service#injecting-services"
      },
      {
        "text": "Injecting services in other services",
        "href": "guide/creating-injectable-service#injecting-services-in-other-services"
      },
      {
        "text": "What's next",
        "href": "guide/creating-injectable-service#whats-next"
      },
      {
        "text": "link",
        "href": "guide/creating-injectable-service#service-examples"
      },
      {
        "text": "HttpClient",
        "href": "api/common/http/HttpClient"
      },
      {
        "text": "link",
        "href": "guide/creating-injectable-service#creating-an-injectable-service-1"
      },
      {
        "text": "Angular CLI",
        "href": "cli"
      },
      {
        "text": "Injectable",
        "href": "api/core/Injectable"
      },
      {
        "text": "Injectable",
        "href": "api/core/Injectable"
      },
      {
        "text": "Injectable",
        "href": "api/core/Injectable"
      },
      {
        "text": "Injectable",
        "href": "api/core/Injectable"
      },
      {
        "text": "Injectable",
        "href": "api/core/Injectable"
      },
      {
        "text": "link",
        "href": "guide/creating-injectable-service#injecting-services"
      },
      {
        "text": "Injectable",
        "href": "api/core/Injectable"
      },
      {
        "text": "link",
        "href": "guide/creating-injectable-service#injecting-services-in-other-services"
      },
      {
        "text": "Injectable",
        "href": "api/core/Injectable"
      },
      {
        "text": "Injectable",
        "href": "api/core/Injectable"
      },
      {
        "text": "link",
        "href": "guide/creating-injectable-service#whats-next"
      },
      {
        "text": "How to configure dependencies in DI",
        "href": "guide/dependency-injection-providers"
      },
      {
        "text": "How to use InjectionTokens to provide and inject values other than services/classes",
        "href": "guide/dependency-injection-providers#configuring-dependency-providers"
      },
      {
        "text": "Dependency Injection in Action",
        "href": "guide/dependency-injection-in-action"
      }
    ],
    "meta": {
      "description": "",
      "keywords": ""
    },
    "summary": "Creating an injectable servicelink Contents Service examplesCreating an injectable serviceInjecting servicesInjecting services in other servicesWhat's next Service is a broad category encompassing any...",
    "tags": [
      "react",
      "angular",
      "javascript",
      "typescript",
      "node",
      "creating",
      "injectable",
      "servicelink",
      "injecting",
      "serviceslink"
    ],
    "id": "angular-creatinginjectableservice-part-1",
    "quality": 90
  },
  {
    "title": "Angular",
    "url": "https://v17.angular.io/guide/built-in-directives",
    "category": "angular",
    "content": "Built-in directiveslink Contents Built-in attribute directivesAdding and removing classes with NgClassImport CommonModule in the componentUsing NgClass with an expressionUsing NgClass with a methodSetting inline styles with NgStyleImport CommonModule in the componentUsing NgStyle in your componentDisplaying and updating properties with ngModelNgModel and value accessorsBuilt-in structural directivesImport CommonModule in the componentAdding or removing an element with NgIfGuarding against nullListing items with NgForRepeating a component viewGetting the index of *ngForRepeating elements when a condition is trueTracking items with *ngFor trackByHosting a directive without a DOM elementSwitching cases with NgSwitchWhat's next Directives are classes that add additional behavior to elements in your Angular applications. Use Angular's built-in directives to manage forms, lists, styles, and what users see. See the live example / download example for a working example containing the code snippets in this guide. The different types of Angular directives are as follows: Directive Types Details Components Used with a template. This type of directive is the most common directive type. Attribute directives Change the appearance or behavior of an element, component, or another directive. Structural directives Change the DOM layout by adding and removing DOM elements. This guide covers built-in attribute directives and structural directives. Built-in attribute directiveslink Attribute directives listen to and modify the behavior of other HTML elements, attributes, properties, and components. Many attribute directives are defined through modules such as the CommonModule, RouterModule and FormsModule. The most common attribute directives are as follows: Common directives Details NgClass Adds and removes a set of CSS classes. NgStyle Adds and removes a set of HTML styles. NgModel Adds two-way data binding to an HTML form element. Built-in directives use only public APIs. They do not have special access to any private APIs that other directives can't access. Adding and removing classes with NgClasslink Add or remove multiple CSS classes simultaneously with ngClass. To add or remove a single class, use class binding rather than NgClass. Import CommonModule in the componentlink To use NgClass, import CommonModule and add it to the component's imports list. content_copy import {CommonModule} from '@angular/common'; /* . . . */ @Component({ standalone: true, /* . . . */ imports: [ CommonModule, // -- import into the component /* . . . */ ], }) export class AppComponent implements OnInit { /* . . . */ } Using NgClass with an expressionlink On the element you'd like to style, add [ngClass] and set it equal to an expression. In this case, isSpecial is a boolean set to true in app.component.ts. Because isSpecial is true, ngClass applies the class of special to the div. content_copy !-- toggle the \"special\" class on/off with a property -- div [ngClass]=\"isSpecial ? 'special' : ''\"This div is special/div Using NgClass with a methodlink To use NgClass with a method, add the method to the component class. In the following example, setCurrentClasses() sets the property currentClasses with an object that adds or removes three classes based on the true or false state of three other component properties. Each key of the object is a CSS class name. If a key is true, ngClass adds the class. If a key is false, ngClass removes the class. content_copy currentClasses: Recordstring, boolean = {}; /* . . . */ setCurrentClasses() { // CSS classes: added/removed per current state of component properties this.currentClasses = { saveable: this.canSave, modified: !this.isUnchanged, special: this.isSpecial, }; } In the template, add the ngClass property binding to currentClasses to set the element's classes: content_copy div [ngClass]=\"currentClasses\"This div is initially saveable, unchanged, and special./div For this use case, Angular applies the classes on initialization and in case of changes. The full example calls setCurrentClasses() initially with ngOnInit() and when the dependent properties change through a button click. These steps are not necessary to implement ngClass. For more information, see the live example / download example app.component.ts and app.component.html. Setting inline styles with NgStylelink Import CommonModule in the componentlink To use NgStyle, import CommonModule and add it to the component's imports list. content_copy import {CommonModule} from '@angular/common'; /* . . . */ @Component({ standalone: true, /* . . . */ imports: [ CommonModule, // -- import into the component /* . . . */ ], }) export class AppComponent implements OnInit { /* . . . */ } Using NgStyle in your componentlink Use NgStyle to set multiple inline styles simultaneously, based on the state of the component. To use NgStyle, add a method to the component class. In the following example, setCurrentStyles() sets the property currentStyles with an object that defines three styles, based on the state of three other component properties. content_copy currentStyles: Recordstring, string = {}; /* . . . */ setCurrentStyles() { // CSS styles: set per current state of component properties this.currentStyles = { 'font-style': this.canSave ? 'italic' : 'normal', 'font-weight': !this.isUnchanged ? 'bold' : 'normal', 'font-size': this.isSpecial ? '24px' : '12px', }; } To set the element's styles, add an ngStyle property binding to currentStyles. content_copy div [ngStyle]=\"currentStyles\" This div is initially italic, normal weight, and extra large (24px). /div For this use case, Angular applies the styles upon initialization and in case of changes. To do this, the full example calls setCurrentStyles() initially with ngOnInit() and when the dependent properties change through a button click. However, these steps are not necessary to implement ngStyle on its own. See the live example / download example app.component.ts and app.component.html for this optional implementation. Displaying and updating properties with ngModellink Use the NgModel directive to display a data property and update that property when the user makes changes. Import FormsModule and add it to the AppComponent's imports list. content_copy import {FormsModule} from '@angular/forms'; // --- JavaScript import from Angular /* . . . */ @Component({ standalone: true, /* . . . */ imports: [ CommonModule, // -- import into the component FormsModule, // --- import into the component /* . . . */ ], }) export class AppComponent implements OnInit { /* . . . */ } Add an [(ngModel)] binding on an HTML form element and set it equal to the property, here name. content_copy label for=\"example-ngModel\"[(ngModel)]:/label input [(ngModel)]=\"currentItem.name\" id=\"example-ngModel\" This [(ngModel)] syntax can only set a data-bound property. To customize your configuration, write the expanded form, which separates the property and event binding. Use property binding to set the property and event binding to respond to changes. The following example changes the input value to uppercase: content_copy input [ngModel]=\"currentItem.name\" (ngModelChange)=\"setUppercaseName($event)\" id=\"example-uppercase\" Here are all variations in action, including the uppercase version: NgModel and value accessorslink The NgModel directive works for an element supported by a ControlValueAccessor. Angular provides value accessors for all of the basic HTML form elements. For more information, see Forms. To apply [(ngModel)] to a non-form built-in element or a third-party custom component, you have to write a value accessor. For more information, see the API documentation on DefaultValueAccessor. When you write an Angular component, you don't need a value accessor or NgModel if you name the value and event properties according to Angular's two-way binding syntax. Built-in structural directiveslink Structural directives are responsible for HTML layout. They shape or reshape the DOM's structure, typically by adding, removing, and manipulating the host elements to which they are attached. This section introduces the most common built-in structural directives: Common built-in structural directives Details NgIf Conditionally creates or disposes of subviews from the template. NgFor Repeat a node for each item in a list. NgSwitch A set of directives that switch among alternative views. For more information, see Structural Directives. Import CommonModule in the componentlink To use built-in structural directives, import CommonModule and add it to the component's imports list. content_copy import {CommonModule} from '@angular/common'; /* . . . */ @Component({ standalone: true, /* . . . */ imports: [ CommonModule, // -- import into the component /* . . . */ ], }) export class AppComponent implements OnInit { /* . . . */ } Adding or removing an element with NgIflink Add or remove an element by applying an NgIf directive to a host element. When NgIf is false, Angular removes an element and its descendants from the DOM. Angular then disposes of their components, which frees up memory and resources. To add or remove an element, bind *ngIf to a condition expression such as isActive in the following example. content_copy app-item-detail *ngIf=\"isActive\" [item]=\"item\"/app-item-detail When the isActive expression returns a truthy value, NgIf adds the ItemDetailComponent to the DOM. When the expression is falsy, NgIf removes the ItemDetailComponent from the DOM and disposes of the component and all of its subcomponents. For more information on NgIf and NgIfElse, see the NgIf API documentation. Guarding against nulllink By default, NgIf prevents display of an element bound to a null value. To use NgIf to guard a div, add *ngIf=\"yourProperty\" to the div. In the following example, the currentCustomer name appears because there is a currentCustomer. content_copy div *ngIf=\"currentCustomer\"Hello, {{currentCustomer.name}}/div However, if the property is null, Angular does not display the div. In this example, Angular does not display the nullCustomer because it is null. content_copy div *ngIf=\"nullCustomer\"Hello, span{{nullCustomer}}/span/div Listing items with NgForlink Use the NgFor directive to present a list of items. Define a block of HTML that determines how Angular renders a single item. To list your items, assign the shorthand let item of items to *ngFor. content_copy div *ngFor=\"let item of items\"{{item.name}}/div The string \"let item of items\" instructs Angular to do the following: Store each item in the items array in the local item looping variable Make each item available to the templated HTML for each iteration Translate \"let item of items\" into an ng-template around the host element Repeat the ng-template for each item in the list For more information see the Structural directive shorthand section of Structural directives. Repeating a component viewlink To repeat a component element, apply *ngFor to the selector. In the following example, the selector is app-item-detail. content_copy app-item-detail *ngFor=\"let item of items\" [item]=\"item\"/app-item-detail Reference a template input variable, such as item, in the following locations: Within the ngFor host element Within the host element descendants to access the item's properties The following example references item first in an interpolation and then passes in a binding to the item property of the app-item-detail component. content_copy div *ngFor=\"let item of items\"{{item.name}}/div !-- . . . -- app-item-detail *ngFor=\"let item of items\" [item]=\"item\"/app-item-detail For more information about template input variables, see Structural directive shorthand. Getting the index of *ngForlink Get the index of *ngFor in a template input variable and use it in the template. In the *ngFor, add a semicolon and let i=index to the shorthand. The following example gets the index in a variable named i and displays it with the item name. content_copy div *ngFor=\"let item of items; let i=index\"{{i + 1}} - {{item.name}}/div The index property of the NgFor directive context returns the zero-based index of the item in each iteration. Angular translates this instruction into an ng-template around the host element, then uses this template repeatedly to create a new set of elements and bindings for each item in the list. For more information about shorthand, see the Structural Directives guide. Repeating elements when a condition is truelink To repeat a block of HTML when a particular condition is true, put the *ngIf on a container element that wraps an *ngFor element. For more information see one structural directive per element. Tracking items with *ngFor trackBylink Reduce the number of calls your application makes to the server by tracking changes to an item list. With the *ngFor trackBy property, Angular can change and re-render only those items that have changed, rather than reloading the entire list of items. Add a method to the component that returns the value NgFor should track. In this example, the value to track is the item's id. If the browser has already rendered id, Angular keeps track of it and doesn't re-query the server for the same id. content_copy trackByItems(index: number, item: Item): number { return item.id; } In the shorthand expression, set trackBy to the trackByItems() method. content_copy div *ngFor=\"let item of items; trackBy: trackByItems\" ({{item.id}}) {{item.name}} /div Change ids creates new items with new item.ids. In the following illustration of the trackBy effect, Reset items creates new items with the same item.ids. With no trackBy, both buttons trigger complete DOM element replacement. With trackBy, only changing the id triggers element replacement. Hosting a directive without a DOM elementlink The Angular ng-container is a grouping element that doesn't interfere with styles or layout because Angular doesn't put it in the DOM. Use ng-container when there's no single element to host the directive. Here's a conditional paragraph using ng-container. content_copy p I turned the corner ng-container *ngIf=\"hero\" and saw {{hero.name}}. I waved /ng-container and continued on my way. /p Import the ngModel directive from FormsModule. Add FormsModule to the imports section of the relevant Angular module. To conditionally exclude an option, wrap the option in an ng-container. content_copy div Pick your favorite hero (label for=\"showSad\"input id=\"showSad\" type=\"checkbox\" checked (change)=\"showSad = !showSad\"show sad/label) /div select [(ngModel)]=\"hero\" ng-container *ngFor=\"let h of heroes\" ng-container *ngIf=\"showSad  h.emotion !== 'sad'\" option [ngValue]=\"h\"{{h.name}} ({{h.emotion}})/option /ng-container /ng-container /select Switching cases with NgSwitchlink Like the JavaScript switch statement, NgSwitch displays one element from among several possible elements, based on a switch condition. Angular puts only the selected element into the DOM. NgSwitch is a set of three directives: NgSwitch directives Details NgSwitch An attribute directive that changes the behavior of its companion directives. NgSwitchCase Structural directive that adds its element to the DOM when its bound value equals the switch value and removes its bound value when it doesn't equal the switch value. NgSwitchDefault Structural directive that adds its element to the DOM when there is no selected NgSwitchCase. On an element, such as a div, add [ngSwitch] bound to an expression that returns the switch value, such as feature. Though the feature value in this example is a string, the switch value can be of any type. Bind to *ngSwitchCase and *ngSwitchDefault on the elements for the cases. content_copy div [ngSwitch]=\"currentItem.feature\" app-stout-item *ngSwitchCase=\"'stout'\" [item]=\"currentItem\"/app-stout-item app-device-item *ngSwitchCase=\"'slim'\" [item]=\"currentItem\"/app-device-item app-lost-item *ngSwitchCase=\"'vintage'\" [item]=\"currentItem\"/app-lost-item app-best-item *ngSwitchCase=\"'bright'\" [item]=\"currentItem\"/app-best-item !-- . . . -- app-unknown-item *ngSwitchDefault [item]=\"currentItem\"/app-unknown-item /div In the parent component, define currentItem, to use it in the [ngSwitch] expression. content_copy currentItem!: Item; In each child component, add an item input property which is bound to the currentItem of the parent component. The following two snippets show the parent component and one of the child components. The other child components are identical to StoutItemComponent. content_copy export class StoutItemComponent { @Input() item!: Item; } Switch directives also work with built-in HTML elements and web components. For example, you could replace the app-best-item switch case with a div as follows. content_copy div *ngSwitchCase=\"'bright'\" Are you as bright as {{currentItem.name}}?/div What's nextlink For information on how to build your own custom directives, see Attribute Directives and Structural Directives. Last reviewed on Mon Feb 28 2022",
    "headings": [
      {
        "level": 1,
        "text": "Built-in directiveslink",
        "id": "built-in-directives"
      },
      {
        "level": 2,
        "text": "Built-in attribute directiveslink",
        "id": "built-in-attribute-directives"
      },
      {
        "level": 2,
        "text": "Adding and removing classes with NgClasslink",
        "id": "adding-and-removing-classes-with-ngclass"
      },
      {
        "level": 2,
        "text": "Setting inline styles with NgStylelink",
        "id": "setting-inline-styles-with-ngstyle"
      },
      {
        "level": 2,
        "text": "Displaying and updating properties with ngModellink",
        "id": "displaying-and-updating-properties-with-ngmodel"
      },
      {
        "level": 2,
        "text": "Built-in structural directiveslink",
        "id": "built-in-structural-directives"
      },
      {
        "level": 2,
        "text": "Adding or removing an element with NgIflink",
        "id": "adding-or-removing-an-element-with-ngif"
      },
      {
        "level": 2,
        "text": "Listing items with NgForlink",
        "id": "listing-items-with-ngfor"
      },
      {
        "level": 2,
        "text": "Repeating elements when a condition is truelink",
        "id": "repeating-elements-when-a-condition-is-true"
      },
      {
        "level": 2,
        "text": "Hosting a directive without a DOM elementlink",
        "id": "hosting-a-directive-without-a-dom-element"
      },
      {
        "level": 2,
        "text": "Switching cases with NgSwitchlink",
        "id": "switching-cases-with-ngswitch"
      },
      {
        "level": 2,
        "text": "What's nextlink",
        "id": "whats-next"
      },
      {
        "level": 3,
        "text": "Import CommonModule in the componentlink",
        "id": "import-commonmodule-in-the-component"
      },
      {
        "level": 3,
        "text": "Using NgClass with an expressionlink",
        "id": "using-ngclass-with-an-expression"
      },
      {
        "level": 3,
        "text": "Using NgClass with a methodlink",
        "id": "using-ngclass-with-a-method"
      },
      {
        "level": 3,
        "text": "Import CommonModule in the componentlink",
        "id": "import-commonmodule-in-the-component-1"
      },
      {
        "level": 3,
        "text": "Using NgStyle in your componentlink",
        "id": "using-ngstyle-in-your-component"
      },
      {
        "level": 3,
        "text": "NgModel and value accessorslink",
        "id": "ngmodel-and-value-accessors"
      },
      {
        "level": 3,
        "text": "Import CommonModule in the componentlink",
        "id": "import-commonmodule-in-the-component-2"
      },
      {
        "level": 3,
        "text": "Guarding against nulllink",
        "id": "guarding-against-null"
      },
      {
        "level": 3,
        "text": "Repeating a component viewlink",
        "id": "repeating-a-component-view"
      },
      {
        "level": 3,
        "text": "Getting the index of *ngForlink",
        "id": "getting-the-index-of-ngfor"
      },
      {
        "level": 3,
        "text": "Tracking items with *ngFor trackBylink",
        "id": "tracking-items-with-ngfor-trackby"
      }
    ],
    "codeBlocks": [
      {
        "language": "text",
        "code": "CommonModule"
      },
      {
        "language": "text",
        "code": "CommonModule"
      },
      {
        "language": "text",
        "code": "CommonModule"
      },
      {
        "language": "text",
        "code": "CommonModule"
      },
      {
        "language": "text",
        "code": "RouterModule"
      },
      {
        "language": "text",
        "code": "FormsModule"
      },
      {
        "language": "text",
        "code": "CommonModule"
      },
      {
        "language": "text",
        "code": "CommonModule"
      },
      {
        "language": "text",
        "code": "content_copy\n      \n      import {CommonModule} from '@angular/common';\n/* . . . */\n@Component({\n  standalone: true,\n  /* . . . */\n  imports: [\n    CommonModule, // <-- import into the component\n    /* . . . */\n  ],\n})\nexport class AppComponent implements OnInit {\n  /* . . . */\n}"
      },
      {
        "language": "text",
        "code": "import {CommonModule} from '@angular/common';\n/* . . . */\n@Component({\n  standalone: true,\n  /* . . . */\n  imports: [\n    CommonModule, // <-- import into the component\n    /* . . . */\n  ],\n})\nexport class AppComponent implements OnInit {\n  /* . . . */\n}"
      },
      {
        "language": "text",
        "code": "app.component.ts"
      },
      {
        "language": "text",
        "code": "content_copy\n      \n      <!-- toggle the \"special\" class on/off with a property -->\n<div [ngClass]=\"isSpecial ? 'special' : ''\">This div is special</div>"
      },
      {
        "language": "text",
        "code": "<!-- toggle the \"special\" class on/off with a property -->\n<div [ngClass]=\"isSpecial ? 'special' : ''\">This div is special</div>"
      },
      {
        "language": "text",
        "code": "setCurrentClasses()"
      },
      {
        "language": "text",
        "code": "currentClasses"
      },
      {
        "language": "text",
        "code": "content_copy\n      \n      currentClasses: Record<string, boolean> = {};\n/* . . . */\nsetCurrentClasses() {\n  // CSS classes: added/removed per current state of component properties\n  this.currentClasses = {\n    saveable: this.canSave,\n    modified: !this.isUnchanged,\n    special: this.isSpecial,\n  };\n}"
      },
      {
        "language": "text",
        "code": "currentClasses: Record<string, boolean> = {};\n/* . . . */\nsetCurrentClasses() {\n  // CSS classes: added/removed per current state of component properties\n  this.currentClasses = {\n    saveable: this.canSave,\n    modified: !this.isUnchanged,\n    special: this.isSpecial,\n  };\n}"
      },
      {
        "language": "text",
        "code": "currentClasses"
      },
      {
        "language": "text",
        "code": "content_copy\n      \n      <div [ngClass]=\"currentClasses\">This div is initially saveable, unchanged, and special.</div>"
      },
      {
        "language": "text",
        "code": "<div [ngClass]=\"currentClasses\">This div is initially saveable, unchanged, and special.</div>"
      },
      {
        "language": "text",
        "code": "setCurrentClasses()"
      },
      {
        "language": "text",
        "code": "app.component.ts"
      },
      {
        "language": "text",
        "code": "app.component.html"
      },
      {
        "language": "text",
        "code": "CommonModule"
      },
      {
        "language": "text",
        "code": "CommonModule"
      },
      {
        "language": "text",
        "code": "content_copy\n      \n      import {CommonModule} from '@angular/common';\n/* . . . */\n@Component({\n  standalone: true,\n  /* . . . */\n  imports: [\n    CommonModule, // <-- import into the component\n    /* . . . */\n  ],\n})\nexport class AppComponent implements OnInit {\n  /* . . . */\n}"
      },
      {
        "language": "text",
        "code": "import {CommonModule} from '@angular/common';\n/* . . . */\n@Component({\n  standalone: true,\n  /* . . . */\n  imports: [\n    CommonModule, // <-- import into the component\n    /* . . . */\n  ],\n})\nexport class AppComponent implements OnInit {\n  /* . . . */\n}"
      },
      {
        "language": "text",
        "code": "setCurrentStyles()"
      },
      {
        "language": "text",
        "code": "currentStyles"
      },
      {
        "language": "text",
        "code": "content_copy\n      \n      currentStyles: Record<string, string> = {};\n/* . . . */\nsetCurrentStyles() {\n  // CSS styles: set per current state of component properties\n  this.currentStyles = {\n    'font-style': this.canSave ? 'italic' : 'normal',\n    'font-weight': !this.isUnchanged ? 'bold' : 'normal',\n    'font-size': this.isSpecial ? '24px' : '12px',\n  };\n}"
      },
      {
        "language": "text",
        "code": "currentStyles: Record<string, string> = {};\n/* . . . */\nsetCurrentStyles() {\n  // CSS styles: set per current state of component properties\n  this.currentStyles = {\n    'font-style': this.canSave ? 'italic' : 'normal',\n    'font-weight': !this.isUnchanged ? 'bold' : 'normal',\n    'font-size': this.isSpecial ? '24px' : '12px',\n  };\n}"
      },
      {
        "language": "text",
        "code": "currentStyles"
      },
      {
        "language": "text",
        "code": "content_copy\n      \n      <div [ngStyle]=\"currentStyles\">\n  This div is initially italic, normal weight, and extra large (24px).\n</div>"
      },
      {
        "language": "text",
        "code": "<div [ngStyle]=\"currentStyles\">\n  This div is initially italic, normal weight, and extra large (24px).\n</div>"
      },
      {
        "language": "text",
        "code": "setCurrentStyles()"
      },
      {
        "language": "text",
        "code": "app.component.ts"
      },
      {
        "language": "text",
        "code": "app.component.html"
      },
      {
        "language": "text",
        "code": "FormsModule"
      },
      {
        "language": "text",
        "code": "content_copy\n      \n      import {FormsModule} from '@angular/forms'; // <--- JavaScript import from Angular\n/* . . . */\n@Component({\n  standalone: true,\n  /* . . . */\n  imports: [\n    CommonModule, // <-- import into the component\n    FormsModule, // <--- import into the component\n    /* . . . */\n  ],\n})\nexport class AppComponent implements OnInit {\n  /* . . . */\n}"
      },
      {
        "language": "text",
        "code": "import {FormsModule} from '@angular/forms'; // <--- JavaScript import from Angular\n/* . . . */\n@Component({\n  standalone: true,\n  /* . . . */\n  imports: [\n    CommonModule, // <-- import into the component\n    FormsModule, // <--- import into the component\n    /* . . . */\n  ],\n})\nexport class AppComponent implements OnInit {\n  /* . . . */\n}"
      },
      {
        "language": "text",
        "code": "[(ngModel)]"
      },
      {
        "language": "text",
        "code": "content_copy\n      \n      <label for=\"example-ngModel\">[(ngModel)]:</label>\n<input [(ngModel)]=\"currentItem.name\" id=\"example-ngModel\">"
      },
      {
        "language": "text",
        "code": "<label for=\"example-ngModel\">[(ngModel)]:</label>\n<input [(ngModel)]=\"currentItem.name\" id=\"example-ngModel\">"
      },
      {
        "language": "text",
        "code": "[(ngModel)]"
      },
      {
        "language": "text",
        "code": "content_copy\n      \n      <input [ngModel]=\"currentItem.name\" (ngModelChange)=\"setUppercaseName($event)\" id=\"example-uppercase\">"
      },
      {
        "language": "text",
        "code": "<input [ngModel]=\"currentItem.name\" (ngModelChange)=\"setUppercaseName($event)\" id=\"example-uppercase\">"
      },
      {
        "language": "text",
        "code": "[(ngModel)]"
      },
      {
        "language": "text",
        "code": "CommonModule"
      },
      {
        "language": "text",
        "code": "CommonModule"
      },
      {
        "language": "text",
        "code": "content_copy\n      \n      import {CommonModule} from '@angular/common';\n/* . . . */\n@Component({\n  standalone: true,\n  /* . . . */\n  imports: [\n    CommonModule, // <-- import into the component\n    /* . . . */\n  ],\n})\nexport class AppComponent implements OnInit {\n  /* . . . */\n}"
      },
      {
        "language": "text",
        "code": "import {CommonModule} from '@angular/common';\n/* . . . */\n@Component({\n  standalone: true,\n  /* . . . */\n  imports: [\n    CommonModule, // <-- import into the component\n    /* . . . */\n  ],\n})\nexport class AppComponent implements OnInit {\n  /* . . . */\n}"
      },
      {
        "language": "text",
        "code": "content_copy\n      \n      <app-item-detail *ngIf=\"isActive\" [item]=\"item\"></app-item-detail>"
      },
      {
        "language": "text",
        "code": "<app-item-detail *ngIf=\"isActive\" [item]=\"item\"></app-item-detail>"
      },
      {
        "language": "text",
        "code": "ItemDetailComponent"
      },
      {
        "language": "text",
        "code": "ItemDetailComponent"
      },
      {
        "language": "text",
        "code": "*ngIf=\"yourProperty\""
      },
      {
        "language": "text",
        "code": "currentCustomer"
      },
      {
        "language": "text",
        "code": "currentCustomer"
      },
      {
        "language": "text",
        "code": "content_copy\n      \n      <div *ngIf=\"currentCustomer\">Hello, {{currentCustomer.name}}</div>"
      },
      {
        "language": "text",
        "code": "<div *ngIf=\"currentCustomer\">Hello, {{currentCustomer.name}}</div>"
      },
      {
        "language": "text",
        "code": "nullCustomer"
      },
      {
        "language": "text",
        "code": "content_copy\n      \n      <div *ngIf=\"nullCustomer\">Hello, <span>{{nullCustomer}}</span></div>"
      },
      {
        "language": "text",
        "code": "<div *ngIf=\"nullCustomer\">Hello, <span>{{nullCustomer}}</span></div>"
      },
      {
        "language": "text",
        "code": "let item of items"
      },
      {
        "language": "text",
        "code": "content_copy\n      \n      <div *ngFor=\"let item of items\">{{item.name}}</div>"
      },
      {
        "language": "text",
        "code": "<div *ngFor=\"let item of items\">{{item.name}}</div>"
      },
      {
        "language": "text",
        "code": "\"let item of items\""
      },
      {
        "language": "text",
        "code": "\"let item of items\""
      },
      {
        "language": "text",
        "code": "<ng-template>"
      },
      {
        "language": "text",
        "code": "<ng-template>"
      },
      {
        "language": "text",
        "code": "<app-item-detail>"
      },
      {
        "language": "text",
        "code": "content_copy\n      \n      <app-item-detail *ngFor=\"let item of items\" [item]=\"item\"></app-item-detail>"
      },
      {
        "language": "text",
        "code": "<app-item-detail *ngFor=\"let item of items\" [item]=\"item\"></app-item-detail>"
      },
      {
        "language": "text",
        "code": "<app-item-detail>"
      },
      {
        "language": "text",
        "code": "content_copy\n      \n      <div *ngFor=\"let item of items\">{{item.name}}</div>\n<!-- . . . -->\n<app-item-detail *ngFor=\"let item of items\" [item]=\"item\"></app-item-detail>"
      },
      {
        "language": "text",
        "code": "<div *ngFor=\"let item of items\">{{item.name}}</div>\n<!-- . . . -->\n<app-item-detail *ngFor=\"let item of items\" [item]=\"item\"></app-item-detail>"
      },
      {
        "language": "text",
        "code": "let i=index"
      },
      {
        "language": "text",
        "code": "content_copy\n      \n      <div *ngFor=\"let item of items; let i=index\">{{i + 1}} - {{item.name}}</div>"
      },
      {
        "language": "text",
        "code": "<div *ngFor=\"let item of items; let i=index\">{{i + 1}} - {{item.name}}</div>"
      },
      {
        "language": "text",
        "code": "<ng-template>"
      },
      {
        "language": "text",
        "code": "content_copy\n      \n      trackByItems(index: number, item: Item): number {\n  return item.id;\n}"
      },
      {
        "language": "text",
        "code": "trackByItems(index: number, item: Item): number {\n  return item.id;\n}"
      },
      {
        "language": "text",
        "code": "trackByItems()"
      },
      {
        "language": "text",
        "code": "content_copy\n      \n      <div *ngFor=\"let item of items; trackBy: trackByItems\">\n  ({{item.id}}) {{item.name}}\n</div>"
      },
      {
        "language": "text",
        "code": "<div *ngFor=\"let item of items; trackBy: trackByItems\">\n  ({{item.id}}) {{item.name}}\n</div>"
      },
      {
        "language": "text",
        "code": "<ng-container>"
      },
      {
        "language": "text",
        "code": "<ng-container>"
      },
      {
        "language": "text",
        "code": "<ng-container>"
      },
      {
        "language": "text",
        "code": "content_copy\n      \n      <p>\n  I turned the corner\n  <ng-container *ngIf=\"hero\">\n    and saw {{hero.name}}. I waved\n  </ng-container>\n  and continued on my way.\n</p>"
      },
      {
        "language": "text",
        "code": "<p>\n  I turned the corner\n  <ng-container *ngIf=\"hero\">\n    and saw {{hero.name}}. I waved\n  </ng-container>\n  and continued on my way.\n</p>"
      },
      {
        "language": "text",
        "code": "FormsModule"
      },
      {
        "language": "text",
        "code": "FormsModule"
      },
      {
        "language": "text",
        "code": "<ng-container>"
      },
      {
        "language": "text",
        "code": "content_copy\n      \n      <div>\n  Pick your favorite hero\n  (<label for=\"showSad\"><input id=\"showSad\" type=\"checkbox\" checked (change)=\"showSad = !showSad\">show sad</label>)\n</div>\n<select [(ngModel)]=\"hero\">\n  <ng-container *ngFor=\"let h of heroes\">\n    <ng-container *ngIf=\"showSad || h.emotion !== 'sad'\">\n      <option [ngValue]=\"h\">{{h.name}} ({{h.emotion}})</option>\n    </ng-container>\n  </ng-container>\n</select>"
      },
      {
        "language": "text",
        "code": "<div>\n  Pick your favorite hero\n  (<label for=\"showSad\"><input id=\"showSad\" type=\"checkbox\" checked (change)=\"showSad = !showSad\">show sad</label>)\n</div>\n<select [(ngModel)]=\"hero\">\n  <ng-container *ngFor=\"let h of heroes\">\n    <ng-container *ngIf=\"showSad || h.emotion !== 'sad'\">\n      <option [ngValue]=\"h\">{{h.name}} ({{h.emotion}})</option>\n    </ng-container>\n  </ng-container>\n</select>"
      },
      {
        "language": "text",
        "code": "NgSwitchCase"
      },
      {
        "language": "text",
        "code": "NgSwitchDefault"
      },
      {
        "language": "text",
        "code": "NgSwitchCase"
      },
      {
        "language": "text",
        "code": "*ngSwitchCase"
      },
      {
        "language": "text",
        "code": "*ngSwitchDefault"
      },
      {
        "language": "text",
        "code": "content_copy\n      \n      <div [ngSwitch]=\"currentItem.feature\">\n  <app-stout-item    *ngSwitchCase=\"'stout'\"    [item]=\"currentItem\"></app-stout-item>\n  <app-device-item   *ngSwitchCase=\"'slim'\"     [item]=\"currentItem\"></app-device-item>\n  <app-lost-item     *ngSwitchCase=\"'vintage'\"  [item]=\"currentItem\"></app-lost-item>\n  <app-best-item     *ngSwitchCase=\"'bright'\"   [item]=\"currentItem\"></app-best-item>\n<!-- . . . -->\n  <app-unknown-item  *ngSwitchDefault           [item]=\"currentItem\"></app-unknown-item>\n</div>"
      },
      {
        "language": "text",
        "code": "<div [ngSwitch]=\"currentItem.feature\">\n  <app-stout-item    *ngSwitchCase=\"'stout'\"    [item]=\"currentItem\"></app-stout-item>\n  <app-device-item   *ngSwitchCase=\"'slim'\"     [item]=\"currentItem\"></app-device-item>\n  <app-lost-item     *ngSwitchCase=\"'vintage'\"  [item]=\"currentItem\"></app-lost-item>\n  <app-best-item     *ngSwitchCase=\"'bright'\"   [item]=\"currentItem\"></app-best-item>\n<!-- . . . -->\n  <app-unknown-item  *ngSwitchDefault           [item]=\"currentItem\"></app-unknown-item>\n</div>"
      },
      {
        "language": "text",
        "code": "currentItem"
      },
      {
        "language": "text",
        "code": "content_copy\n      \n      currentItem!: Item;"
      },
      {
        "language": "text",
        "code": "currentItem!: Item;"
      },
      {
        "language": "text",
        "code": "currentItem"
      },
      {
        "language": "text",
        "code": "StoutItemComponent"
      },
      {
        "language": "text",
        "code": "content_copy\n      \n      export class StoutItemComponent {\n  @Input() item!: Item;\n}"
      },
      {
        "language": "text",
        "code": "export class StoutItemComponent {\n  @Input() item!: Item;\n}"
      },
      {
        "language": "text",
        "code": "<app-best-item>"
      },
      {
        "language": "text",
        "code": "content_copy\n      \n      <div *ngSwitchCase=\"'bright'\"> Are you as bright as {{currentItem.name}}?</div>"
      },
      {
        "language": "text",
        "code": "<div *ngSwitchCase=\"'bright'\"> Are you as bright as {{currentItem.name}}?</div>"
      }
    ],
    "links": [
      {
        "text": "link",
        "href": "guide/built-in-directives#built-in-directives"
      },
      {
        "text": "Built-in attribute directives",
        "href": "guide/built-in-directives#built-in-attribute-directives"
      },
      {
        "text": "Adding and removing classes with NgClass",
        "href": "guide/built-in-directives#adding-and-removing-classes-with-ngclass"
      },
      {
        "text": "Import CommonModule in the component",
        "href": "guide/built-in-directives#import-commonmodule-in-the-component"
      },
      {
        "text": "Using NgClass with an expression",
        "href": "guide/built-in-directives#using-ngclass-with-an-expression"
      },
      {
        "text": "Using NgClass with a method",
        "href": "guide/built-in-directives#using-ngclass-with-a-method"
      },
      {
        "text": "Setting inline styles with NgStyle",
        "href": "guide/built-in-directives#setting-inline-styles-with-ngstyle"
      },
      {
        "text": "Import CommonModule in the component",
        "href": "guide/built-in-directives#import-commonmodule-in-the-component-1"
      },
      {
        "text": "Using NgStyle in your component",
        "href": "guide/built-in-directives#using-ngstyle-in-your-component"
      },
      {
        "text": "Displaying and updating properties with ngModel",
        "href": "guide/built-in-directives#displaying-and-updating-properties-with-ngmodel"
      },
      {
        "text": "NgModel and value accessors",
        "href": "guide/built-in-directives#ngmodel-and-value-accessors"
      },
      {
        "text": "Built-in structural directives",
        "href": "guide/built-in-directives#built-in-structural-directives"
      },
      {
        "text": "Import CommonModule in the component",
        "href": "guide/built-in-directives#import-commonmodule-in-the-component-2"
      },
      {
        "text": "Adding or removing an element with NgIf",
        "href": "guide/built-in-directives#adding-or-removing-an-element-with-ngif"
      },
      {
        "text": "Guarding against null",
        "href": "guide/built-in-directives#guarding-against-null"
      },
      {
        "text": "Listing items with NgFor",
        "href": "guide/built-in-directives#listing-items-with-ngfor"
      },
      {
        "text": "Repeating a component view",
        "href": "guide/built-in-directives#repeating-a-component-view"
      },
      {
        "text": "Getting the index of *ngFor",
        "href": "guide/built-in-directives#getting-the-index-of-ngfor"
      },
      {
        "text": "Repeating elements when a condition is true",
        "href": "guide/built-in-directives#repeating-elements-when-a-condition-is-true"
      },
      {
        "text": "Tracking items with *ngFor trackBy",
        "href": "guide/built-in-directives#tracking-items-with-ngfor-trackby"
      },
      {
        "text": "Hosting a directive without a DOM element",
        "href": "guide/built-in-directives#hosting-a-directive-without-a-dom-element"
      },
      {
        "text": "Switching cases with NgSwitch",
        "href": "guide/built-in-directives#switching-cases-with-ngswitch"
      },
      {
        "text": "What's next",
        "href": "guide/built-in-directives#whats-next"
      },
      {
        "text": "live example",
        "href": "generated/live-examples/built-in-directives/stackblitz.html"
      },
      {
        "text": "download example",
        "href": "generated/zips/built-in-directives/built-in-directives.zip"
      },
      {
        "text": "Components",
        "href": "guide/component-overview"
      },
      {
        "text": "Attribute directives",
        "href": "guide/built-in-directives#built-in-attribute-directives"
      },
      {
        "text": "Structural directives",
        "href": "guide/built-in-directives#built-in-structural-directives"
      },
      {
        "text": "attribute directives",
        "href": "guide/built-in-directives#built-in-attribute-directives"
      },
      {
        "text": "structural directives",
        "href": "guide/built-in-directives#built-in-structural-directives"
      },
      {
        "text": "link",
        "href": "guide/built-in-directives#built-in-attribute-directives"
      },
      {
        "text": "CommonModule",
        "href": "api/common/CommonModule"
      },
      {
        "text": "RouterModule",
        "href": "guide/router"
      },
      {
        "text": "FormsModule",
        "href": "guide/forms"
      },
      {
        "text": "NgClass",
        "href": "guide/built-in-directives#ngClass"
      },
      {
        "text": "NgStyle",
        "href": "guide/built-in-directives#ngstyle"
      },
      {
        "text": "NgModel",
        "href": "guide/built-in-directives#ngModel"
      },
      {
        "text": "NgClass",
        "href": "api/common/NgClass"
      },
      {
        "text": "link",
        "href": "guide/built-in-directives#adding-and-removing-classes-with-ngclass"
      },
      {
        "text": "ngClass",
        "href": "api/common/NgClass"
      },
      {
        "text": "class binding",
        "href": "guide/class-binding"
      },
      {
        "text": "NgClass",
        "href": "api/common/NgClass"
      },
      {
        "text": "CommonModule",
        "href": "api/common/CommonModule"
      },
      {
        "text": "link",
        "href": "guide/built-in-directives#import-commonmodule-in-the-component"
      },
      {
        "text": "NgClass",
        "href": "api/common/NgClass"
      },
      {
        "text": "CommonModule",
        "href": "api/common/CommonModule"
      },
      {
        "text": "CommonModule",
        "href": "api/common/CommonModule"
      },
      {
        "text": "Component",
        "href": "api/core/Component"
      },
      {
        "text": "CommonModule",
        "href": "api/common/CommonModule"
      },
      {
        "text": "OnInit",
        "href": "api/core/OnInit"
      },
      {
        "text": "NgClass",
        "href": "api/common/NgClass"
      },
      {
        "text": "link",
        "href": "guide/built-in-directives#using-ngclass-with-an-expression"
      },
      {
        "text": "ngClass",
        "href": "api/common/NgClass"
      },
      {
        "text": "ngClass",
        "href": "api/common/NgClass"
      },
      {
        "text": "ngClass",
        "href": "api/common/NgClass"
      },
      {
        "text": "NgClass",
        "href": "api/common/NgClass"
      },
      {
        "text": "link",
        "href": "guide/built-in-directives#using-ngclass-with-a-method"
      },
      {
        "text": "NgClass",
        "href": "api/common/NgClass"
      },
      {
        "text": "ngClass",
        "href": "api/common/NgClass"
      },
      {
        "text": "ngClass",
        "href": "api/common/NgClass"
      },
      {
        "text": "ngClass",
        "href": "api/common/NgClass"
      },
      {
        "text": "ngClass",
        "href": "api/common/NgClass"
      },
      {
        "text": "ngClass",
        "href": "api/common/NgClass"
      },
      {
        "text": "live example",
        "href": "generated/live-examples/built-in-directives/stackblitz.html"
      },
      {
        "text": "download example",
        "href": "generated/zips/built-in-directives/built-in-directives.zip"
      },
      {
        "text": "NgStyle",
        "href": "api/common/NgStyle"
      },
      {
        "text": "link",
        "href": "guide/built-in-directives#setting-inline-styles-with-ngstyle"
      },
      {
        "text": "CommonModule",
        "href": "api/common/CommonModule"
      },
      {
        "text": "link",
        "href": "guide/built-in-directives#import-commonmodule-in-the-component-1"
      },
      {
        "text": "NgStyle",
        "href": "api/common/NgStyle"
      },
      {
        "text": "CommonModule",
        "href": "api/common/CommonModule"
      },
      {
        "text": "CommonModule",
        "href": "api/common/CommonModule"
      },
      {
        "text": "Component",
        "href": "api/core/Component"
      },
      {
        "text": "CommonModule",
        "href": "api/common/CommonModule"
      },
      {
        "text": "OnInit",
        "href": "api/core/OnInit"
      },
      {
        "text": "NgStyle",
        "href": "api/common/NgStyle"
      },
      {
        "text": "link",
        "href": "guide/built-in-directives#using-ngstyle-in-your-component"
      },
      {
        "text": "NgStyle",
        "href": "api/common/NgStyle"
      },
      {
        "text": "NgStyle",
        "href": "api/common/NgStyle"
      },
      {
        "text": "ngStyle",
        "href": "api/common/NgStyle"
      },
      {
        "text": "ngStyle",
        "href": "api/common/NgStyle"
      },
      {
        "text": "ngStyle",
        "href": "api/common/NgStyle"
      },
      {
        "text": "live example",
        "href": "generated/live-examples/built-in-directives/stackblitz.html"
      },
      {
        "text": "download example",
        "href": "generated/zips/built-in-directives/built-in-directives.zip"
      },
      {
        "text": "ngModel",
        "href": "api/forms/NgModel"
      },
      {
        "text": "link",
        "href": "guide/built-in-directives#displaying-and-updating-properties-with-ngmodel"
      },
      {
        "text": "NgModel",
        "href": "api/forms/NgModel"
      },
      {
        "text": "FormsModule",
        "href": "api/forms/FormsModule"
      },
      {
        "text": "FormsModule",
        "href": "api/forms/FormsModule"
      },
      {
        "text": "Component",
        "href": "api/core/Component"
      },
      {
        "text": "CommonModule",
        "href": "api/common/CommonModule"
      },
      {
        "text": "FormsModule",
        "href": "api/forms/FormsModule"
      },
      {
        "text": "OnInit",
        "href": "api/core/OnInit"
      },
      {
        "text": "ngModel",
        "href": "api/forms/NgModel"
      },
      {
        "text": "ngModel",
        "href": "api/forms/NgModel"
      },
      {
        "text": "ngModel",
        "href": "api/forms/NgModel"
      },
      {
        "text": "ngModel",
        "href": "api/forms/NgModel"
      },
      {
        "text": "property binding",
        "href": "guide/property-binding"
      },
      {
        "text": "event binding",
        "href": "guide/event-binding"
      },
      {
        "text": "ngModel",
        "href": "api/forms/NgModel"
      },
      {
        "text": "NgModel",
        "href": "api/forms/NgModel"
      },
      {
        "text": "link",
        "href": "guide/built-in-directives#ngmodel-and-value-accessors"
      },
      {
        "text": "NgModel",
        "href": "api/forms/NgModel"
      },
      {
        "text": "ControlValueAccessor",
        "href": "api/forms/ControlValueAccessor"
      },
      {
        "text": "Forms",
        "href": "guide/forms"
      },
      {
        "text": "ngModel",
        "href": "api/forms/NgModel"
      },
      {
        "text": "DefaultValueAccessor",
        "href": "api/forms/DefaultValueAccessor"
      },
      {
        "text": "NgModel",
        "href": "api/forms/NgModel"
      },
      {
        "text": "two-way binding syntax",
        "href": "guide/two-way-binding#how-two-way-binding-works"
      },
      {
        "text": "link",
        "href": "guide/built-in-directives#built-in-structural-directives"
      },
      {
        "text": "NgIf",
        "href": "guide/built-in-directives#ngIf"
      },
      {
        "text": "NgFor",
        "href": "guide/built-in-directives#ngFor"
      },
      {
        "text": "NgSwitch",
        "href": "guide/built-in-directives#ngSwitch"
      },
      {
        "text": "Structural Directives",
        "href": "guide/structural-directives"
      },
      {
        "text": "CommonModule",
        "href": "api/common/CommonModule"
      },
      {
        "text": "link",
        "href": "guide/built-in-directives#import-commonmodule-in-the-component-2"
      },
      {
        "text": "CommonModule",
        "href": "api/common/CommonModule"
      },
      {
        "text": "CommonModule",
        "href": "api/common/CommonModule"
      },
      {
        "text": "Component",
        "href": "api/core/Component"
      },
      {
        "text": "CommonModule",
        "href": "api/common/CommonModule"
      },
      {
        "text": "OnInit",
        "href": "api/core/OnInit"
      },
      {
        "text": "NgIf",
        "href": "api/common/NgIf"
      },
      {
        "text": "link",
        "href": "guide/built-in-directives#adding-or-removing-an-element-with-ngif"
      },
      {
        "text": "NgIf",
        "href": "api/common/NgIf"
      },
      {
        "text": "NgIf",
        "href": "api/common/NgIf"
      },
      {
        "text": "ngIf",
        "href": "api/common/NgIf"
      },
      {
        "text": "ngIf",
        "href": "api/common/NgIf"
      },
      {
        "text": "NgIf",
        "href": "api/common/NgIf"
      },
      {
        "text": "NgIf",
        "href": "api/common/NgIf"
      },
      {
        "text": "NgIf",
        "href": "api/common/NgIf"
      },
      {
        "text": "NgIf API documentation",
        "href": "api/common/NgIf"
      },
      {
        "text": "link",
        "href": "guide/built-in-directives#guarding-against-null"
      },
      {
        "text": "NgIf",
        "href": "api/common/NgIf"
      },
      {
        "text": "NgIf",
        "href": "api/common/NgIf"
      },
      {
        "text": "ngIf",
        "href": "api/common/NgIf"
      },
      {
        "text": "ngIf",
        "href": "api/common/NgIf"
      },
      {
        "text": "ngIf",
        "href": "api/common/NgIf"
      },
      {
        "text": "NgFor",
        "href": "api/common/NgFor"
      },
      {
        "text": "link",
        "href": "guide/built-in-directives#listing-items-with-ngfor"
      },
      {
        "text": "NgFor",
        "href": "api/common/NgFor"
      },
      {
        "text": "ngFor",
        "href": "api/common/NgFor"
      },
      {
        "text": "ngFor",
        "href": "api/common/NgFor"
      },
      {
        "text": "<ng-template>",
        "href": "api/core/ng-template"
      },
      {
        "text": "<ng-template>",
        "href": "api/core/ng-template"
      },
      {
        "text": "Structural directive shorthand",
        "href": "guide/structural-directives#shorthand"
      },
      {
        "text": "Structural directives",
        "href": "guide/structural-directives"
      },
      {
        "text": "link",
        "href": "guide/built-in-directives#repeating-a-component-view"
      },
      {
        "text": "ngFor",
        "href": "api/common/NgFor"
      },
      {
        "text": "ngFor",
        "href": "api/common/NgFor"
      },
      {
        "text": "ngFor",
        "href": "api/common/NgFor"
      },
      {
        "text": "ngFor",
        "href": "api/common/NgFor"
      },
      {
        "text": "ngFor",
        "href": "api/common/NgFor"
      },
      {
        "text": "Structural directive shorthand",
        "href": "guide/structural-directives#shorthand"
      },
      {
        "text": "ngFor",
        "href": "api/common/NgFor"
      },
      {
        "text": "link",
        "href": "guide/built-in-directives#getting-the-index-of-ngfor"
      },
      {
        "text": "ngFor",
        "href": "api/common/NgFor"
      },
      {
        "text": "ngFor",
        "href": "api/common/NgFor"
      },
      {
        "text": "ngFor",
        "href": "api/common/NgFor"
      },
      {
        "text": "NgFor",
        "href": "api/common/NgFor"
      },
      {
        "text": "<ng-template>",
        "href": "api/core/ng-template"
      },
      {
        "text": "Structural Directives",
        "href": "guide/structural-directives#shorthand"
      },
      {
        "text": "link",
        "href": "guide/built-in-directives#repeating-elements-when-a-condition-is-true"
      },
      {
        "text": "ngIf",
        "href": "api/common/NgIf"
      },
      {
        "text": "ngFor",
        "href": "api/common/NgFor"
      },
      {
        "text": "one structural directive per element",
        "href": "guide/structural-directives#one-per-element"
      },
      {
        "text": "ngFor",
        "href": "api/common/NgFor"
      },
      {
        "text": "link",
        "href": "guide/built-in-directives#tracking-items-with-ngfor-trackby"
      },
      {
        "text": "ngFor",
        "href": "api/common/NgFor"
      },
      {
        "text": "NgFor",
        "href": "api/common/NgFor"
      },
      {
        "text": "ngFor",
        "href": "api/common/NgFor"
      },
      {
        "text": "link",
        "href": "guide/built-in-directives#hosting-a-directive-without-a-dom-element"
      },
      {
        "text": "<ng-container>",
        "href": "api/core/ng-container"
      },
      {
        "text": "<ng-container>",
        "href": "api/core/ng-container"
      },
      {
        "text": "<ng-container>",
        "href": "api/core/ng-container"
      },
      {
        "text": "ngIf",
        "href": "api/common/NgIf"
      },
      {
        "text": "ngModel",
        "href": "api/forms/NgModel"
      },
      {
        "text": "FormsModule",
        "href": "api/forms/FormsModule"
      },
      {
        "text": "FormsModule",
        "href": "api/forms/FormsModule"
      },
      {
        "text": "<ng-container>",
        "href": "api/core/ng-container"
      },
      {
        "text": "ngModel",
        "href": "api/forms/NgModel"
      },
      {
        "text": "ngFor",
        "href": "api/common/NgFor"
      },
      {
        "text": "ngIf",
        "href": "api/common/NgIf"
      },
      {
        "text": "NgSwitch",
        "href": "api/common/NgSwitch"
      },
      {
        "text": "link",
        "href": "guide/built-in-directives#switching-cases-with-ngswitch"
      },
      {
        "text": "NgSwitch",
        "href": "api/common/NgSwitch"
      },
      {
        "text": "NgSwitch",
        "href": "api/common/NgSwitch"
      },
      {
        "text": "NgSwitch",
        "href": "api/common/NgSwitch"
      },
      {
        "text": "NgSwitch",
        "href": "api/common/NgSwitch"
      },
      {
        "text": "NgSwitchCase",
        "href": "api/common/NgSwitchCase"
      },
      {
        "text": "NgSwitchDefault",
        "href": "api/common/NgSwitchDefault"
      },
      {
        "text": "NgSwitchCase",
        "href": "api/common/NgSwitchCase"
      },
      {
        "text": "ngSwitch",
        "href": "api/common/NgSwitch"
      },
      {
        "text": "ngSwitchCase",
        "href": "api/common/NgSwitchCase"
      },
      {
        "text": "ngSwitchDefault",
        "href": "api/common/NgSwitchDefault"
      },
      {
        "text": "ngSwitch",
        "href": "api/common/NgSwitch"
      },
      {
        "text": "ngSwitchCase",
        "href": "api/common/NgSwitchCase"
      },
      {
        "text": "ngSwitchCase",
        "href": "api/common/NgSwitchCase"
      },
      {
        "text": "ngSwitchCase",
        "href": "api/common/NgSwitchCase"
      },
      {
        "text": "ngSwitchCase",
        "href": "api/common/NgSwitchCase"
      },
      {
        "text": "ngSwitchDefault",
        "href": "api/common/NgSwitchDefault"
      },
      {
        "text": "ngSwitch",
        "href": "api/common/NgSwitch"
      },
      {
        "text": "input property",
        "href": "guide/inputs-outputs#input"
      },
      {
        "text": "Input",
        "href": "api/core/Input"
      },
      {
        "text": "ngSwitchCase",
        "href": "api/common/NgSwitchCase"
      },
      {
        "text": "link",
        "href": "guide/built-in-directives#whats-next"
      },
      {
        "text": "Attribute Directives",
        "href": "guide/attribute-directives"
      },
      {
        "text": "Structural Directives",
        "href": "guide/structural-directives"
      }
    ],
    "meta": {
      "description": "",
      "keywords": ""
    },
    "summary": "Built-in directiveslink Contents Built-in attribute directivesAdding and removing classes with NgClassImport CommonModule in the componentUsing NgClass with an expressionUsing NgClass with a methodSet...",
    "tags": [
      "react",
      "vue",
      "angular",
      "javascript",
      "typescript",
      "css",
      "html",
      "node",
      "vite",
      "componentlink"
    ],
    "id": "angular-builtindirectives-part-1",
    "quality": 90
  },
  {
    "title": "Angular",
    "url": "https://v17.angular.io/guide/forms-overview",
    "category": "angular",
    "content": "Introduction to forms in Angularlink Contents PrerequisitesChoosing an approachKey differencesScalabilitySetting up the form modelCommon form foundation classesSetup in reactive formsSetup in template-driven formsData flow in formsData flow in reactive formsData flow in template-driven formsMutability of the data modelForm validationTestingTesting reactive formsTesting template-driven formsNext steps Handling user input with forms is the cornerstone of many common applications. Applications use forms to enable users to log in, to update a profile, to enter sensitive information, and to perform many other data-entry tasks. Angular provides two different approaches to handling user input through forms: reactive and template-driven. Both capture user input events from the view, validate the user input, create a form model and data model to update, and provide a way to track changes. This guide provides information to help you decide which type of form works best for your situation. It introduces the common building blocks used by both approaches. It also summarizes the key differences between the two approaches, and demonstrates those differences in the context of setup, data flow, and testing. Prerequisiteslink This guide assumes that you have a basic understanding of the following. TypeScript and HTML5 programming Angular app-design fundamentals, as described in Angular Concepts The basics of Angular template syntax Choosing an approachlink Reactive forms and template-driven forms process and manage form data differently. Each approach offers different advantages. Forms Details Reactive forms Provide direct, explicit access to the underlying form's object model. Compared to template-driven forms, they are more robust: they're more scalable, reusable, and testable. If forms are a key part of your application, or you're already using reactive patterns for building your application, use reactive forms. Template-driven forms Rely on directives in the template to create and manipulate the underlying object model. They are useful for adding a simple form to an app, such as an email list signup form. They're straightforward to add to an app, but they don't scale as well as reactive forms. If you have very basic form requirements and logic that can be managed solely in the template, template-driven forms could be a good fit. Key differenceslink The following table summarizes the key differences between reactive and template-driven forms. Reactive Template-driven Setup of form model Explicit, created in component class Implicit, created by directives Data model Structured and immutable Unstructured and mutable Data flow Synchronous Asynchronous Form validation Functions Directives Scalabilitylink If forms are a central part of your application, scalability is very important. Being able to reuse form models across components is critical. Reactive forms are more scalable than template-driven forms. They provide direct access to the underlying form API, and use synchronous data flow between the view and the data model, which makes creating large-scale forms easier. Reactive forms require less setup for testing, and testing does not require deep understanding of change detection to properly test form updates and validation. Template-driven forms focus on simple scenarios and are not as reusable. They abstract away the underlying form API, and use asynchronous data flow between the view and the data model. The abstraction of template-driven forms also affects testing. Tests are deeply reliant on manual change detection execution to run properly, and require more setup. Setting up the form modellink Both reactive and template-driven forms track value changes between the form input elements that users interact with and the form data in your component model. The two approaches share underlying building blocks, but differ in how you create and manage the common form-control instances. Common form foundation classeslink Both reactive and template-driven forms are built on the following base classes. Base classes Details FormControl Tracks the value and validation status of an individual form control. FormGroup Tracks the same values and status for a collection of form controls. FormArray Tracks the same values and status for an array of form controls. ControlValueAccessor Creates a bridge between Angular FormControl instances and built-in DOM elements. Setup in reactive formslink With reactive forms, you define the form model directly in the component class. The [formControl] directive links the explicitly created FormControl instance to a specific form element in the view, using an internal value accessor. The following component implements an input field for a single control, using reactive forms. In this example, the form model is the FormControl instance. content_copy import { Component } from '@angular/core'; import { FormControl, ReactiveFormsModule } from '@angular/forms'; @Component({ standalone: true, selector: 'app-reactive-favorite-color', template:  Favorite Color: input type=\"text\" [formControl]=\"favoriteColorControl\" / , imports: [ReactiveFormsModule], }) export class FavoriteColorComponent { favoriteColorControl = new FormControl(''); } Figure 1 shows how, in reactive forms, the form model is the source of truth; it provides the value and status of the form element at any given point in time, through the [formControl] directive on the input element. Figure 1. Direct access to forms model in a reactive form. Setup in template-driven formslink In template-driven forms, the form model is implicit, rather than explicit. The directive NgModel creates and manages a FormControl instance for a given form element. The following component implements the same input field for a single control, using template-driven forms. content_copy import { Component } from '@angular/core'; import { FormsModule } from '@angular/forms'; @Component({ standalone: true, selector: 'app-template-favorite-color', template:  Favorite Color: input type=\"text\" [(ngModel)]=\"favoriteColor\" / , imports: [FormsModule], }) export class FavoriteColorComponent { favoriteColor = ''; } In a template-driven form the source of truth is the template. You do not have direct programmatic access to the FormControl instance, as shown in Figure 2. Figure 2. Indirect access to forms model in a template-driven form. Data flow in formslink When an application contains a form, Angular must keep the view in sync with the component model and the component model in sync with the view. As users change values and make selections through the view, the new values must be reflected in the data model. Similarly, when the program logic changes values in the data model, those values must be reflected in the view. Reactive and template-driven forms differ in how they handle data flowing from the user or from programmatic changes. The following diagrams illustrate both kinds of data flow for each type of form, using the favorite-color input field defined above. Data flow in reactive formslink In reactive forms each form element in the view is directly linked to the form model (a FormControl instance). Updates from the view to the model and from the model to the view are synchronous and do not depend on how the UI is rendered. The view-to-model diagram shows how data flows when an input field's value is changed from the view through the following steps. The user types a value into the input element, in this case the favorite color Blue. The form input element emits an \"input\" event with the latest value. The control value accessor listening for events on the form input element immediately relays the new value to the FormControl instance. The FormControl instance emits the new value through the valueChanges observable. Any subscribers to the valueChanges observable receive the new value. The model-to-view diagram shows how a programmatic change to the model is propagated to the view through the following steps. The user calls the favoriteColorControl.setValue() method, which updates the FormControl value. The FormControl instance emits the new value through the valueChanges observable. Any subscribers to the valueChanges observable receive the new value. The control value accessor on the form input element updates the element with the new value. Data flow in template-driven formslink In template-driven forms, each form element is linked to a directive that manages the form model internally. The view-to-model diagram shows how data flows when an input field's value is changed from the view through the following steps. The user types Blue into the input element. The input element emits an \"input\" event with the value Blue. The control value accessor attached to the input triggers the setValue() method on the FormControl instance. The FormControl instance emits the new value through the valueChanges observable. Any subscribers to the valueChanges observable receive the new value. The control value accessor also calls the NgModel.viewToModelUpdate() method which emits an ngModelChange event. Because the component template uses two-way data binding for the favoriteColor property, the favoriteColor property in the component is updated to the value emitted by the ngModelChange event (Blue). The model-to-view diagram shows how data flows from model to view when the favoriteColor changes from Blue to Red, through the following steps The favoriteColor value is updated in the component. Change detection begins. During change detection, the ngOnChanges lifecycle hook is called on the NgModel directive instance because the value of one of its inputs has changed. The ngOnChanges() method queues an async task to set the value for the internal FormControl instance. Change detection completes. On the next tick, the task to set the FormControl instance value is executed. The FormControl instance emits the latest value through the valueChanges observable. Any subscribers to the valueChanges observable receive the new value. The control value accessor updates the form input element in the view with the latest favoriteColor value. Mutability of the data modellink The change-tracking method plays a role in the efficiency of your application. Forms Details Reactive forms Keep the data model pure by providing it as an immutable data structure. Each time a change is triggered on the data model, the FormControl instance returns a new data model rather than updating the existing data model. This gives you the ability to track unique changes to the data model through the control's observable. Change detection is more efficient because it only needs to update on unique changes. Because data updates follow reactive patterns, you can integrate with observable operators to transform data. Template-driven forms Rely on mutability with two-way data binding to update the data model in the component as changes are made in the template. Because there are no unique changes to track on the data model when using two-way data binding, change detection is less efficient at determining when updates are required. The difference is demonstrated in the previous examples that use the favorite-color input element. With reactive forms, the FormControl instance always returns a new value when the control's value is updated With template-driven forms, the favorite color property is always modified to its new value Form validationlink Validation is an integral part of managing any set of forms. Whether you're checking for required fields or querying an external API for an existing username, Angular provides a set of built-in validators as well as the ability to create custom validators. Forms Details Reactive forms Define custom validators as functions that receive a control to validate Template-driven forms Tied to template directives, and must provide custom validator directives that wrap validation functions For more information, see Form Validation. Testinglink Testing plays a large part in complex applications. A simpler testing strategy is useful when validating that your forms function correctly. Reactive forms and template-driven forms have different levels of reliance on rendering the UI to perform assertions based on form control and form field changes. The following examples demonstrate the process of testing forms with reactive and template-driven forms. Testing reactive formslink Reactive forms provide a relatively straightforward testing strategy because they provide synchronous access to the form and data models, and they can be tested without rendering the UI. In these tests, status and data are queried and manipulated through the control without interacting with the change detection cycle. The following tests use the favorite-color components from previous examples to verify the view-to-model and model-to-view data flows for a reactive form. Verifying view-to-model data flow The first example performs the following steps to verify the view-to-model data flow. Query the view for the form input element, and create a custom \"input\" event for the test. Set the new value for the input to Red, and dispatch the \"input\" event on the form input element. Assert that the component's favoriteColorControl value matches the value from the input. content_copy it('should update the value of the input field', () = { const input = fixture.nativeElement.querySelector('input'); const event = createNewEvent('input'); input.value = 'Red'; input.dispatchEvent(event); expect(fixture.componentInstance.favoriteColorControl.value).toEqual('Red'); }); The next example performs the following steps to verify the model-to-view data flow. Use the favoriteColorControl, a FormControl instance, to set the new value. Query the view for the form input element. Assert that the new value set on the control matches the value in the input. content_copy it('should update the value in the control', () = { component.favoriteColorControl.setValue('Blue'); const input = fixture.nativeElement.querySelector('input'); expect(input.value).toBe('Blue'); }); Testing template-driven formslink Writing tests with template-driven forms requires a detailed knowledge of the change detection process and an understanding of how directives run on each cycle to ensure that elements are queried, tested, or changed at the correct time. The following tests use the favorite color components mentioned earlier to verify the data flows from view to model and model to view for a template-driven form. The following test verifies the data flow from view to model. content_copy it('should update the favorite color in the component', fakeAsync(() = { const input = fixture.nativeElement.querySelector('input'); const event = createNewEvent('input'); input.value = 'Red'; input.dispatchEvent(event); fixture.detectChanges(); expect(component.favoriteColor).toEqual('Red'); })); Here are the steps performed in the view to model test. Query the view for the form input element, and create a custom \"input\" event for the test. Set the new value for the input to Red, and dispatch the \"input\" event on the form input element. Run change detection through the test fixture. Assert that the component favoriteColor property value matches the value from the input. The following test verifies the data flow from model to view. content_copy it('should update the favorite color on the input field', fakeAsync(() = { component.favoriteColor = 'Blue'; fixture.detectChanges(); tick(); const input = fixture.nativeElement.querySelector('input'); expect(input.value).toBe('Blue'); })); Here are the steps performed in the model to view test. Use the component instance to set the value of the favoriteColor property. Run change detection through the test fixture. Use the tick() method to simulate the passage of time within the fakeAsync() task. Query the view for the form input element. Assert that the input value matches the value of the favoriteColor property in the component instance. Next stepslink To learn more about reactive forms, see the following guides: Reactive forms Form validation Dynamic forms To learn more about template-driven forms, see the following guides: Building a template-driven form tutorial Form validation NgForm directive API reference Last reviewed on Thu Sep 07 2023",
    "headings": [
      {
        "level": 1,
        "text": "Introduction to forms in Angularlink",
        "id": "introduction-to-forms-in-angular"
      },
      {
        "level": 2,
        "text": "Prerequisiteslink",
        "id": "prerequisites"
      },
      {
        "level": 2,
        "text": "Choosing an approachlink",
        "id": "choosing-an-approach"
      },
      {
        "level": 2,
        "text": "Setting up the form modellink",
        "id": "setting-up-the-form-model"
      },
      {
        "level": 2,
        "text": "Data flow in formslink",
        "id": "data-flow-in-forms"
      },
      {
        "level": 2,
        "text": "Form validationlink",
        "id": "form-validation"
      },
      {
        "level": 2,
        "text": "Testinglink",
        "id": "testing"
      },
      {
        "level": 2,
        "text": "Next stepslink",
        "id": "next-steps"
      },
      {
        "level": 3,
        "text": "Key differenceslink",
        "id": "key-differences"
      },
      {
        "level": 3,
        "text": "Scalabilitylink",
        "id": "scalability"
      },
      {
        "level": 3,
        "text": "Common form foundation classeslink",
        "id": "common-form-foundation-classes"
      },
      {
        "level": 3,
        "text": "Setup in reactive formslink",
        "id": "setup-in-reactive-forms"
      },
      {
        "level": 3,
        "text": "Setup in template-driven formslink",
        "id": "setup-in-template-driven-forms"
      },
      {
        "level": 3,
        "text": "Data flow in reactive formslink",
        "id": "data-flow-in-reactive-forms"
      },
      {
        "level": 3,
        "text": "Data flow in template-driven formslink",
        "id": "data-flow-in-template-driven-forms"
      },
      {
        "level": 3,
        "text": "Mutability of the data modellink",
        "id": "mutability-of-the-data-model"
      },
      {
        "level": 3,
        "text": "Testing reactive formslink",
        "id": "testing-reactive-forms"
      },
      {
        "level": 3,
        "text": "Testing template-driven formslink",
        "id": "testing-template-driven-forms"
      }
    ],
    "codeBlocks": [
      {
        "language": "text",
        "code": "FormControl"
      },
      {
        "language": "text",
        "code": "ControlValueAccessor"
      },
      {
        "language": "text",
        "code": "FormControl"
      },
      {
        "language": "text",
        "code": "[formControl]"
      },
      {
        "language": "text",
        "code": "FormControl"
      },
      {
        "language": "text",
        "code": "FormControl"
      },
      {
        "language": "text",
        "code": "content_copy\n      \n      import { Component } from '@angular/core';\nimport { FormControl, ReactiveFormsModule } from '@angular/forms';\n\n@Component({\n  standalone: true,\n  selector: 'app-reactive-favorite-color',\n  template: `\n    Favorite Color: <input type=\"text\" [formControl]=\"favoriteColorControl\" />\n  `,\n  imports: [ReactiveFormsModule],\n})\nexport class FavoriteColorComponent {\n  favoriteColorControl = new FormControl('');\n}"
      },
      {
        "language": "text",
        "code": "import { Component } from '@angular/core';\nimport { FormControl, ReactiveFormsModule } from '@angular/forms';\n\n@Component({\n  standalone: true,\n  selector: 'app-reactive-favorite-color',\n  template: `\n    Favorite Color: <input type=\"text\" [formControl]=\"favoriteColorControl\" />\n  `,\n  imports: [ReactiveFormsModule],\n})\nexport class FavoriteColorComponent {\n  favoriteColorControl = new FormControl('');\n}"
      },
      {
        "language": "text",
        "code": "[formControl]"
      },
      {
        "language": "text",
        "code": "FormControl"
      },
      {
        "language": "text",
        "code": "content_copy\n      \n      import { Component } from '@angular/core';\nimport { FormsModule } from '@angular/forms';\n\n@Component({\n  standalone: true,\n  selector: 'app-template-favorite-color',\n  template: `\n    Favorite Color: <input type=\"text\" [(ngModel)]=\"favoriteColor\" />\n  `,\n  imports: [FormsModule],\n})\nexport class FavoriteColorComponent {\n  favoriteColor = '';\n}"
      },
      {
        "language": "text",
        "code": "import { Component } from '@angular/core';\nimport { FormsModule } from '@angular/forms';\n\n@Component({\n  standalone: true,\n  selector: 'app-template-favorite-color',\n  template: `\n    Favorite Color: <input type=\"text\" [(ngModel)]=\"favoriteColor\" />\n  `,\n  imports: [FormsModule],\n})\nexport class FavoriteColorComponent {\n  favoriteColor = '';\n}"
      },
      {
        "language": "text",
        "code": "FormControl"
      },
      {
        "language": "text",
        "code": "FormControl"
      },
      {
        "language": "text",
        "code": "FormControl"
      },
      {
        "language": "text",
        "code": "FormControl"
      },
      {
        "language": "text",
        "code": "valueChanges"
      },
      {
        "language": "text",
        "code": "valueChanges"
      },
      {
        "language": "text",
        "code": "favoriteColorControl.setValue()"
      },
      {
        "language": "text",
        "code": "FormControl"
      },
      {
        "language": "text",
        "code": "FormControl"
      },
      {
        "language": "text",
        "code": "valueChanges"
      },
      {
        "language": "text",
        "code": "valueChanges"
      },
      {
        "language": "text",
        "code": "FormControl"
      },
      {
        "language": "text",
        "code": "FormControl"
      },
      {
        "language": "text",
        "code": "valueChanges"
      },
      {
        "language": "text",
        "code": "valueChanges"
      },
      {
        "language": "text",
        "code": "NgModel.viewToModelUpdate()"
      },
      {
        "language": "text",
        "code": "ngModelChange"
      },
      {
        "language": "text",
        "code": "favoriteColor"
      },
      {
        "language": "text",
        "code": "favoriteColor"
      },
      {
        "language": "text",
        "code": "ngModelChange"
      },
      {
        "language": "text",
        "code": "favoriteColor"
      },
      {
        "language": "text",
        "code": "favoriteColor"
      },
      {
        "language": "text",
        "code": "ngOnChanges"
      },
      {
        "language": "text",
        "code": "ngOnChanges()"
      },
      {
        "language": "text",
        "code": "FormControl"
      },
      {
        "language": "text",
        "code": "FormControl"
      },
      {
        "language": "text",
        "code": "FormControl"
      },
      {
        "language": "text",
        "code": "valueChanges"
      },
      {
        "language": "text",
        "code": "valueChanges"
      },
      {
        "language": "text",
        "code": "favoriteColor"
      },
      {
        "language": "text",
        "code": "FormControl"
      },
      {
        "language": "text",
        "code": "FormControl"
      },
      {
        "language": "text",
        "code": "favoriteColorControl"
      },
      {
        "language": "text",
        "code": "content_copy\n      \n      it('should update the value of the input field', () => {\n  const input = fixture.nativeElement.querySelector('input');\n  const event = createNewEvent('input');\n\n  input.value = 'Red';\n  input.dispatchEvent(event);\n\n  expect(fixture.componentInstance.favoriteColorControl.value).toEqual('Red');\n});"
      },
      {
        "language": "text",
        "code": "it('should update the value of the input field', () => {\n  const input = fixture.nativeElement.querySelector('input');\n  const event = createNewEvent('input');\n\n  input.value = 'Red';\n  input.dispatchEvent(event);\n\n  expect(fixture.componentInstance.favoriteColorControl.value).toEqual('Red');\n});"
      },
      {
        "language": "text",
        "code": "favoriteColorControl"
      },
      {
        "language": "text",
        "code": "FormControl"
      },
      {
        "language": "text",
        "code": "content_copy\n      \n      it('should update the value in the control', () => {\n  component.favoriteColorControl.setValue('Blue');\n\n  const input = fixture.nativeElement.querySelector('input');\n\n  expect(input.value).toBe('Blue');\n});"
      },
      {
        "language": "text",
        "code": "it('should update the value in the control', () => {\n  component.favoriteColorControl.setValue('Blue');\n\n  const input = fixture.nativeElement.querySelector('input');\n\n  expect(input.value).toBe('Blue');\n});"
      },
      {
        "language": "text",
        "code": "content_copy\n      \n      it('should update the favorite color in the component', fakeAsync(() => {\n  const input = fixture.nativeElement.querySelector('input');\n  const event = createNewEvent('input');\n\n  input.value = 'Red';\n  input.dispatchEvent(event);\n\n  fixture.detectChanges();\n\n  expect(component.favoriteColor).toEqual('Red');\n}));"
      },
      {
        "language": "text",
        "code": "it('should update the favorite color in the component', fakeAsync(() => {\n  const input = fixture.nativeElement.querySelector('input');\n  const event = createNewEvent('input');\n\n  input.value = 'Red';\n  input.dispatchEvent(event);\n\n  fixture.detectChanges();\n\n  expect(component.favoriteColor).toEqual('Red');\n}));"
      },
      {
        "language": "text",
        "code": "favoriteColor"
      },
      {
        "language": "text",
        "code": "content_copy\n      \n      it('should update the favorite color on the input field', fakeAsync(() => {\n  component.favoriteColor = 'Blue';\n\n  fixture.detectChanges();\n\n  tick();\n\n  const input = fixture.nativeElement.querySelector('input');\n\n  expect(input.value).toBe('Blue');\n}));"
      },
      {
        "language": "text",
        "code": "it('should update the favorite color on the input field', fakeAsync(() => {\n  component.favoriteColor = 'Blue';\n\n  fixture.detectChanges();\n\n  tick();\n\n  const input = fixture.nativeElement.querySelector('input');\n\n  expect(input.value).toBe('Blue');\n}));"
      },
      {
        "language": "text",
        "code": "favoriteColor"
      },
      {
        "language": "text",
        "code": "fakeAsync()"
      },
      {
        "language": "text",
        "code": "favoriteColor"
      }
    ],
    "links": [
      {
        "text": "link",
        "href": "guide/forms-overview#introduction-to-forms-in-angular"
      },
      {
        "text": "Prerequisites",
        "href": "guide/forms-overview#prerequisites"
      },
      {
        "text": "Choosing an approach",
        "href": "guide/forms-overview#choosing-an-approach"
      },
      {
        "text": "Key differences",
        "href": "guide/forms-overview#key-differences"
      },
      {
        "text": "Scalability",
        "href": "guide/forms-overview#scalability"
      },
      {
        "text": "Setting up the form model",
        "href": "guide/forms-overview#setting-up-the-form-model"
      },
      {
        "text": "Common form foundation classes",
        "href": "guide/forms-overview#common-form-foundation-classes"
      },
      {
        "text": "Setup in reactive forms",
        "href": "guide/forms-overview#setup-in-reactive-forms"
      },
      {
        "text": "Setup in template-driven forms",
        "href": "guide/forms-overview#setup-in-template-driven-forms"
      },
      {
        "text": "Data flow in forms",
        "href": "guide/forms-overview#data-flow-in-forms"
      },
      {
        "text": "Data flow in reactive forms",
        "href": "guide/forms-overview#data-flow-in-reactive-forms"
      },
      {
        "text": "Data flow in template-driven forms",
        "href": "guide/forms-overview#data-flow-in-template-driven-forms"
      },
      {
        "text": "Mutability of the data model",
        "href": "guide/forms-overview#mutability-of-the-data-model"
      },
      {
        "text": "Form validation",
        "href": "guide/forms-overview#form-validation"
      },
      {
        "text": "Testing",
        "href": "guide/forms-overview#testing"
      },
      {
        "text": "Testing reactive forms",
        "href": "guide/forms-overview#testing-reactive-forms"
      },
      {
        "text": "Testing template-driven forms",
        "href": "guide/forms-overview#testing-template-driven-forms"
      },
      {
        "text": "Next steps",
        "href": "guide/forms-overview#next-steps"
      },
      {
        "text": "link",
        "href": "guide/forms-overview#prerequisites"
      },
      {
        "text": "TypeScript",
        "href": "https://www.typescriptlang.org/"
      },
      {
        "text": "Angular Concepts",
        "href": "guide/architecture"
      },
      {
        "text": "Angular template syntax",
        "href": "guide/architecture-components#template-syntax"
      },
      {
        "text": "link",
        "href": "guide/forms-overview#choosing-an-approach"
      },
      {
        "text": "link",
        "href": "guide/forms-overview#key-differences"
      },
      {
        "text": "Setup of form model",
        "href": "guide/forms-overview#setup"
      },
      {
        "text": "Data model",
        "href": "guide/forms-overview#mutability-of-the-data-model"
      },
      {
        "text": "Data flow",
        "href": "guide/forms-overview#data-flow-in-forms"
      },
      {
        "text": "Form validation",
        "href": "guide/forms-overview#validation"
      },
      {
        "text": "link",
        "href": "guide/forms-overview#scalability"
      },
      {
        "text": "synchronous data flow",
        "href": "guide/forms-overview#data-flow-in-reactive-forms"
      },
      {
        "text": "asynchronous data flow",
        "href": "guide/forms-overview#data-flow-in-template-driven-forms"
      },
      {
        "text": "link",
        "href": "guide/forms-overview#setting-up-the-form-model"
      },
      {
        "text": "link",
        "href": "guide/forms-overview#common-form-foundation-classes"
      },
      {
        "text": "FormControl",
        "href": "api/forms/FormControl"
      },
      {
        "text": "FormGroup",
        "href": "api/forms/FormGroup"
      },
      {
        "text": "FormArray",
        "href": "api/forms/FormArray"
      },
      {
        "text": "ControlValueAccessor",
        "href": "api/forms/ControlValueAccessor"
      },
      {
        "text": "FormControl",
        "href": "api/forms/FormControl"
      },
      {
        "text": "link",
        "href": "guide/forms-overview#setup-in-reactive-forms"
      },
      {
        "text": "FormControl",
        "href": "api/forms/FormControl"
      },
      {
        "text": "FormControl",
        "href": "api/forms/FormControl"
      },
      {
        "text": "Component",
        "href": "api/core/Component"
      },
      {
        "text": "FormControl",
        "href": "api/forms/FormControl"
      },
      {
        "text": "ReactiveFormsModule",
        "href": "api/forms/ReactiveFormsModule"
      },
      {
        "text": "Component",
        "href": "api/core/Component"
      },
      {
        "text": "ReactiveFormsModule",
        "href": "api/forms/ReactiveFormsModule"
      },
      {
        "text": "FormControl",
        "href": "api/forms/FormControl"
      },
      {
        "text": "link",
        "href": "guide/forms-overview#setup-in-template-driven-forms"
      },
      {
        "text": "NgModel",
        "href": "api/forms/NgModel"
      },
      {
        "text": "FormControl",
        "href": "api/forms/FormControl"
      },
      {
        "text": "Component",
        "href": "api/core/Component"
      },
      {
        "text": "FormsModule",
        "href": "api/forms/FormsModule"
      },
      {
        "text": "Component",
        "href": "api/core/Component"
      },
      {
        "text": "ngModel",
        "href": "api/forms/NgModel"
      },
      {
        "text": "FormsModule",
        "href": "api/forms/FormsModule"
      },
      {
        "text": "FormControl",
        "href": "api/forms/FormControl"
      },
      {
        "text": "link",
        "href": "guide/forms-overview#data-flow-in-forms"
      },
      {
        "text": "link",
        "href": "guide/forms-overview#data-flow-in-reactive-forms"
      },
      {
        "text": "FormControl",
        "href": "api/forms/FormControl"
      },
      {
        "text": "FormControl",
        "href": "api/forms/FormControl"
      },
      {
        "text": "FormControl",
        "href": "api/forms/FormControl"
      },
      {
        "text": "FormControl",
        "href": "api/forms/FormControl"
      },
      {
        "text": "FormControl",
        "href": "api/forms/FormControl"
      },
      {
        "text": "link",
        "href": "guide/forms-overview#data-flow-in-template-driven-forms"
      },
      {
        "text": "FormControl",
        "href": "api/forms/FormControl"
      },
      {
        "text": "FormControl",
        "href": "api/forms/FormControl"
      },
      {
        "text": "NgModel.viewToModelUpdate()",
        "href": "api/forms/NgModel#viewToModelUpdate"
      },
      {
        "text": "NgModel",
        "href": "api/forms/NgModel"
      },
      {
        "text": "FormControl",
        "href": "api/forms/FormControl"
      },
      {
        "text": "FormControl",
        "href": "api/forms/FormControl"
      },
      {
        "text": "FormControl",
        "href": "api/forms/FormControl"
      },
      {
        "text": "link",
        "href": "guide/forms-overview#mutability-of-the-data-model"
      },
      {
        "text": "FormControl",
        "href": "api/forms/FormControl"
      },
      {
        "text": "FormControl",
        "href": "api/forms/FormControl"
      },
      {
        "text": "link",
        "href": "guide/forms-overview#form-validation"
      },
      {
        "text": "Form Validation",
        "href": "guide/form-validation"
      },
      {
        "text": "link",
        "href": "guide/forms-overview#testing"
      },
      {
        "text": "link",
        "href": "guide/forms-overview#testing-reactive-forms"
      },
      {
        "text": "FormControl",
        "href": "api/forms/FormControl"
      },
      {
        "text": "link",
        "href": "guide/forms-overview#testing-template-driven-forms"
      },
      {
        "text": "fakeAsync",
        "href": "api/core/testing/fakeAsync"
      },
      {
        "text": "fakeAsync",
        "href": "api/core/testing/fakeAsync"
      },
      {
        "text": "tick",
        "href": "api/core/testing/tick"
      },
      {
        "text": "tick",
        "href": "api/core/testing/tick"
      },
      {
        "text": "fakeAsync",
        "href": "api/core/testing/fakeAsync"
      },
      {
        "text": "link",
        "href": "guide/forms-overview#next-steps"
      },
      {
        "text": "Reactive forms",
        "href": "guide/reactive-forms"
      },
      {
        "text": "Form validation",
        "href": "guide/form-validation#reactive-form-validation"
      },
      {
        "text": "Dynamic forms",
        "href": "guide/dynamic-form"
      },
      {
        "text": "Building a template-driven form",
        "href": "guide/forms"
      },
      {
        "text": "Form validation",
        "href": "guide/form-validation#template-driven-validation"
      },
      {
        "text": "NgForm",
        "href": "api/forms/NgForm"
      }
    ],
    "meta": {
      "description": "",
      "keywords": ""
    },
    "summary": "Introduction to forms in Angularlink Contents PrerequisitesChoosing an approachKey differencesScalabilitySetting up the form modelCommon form foundation classesSetup in reactive formsSetup in template...",
    "tags": [
      "react",
      "vue",
      "angular",
      "javascript",
      "typescript",
      "html",
      "node",
      "vite",
      "formslink",
      "data"
    ],
    "id": "angular-formsoverview-part-1",
    "quality": 90
  },
  {
    "title": "Angular",
    "url": "https://v17.angular.io/guide/reactive-forms",
    "category": "angular",
    "content": "Reactive formslink Contents PrerequisitesOverview of reactive formsAdding a basic form controlDisplaying a form control valueReplacing a form control valueGrouping form controlsCreating nested form groupsUpdating parts of the data modelUsing the FormBuilder service to generate controlsValidating form inputCreating dynamic formsReactive forms API summary Reactive forms provide a model-driven approach to handling form inputs whose values change over time. This guide shows you how to create and update a basic form control, progress to using multiple controls in a group, validate form values, and create dynamic forms where you can add or remove controls at run time. Try this Reactive Forms live-exampleReactive Forms live-example / download example. Prerequisiteslink Before going further into reactive forms, you should have a basic understanding of the following: TypeScript programming Angular application-design fundamentals, as described in Angular Concepts The form-design concepts that are presented in Introduction to Forms Overview of reactive formslink Reactive forms use an explicit and immutable approach to managing the state of a form at a given point in time. Each change to the form state returns a new state, which maintains the integrity of the model between changes. Reactive forms are built around observable streams, where form inputs and values are provided as streams of input values, which can be accessed synchronously. Reactive forms also provide a straightforward path to testing because you are assured that your data is consistent and predictable when requested. Any consumers of the streams have access to manipulate that data safely. Reactive forms differ from template-driven forms in distinct ways. Reactive forms provide synchronous access to the data model, immutability with observable operators, and change tracking through observable streams. Template-driven forms let direct access modify data in your template, but are less explicit than reactive forms because they rely on directives embedded in the template, along with mutable data to track changes asynchronously. See the Forms Overview for detailed comparisons between the two paradigms. Adding a basic form controllink There are three steps to using form controls. Generate a new component to import the reactive forms module and instantiate a new FormControl. Register the FormControl in the template. You can then display the form by adding the component to the template. The following examples show how to add a single form control. In the example, the user enters their name into an input field, captures that input value, and displays the current value of the form control element. Action Details Generate a new FormControl Use the CLI command ng generate to generate a component in your project to register and host the FormControl and ReactiveFormsModule. content_copy import { Component } from '@angular/core'; import { FormControl, ReactiveFormsModule } from '@angular/forms'; @Component({ standalone: true, selector: 'app-name-editor', templateUrl: './name-editor.component.html', styleUrls: ['./name-editor.component.css'], imports: [ReactiveFormsModule], }) export class NameEditorComponent { name = new FormControl(''); } Use the constructor of FormControl to set its initial value, which in this case is an empty string. By creating these controls in your component class, you get immediate access to listen for, update, and validate the state of the form input. Register the control in the template After you create the control in the component class, you must associate it with a form control element in the template. Update the template with the form control using the formControl binding provided by FormControlDirective, which is also included in the ReactiveFormsModule. content_copy label for=\"name\"Name: /label input id=\"name\" type=\"text\" [formControl]=\"name\" For a summary of the classes and directives provided by ReactiveFormsModule, see the following Reactive forms API section For complete syntax details of these classes and directives, see the API reference documentation for the Forms package Using the template binding syntax, the form control is now registered to the name input element in the template. The form control and DOM element communicate with each other: the view reflects changes in the model, and the model reflects changes in the view. Display the component The FormControl assigned to the name property is displayed when the property's host component is added to a template. content_copy app-name-editor/app-name-editor Displaying a form control valuelink You can display the value in the following ways. Through the valueChanges observable where you can listen for changes in the form's value in the template using AsyncPipe or in the component class using the subscribe() method With the value property, which gives you a snapshot of the current value The following example shows you how to display the current value using interpolation in the template. content_copy pValue: {{ name.value }}/p The displayed value changes as you update the form control element. Reactive forms provide access to information about a given control through properties and methods provided with each instance. These properties and methods of the underlying AbstractControl class are used to control form state and determine when to display messages when handling input validation. Read about other FormControl properties and methods in the API Reference. Replacing a form control valuelink Reactive forms have methods to change a control's value programmatically, which gives you the flexibility to update the value without user interaction. A form control instance provides a setValue() method that updates the value of the form control and validates the structure of the value provided against the control's structure. For example, when retrieving form data from a backend API or service, use the setValue() method to update the control to its new value, replacing the old value entirely. The following example adds a method to the component class to update the value of the control to Nancy using the setValue() method. content_copy updateName() { this.name.setValue('Nancy'); } Update the template with a button to simulate a name update. When you click the Update Name button, the value entered in the form control element is reflected as its current value. content_copy button type=\"button\" (click)=\"updateName()\"Update Name/button The form model is the source of truth for the control, so when you click the button, the value of the input is changed within the component class, overriding its current value. NOTE: In this example, you're using a single control. When using the setValue() method with a form group or form array instance, the value needs to match the structure of the group or array. Grouping form controlslink Forms typically contain several related controls. Reactive forms provide two ways of grouping multiple related controls into a single input form. Form groups Details Form group Defines a form with a fixed set of controls that you can manage together. Form group basics are discussed in this section. You can also nest form groups to create more complex forms. Form array Defines a dynamic form, where you can add and remove controls at run time. You can also nest form arrays to create more complex forms. For more about this option, see Creating dynamic forms. Just as a form control instance gives you control over a single input field, a form group instance tracks the form state of a group of form control instances (for example, a form). Each control in a form group instance is tracked by name when creating the form group. The following example shows how to manage multiple form control instances in a single group. Generate a ProfileEditor component and import the FormGroup and FormControl classes from the @angular/forms package. content_copy ng generate component ProfileEditor content_copy import { FormGroup, FormControl } from '@angular/forms'; To add a form group to this component, take the following steps. Create a FormGroup instance. Associate the FormGroup model and view. Save the form data. Action Details Create a FormGroup instance Create a property in the component class named profileForm and set the property to a new form group instance. To initialize the form group, provide the constructor with an object of named keys mapped to their control. For the profile form, add two form control instances with the names firstName and lastName. content_copy import { Component } from '@angular/core'; import { FormGroup, FormControl } from '@angular/forms'; @Component({ standalone: true, selector: 'app-profile-editor', templateUrl: './profile-editor.component.html', styleUrls: ['./profile-editor.component.css'], }) export class ProfileEditorComponent { profileForm = new FormGroup({ firstName: new FormControl(''), lastName: new FormControl(''), }); } The individual form controls are now collected within a group. A FormGroup instance provides its model value as an object reduced from the values of each control in the group. A form group instance has the same properties (such as value and untouched) and methods (such as setValue()) as a form control instance. Associate the FormGroup model and view A form group tracks the status and changes for each of its controls, so if one of the controls changes, the parent control also emits a new status or value change. The model for the group is maintained from its members. After you define the model, you must update the template to reflect the model in the view. content_copy form [formGroup]=\"profileForm\" label for=\"first-name\"First Name: /label input id=\"first-name\" type=\"text\" formControlName=\"firstName\" label for=\"last-name\"Last Name: /label input id=\"last-name\" type=\"text\" formControlName=\"lastName\" /form NOTE: Just as a form group contains a group of controls, the profileForm FormGroup is bound to the form element with the FormGroup directive, creating a communication layer between the model and the form containing the inputs. The formControlName input provided by the FormControlName directive binds each individual input to the form control defined in FormGroup. The form controls communicate with their respective elements. They also communicate changes to the form group instance, which provides the source of truth for the model value. Save form data The ProfileEditor component accepts input from the user, but in a real scenario you want to capture the form value and make it available for further processing outside the component. The FormGroup directive listens for the submit event emitted by the form element and emits an ngSubmit event that you can bind to a callback function. Add an ngSubmit event listener to the form tag with the onSubmit() callback method. content_copy form [formGroup]=\"profileForm\" (ngSubmit)=\"onSubmit()\" The onSubmit() method in the ProfileEditor component captures the current value of profileForm. Use EventEmitter to keep the form encapsulated and to provide the form value outside the component. The following example uses console.warn to log a message to the browser console. content_copy onSubmit() { // TODO: Use EventEmitter with form value console.warn(this.profileForm.value); } The submit event is emitted by the form tag using the built-in DOM event. You trigger the event by clicking a button with submit type. This lets the user press the Enter key to submit the completed form. Use a button element to add a button to the bottom of the form to trigger the form submission. content_copy pComplete the form to enable button./p button type=\"submit\" [disabled]=\"!profileForm.valid\"Submit/button NOTE: The button in the preceding snippet also has a disabled binding attached to it to disable the button when profileForm is invalid. You aren't performing any validation yet, so the button is always enabled. Basic form validation is covered in the Validating form input section. Display the component To display the ProfileEditor component that contains the form, add it to a component template. content_copy app-profile-editor/app-profile-editor ProfileEditor lets you manage the form control instances for the firstName and lastName controls within the form group instance. Creating nested form groupslink Form groups can accept both individual form control instances and other form group instances as children. This makes composing complex form models easier to maintain and logically group together. When building complex forms, managing the different areas of information is easier in smaller sections. Using a nested form group instance lets you break large forms groups into smaller, more manageable ones. To make more complex forms, use the following steps. Create a nested group. Group the nested form in the template. Some types of information naturally fall into the same group. A name and address are typical examples of such nested groups, and are used in the following examples. Action Details Create a nested group To create a nested group in profileForm, add a nested address element to the form group instance. content_copy import { Component } from '@angular/core'; import { FormGroup, FormControl } from '@angular/forms'; @Component({ standalone: true, selector: 'app-profile-editor', templateUrl: './profile-editor.component.html', styleUrls: ['./profile-editor.component.css'], }) export class ProfileEditorComponent { profileForm = new FormGroup({ firstName: new FormControl(''), lastName: new FormControl(''), address: new FormGroup({ street: new FormControl(''), city: new FormControl(''), state: new FormControl(''), zip: new FormControl(''), }), }); } In this example, address group combines the current firstName and lastName controls with the new street, city, state, and zip controls. Even though the address element in the form group is a child of the overall profileForm element in the form group, the same rules apply with value and status changes. Changes in status and value from the nested form group propagate to the parent form group, maintaining consistency with the overall model. Group the nested form in the template After you update the model in the component class, update the template to connect the form group instance and its input elements. Add the address form group containing the street, city, state, and zip fields to the ProfileEditor template. content_copy div formGroupName=\"address\" h2Address/h2 label for=\"street\"Street: /label input id=\"street\" type=\"text\" formControlName=\"street\" label for=\"city\"City: /label input id=\"city\" type=\"text\" formControlName=\"city\" label for=\"state\"State: /label input id=\"state\" type=\"text\" formControlName=\"state\" label for=\"zip\"Zip Code: /label input id=\"zip\" type=\"text\" formControlName=\"zip\" /div The ProfileEditor form is displayed as one group, but the model is broken down further to represent the logical grouping areas. TIP: Display the value for the form group instance in the component template using the value property and JsonPipe. Updating parts of the data modellink When updating the value for a form group instance that contains multiple controls, you might only want to update parts of the model. This section covers how to update specific parts of a form control data model. There are two ways to update the model value: Methods Details setValue() Set a new value for an individual control. The setValue() method strictly adheres to the structure of the form group and replaces the entire value for the control. patchValue() Replace any properties defined in the object that have changed in the form model. The strict checks of the setValue() method help catch nesting errors in complex forms, while patchValue() fails silently on those errors. In ProfileEditorComponent, use the updateProfile method with the following example to update the first name and street address for the user. content_copy updateProfile() { this.profileForm.patchValue({ firstName: 'Nancy', address: { street: '123 Drew Street', }, }); } Simulate an update by adding a button to the template to update the user profile on demand. content_copy button type=\"button\" (click)=\"updateProfile()\"Update Profile/button When a user clicks the button, the profileForm model is updated with new values for firstName and street. Notice that street is provided in an object inside the address property. This is necessary because the patchValue() method applies the update against the model structure. PatchValue() only updates properties that the form model defines. Using the FormBuilder service to generate controlslink Creating form control instances manually can become repetitive when dealing with multiple forms. The FormBuilder service provides convenient methods for generating controls. Use the following steps to take advantage of this service. Import the FormBuilder class. Inject the FormBuilder service. Generate the form contents. The following examples show how to refactor the ProfileEditor component to use the form builder service to create form control and form group instances. Action Details Import the FormBuilder class Import the FormBuilder class from the @angular/forms package. content_copy import { FormBuilder } from '@angular/forms'; Inject the FormBuilder service The FormBuilder service is an injectable provider that is provided with the reactive forms module. Inject this dependency by adding it to the component constructor. content_copy constructor(private formBuilder: FormBuilder) {} Generate form controls The FormBuilder service has three methods: control(), group(), and array(). These are factory methods for generating instances in your component classes including form controls, form groups, and form arrays. Use the group method to create the profileForm controls. content_copy import { Component } from '@angular/core'; import { FormBuilder } from '@angular/forms'; @Component({ standalone: true, selector: 'app-profile-editor', templateUrl: './profile-editor.component.html', styleUrls: ['./profile-editor.component.css'], }) export class ProfileEditorComponent { profileForm = this.formBuilder.group({ firstName: [''], lastName: [''], address: this.formBuilder.group({ street: [''], city: [''], state: [''], zip: [''], }), }); constructor(private formBuilder: FormBuilder) {} } In the preceding example, you use the group() method with the same object to define the properties in the model. The value for each control name is an array containing the initial value as the first item in the array. TIP: You can define the control with just the initial value, but if your controls need sync or async validation, add sync and async validators as the second and third items in the array. Compare using the form builder to creating the instances manually. src/app/profile-editor/profile-editor.component.ts (instances)src/app/profile-editor/profile-editor.component.ts (form builder) content_copy profileForm = new FormGroup({ firstName: new FormControl(''), lastName: new FormControl(''), address: new FormGroup({ street: new FormControl(''), city: new FormControl(''), state: new FormControl(''), zip: new FormControl(''), }), }); Validating form inputlink Form validation is used to ensure that user input is complete and correct. This section covers adding a single validator to a form control and displaying the overall form status. Form validation is covered more extensively in the Form Validation guide. Use the following steps to add form validation. Import a validator function in your form component. Add the validator to the field in the form. Add logic to handle the validation status. The most common validation is making a field required. The following example shows how to add a required validation to the firstName control and display the result of validation. Action Details Import a validator function Reactive forms include a set of validator functions for common use cases. These functions receive a control to validate against and return an error object or a null value based on the validation check. Import the Validators class from the @angular/forms package. content_copy import { Validators } from '@angular/forms'; Make a field required In the ProfileEditor component, add the Validators.required static method as the second item in the array for the firstName control. content_copy profileForm = this.formBuilder.group({ firstName: ['', Validators.required], lastName: [''], address: this.formBuilder.group({ street: [''], city: [''], state: [''], zip: [''], }), }); Display form status When you add a required field to the form control, its initial status is invalid. This invalid status propagates to the parent form group element, making its status invalid. Access the current status of the form group instance through its status property. Display the current status of profileForm using interpolation. content_copy pForm Status: {{ profileForm.status }}/p The Submit button is disabled because profileForm is invalid due to the required firstName form control. After you fill out the firstName input, the form becomes valid and the Submit button is enabled. For more on form validation, visit the Form Validation guide. Creating dynamic formslink FormArray is an alternative to FormGroup for managing any number of unnamed controls. As with form group instances, you can dynamically insert and remove controls from form array instances, and the form array instance value and validation status is calculated from its child controls. However, you don't need to define a key for each control by name, so this is a great option if you don't know the number of child values in advance. To define a dynamic form, take the following steps. Import the FormArray class. Define a FormArray control. Access the FormArray control with a getter method. Display the form array in a template. The following example shows you how to manage an array of aliases in ProfileEditor. Action Details Import the FormArray class Import the FormArray class from @angular/forms to use for type information. The FormBuilder service is ready to create a FormArray instance. content_copy import { FormArray } from '@angular/forms'; Define a FormArray control You can initialize a form array with any number of controls, from zero to many, by defining them in an array. Add an aliases property to the form group instance for profileForm to define the form array. Use the FormBuilder.array() method to define the array, and the FormBuilder.control() method to populate the array with an initial control. content_copy profileForm = this.formBuilder.group({ firstName: ['', Validators.required], lastName: [''], address: this.formBuilder.group({ street: [''], city: [''], state: [''], zip: [''], }), aliases: this.formBuilder.array([this.formBuilder.control('')]), }); The aliases control in the form group instance is now populated with a single control until more controls are added dynamically. Access the FormArray control A getter provides access to the aliases in the form array instance compared to repeating the profileForm.get() method to get each instance. The form array instance represents an undefined number of controls in an array. It's convenient to access a control through a getter, and this approach is straightforward to repeat for additional controls. Use the getter syntax to create an aliases class property to retrieve the alias's form array control from the parent form group. content_copy get aliases() { return this.profileForm.get('aliases') as FormArray; } NOTE: Because the returned control is of the type AbstractControl, you need to provide an explicit type to access the method syntax for the form array instance. Define a method to dynamically insert an alias control into the alias's form array. The FormArray.push() method inserts the control as a new item in the array. content_copy addAlias() { this.aliases.push(this.formBuilder.control('')); } In the template, each control is displayed as a separate input field. Display the form array in the template To attach the aliases from your form model, you must add it to the template. Similar to the formGroupName input provided by FormGroupNameDirective, formArrayName binds communication from the form array instance to the template with FormArrayNameDirective. Add the following template HTML after the div closing the formGroupName element. content_copy div formArrayName=\"aliases\" h2Aliases/h2 button type=\"button\" (click)=\"addAlias()\"+ Add another alias/button div *ngFor=\"let alias of aliases.controls; let i=index\" !-- The repeated alias template -- label for=\"alias-{{ i }}\"Alias:/label input id=\"alias-{{ i }}\" type=\"text\" [formControlName]=\"i\" /div /div The *ngFor directive iterates over each form control instance provided by the aliases form array instance. Because form array elements are unnamed, you assign the index to the i variable and pass it to each control to bind it to the formControlName input. Each time a new alias instance is added, the new form array instance is provided its control based on the index. This lets you track each individual control when calculating the status and value of the root control. Add an alias Initially, the form contains one Alias field. To add another field, click the Add Alias button. You can also validate the array of aliases reported by the form model displayed by Form Value at the bottom of the template. NOTE: Instead of a form control instance for each alias, you can compose another form group instance with additional fields. The process of defining a control for each item is the same. Reactive forms API summarylink The following table lists the base classes and services used to create and manage reactive form controls. For complete syntax details, see the API reference documentation for the Forms package. Classeslink Class Details AbstractControl The abstract base class for the concrete form control classes FormControl, FormGroup, and FormArray. It provides their common behaviors and properties. FormControl Manages the value and validity status of an individual form control. It corresponds to an HTML form control such as input or select. FormGroup Manages the value and validity state of a group of AbstractControl instances. The group's properties include its child controls. The top-level form in your component is FormGroup. FormArray Manages the value and validity state of a numerically indexed array of AbstractControl instances. FormBuilder An injectable service that provides factory methods for creating control instances. FormRecord Tracks the value and validity state of a collection of FormControl instances, each of which has the same value type. Directiveslink Directive Details FormControlDirective Syncs a standalone FormControl instance to a form control element. FormControlName Syncs FormControl in an existing FormGroup instance to a form control element by name. FormGroupDirective Syncs an existing FormGroup instance to a DOM element. FormGroupName Syncs a nested FormGroup instance to a DOM element. FormArrayName Syncs a nested FormArray instance to a DOM element. Last reviewed on Fri Sep 08 2023",
    "headings": [
      {
        "level": 1,
        "text": "Reactive formslink",
        "id": "reactive-forms"
      },
      {
        "level": 2,
        "text": "Prerequisiteslink",
        "id": "prerequisites"
      },
      {
        "level": 2,
        "text": "Overview of reactive formslink",
        "id": "overview-of-reactive-forms"
      },
      {
        "level": 2,
        "text": "Adding a basic form controllink",
        "id": "adding-a-basic-form-control"
      },
      {
        "level": 2,
        "text": "Grouping form controlslink",
        "id": "grouping-form-controls"
      },
      {
        "level": 2,
        "text": "Using the FormBuilder service to generate controlslink",
        "id": "using-the-formbuilder-service-to-generate-controls"
      },
      {
        "level": 2,
        "text": "Validating form inputlink",
        "id": "validating-form-input"
      },
      {
        "level": 2,
        "text": "Creating dynamic formslink",
        "id": "creating-dynamic-forms"
      },
      {
        "level": 2,
        "text": "Reactive forms API summarylink",
        "id": "reactive-forms-api-summary"
      },
      {
        "level": 3,
        "text": "Displaying a form control valuelink",
        "id": "displaying-a-form-control-value"
      },
      {
        "level": 3,
        "text": "Replacing a form control valuelink",
        "id": "replacing-a-form-control-value"
      },
      {
        "level": 3,
        "text": "Creating nested form groupslink",
        "id": "creating-nested-form-groups"
      },
      {
        "level": 3,
        "text": "Updating parts of the data modellink",
        "id": "updating-parts-of-the-data-model"
      },
      {
        "level": 4,
        "text": "Classeslink",
        "id": "classes"
      },
      {
        "level": 4,
        "text": "Directiveslink",
        "id": "directives"
      }
    ],
    "codeBlocks": [
      {
        "language": "text",
        "code": "FormControl"
      },
      {
        "language": "text",
        "code": "FormControl"
      },
      {
        "language": "text",
        "code": "FormControl"
      },
      {
        "language": "text",
        "code": "ng generate"
      },
      {
        "language": "text",
        "code": "FormControl"
      },
      {
        "language": "text",
        "code": "ReactiveFormsModule"
      },
      {
        "language": "text",
        "code": "content_copy\n      \n      import { Component } from '@angular/core';\nimport { FormControl, ReactiveFormsModule } from '@angular/forms';\n\n@Component({\n  standalone: true,\n  selector: 'app-name-editor',\n  templateUrl: './name-editor.component.html',\n  styleUrls: ['./name-editor.component.css'],\n  imports: [ReactiveFormsModule],\n})\nexport class NameEditorComponent {\n  name = new FormControl('');\n}"
      },
      {
        "language": "text",
        "code": "import { Component } from '@angular/core';\nimport { FormControl, ReactiveFormsModule } from '@angular/forms';\n\n@Component({\n  standalone: true,\n  selector: 'app-name-editor',\n  templateUrl: './name-editor.component.html',\n  styleUrls: ['./name-editor.component.css'],\n  imports: [ReactiveFormsModule],\n})\nexport class NameEditorComponent {\n  name = new FormControl('');\n}"
      },
      {
        "language": "text",
        "code": "FormControl"
      },
      {
        "language": "text",
        "code": "formControl"
      },
      {
        "language": "text",
        "code": "FormControlDirective"
      },
      {
        "language": "text",
        "code": "ReactiveFormsModule"
      },
      {
        "language": "text",
        "code": "content_copy\n      \n      <label for=\"name\">Name: </label>\n<input id=\"name\" type=\"text\" [formControl]=\"name\">"
      },
      {
        "language": "text",
        "code": "<label for=\"name\">Name: </label>\n<input id=\"name\" type=\"text\" [formControl]=\"name\">"
      },
      {
        "language": "text",
        "code": "ReactiveFormsModule"
      },
      {
        "language": "text",
        "code": "FormControl"
      },
      {
        "language": "text",
        "code": "content_copy\n      \n      <app-name-editor></app-name-editor>"
      },
      {
        "language": "text",
        "code": "<app-name-editor></app-name-editor>"
      },
      {
        "language": "text",
        "code": "valueChanges"
      },
      {
        "language": "text",
        "code": "subscribe()"
      },
      {
        "language": "text",
        "code": "content_copy\n      \n      <p>Value: {{ name.value }}</p>"
      },
      {
        "language": "text",
        "code": "<p>Value: {{ name.value }}</p>"
      },
      {
        "language": "text",
        "code": "FormControl"
      },
      {
        "language": "text",
        "code": "content_copy\n      \n      updateName() {\n  this.name.setValue('Nancy');\n}"
      },
      {
        "language": "text",
        "code": "updateName() {\n  this.name.setValue('Nancy');\n}"
      },
      {
        "language": "text",
        "code": "content_copy\n      \n      <button type=\"button\" (click)=\"updateName()\">Update Name</button>"
      },
      {
        "language": "text",
        "code": "<button type=\"button\" (click)=\"updateName()\">Update Name</button>"
      },
      {
        "language": "text",
        "code": "ProfileEditor"
      },
      {
        "language": "text",
        "code": "FormControl"
      },
      {
        "language": "text",
        "code": "@angular/forms"
      },
      {
        "language": "text",
        "code": "content_copy\n      \n      ng generate component ProfileEditor"
      },
      {
        "language": "text",
        "code": "ng generate component ProfileEditor"
      },
      {
        "language": "text",
        "code": "content_copy\n      \n      import { FormGroup, FormControl } from '@angular/forms';"
      },
      {
        "language": "text",
        "code": "import { FormGroup, FormControl } from '@angular/forms';"
      },
      {
        "language": "text",
        "code": "profileForm"
      },
      {
        "language": "text",
        "code": "content_copy\n      \n      import { Component } from '@angular/core';\nimport { FormGroup, FormControl } from '@angular/forms';\n\n@Component({\n  standalone: true,\n  selector: 'app-profile-editor',\n  templateUrl: './profile-editor.component.html',\n  styleUrls: ['./profile-editor.component.css'],\n})\nexport class ProfileEditorComponent {\n  profileForm = new FormGroup({\n    firstName: new FormControl(''),\n    lastName: new FormControl(''),\n  });\n}"
      },
      {
        "language": "text",
        "code": "import { Component } from '@angular/core';\nimport { FormGroup, FormControl } from '@angular/forms';\n\n@Component({\n  standalone: true,\n  selector: 'app-profile-editor',\n  templateUrl: './profile-editor.component.html',\n  styleUrls: ['./profile-editor.component.css'],\n})\nexport class ProfileEditorComponent {\n  profileForm = new FormGroup({\n    firstName: new FormControl(''),\n    lastName: new FormControl(''),\n  });\n}"
      },
      {
        "language": "text",
        "code": "content_copy\n      \n      <form [formGroup]=\"profileForm\">\n\n  <label for=\"first-name\">First Name: </label>\n  <input id=\"first-name\" type=\"text\" formControlName=\"firstName\">\n\n  <label for=\"last-name\">Last Name: </label>\n  <input id=\"last-name\" type=\"text\" formControlName=\"lastName\">\n\n</form>"
      },
      {
        "language": "text",
        "code": "<form [formGroup]=\"profileForm\">\n\n  <label for=\"first-name\">First Name: </label>\n  <input id=\"first-name\" type=\"text\" formControlName=\"firstName\">\n\n  <label for=\"last-name\">Last Name: </label>\n  <input id=\"last-name\" type=\"text\" formControlName=\"lastName\">\n\n</form>"
      },
      {
        "language": "text",
        "code": "formControlName"
      },
      {
        "language": "text",
        "code": "FormControlName"
      },
      {
        "language": "text",
        "code": "ProfileEditor"
      },
      {
        "language": "text",
        "code": "content_copy\n      \n      <form [formGroup]=\"profileForm\" (ngSubmit)=\"onSubmit()\">"
      },
      {
        "language": "text",
        "code": "<form [formGroup]=\"profileForm\" (ngSubmit)=\"onSubmit()\">"
      },
      {
        "language": "text",
        "code": "ProfileEditor"
      },
      {
        "language": "text",
        "code": "profileForm"
      },
      {
        "language": "text",
        "code": "EventEmitter"
      },
      {
        "language": "text",
        "code": "console.warn"
      },
      {
        "language": "text",
        "code": "content_copy\n      \n      onSubmit() {\n  // TODO: Use EventEmitter with form value\n  console.warn(this.profileForm.value);\n}"
      },
      {
        "language": "text",
        "code": "onSubmit() {\n  // TODO: Use EventEmitter with form value\n  console.warn(this.profileForm.value);\n}"
      },
      {
        "language": "text",
        "code": "content_copy\n      \n      <p>Complete the form to enable button.</p>\n<button type=\"submit\" [disabled]=\"!profileForm.valid\">Submit</button>"
      },
      {
        "language": "text",
        "code": "<p>Complete the form to enable button.</p>\n<button type=\"submit\" [disabled]=\"!profileForm.valid\">Submit</button>"
      },
      {
        "language": "text",
        "code": "profileForm"
      },
      {
        "language": "text",
        "code": "ProfileEditor"
      },
      {
        "language": "text",
        "code": "content_copy\n      \n      <app-profile-editor></app-profile-editor>"
      },
      {
        "language": "text",
        "code": "<app-profile-editor></app-profile-editor>"
      },
      {
        "language": "text",
        "code": "ProfileEditor"
      },
      {
        "language": "text",
        "code": "profileForm"
      },
      {
        "language": "text",
        "code": "content_copy\n      \n      import { Component } from '@angular/core';\nimport { FormGroup, FormControl } from '@angular/forms';\n\n@Component({\n  standalone: true,\n  selector: 'app-profile-editor',\n  templateUrl: './profile-editor.component.html',\n  styleUrls: ['./profile-editor.component.css'],\n})\nexport class ProfileEditorComponent {\n  profileForm = new FormGroup({\n    firstName: new FormControl(''),\n    lastName: new FormControl(''),\n    address: new FormGroup({\n      street: new FormControl(''),\n      city: new FormControl(''),\n      state: new FormControl(''),\n      zip: new FormControl(''),\n    }),\n  });\n}"
      },
      {
        "language": "text",
        "code": "import { Component } from '@angular/core';\nimport { FormGroup, FormControl } from '@angular/forms';\n\n@Component({\n  standalone: true,\n  selector: 'app-profile-editor',\n  templateUrl: './profile-editor.component.html',\n  styleUrls: ['./profile-editor.component.css'],\n})\nexport class ProfileEditorComponent {\n  profileForm = new FormGroup({\n    firstName: new FormControl(''),\n    lastName: new FormControl(''),\n    address: new FormGroup({\n      street: new FormControl(''),\n      city: new FormControl(''),\n      state: new FormControl(''),\n      zip: new FormControl(''),\n    }),\n  });\n}"
      },
      {
        "language": "text",
        "code": "address group"
      },
      {
        "language": "text",
        "code": "profileForm"
      },
      {
        "language": "text",
        "code": "ProfileEditor"
      },
      {
        "language": "text",
        "code": "content_copy\n      \n      <div formGroupName=\"address\">\n  <h2>Address</h2>\n\n  <label for=\"street\">Street: </label>\n  <input id=\"street\" type=\"text\" formControlName=\"street\">\n\n  <label for=\"city\">City: </label>\n  <input id=\"city\" type=\"text\" formControlName=\"city\">\n\n  <label for=\"state\">State: </label>\n  <input id=\"state\" type=\"text\" formControlName=\"state\">\n\n  <label for=\"zip\">Zip Code: </label>\n  <input id=\"zip\" type=\"text\" formControlName=\"zip\">\n</div>"
      },
      {
        "language": "text",
        "code": "<div formGroupName=\"address\">\n  <h2>Address</h2>\n\n  <label for=\"street\">Street: </label>\n  <input id=\"street\" type=\"text\" formControlName=\"street\">\n\n  <label for=\"city\">City: </label>\n  <input id=\"city\" type=\"text\" formControlName=\"city\">\n\n  <label for=\"state\">State: </label>\n  <input id=\"state\" type=\"text\" formControlName=\"state\">\n\n  <label for=\"zip\">Zip Code: </label>\n  <input id=\"zip\" type=\"text\" formControlName=\"zip\">\n</div>"
      },
      {
        "language": "text",
        "code": "ProfileEditor"
      },
      {
        "language": "text",
        "code": "patchValue()"
      },
      {
        "language": "text",
        "code": "patchValue()"
      },
      {
        "language": "text",
        "code": "ProfileEditorComponent"
      },
      {
        "language": "text",
        "code": "updateProfile"
      },
      {
        "language": "text",
        "code": "content_copy\n      \n      updateProfile() {\n  this.profileForm.patchValue({\n    firstName: 'Nancy',\n    address: {\n      street: '123 Drew Street',\n    },\n  });\n}"
      },
      {
        "language": "text",
        "code": "updateProfile() {\n  this.profileForm.patchValue({\n    firstName: 'Nancy',\n    address: {\n      street: '123 Drew Street',\n    },\n  });\n}"
      },
      {
        "language": "text",
        "code": "content_copy\n      \n      <button type=\"button\" (click)=\"updateProfile()\">Update Profile</button>"
      },
      {
        "language": "text",
        "code": "<button type=\"button\" (click)=\"updateProfile()\">Update Profile</button>"
      },
      {
        "language": "text",
        "code": "profileForm"
      },
      {
        "language": "text",
        "code": "patchValue()"
      },
      {
        "language": "text",
        "code": "PatchValue()"
      },
      {
        "language": "text",
        "code": "FormBuilder"
      },
      {
        "language": "text",
        "code": "FormBuilder"
      },
      {
        "language": "text",
        "code": "FormBuilder"
      },
      {
        "language": "text",
        "code": "ProfileEditor"
      },
      {
        "language": "text",
        "code": "FormBuilder"
      },
      {
        "language": "text",
        "code": "@angular/forms"
      },
      {
        "language": "text",
        "code": "content_copy\n      \n      import { FormBuilder } from '@angular/forms';"
      },
      {
        "language": "text",
        "code": "import { FormBuilder } from '@angular/forms';"
      },
      {
        "language": "text",
        "code": "FormBuilder"
      },
      {
        "language": "text",
        "code": "content_copy\n      \n      constructor(private formBuilder: FormBuilder) {}"
      },
      {
        "language": "text",
        "code": "constructor(private formBuilder: FormBuilder) {}"
      },
      {
        "language": "text",
        "code": "FormBuilder"
      },
      {
        "language": "text",
        "code": "profileForm"
      },
      {
        "language": "text",
        "code": "content_copy\n      \n      import { Component } from '@angular/core';\nimport { FormBuilder } from '@angular/forms';\n\n@Component({\n  standalone: true,\n  selector: 'app-profile-editor',\n  templateUrl: './profile-editor.component.html',\n  styleUrls: ['./profile-editor.component.css'],\n})\nexport class ProfileEditorComponent {\n  profileForm = this.formBuilder.group({\n    firstName: [''],\n    lastName: [''],\n    address: this.formBuilder.group({\n      street: [''],\n      city: [''],\n      state: [''],\n      zip: [''],\n    }),\n  });\n\n  constructor(private formBuilder: FormBuilder) {}\n}"
      },
      {
        "language": "text",
        "code": "import { Component } from '@angular/core';\nimport { FormBuilder } from '@angular/forms';\n\n@Component({\n  standalone: true,\n  selector: 'app-profile-editor',\n  templateUrl: './profile-editor.component.html',\n  styleUrls: ['./profile-editor.component.css'],\n})\nexport class ProfileEditorComponent {\n  profileForm = this.formBuilder.group({\n    firstName: [''],\n    lastName: [''],\n    address: this.formBuilder.group({\n      street: [''],\n      city: [''],\n      state: [''],\n      zip: [''],\n    }),\n  });\n\n  constructor(private formBuilder: FormBuilder) {}\n}"
      },
      {
        "language": "text",
        "code": "content_copy\n      \n      profileForm = new FormGroup({\n  firstName: new FormControl(''),\n  lastName: new FormControl(''),\n  address: new FormGroup({\n    street: new FormControl(''),\n    city: new FormControl(''),\n    state: new FormControl(''),\n    zip: new FormControl(''),\n  }),\n});"
      },
      {
        "language": "text",
        "code": "profileForm = new FormGroup({\n  firstName: new FormControl(''),\n  lastName: new FormControl(''),\n  address: new FormGroup({\n    street: new FormControl(''),\n    city: new FormControl(''),\n    state: new FormControl(''),\n    zip: new FormControl(''),\n  }),\n});"
      },
      {
        "language": "text",
        "code": "@angular/forms"
      },
      {
        "language": "text",
        "code": "content_copy\n      \n      import { Validators } from '@angular/forms';"
      },
      {
        "language": "text",
        "code": "import { Validators } from '@angular/forms';"
      },
      {
        "language": "text",
        "code": "ProfileEditor"
      },
      {
        "language": "text",
        "code": "Validators.required"
      },
      {
        "language": "text",
        "code": "content_copy\n      \n      profileForm = this.formBuilder.group({\n  firstName: ['', Validators.required],\n  lastName: [''],\n  address: this.formBuilder.group({\n    street: [''],\n    city: [''],\n    state: [''],\n    zip: [''],\n  }),\n});"
      },
      {
        "language": "text",
        "code": "profileForm = this.formBuilder.group({\n  firstName: ['', Validators.required],\n  lastName: [''],\n  address: this.formBuilder.group({\n    street: [''],\n    city: [''],\n    state: [''],\n    zip: [''],\n  }),\n});"
      },
      {
        "language": "text",
        "code": "profileForm"
      },
      {
        "language": "text",
        "code": "content_copy\n      \n      <p>Form Status: {{ profileForm.status }}</p>"
      },
      {
        "language": "text",
        "code": "<p>Form Status: {{ profileForm.status }}</p>"
      },
      {
        "language": "text",
        "code": "profileForm"
      },
      {
        "language": "text",
        "code": "ProfileEditor"
      },
      {
        "language": "text",
        "code": "@angular/forms"
      },
      {
        "language": "text",
        "code": "FormBuilder"
      },
      {
        "language": "text",
        "code": "content_copy\n      \n      import { FormArray } from '@angular/forms';"
      },
      {
        "language": "text",
        "code": "import { FormArray } from '@angular/forms';"
      },
      {
        "language": "text",
        "code": "profileForm"
      },
      {
        "language": "text",
        "code": "FormBuilder.array()"
      },
      {
        "language": "text",
        "code": "FormBuilder.control()"
      },
      {
        "language": "text",
        "code": "content_copy\n      \n      profileForm = this.formBuilder.group({\n  firstName: ['', Validators.required],\n  lastName: [''],\n  address: this.formBuilder.group({\n    street: [''],\n    city: [''],\n    state: [''],\n    zip: [''],\n  }),\n  aliases: this.formBuilder.array([this.formBuilder.control('')]),\n});"
      },
      {
        "language": "text",
        "code": "profileForm = this.formBuilder.group({\n  firstName: ['', Validators.required],\n  lastName: [''],\n  address: this.formBuilder.group({\n    street: [''],\n    city: [''],\n    state: [''],\n    zip: [''],\n  }),\n  aliases: this.formBuilder.array([this.formBuilder.control('')]),\n});"
      },
      {
        "language": "text",
        "code": "profileForm.get()"
      },
      {
        "language": "text",
        "code": "content_copy\n      \n      get aliases() {\n  return this.profileForm.get('aliases') as FormArray;\n}"
      },
      {
        "language": "text",
        "code": "get aliases() {\n  return this.profileForm.get('aliases') as FormArray;\n}"
      },
      {
        "language": "text",
        "code": "AbstractControl"
      },
      {
        "language": "text",
        "code": "FormArray.push()"
      },
      {
        "language": "text",
        "code": "content_copy\n      \n      addAlias() {\n  this.aliases.push(this.formBuilder.control(''));\n}"
      },
      {
        "language": "text",
        "code": "addAlias() {\n  this.aliases.push(this.formBuilder.control(''));\n}"
      },
      {
        "language": "text",
        "code": "formGroupName"
      },
      {
        "language": "text",
        "code": "FormGroupNameDirective"
      },
      {
        "language": "text",
        "code": "formArrayName"
      },
      {
        "language": "text",
        "code": "FormArrayNameDirective"
      },
      {
        "language": "text",
        "code": "formGroupName"
      },
      {
        "language": "text",
        "code": "content_copy\n      \n      <div formArrayName=\"aliases\">\n  <h2>Aliases</h2>\n  <button type=\"button\" (click)=\"addAlias()\">+ Add another alias</button>\n\n  <div *ngFor=\"let alias of aliases.controls; let i=index\">\n    <!-- The repeated alias template -->\n    <label for=\"alias-{{ i }}\">Alias:</label>\n    <input id=\"alias-{{ i }}\" type=\"text\" [formControlName]=\"i\">\n  </div>\n</div>"
      },
      {
        "language": "text",
        "code": "<div formArrayName=\"aliases\">\n  <h2>Aliases</h2>\n  <button type=\"button\" (click)=\"addAlias()\">+ Add another alias</button>\n\n  <div *ngFor=\"let alias of aliases.controls; let i=index\">\n    <!-- The repeated alias template -->\n    <label for=\"alias-{{ i }}\">Alias:</label>\n    <input id=\"alias-{{ i }}\" type=\"text\" [formControlName]=\"i\">\n  </div>\n</div>"
      },
      {
        "language": "text",
        "code": "formControlName"
      },
      {
        "language": "text",
        "code": "AbstractControl"
      },
      {
        "language": "text",
        "code": "FormControl"
      },
      {
        "language": "text",
        "code": "FormControl"
      },
      {
        "language": "text",
        "code": "AbstractControl"
      },
      {
        "language": "text",
        "code": "AbstractControl"
      },
      {
        "language": "text",
        "code": "FormBuilder"
      },
      {
        "language": "text",
        "code": "FormControl"
      },
      {
        "language": "text",
        "code": "FormControlDirective"
      },
      {
        "language": "text",
        "code": "FormControl"
      },
      {
        "language": "text",
        "code": "FormControlName"
      },
      {
        "language": "text",
        "code": "FormControl"
      },
      {
        "language": "text",
        "code": "FormGroupDirective"
      },
      {
        "language": "text",
        "code": "FormGroupName"
      },
      {
        "language": "text",
        "code": "FormArrayName"
      }
    ],
    "links": [
      {
        "text": "link",
        "href": "guide/reactive-forms#reactive-forms"
      },
      {
        "text": "Prerequisites",
        "href": "guide/reactive-forms#prerequisites"
      },
      {
        "text": "Overview of reactive forms",
        "href": "guide/reactive-forms#overview-of-reactive-forms"
      },
      {
        "text": "Adding a basic form control",
        "href": "guide/reactive-forms#adding-a-basic-form-control"
      },
      {
        "text": "Displaying a form control value",
        "href": "guide/reactive-forms#displaying-a-form-control-value"
      },
      {
        "text": "Replacing a form control value",
        "href": "guide/reactive-forms#replacing-a-form-control-value"
      },
      {
        "text": "Grouping form controls",
        "href": "guide/reactive-forms#grouping-form-controls"
      },
      {
        "text": "Creating nested form groups",
        "href": "guide/reactive-forms#creating-nested-form-groups"
      },
      {
        "text": "Updating parts of the data model",
        "href": "guide/reactive-forms#updating-parts-of-the-data-model"
      },
      {
        "text": "Using the FormBuilder service to generate controls",
        "href": "guide/reactive-forms#using-the-formbuilder-service-to-generate-controls"
      },
      {
        "text": "Validating form input",
        "href": "guide/reactive-forms#validating-form-input"
      },
      {
        "text": "Creating dynamic forms",
        "href": "guide/reactive-forms#creating-dynamic-forms"
      },
      {
        "text": "Reactive forms API summary",
        "href": "guide/reactive-forms#reactive-forms-api-summary"
      },
      {
        "text": "Reactive Forms live-example",
        "href": "generated/live-examples/reactive-forms/stackblitz.html"
      },
      {
        "text": "download example",
        "href": "generated/zips/reactive-forms/reactive-forms.zip"
      },
      {
        "text": "link",
        "href": "guide/reactive-forms#prerequisites"
      },
      {
        "text": "TypeScript",
        "href": "https://www.typescriptlang.org/"
      },
      {
        "text": "Angular Concepts",
        "href": "guide/architecture"
      },
      {
        "text": "Introduction to Forms",
        "href": "guide/forms-overview"
      },
      {
        "text": "link",
        "href": "guide/reactive-forms#overview-of-reactive-forms"
      },
      {
        "text": "observable",
        "href": "guide/glossary#observable"
      },
      {
        "text": "template-driven forms",
        "href": "guide/forms"
      },
      {
        "text": "Forms Overview",
        "href": "guide/forms-overview"
      },
      {
        "text": "link",
        "href": "guide/reactive-forms#adding-a-basic-form-control"
      },
      {
        "text": "FormControl",
        "href": "api/forms/FormControl"
      },
      {
        "text": "FormControl",
        "href": "api/forms/FormControl"
      },
      {
        "text": "FormControl",
        "href": "api/forms/FormControl"
      },
      {
        "text": "CLI command",
        "href": "cli/generate#component-command"
      },
      {
        "text": "FormControl",
        "href": "api/forms/FormControl"
      },
      {
        "text": "ReactiveFormsModule",
        "href": "api/forms/ReactiveFormsModule"
      },
      {
        "text": "Component",
        "href": "api/core/Component"
      },
      {
        "text": "FormControl",
        "href": "api/forms/FormControl"
      },
      {
        "text": "ReactiveFormsModule",
        "href": "api/forms/ReactiveFormsModule"
      },
      {
        "text": "Component",
        "href": "api/core/Component"
      },
      {
        "text": "ReactiveFormsModule",
        "href": "api/forms/ReactiveFormsModule"
      },
      {
        "text": "FormControl",
        "href": "api/forms/FormControl"
      },
      {
        "text": "FormControl",
        "href": "api/forms/FormControl"
      },
      {
        "text": "FormControlDirective",
        "href": "api/forms/FormControlDirective"
      },
      {
        "text": "ReactiveFormsModule",
        "href": "api/forms/ReactiveFormsModule"
      },
      {
        "text": "ReactiveFormsModule",
        "href": "api/forms/ReactiveFormsModule"
      },
      {
        "text": "Reactive forms API",
        "href": "guide/reactive-forms#reactive-forms-api"
      },
      {
        "text": "Forms package",
        "href": "api/forms"
      },
      {
        "text": "FormControl",
        "href": "api/forms/FormControl"
      },
      {
        "text": "link",
        "href": "guide/reactive-forms#displaying-a-form-control-value"
      },
      {
        "text": "AsyncPipe",
        "href": "api/common/AsyncPipe"
      },
      {
        "text": "AbstractControl",
        "href": "api/forms/AbstractControl"
      },
      {
        "text": "input validation",
        "href": "guide/reactive-forms#basic-form-validation"
      },
      {
        "text": "FormControl",
        "href": "api/forms/FormControl"
      },
      {
        "text": "API Reference",
        "href": "api/forms/FormControl"
      },
      {
        "text": "link",
        "href": "guide/reactive-forms#replacing-a-form-control-value"
      },
      {
        "text": "form group",
        "href": "guide/reactive-forms#grouping-form-controls"
      },
      {
        "text": "form array",
        "href": "guide/reactive-forms#creating-dynamic-forms"
      },
      {
        "text": "link",
        "href": "guide/reactive-forms#grouping-form-controls"
      },
      {
        "text": "nest form groups",
        "href": "guide/reactive-forms#nested-groups"
      },
      {
        "text": "Creating dynamic forms",
        "href": "guide/reactive-forms#dynamic-forms"
      },
      {
        "text": "FormGroup",
        "href": "api/forms/FormGroup"
      },
      {
        "text": "FormControl",
        "href": "api/forms/FormControl"
      },
      {
        "text": "FormGroup",
        "href": "api/forms/FormGroup"
      },
      {
        "text": "FormControl",
        "href": "api/forms/FormControl"
      },
      {
        "text": "FormGroup",
        "href": "api/forms/FormGroup"
      },
      {
        "text": "FormGroup",
        "href": "api/forms/FormGroup"
      },
      {
        "text": "FormGroup",
        "href": "api/forms/FormGroup"
      },
      {
        "text": "Component",
        "href": "api/core/Component"
      },
      {
        "text": "FormGroup",
        "href": "api/forms/FormGroup"
      },
      {
        "text": "FormControl",
        "href": "api/forms/FormControl"
      },
      {
        "text": "Component",
        "href": "api/core/Component"
      },
      {
        "text": "FormGroup",
        "href": "api/forms/FormGroup"
      },
      {
        "text": "FormControl",
        "href": "api/forms/FormControl"
      },
      {
        "text": "FormControl",
        "href": "api/forms/FormControl"
      },
      {
        "text": "FormGroup",
        "href": "api/forms/FormGroup"
      },
      {
        "text": "FormGroup",
        "href": "api/forms/FormGroup"
      },
      {
        "text": "formControlName",
        "href": "api/forms/FormControlName"
      },
      {
        "text": "formControlName",
        "href": "api/forms/FormControlName"
      },
      {
        "text": "FormGroup",
        "href": "api/forms/FormGroup"
      },
      {
        "text": "FormGroup",
        "href": "api/forms/FormGroup"
      },
      {
        "text": "formControlName",
        "href": "api/forms/FormControlName"
      },
      {
        "text": "FormControlName",
        "href": "api/forms/FormControlName"
      },
      {
        "text": "FormGroup",
        "href": "api/forms/FormGroup"
      },
      {
        "text": "FormGroup",
        "href": "api/forms/FormGroup"
      },
      {
        "text": "EventEmitter",
        "href": "api/core/EventEmitter"
      },
      {
        "text": "EventEmitter",
        "href": "api/core/EventEmitter"
      },
      {
        "text": "Validating form input",
        "href": "guide/reactive-forms#basic-form-validation"
      },
      {
        "text": "link",
        "href": "guide/reactive-forms#creating-nested-form-groups"
      },
      {
        "text": "Component",
        "href": "api/core/Component"
      },
      {
        "text": "FormGroup",
        "href": "api/forms/FormGroup"
      },
      {
        "text": "FormControl",
        "href": "api/forms/FormControl"
      },
      {
        "text": "Component",
        "href": "api/core/Component"
      },
      {
        "text": "FormGroup",
        "href": "api/forms/FormGroup"
      },
      {
        "text": "FormControl",
        "href": "api/forms/FormControl"
      },
      {
        "text": "FormControl",
        "href": "api/forms/FormControl"
      },
      {
        "text": "FormGroup",
        "href": "api/forms/FormGroup"
      },
      {
        "text": "FormControl",
        "href": "api/forms/FormControl"
      },
      {
        "text": "FormControl",
        "href": "api/forms/FormControl"
      },
      {
        "text": "FormControl",
        "href": "api/forms/FormControl"
      },
      {
        "text": "FormControl",
        "href": "api/forms/FormControl"
      },
      {
        "text": "formGroupName",
        "href": "api/forms/FormGroupName"
      },
      {
        "text": "formControlName",
        "href": "api/forms/FormControlName"
      },
      {
        "text": "formControlName",
        "href": "api/forms/FormControlName"
      },
      {
        "text": "formControlName",
        "href": "api/forms/FormControlName"
      },
      {
        "text": "formControlName",
        "href": "api/forms/FormControlName"
      },
      {
        "text": "JsonPipe",
        "href": "api/common/JsonPipe"
      },
      {
        "text": "link",
        "href": "guide/reactive-forms#updating-parts-of-the-data-model"
      },
      {
        "text": "link",
        "href": "guide/reactive-forms#using-the-formbuilder-service-to-generate-controls"
      },
      {
        "text": "FormBuilder",
        "href": "api/forms/FormBuilder"
      },
      {
        "text": "FormBuilder",
        "href": "api/forms/FormBuilder"
      },
      {
        "text": "FormBuilder",
        "href": "api/forms/FormBuilder"
      },
      {
        "text": "FormBuilder",
        "href": "api/forms/FormBuilder"
      },
      {
        "text": "FormBuilder",
        "href": "api/forms/FormBuilder"
      },
      {
        "text": "FormBuilder",
        "href": "api/forms/FormBuilder"
      },
      {
        "text": "FormBuilder",
        "href": "api/forms/FormBuilder"
      },
      {
        "text": "FormBuilder",
        "href": "api/forms/FormBuilder"
      },
      {
        "text": "Component",
        "href": "api/core/Component"
      },
      {
        "text": "FormBuilder",
        "href": "api/forms/FormBuilder"
      },
      {
        "text": "Component",
        "href": "api/core/Component"
      },
      {
        "text": "FormBuilder",
        "href": "api/forms/FormBuilder"
      },
      {
        "text": "FormGroup",
        "href": "api/forms/FormGroup"
      },
      {
        "text": "FormControl",
        "href": "api/forms/FormControl"
      },
      {
        "text": "FormControl",
        "href": "api/forms/FormControl"
      },
      {
        "text": "FormGroup",
        "href": "api/forms/FormGroup"
      },
      {
        "text": "FormControl",
        "href": "api/forms/FormControl"
      },
      {
        "text": "FormControl",
        "href": "api/forms/FormControl"
      },
      {
        "text": "FormControl",
        "href": "api/forms/FormControl"
      },
      {
        "text": "FormControl",
        "href": "api/forms/FormControl"
      },
      {
        "text": "link",
        "href": "guide/reactive-forms#validating-form-input"
      },
      {
        "text": "Form Validation",
        "href": "guide/form-validation"
      },
      {
        "text": "Validators",
        "href": "api/forms/Validators"
      },
      {
        "text": "Validators",
        "href": "api/forms/Validators"
      },
      {
        "text": "Form",
        "href": "api/forms/Form"
      },
      {
        "text": "Form Validation",
        "href": "guide/form-validation"
      },
      {
        "text": "link",
        "href": "guide/reactive-forms#creating-dynamic-forms"
      },
      {
        "text": "FormArray",
        "href": "api/forms/FormArray"
      },
      {
        "text": "FormGroup",
        "href": "api/forms/FormGroup"
      },
      {
        "text": "FormArray",
        "href": "api/forms/FormArray"
      },
      {
        "text": "FormArray",
        "href": "api/forms/FormArray"
      },
      {
        "text": "FormArray",
        "href": "api/forms/FormArray"
      },
      {
        "text": "FormArray",
        "href": "api/forms/FormArray"
      },
      {
        "text": "FormArray",
        "href": "api/forms/FormArray"
      },
      {
        "text": "FormBuilder",
        "href": "api/forms/FormBuilder"
      },
      {
        "text": "FormArray",
        "href": "api/forms/FormArray"
      },
      {
        "text": "FormArray",
        "href": "api/forms/FormArray"
      },
      {
        "text": "FormArray",
        "href": "api/forms/FormArray"
      },
      {
        "text": "FormBuilder.array()",
        "href": "api/forms/FormBuilder#array"
      },
      {
        "text": "FormBuilder.control()",
        "href": "api/forms/FormBuilder#control"
      },
      {
        "text": "FormArray",
        "href": "api/forms/FormArray"
      },
      {
        "text": "FormArray",
        "href": "api/forms/FormArray"
      },
      {
        "text": "AbstractControl",
        "href": "api/forms/AbstractControl"
      },
      {
        "text": "FormArray.push()",
        "href": "api/forms/FormArray#push"
      },
      {
        "text": "formGroupName",
        "href": "api/forms/FormGroupName"
      },
      {
        "text": "formArrayName",
        "href": "api/forms/FormArrayName"
      },
      {
        "text": "formGroupName",
        "href": "api/forms/FormGroupName"
      },
      {
        "text": "formArrayName",
        "href": "api/forms/FormArrayName"
      },
      {
        "text": "ngFor",
        "href": "api/common/NgFor"
      },
      {
        "text": "formControlName",
        "href": "api/forms/FormControlName"
      },
      {
        "text": "ngFor",
        "href": "api/common/NgFor"
      },
      {
        "text": "formControlName",
        "href": "api/forms/FormControlName"
      },
      {
        "text": "Form",
        "href": "api/forms/Form"
      },
      {
        "text": "link",
        "href": "guide/reactive-forms#reactive-forms-api-summary"
      },
      {
        "text": "Forms package",
        "href": "api/forms"
      },
      {
        "text": "link",
        "href": "guide/reactive-forms#classes"
      },
      {
        "text": "AbstractControl",
        "href": "api/forms/AbstractControl"
      },
      {
        "text": "FormControl",
        "href": "api/forms/FormControl"
      },
      {
        "text": "FormGroup",
        "href": "api/forms/FormGroup"
      },
      {
        "text": "FormArray",
        "href": "api/forms/FormArray"
      },
      {
        "text": "FormControl",
        "href": "api/forms/FormControl"
      },
      {
        "text": "FormGroup",
        "href": "api/forms/FormGroup"
      },
      {
        "text": "AbstractControl",
        "href": "api/forms/AbstractControl"
      },
      {
        "text": "FormGroup",
        "href": "api/forms/FormGroup"
      },
      {
        "text": "FormArray",
        "href": "api/forms/FormArray"
      },
      {
        "text": "AbstractControl",
        "href": "api/forms/AbstractControl"
      },
      {
        "text": "FormBuilder",
        "href": "api/forms/FormBuilder"
      },
      {
        "text": "FormRecord",
        "href": "api/forms/FormRecord"
      },
      {
        "text": "FormControl",
        "href": "api/forms/FormControl"
      },
      {
        "text": "link",
        "href": "guide/reactive-forms#directives"
      },
      {
        "text": "FormControlDirective",
        "href": "api/forms/FormControlDirective"
      },
      {
        "text": "FormControl",
        "href": "api/forms/FormControl"
      },
      {
        "text": "FormControlName",
        "href": "api/forms/FormControlName"
      },
      {
        "text": "FormControl",
        "href": "api/forms/FormControl"
      },
      {
        "text": "FormGroup",
        "href": "api/forms/FormGroup"
      },
      {
        "text": "FormGroupDirective",
        "href": "api/forms/FormGroupDirective"
      },
      {
        "text": "FormGroup",
        "href": "api/forms/FormGroup"
      },
      {
        "text": "FormGroupName",
        "href": "api/forms/FormGroupName"
      },
      {
        "text": "FormGroup",
        "href": "api/forms/FormGroup"
      },
      {
        "text": "FormArrayName",
        "href": "api/forms/FormArrayName"
      },
      {
        "text": "FormArray",
        "href": "api/forms/FormArray"
      }
    ],
    "meta": {
      "description": "",
      "keywords": ""
    },
    "summary": "Reactive formslink Contents PrerequisitesOverview of reactive formsAdding a basic form controlDisplaying a form control valueReplacing a form control valueGrouping form controlsCreating nested form gr...",
    "tags": [
      "react",
      "vue",
      "angular",
      "javascript",
      "typescript",
      "css",
      "html",
      "node",
      "vite",
      "form"
    ],
    "id": "angular-reactiveforms-part-1",
    "quality": 90
  },
  {
    "title": "Angular",
    "url": "https://v17.angular.io/guide/form-validation",
    "category": "angular",
    "content": "Validating form inputlink Contents PrerequisitesValidating input in template-driven formsValidating input in reactive formsValidator functionsBuilt-in validator functionsDefining custom validatorsAdding custom validators to reactive formsAdding custom validators to template-driven formsControl status CSS classesCross-field validationAdding cross-validation to reactive formsAdding cross-validation to template-driven formsCreating asynchronous validatorsImplementing a custom async validatorAdding async validators to reactive formsAdding async validators to template-driven formsOptimizing performance of async validatorsInteraction with native HTML form validation You can improve overall data quality by validating user input for accuracy and completeness. This page shows how to validate user input from the UI and display useful validation messages, in both reactive and template-driven forms. Prerequisiteslink Before reading about form validation, you should have a basic understanding of the following. TypeScript and HTML5 programming Fundamental concepts of Angular application design The two types of forms that Angular supports Basics of either Template-driven Forms or Reactive Forms Get the complete example code for the reactive and template-driven forms used here to illustrate form validation. Run the live example / download example. Validating input in template-driven formslink To add validation to a template-driven form, you add the same validation attributes as you would with native HTML form validation. Angular uses directives to match these attributes with validator functions in the framework. Every time the value of a form control changes, Angular runs validation and generates either a list of validation errors that results in an INVALID status, or null, which results in a VALID status. You can then inspect the control's state by exporting ngModel to a local template variable. The following example exports NgModel into a variable called name: content_copy input type=\"text\" id=\"name\" name=\"name\" class=\"form-control\" required minlength=\"4\" appForbiddenName=\"bob\" [(ngModel)]=\"hero.name\" #name=\"ngModel\" / div *ngIf=\"name.invalid && (name.dirty  name.touched)\" class=\"alert\"  div *ngIf=\"name.errors?.['required']\"Name is required./div div *ngIf=\"name.errors?.['minlength']\" Name must be at least 4 characters long. /div div *ngIf=\"name.errors?.['forbiddenName']\" Name cannot be Bob. /div /div Notice the following features illustrated by the example. The input element carries the HTML validation attributes: required and minlength. It also carries a custom validator directive, forbiddenName. For more information, see the Custom validators section. #name=\"ngModel\" exports NgModel into a local variable called name. NgModel mirrors many of the properties of its underlying FormControl instance, so you can use this in the template to check for control states such as valid and dirty. For a full list of control properties, see the AbstractControl API reference. The *ngIf on the div element reveals a set of nested message divs but only if the name is invalid and the control is either dirty or touched. Each nested div can present a custom message for one of the possible validation errors. There are messages for required, minlength, and forbiddenName. To prevent the validator from displaying errors before the user has a chance to edit the form, you should check for either the dirty or touched states in a control. When the user changes the value in the watched field, the control is marked as \"dirty\" When the user blurs the form control element, the control is marked as \"touched\" Validating input in reactive formslink In a reactive form, the source of truth is the component class. Instead of adding validators through attributes in the template, you add validator functions directly to the form control model in the component class. Angular then calls these functions whenever the value of the control changes. Validator functionslink Validator functions can be either synchronous or asynchronous. Validator type Details Sync validators Synchronous functions that take a control instance and immediately return either a set of validation errors or null. Pass these in as the second argument when you instantiate a FormControl. Async validators Asynchronous functions that take a control instance and return a Promise or Observable that later emits a set of validation errors or null. Pass these in as the third argument when you instantiate a FormControl. For performance reasons, Angular only runs async validators if all sync validators pass. Each must complete before errors are set. Built-in validator functionslink You can choose to write your own validator functions, or you can use some of Angular's built-in validators. The same built-in validators that are available as attributes in template-driven forms, such as required and minlength, are all available to use as functions from the Validators class. For a full list of built-in validators, see the Validators API reference. To update the hero form to be a reactive form, use some of the same built-in validators this time, in function form, as in the following example. content_copy ngOnInit(): void { this.heroForm = new FormGroup({ name: new FormControl(this.hero.name, [ Validators.required, Validators.minLength(4), forbiddenNameValidator(/bob/i), // -- Here's how you pass in the custom validator. ]), alterEgo: new FormControl(this.hero.alterEgo), power: new FormControl(this.hero.power, Validators.required), }); } get name() { return this.heroForm.get('name'); } get power() { return this.heroForm.get('power'); } In this example, the name control sets up two built-in validators Validators.required and Validators.minLength(4) and one custom validator, forbiddenNameValidator. (For more details see custom validators.) All of these validators are synchronous, so they are passed as the second argument. Notice that you can support multiple validators by passing the functions in as an array. This example also adds a few getter methods. In a reactive form, you can always access any form control through the get method on its parent group, but sometimes it's useful to define getters as shorthand for the template. If you look at the template for the name input again, it is fairly similar to the template-driven example. content_copy input type=\"text\" id=\"name\" class=\"form-control\" formControlName=\"name\" required / div *ngIf=\"name.invalid && (name.dirty  name.touched)\" class=\"alert alert-danger\"  div *ngIf=\"name.errors?.['required']\"Name is required./div div *ngIf=\"name.errors?.['minlength']\" Name must be at least 4 characters long. /div div *ngIf=\"name.errors?.['forbiddenName']\" Name cannot be Bob. /div /div This form differs from the template-driven version in that it no longer exports any directives. Instead, it uses the name getter defined in the component class. Notice that the required attribute is still present in the template. Although it's not necessary for validation, it should be retained for accessibility purposes. Defining custom validatorslink The built-in validators don't always match the exact use case of your application, so you sometimes need to create a custom validator. Consider the forbiddenNameValidator function from previous reactive-form examples. Here's what the definition of that function looks like. content_copy /** A hero's name can't match the given regular expression */ export function forbiddenNameValidator(nameRe: RegExp): ValidatorFn { return (control: AbstractControl): ValidationErrors  null = { const forbidden = nameRe.test(control.value); return forbidden ? { forbiddenName: { value: control.value } } : null; }; } The function is a factory that takes a regular expression to detect a specific forbidden name and returns a validator function. In this sample, the forbidden name is \"bob\", so the validator rejects any hero name containing \"bob\". Elsewhere it could reject \"alice\" or any name that the configuring regular expression matches. The forbiddenNameValidator factory returns the configured validator function. That function takes an Angular control object and returns either null if the control value is valid or a validation error object. The validation error object typically has a property whose name is the validation key, 'forbiddenName', and whose value is an arbitrary dictionary of values that you could insert into an error message, {name}. Custom async validators are similar to sync validators, but they must instead return a Promise or observable that later emits null or a validation error object. In the case of an observable, the observable must complete, at which point the form uses the last value emitted for validation. Adding custom validators to reactive formslink In reactive forms, add a custom validator by passing the function directly to the FormControl. content_copy this.heroForm = new FormGroup({ name: new FormControl(this.hero.name, [ Validators.required, Validators.minLength(4), forbiddenNameValidator(/bob/i), // -- Here's how you pass in the custom validator. ]), alterEgo: new FormControl(this.hero.alterEgo), power: new FormControl(this.hero.power, Validators.required), }); Adding custom validators to template-driven formslink In template-driven forms, add a directive to the template, where the directive wraps the validator function. For example, the corresponding ForbiddenValidatorDirective serves as a wrapper around the forbiddenNameValidator. Angular recognizes the directive's role in the validation process because the directive registers itself with the NG_VALIDATORS provider, as shown in the following example. NG_VALIDATORS is a predefined provider with an extensible collection of validators. content_copy providers: [ { provide: NG_VALIDATORS, useExisting: ForbiddenValidatorDirective, multi: true, }, ], The directive class then implements the Validator interface, so that it can easily integrate with Angular forms. Here is the rest of the directive to help you get an idea of how it all comes together. content_copy @Directive({ selector: '[appForbiddenName]', providers: [ { provide: NG_VALIDATORS, useExisting: ForbiddenValidatorDirective, multi: true, }, ], standalone: true, }) export class ForbiddenValidatorDirective implements Validator { @Input('appForbiddenName') forbiddenName = ''; validate(control: AbstractControl): ValidationErrors  null { return this.forbiddenName ? forbiddenNameValidator(new RegExp(this.forbiddenName, 'i'))(control) : null; } } Once the ForbiddenValidatorDirective is ready, you can add its selector, appForbiddenName, to any input element to activate it. For example: content_copy input type=\"text\" id=\"name\" name=\"name\" class=\"form-control\" required minlength=\"4\" appForbiddenName=\"bob\" [(ngModel)]=\"hero.name\" #name=\"ngModel\" / Notice that the custom validation directive is instantiated with useExisting rather than useClass. The registered validator must be this instance of the ForbiddenValidatorDirective the instance in the form with its forbiddenName property bound to \"bob\". If you were to replace useExisting with useClass, then you'd be registering a new class instance, one that doesn't have a forbiddenName. Control status CSS classeslink Angular automatically mirrors many control properties onto the form control element as CSS classes. Use these classes to style form control elements according to the state of the form. The following classes are currently supported. .ng-valid .ng-invalid .ng-pending .ng-pristine .ng-dirty .ng-untouched .ng-touched .ng-submitted (enclosing form element only) In the following example, the hero form uses the .ng-valid and .ng-invalid classes to set the color of each form control's border. content_copy .ng-valid[required], .ng-valid.required { border-left: 5px solid #42A948; /* green */ } .ng-invalid:not(form) { border-left: 5px solid #a94442; /* red */ } .alert div { background-color: #fed3d3; color: #820000; padding: 1rem; margin-bottom: 1rem; } .form-group { margin-bottom: 1rem; } label { display: block; margin-bottom: .5rem; } select { width: 100%; padding: .5rem; } Cross-field validationlink A cross-field validator is a custom validator that compares the values of different fields in a form and accepts or rejects them in combination. For example, you might have a form that offers mutually incompatible options, so that if the user can choose A or B, but not both. Some field values might also depend on others; a user might be allowed to choose B only if A is also chosen. The following cross validation examples show how to do the following: Validate reactive or template-based form input based on the values of two sibling controls, Show a descriptive error message after the user interacted with the form and the validation failed. The examples use cross-validation to ensure that heroes do not reveal their true identities by filling out the Hero Form. The validators do this by checking that the hero names and alter egos do not match. Adding cross-validation to reactive formslink The form has the following structure: content_copy const heroForm = new FormGroup({ 'name': new FormControl(), 'alterEgo': new FormControl(), 'power': new FormControl() }); Notice that the name and alterEgo are sibling controls. To evaluate both controls in a single custom validator, you must perform the validation in a common ancestor control: the FormGroup. You query the FormGroup for its child controls so that you can compare their values. To add a validator to the FormGroup, pass the new validator in as the second argument on creation. content_copy const heroForm = new FormGroup({ 'name': new FormControl(), 'alterEgo': new FormControl(), 'power': new FormControl() }, { validators: identityRevealedValidator }); The validator code is as follows. content_copy /** A hero's name can't match the hero's alter ego */ export const identityRevealedValidator: ValidatorFn = ( control: AbstractControl, ): ValidationErrors  null = { const name = control.get('name'); const alterEgo = control.get('alterEgo'); return name && alterEgo && name.value === alterEgo.value ? { identityRevealed: true } : null; }; The identity validator implements the ValidatorFn interface. It takes an Angular control object as an argument and returns either null if the form is valid, or ValidationErrors otherwise. The validator retrieves the child controls by calling the FormGroup's get method, then compares the values of the name and alterEgo controls. If the values do not match, the hero's identity remains secret, both are valid, and the validator returns null. If they do match, the hero's identity is revealed and the validator must mark the form as invalid by returning an error object. To provide better user experience, the template shows an appropriate error message when the form is invalid. content_copy div *ngIf=\" heroForm.errors?.['identityRevealed'] && (heroForm.touched  heroForm.dirty) \" class=\"cross-validation-error-message alert alert-danger\"  Name cannot match alter ego. /div This *ngIf displays the error if the FormGroup has the cross validation error returned by the identityRevealed validator, but only if the user finished interacting with the form. Adding cross-validation to template-driven formslink For a template-driven form, you must create a directive to wrap the validator function. You provide that directive as the validator using the NG_VALIDATORS token, as shown in the following example. content_copy @Directive({ selector: '[appIdentityRevealed]', providers: [ { provide: NG_VALIDATORS, useExisting: IdentityRevealedValidatorDirective, multi: true, }, ], standalone: true, }) export class IdentityRevealedValidatorDirective implements Validator { validate(control: AbstractControl): ValidationErrors  null { return identityRevealedValidator(control); } } You must add the new directive to the HTML template. Because the validator must be registered at the highest level in the form, the following template puts the directive on the form tag. content_copy form #heroForm=\"ngForm\" appIdentityRevealed To provide better user experience, an appropriate error message appears when the form is invalid. content_copy div *ngIf=\" heroForm.errors?.['identityRevealed'] && (heroForm.touched  heroForm.dirty) \" class=\"cross-validation-error-message alert\"  Name cannot match alter ego. /div This is the same in both template-driven and reactive forms. Creating asynchronous validatorslink Asynchronous validators implement the AsyncValidatorFn and AsyncValidator interfaces. These are very similar to their synchronous counterparts, with the following differences. The validate() functions must return a Promise or an observable, The observable returned must be finite, meaning it must complete at some point. To convert an infinite observable into a finite one, pipe the observable through a filtering operator such as first, last, take, or takeUntil. Asynchronous validation happens after the synchronous validation, and is performed only if the synchronous validation is successful. This check lets forms avoid potentially expensive async validation processes (such as an HTTP request) if the more basic validation methods have already found invalid input. After asynchronous validation begins, the form control enters a pending state. Inspect the control's pending property and use it to give visual feedback about the ongoing validation operation. A common UI pattern is to show a spinner while the async validation is being performed. The following example shows how to achieve this in a template-driven form. content_copy input [(ngModel)]=\"name\" #model=\"ngModel\" appSomeAsyncValidator app-spinner *ngIf=\"model.pending\"/app-spinner Implementing a custom async validatorlink In the following example, an async validator ensures that heroes pick an alter ego that is not already taken. New heroes are constantly enlisting and old heroes are leaving the service, so the list of available alter egos cannot be retrieved ahead of time. To validate the potential alter ego entry, the validator must initiate an asynchronous operation to consult a central database of all currently enlisted heroes. The following code creates the validator class, UniqueAlterEgoValidator, which implements the AsyncValidator interface. content_copy @Injectable({ providedIn: 'root' }) export class UniqueAlterEgoValidator implements AsyncValidator { constructor(private heroesService: HeroesService) {} validate(control: AbstractControl): ObservableValidationErrors  null { return this.heroesService.isAlterEgoTaken(control.value).pipe( map((isTaken) = (isTaken ? { uniqueAlterEgo: true } : null)), catchError(() = of(null)), ); } } The constructor injects the HeroesService, which defines the following interface. content_copy interface HeroesService { isAlterEgoTaken: (alterEgo: string) = Observableboolean; } In a real world application, the HeroesService would be responsible for making an HTTP request to the hero database to check if the alter ego is available. From the validator's point of view, the actual implementation of the service is not important, so the example can just code against the HeroesService interface. As the validation begins, the UniqueAlterEgoValidator delegates to the HeroesService isAlterEgoTaken() method with the current control value. At this point the control is marked as pending and remains in this state until the observable chain returned from the validate() method completes. The isAlterEgoTaken() method dispatches an HTTP request that checks if the alter ego is available, and returns Observableboolean as the result. The validate() method pipes the response through the map operator and transforms it into a validation result. The method then, like any validator, returns null if the form is valid, and ValidationErrors if it is not. This validator handles any potential errors with the catchError operator. In this case, the validator treats the isAlterEgoTaken() error as a successful validation, because failure to make a validation request does not necessarily mean that the alter ego is invalid. You could handle the error differently and return the ValidationError object instead. After some time passes, the observable chain completes and the asynchronous validation is done. The pending flag is set to false, and the form validity is updated. Adding async validators to reactive formslink To use an async validator in reactive forms, begin by injecting the validator into the constructor of the component class. content_copy constructor(private alterEgoValidator: UniqueAlterEgoValidator) {} Then, pass the validator function directly to the FormControl to apply it. In the following example, the validate function of UniqueAlterEgoValidator is applied to alterEgoControl by passing it to the control's asyncValidators option and binding it to the instance of UniqueAlterEgoValidator that was injected into HeroFormReactiveComponent. The value of asyncValidators can be either a single async validator function, or an array of functions. To learn more about FormControl options, see the AbstractControlOptions API reference. content_copy const alterEgoControl = new FormControl('', { asyncValidators: [ this.alterEgoValidator.validate.bind(this.alterEgoValidator), ], updateOn: 'blur', }); Adding async validators to template-driven formslink To use an async validator in template-driven forms, create a new directive and register the NG_ASYNC_VALIDATORS provider on it. In the example below, the directive injects the UniqueAlterEgoValidator class that contains the actual validation logic and invokes it in the validate function, triggered by Angular when validation should happen. content_copy @Directive({ selector: '[appUniqueAlterEgo]', providers: [ { provide: NG_ASYNC_VALIDATORS, useExisting: forwardRef(() = UniqueAlterEgoValidatorDirective), multi: true, }, ], standalone: true, }) export class UniqueAlterEgoValidatorDirective implements AsyncValidator { constructor(private validator: UniqueAlterEgoValidator) {} validate(control: AbstractControl): ObservableValidationErrors  null { return this.validator.validate(control); } } Then, as with synchronous validators, add the directive's selector to an input to activate it. content_copy input type=\"text\" id=\"alterEgo\" name=\"alterEgo\" #alterEgo=\"ngModel\" [(ngModel)]=\"hero.alterEgo\" [ngModelOptions]=\"{ updateOn: 'blur' }\" appUniqueAlterEgo / Optimizing performance of async validatorslink By default, all validators run after every form value change. With synchronous validators, this does not normally have a noticeable impact on application performance. Async validators, however, commonly perform some kind of HTTP request to validate the control. Dispatching an HTTP request after every keystroke could put a strain on the backend API, and should be avoided if possible. You can delay updating the form validity by changing the updateOn property from change (default) to submit or blur. With template-driven forms, set the property in the template. content_copy input [(ngModel)]=\"name\" [ngModelOptions]=\"{updateOn: 'blur'}\" With reactive forms, set the property in the FormControl instance. content_copy new FormControl('', {updateOn: 'blur'}); Interaction with native HTML form validationlink By default, Angular disables native HTML form validation by adding the novalidate attribute on the enclosing form and uses directives to match these attributes with validator functions in the framework. If you want to use native validation in combination with Angular-based validation, you can re-enable it with the ngNativeValidate directive. See the API docs for details. Last reviewed on Tue Sep 12 2023",
    "headings": [
      {
        "level": 1,
        "text": "Validating form inputlink",
        "id": "validating-form-input"
      },
      {
        "level": 2,
        "text": "Prerequisiteslink",
        "id": "prerequisites"
      },
      {
        "level": 2,
        "text": "Validating input in template-driven formslink",
        "id": "validating-input-in-template-driven-forms"
      },
      {
        "level": 2,
        "text": "Validating input in reactive formslink",
        "id": "validating-input-in-reactive-forms"
      },
      {
        "level": 2,
        "text": "Defining custom validatorslink",
        "id": "defining-custom-validators"
      },
      {
        "level": 2,
        "text": "Control status CSS classeslink",
        "id": "control-status-css-classes"
      },
      {
        "level": 2,
        "text": "Cross-field validationlink",
        "id": "cross-field-validation"
      },
      {
        "level": 2,
        "text": "Creating asynchronous validatorslink",
        "id": "creating-asynchronous-validators"
      },
      {
        "level": 2,
        "text": "Interaction with native HTML form validationlink",
        "id": "interaction-with-native-html-form-validation"
      },
      {
        "level": 3,
        "text": "Validator functionslink",
        "id": "validator-functions"
      },
      {
        "level": 3,
        "text": "Built-in validator functionslink",
        "id": "built-in-validator-functions"
      },
      {
        "level": 3,
        "text": "Adding custom validators to reactive formslink",
        "id": "adding-custom-validators-to-reactive-forms"
      },
      {
        "level": 3,
        "text": "Adding custom validators to template-driven formslink",
        "id": "adding-custom-validators-to-template-driven-forms"
      },
      {
        "level": 3,
        "text": "Adding cross-validation to reactive formslink",
        "id": "adding-cross-validation-to-reactive-forms"
      },
      {
        "level": 3,
        "text": "Adding cross-validation to template-driven formslink",
        "id": "adding-cross-validation-to-template-driven-forms"
      },
      {
        "level": 3,
        "text": "Implementing a custom async validatorlink",
        "id": "implementing-a-custom-async-validator"
      },
      {
        "level": 3,
        "text": "Adding async validators to reactive formslink",
        "id": "adding-async-validators-to-reactive-forms"
      },
      {
        "level": 3,
        "text": "Adding async validators to template-driven formslink",
        "id": "adding-async-validators-to-template-driven-forms"
      },
      {
        "level": 3,
        "text": "Optimizing performance of async validatorslink",
        "id": "optimizing-performance-of-async-validators"
      }
    ],
    "codeBlocks": [
      {
        "language": "text",
        "code": "content_copy\n      \n      <input\n  type=\"text\"\n  id=\"name\"\n  name=\"name\"\n  class=\"form-control\"\n  required\n  minlength=\"4\"\n  appForbiddenName=\"bob\"\n  [(ngModel)]=\"hero.name\"\n  #name=\"ngModel\"\n/>\n\n<div\n  *ngIf=\"name.invalid && (name.dirty || name.touched)\"\n  class=\"alert\"\n>\n  <div *ngIf=\"name.errors?.['required']\">Name is required.</div>\n  <div *ngIf=\"name.errors?.['minlength']\">\n    Name must be at least 4 characters long.\n  </div>\n  <div *ngIf=\"name.errors?.['forbiddenName']\">\n    Name cannot be Bob.\n  </div>\n</div>"
      },
      {
        "language": "text",
        "code": "<input\n  type=\"text\"\n  id=\"name\"\n  name=\"name\"\n  class=\"form-control\"\n  required\n  minlength=\"4\"\n  appForbiddenName=\"bob\"\n  [(ngModel)]=\"hero.name\"\n  #name=\"ngModel\"\n/>\n\n<div\n  *ngIf=\"name.invalid && (name.dirty || name.touched)\"\n  class=\"alert\"\n>\n  <div *ngIf=\"name.errors?.['required']\">Name is required.</div>\n  <div *ngIf=\"name.errors?.['minlength']\">\n    Name must be at least 4 characters long.\n  </div>\n  <div *ngIf=\"name.errors?.['forbiddenName']\">\n    Name cannot be Bob.\n  </div>\n</div>"
      },
      {
        "language": "text",
        "code": "forbiddenName"
      },
      {
        "language": "text",
        "code": "#name=\"ngModel\""
      },
      {
        "language": "text",
        "code": "FormControl"
      },
      {
        "language": "text",
        "code": "forbiddenName"
      },
      {
        "language": "text",
        "code": "FormControl"
      },
      {
        "language": "text",
        "code": "FormControl"
      },
      {
        "language": "text",
        "code": "content_copy\n      \n      ngOnInit(): void {\n  this.heroForm = new FormGroup({\n    name: new FormControl(this.hero.name, [\n      Validators.required,\n      Validators.minLength(4),\n      forbiddenNameValidator(/bob/i), // <-- Here's how you pass in the custom validator.\n    ]),\n    alterEgo: new FormControl(this.hero.alterEgo),\n    power: new FormControl(this.hero.power, Validators.required),\n  });\n}\n\nget name() {\n  return this.heroForm.get('name');\n}\n\nget power() {\n  return this.heroForm.get('power');\n}"
      },
      {
        "language": "text",
        "code": "ngOnInit(): void {\n  this.heroForm = new FormGroup({\n    name: new FormControl(this.hero.name, [\n      Validators.required,\n      Validators.minLength(4),\n      forbiddenNameValidator(/bob/i), // <-- Here's how you pass in the custom validator.\n    ]),\n    alterEgo: new FormControl(this.hero.alterEgo),\n    power: new FormControl(this.hero.power, Validators.required),\n  });\n}\n\nget name() {\n  return this.heroForm.get('name');\n}\n\nget power() {\n  return this.heroForm.get('power');\n}"
      },
      {
        "language": "text",
        "code": "Validators.required"
      },
      {
        "language": "text",
        "code": "Validators.minLength(4)"
      },
      {
        "language": "text",
        "code": "forbiddenNameValidator"
      },
      {
        "language": "text",
        "code": "content_copy\n      \n      <input\n  type=\"text\"\n  id=\"name\"\n  class=\"form-control\"\n  formControlName=\"name\"\n  required\n/>\n\n<div\n  *ngIf=\"name.invalid && (name.dirty || name.touched)\"\n  class=\"alert alert-danger\"\n>\n  <div *ngIf=\"name.errors?.['required']\">Name is required.</div>\n  <div *ngIf=\"name.errors?.['minlength']\">\n    Name must be at least 4 characters long.\n  </div>\n  <div *ngIf=\"name.errors?.['forbiddenName']\">\n    Name cannot be Bob.\n  </div>\n</div>"
      },
      {
        "language": "text",
        "code": "<input\n  type=\"text\"\n  id=\"name\"\n  class=\"form-control\"\n  formControlName=\"name\"\n  required\n/>\n\n<div\n  *ngIf=\"name.invalid && (name.dirty || name.touched)\"\n  class=\"alert alert-danger\"\n>\n  <div *ngIf=\"name.errors?.['required']\">Name is required.</div>\n  <div *ngIf=\"name.errors?.['minlength']\">\n    Name must be at least 4 characters long.\n  </div>\n  <div *ngIf=\"name.errors?.['forbiddenName']\">\n    Name cannot be Bob.\n  </div>\n</div>"
      },
      {
        "language": "text",
        "code": "forbiddenNameValidator"
      },
      {
        "language": "text",
        "code": "content_copy\n      \n      /** A hero's name can't match the given regular expression */\nexport function forbiddenNameValidator(nameRe: RegExp): ValidatorFn {\n  return (control: AbstractControl): ValidationErrors | null => {\n    const forbidden = nameRe.test(control.value);\n    return forbidden ? { forbiddenName: { value: control.value } } : null;\n  };\n}"
      },
      {
        "language": "text",
        "code": "/** A hero's name can't match the given regular expression */\nexport function forbiddenNameValidator(nameRe: RegExp): ValidatorFn {\n  return (control: AbstractControl): ValidationErrors | null => {\n    const forbidden = nameRe.test(control.value);\n    return forbidden ? { forbiddenName: { value: control.value } } : null;\n  };\n}"
      },
      {
        "language": "text",
        "code": "forbiddenNameValidator"
      },
      {
        "language": "text",
        "code": "'forbiddenName'"
      },
      {
        "language": "text",
        "code": "FormControl"
      },
      {
        "language": "text",
        "code": "content_copy\n      \n      this.heroForm = new FormGroup({\n  name: new FormControl(this.hero.name, [\n    Validators.required,\n    Validators.minLength(4),\n    forbiddenNameValidator(/bob/i), // <-- Here's how you pass in the custom validator.\n  ]),\n  alterEgo: new FormControl(this.hero.alterEgo),\n  power: new FormControl(this.hero.power, Validators.required),\n});"
      },
      {
        "language": "text",
        "code": "this.heroForm = new FormGroup({\n  name: new FormControl(this.hero.name, [\n    Validators.required,\n    Validators.minLength(4),\n    forbiddenNameValidator(/bob/i), // <-- Here's how you pass in the custom validator.\n  ]),\n  alterEgo: new FormControl(this.hero.alterEgo),\n  power: new FormControl(this.hero.power, Validators.required),\n});"
      },
      {
        "language": "text",
        "code": "ForbiddenValidatorDirective"
      },
      {
        "language": "text",
        "code": "forbiddenNameValidator"
      },
      {
        "language": "text",
        "code": "NG_VALIDATORS"
      },
      {
        "language": "text",
        "code": "NG_VALIDATORS"
      },
      {
        "language": "text",
        "code": "content_copy\n      \n      providers: [\n  {\n    provide: NG_VALIDATORS,\n    useExisting: ForbiddenValidatorDirective,\n    multi: true,\n  },\n],"
      },
      {
        "language": "text",
        "code": "providers: [\n  {\n    provide: NG_VALIDATORS,\n    useExisting: ForbiddenValidatorDirective,\n    multi: true,\n  },\n],"
      },
      {
        "language": "text",
        "code": "content_copy\n      \n      @Directive({\n  selector: '[appForbiddenName]',\n  providers: [\n    {\n      provide: NG_VALIDATORS,\n      useExisting: ForbiddenValidatorDirective,\n      multi: true,\n    },\n  ],\n  standalone: true,\n})\nexport class ForbiddenValidatorDirective implements Validator {\n  @Input('appForbiddenName') forbiddenName = '';\n\n  validate(control: AbstractControl): ValidationErrors | null {\n    return this.forbiddenName\n      ? forbiddenNameValidator(new RegExp(this.forbiddenName, 'i'))(control)\n      : null;\n  }\n}"
      },
      {
        "language": "text",
        "code": "@Directive({\n  selector: '[appForbiddenName]',\n  providers: [\n    {\n      provide: NG_VALIDATORS,\n      useExisting: ForbiddenValidatorDirective,\n      multi: true,\n    },\n  ],\n  standalone: true,\n})\nexport class ForbiddenValidatorDirective implements Validator {\n  @Input('appForbiddenName') forbiddenName = '';\n\n  validate(control: AbstractControl): ValidationErrors | null {\n    return this.forbiddenName\n      ? forbiddenNameValidator(new RegExp(this.forbiddenName, 'i'))(control)\n      : null;\n  }\n}"
      },
      {
        "language": "text",
        "code": "ForbiddenValidatorDirective"
      },
      {
        "language": "text",
        "code": "appForbiddenName"
      },
      {
        "language": "text",
        "code": "content_copy\n      \n      <input\n  type=\"text\"\n  id=\"name\"\n  name=\"name\"\n  class=\"form-control\"\n  required\n  minlength=\"4\"\n  appForbiddenName=\"bob\"\n  [(ngModel)]=\"hero.name\"\n  #name=\"ngModel\"\n/>"
      },
      {
        "language": "text",
        "code": "<input\n  type=\"text\"\n  id=\"name\"\n  name=\"name\"\n  class=\"form-control\"\n  required\n  minlength=\"4\"\n  appForbiddenName=\"bob\"\n  [(ngModel)]=\"hero.name\"\n  #name=\"ngModel\"\n/>"
      },
      {
        "language": "text",
        "code": "useExisting"
      },
      {
        "language": "text",
        "code": "ForbiddenValidatorDirective"
      },
      {
        "language": "text",
        "code": "forbiddenName"
      },
      {
        "language": "text",
        "code": "useExisting"
      },
      {
        "language": "text",
        "code": "forbiddenName"
      },
      {
        "language": "text",
        "code": ".ng-invalid"
      },
      {
        "language": "text",
        "code": ".ng-pending"
      },
      {
        "language": "text",
        "code": ".ng-pristine"
      },
      {
        "language": "text",
        "code": ".ng-untouched"
      },
      {
        "language": "text",
        "code": ".ng-touched"
      },
      {
        "language": "text",
        "code": ".ng-submitted"
      },
      {
        "language": "text",
        "code": ".ng-invalid"
      },
      {
        "language": "text",
        "code": "content_copy\n      \n      .ng-valid[required], .ng-valid.required  {\n  border-left: 5px solid #42A948; /* green */\n}\n\n.ng-invalid:not(form)  {\n  border-left: 5px solid #a94442; /* red */\n}\n\n.alert div {\n  background-color: #fed3d3;\n  color: #820000;\n  padding: 1rem;\n  margin-bottom: 1rem;\n}\n\n.form-group {\n  margin-bottom: 1rem;\n}\n\nlabel {\n  display: block;\n  margin-bottom: .5rem;\n}\n\nselect {\n  width: 100%;\n  padding: .5rem;\n}"
      },
      {
        "language": "text",
        "code": ".ng-valid[required], .ng-valid.required  {\n  border-left: 5px solid #42A948; /* green */\n}\n\n.ng-invalid:not(form)  {\n  border-left: 5px solid #a94442; /* red */\n}\n\n.alert div {\n  background-color: #fed3d3;\n  color: #820000;\n  padding: 1rem;\n  margin-bottom: 1rem;\n}\n\n.form-group {\n  margin-bottom: 1rem;\n}\n\nlabel {\n  display: block;\n  margin-bottom: .5rem;\n}\n\nselect {\n  width: 100%;\n  padding: .5rem;\n}"
      },
      {
        "language": "text",
        "code": "content_copy\n      \n      const heroForm = new FormGroup({\n  'name': new FormControl(),\n  'alterEgo': new FormControl(),\n  'power': new FormControl()\n});"
      },
      {
        "language": "text",
        "code": "const heroForm = new FormGroup({\n  'name': new FormControl(),\n  'alterEgo': new FormControl(),\n  'power': new FormControl()\n});"
      },
      {
        "language": "text",
        "code": "content_copy\n      \n      const heroForm = new FormGroup({\n  'name': new FormControl(),\n  'alterEgo': new FormControl(),\n  'power': new FormControl()\n}, { validators: identityRevealedValidator });"
      },
      {
        "language": "text",
        "code": "const heroForm = new FormGroup({\n  'name': new FormControl(),\n  'alterEgo': new FormControl(),\n  'power': new FormControl()\n}, { validators: identityRevealedValidator });"
      },
      {
        "language": "text",
        "code": "content_copy\n      \n      /** A hero's name can't match the hero's alter ego */\nexport const identityRevealedValidator: ValidatorFn = (\n  control: AbstractControl,\n): ValidationErrors | null => {\n  const name = control.get('name');\n  const alterEgo = control.get('alterEgo');\n\n  return name && alterEgo && name.value === alterEgo.value\n    ? { identityRevealed: true }\n    : null;\n};"
      },
      {
        "language": "text",
        "code": "/** A hero's name can't match the hero's alter ego */\nexport const identityRevealedValidator: ValidatorFn = (\n  control: AbstractControl,\n): ValidationErrors | null => {\n  const name = control.get('name');\n  const alterEgo = control.get('alterEgo');\n\n  return name && alterEgo && name.value === alterEgo.value\n    ? { identityRevealed: true }\n    : null;\n};"
      },
      {
        "language": "text",
        "code": "ValidatorFn"
      },
      {
        "language": "text",
        "code": "ValidationErrors"
      },
      {
        "language": "text",
        "code": "content_copy\n      \n      <div\n  *ngIf=\"\n    heroForm.errors?.['identityRevealed'] &&\n    (heroForm.touched || heroForm.dirty)\n  \"\n  class=\"cross-validation-error-message alert alert-danger\"\n>\n  Name cannot match alter ego.\n</div>"
      },
      {
        "language": "text",
        "code": "<div\n  *ngIf=\"\n    heroForm.errors?.['identityRevealed'] &&\n    (heroForm.touched || heroForm.dirty)\n  \"\n  class=\"cross-validation-error-message alert alert-danger\"\n>\n  Name cannot match alter ego.\n</div>"
      },
      {
        "language": "text",
        "code": "identityRevealed"
      },
      {
        "language": "text",
        "code": "NG_VALIDATORS"
      },
      {
        "language": "text",
        "code": "content_copy\n      \n      @Directive({\n  selector: '[appIdentityRevealed]',\n  providers: [\n    {\n      provide: NG_VALIDATORS,\n      useExisting: IdentityRevealedValidatorDirective,\n      multi: true,\n    },\n  ],\n  standalone: true,\n})\nexport class IdentityRevealedValidatorDirective implements Validator {\n  validate(control: AbstractControl): ValidationErrors | null {\n    return identityRevealedValidator(control);\n  }\n}"
      },
      {
        "language": "text",
        "code": "@Directive({\n  selector: '[appIdentityRevealed]',\n  providers: [\n    {\n      provide: NG_VALIDATORS,\n      useExisting: IdentityRevealedValidatorDirective,\n      multi: true,\n    },\n  ],\n  standalone: true,\n})\nexport class IdentityRevealedValidatorDirective implements Validator {\n  validate(control: AbstractControl): ValidationErrors | null {\n    return identityRevealedValidator(control);\n  }\n}"
      },
      {
        "language": "text",
        "code": "content_copy\n      \n      <form #heroForm=\"ngForm\" appIdentityRevealed>"
      },
      {
        "language": "text",
        "code": "<form #heroForm=\"ngForm\" appIdentityRevealed>"
      },
      {
        "language": "text",
        "code": "content_copy\n      \n      <div\n  *ngIf=\"\n    heroForm.errors?.['identityRevealed'] &&\n    (heroForm.touched || heroForm.dirty)\n  \"\n  class=\"cross-validation-error-message alert\"\n>\n  Name cannot match alter ego.\n</div>"
      },
      {
        "language": "text",
        "code": "<div\n  *ngIf=\"\n    heroForm.errors?.['identityRevealed'] &&\n    (heroForm.touched || heroForm.dirty)\n  \"\n  class=\"cross-validation-error-message alert\"\n>\n  Name cannot match alter ego.\n</div>"
      },
      {
        "language": "text",
        "code": "AsyncValidatorFn"
      },
      {
        "language": "text",
        "code": "AsyncValidator"
      },
      {
        "language": "text",
        "code": "content_copy\n      \n      <input [(ngModel)]=\"name\" #model=\"ngModel\" appSomeAsyncValidator>\n<app-spinner *ngIf=\"model.pending\"></app-spinner>"
      },
      {
        "language": "text",
        "code": "<input [(ngModel)]=\"name\" #model=\"ngModel\" appSomeAsyncValidator>\n<app-spinner *ngIf=\"model.pending\"></app-spinner>"
      },
      {
        "language": "text",
        "code": "UniqueAlterEgoValidator"
      },
      {
        "language": "text",
        "code": "AsyncValidator"
      },
      {
        "language": "text",
        "code": "content_copy\n      \n      @Injectable({ providedIn: 'root' })\nexport class UniqueAlterEgoValidator implements AsyncValidator {\n  constructor(private heroesService: HeroesService) {}\n\n  validate(control: AbstractControl): Observable<ValidationErrors | null> {\n    return this.heroesService.isAlterEgoTaken(control.value).pipe(\n      map((isTaken) => (isTaken ? { uniqueAlterEgo: true } : null)),\n      catchError(() => of(null)),\n    );\n  }\n}"
      },
      {
        "language": "text",
        "code": "@Injectable({ providedIn: 'root' })\nexport class UniqueAlterEgoValidator implements AsyncValidator {\n  constructor(private heroesService: HeroesService) {}\n\n  validate(control: AbstractControl): Observable<ValidationErrors | null> {\n    return this.heroesService.isAlterEgoTaken(control.value).pipe(\n      map((isTaken) => (isTaken ? { uniqueAlterEgo: true } : null)),\n      catchError(() => of(null)),\n    );\n  }\n}"
      },
      {
        "language": "text",
        "code": "HeroesService"
      },
      {
        "language": "text",
        "code": "content_copy\n      \n      interface HeroesService {\n  isAlterEgoTaken: (alterEgo: string) => Observable<boolean>;\n}"
      },
      {
        "language": "text",
        "code": "interface HeroesService {\n  isAlterEgoTaken: (alterEgo: string) => Observable<boolean>;\n}"
      },
      {
        "language": "text",
        "code": "HeroesService"
      },
      {
        "language": "text",
        "code": "HeroesService"
      },
      {
        "language": "text",
        "code": "UniqueAlterEgoValidator"
      },
      {
        "language": "text",
        "code": "HeroesService"
      },
      {
        "language": "text",
        "code": "isAlterEgoTaken()"
      },
      {
        "language": "text",
        "code": "isAlterEgoTaken()"
      },
      {
        "language": "text",
        "code": "Observable<boolean>"
      },
      {
        "language": "text",
        "code": "ValidationErrors"
      },
      {
        "language": "text",
        "code": "isAlterEgoTaken()"
      },
      {
        "language": "text",
        "code": "ValidationError"
      },
      {
        "language": "text",
        "code": "content_copy\n      \n      constructor(private alterEgoValidator: UniqueAlterEgoValidator) {}"
      },
      {
        "language": "text",
        "code": "constructor(private alterEgoValidator: UniqueAlterEgoValidator) {}"
      },
      {
        "language": "text",
        "code": "FormControl"
      },
      {
        "language": "text",
        "code": "UniqueAlterEgoValidator"
      },
      {
        "language": "text",
        "code": "alterEgoControl"
      },
      {
        "language": "text",
        "code": "asyncValidators"
      },
      {
        "language": "text",
        "code": "UniqueAlterEgoValidator"
      },
      {
        "language": "text",
        "code": "HeroFormReactiveComponent"
      },
      {
        "language": "text",
        "code": "asyncValidators"
      },
      {
        "language": "text",
        "code": "FormControl"
      },
      {
        "language": "text",
        "code": "content_copy\n      \n      const alterEgoControl = new FormControl('', {\n  asyncValidators: [\n    this.alterEgoValidator.validate.bind(this.alterEgoValidator),\n  ],\n  updateOn: 'blur',\n});"
      },
      {
        "language": "text",
        "code": "const alterEgoControl = new FormControl('', {\n  asyncValidators: [\n    this.alterEgoValidator.validate.bind(this.alterEgoValidator),\n  ],\n  updateOn: 'blur',\n});"
      },
      {
        "language": "text",
        "code": "NG_ASYNC_VALIDATORS"
      },
      {
        "language": "text",
        "code": "UniqueAlterEgoValidator"
      },
      {
        "language": "text",
        "code": "content_copy\n      \n      @Directive({\n  selector: '[appUniqueAlterEgo]',\n  providers: [\n    {\n      provide: NG_ASYNC_VALIDATORS,\n      useExisting: forwardRef(() => UniqueAlterEgoValidatorDirective),\n      multi: true,\n    },\n  ],\n  standalone: true,\n})\nexport class UniqueAlterEgoValidatorDirective implements AsyncValidator {\n  constructor(private validator: UniqueAlterEgoValidator) {}\n\n  validate(control: AbstractControl): Observable<ValidationErrors | null> {\n    return this.validator.validate(control);\n  }\n}"
      },
      {
        "language": "text",
        "code": "@Directive({\n  selector: '[appUniqueAlterEgo]',\n  providers: [\n    {\n      provide: NG_ASYNC_VALIDATORS,\n      useExisting: forwardRef(() => UniqueAlterEgoValidatorDirective),\n      multi: true,\n    },\n  ],\n  standalone: true,\n})\nexport class UniqueAlterEgoValidatorDirective implements AsyncValidator {\n  constructor(private validator: UniqueAlterEgoValidator) {}\n\n  validate(control: AbstractControl): Observable<ValidationErrors | null> {\n    return this.validator.validate(control);\n  }\n}"
      },
      {
        "language": "text",
        "code": "content_copy\n      \n      <input\n  type=\"text\"\n  id=\"alterEgo\"\n  name=\"alterEgo\"\n  #alterEgo=\"ngModel\"\n  [(ngModel)]=\"hero.alterEgo\"\n  [ngModelOptions]=\"{ updateOn: 'blur' }\"\n  appUniqueAlterEgo\n/>"
      },
      {
        "language": "text",
        "code": "<input\n  type=\"text\"\n  id=\"alterEgo\"\n  name=\"alterEgo\"\n  #alterEgo=\"ngModel\"\n  [(ngModel)]=\"hero.alterEgo\"\n  [ngModelOptions]=\"{ updateOn: 'blur' }\"\n  appUniqueAlterEgo\n/>"
      },
      {
        "language": "text",
        "code": "content_copy\n      \n      <input [(ngModel)]=\"name\" [ngModelOptions]=\"{updateOn: 'blur'}\">"
      },
      {
        "language": "text",
        "code": "<input [(ngModel)]=\"name\" [ngModelOptions]=\"{updateOn: 'blur'}\">"
      },
      {
        "language": "text",
        "code": "FormControl"
      },
      {
        "language": "text",
        "code": "content_copy\n      \n      new FormControl('', {updateOn: 'blur'});"
      },
      {
        "language": "text",
        "code": "new FormControl('', {updateOn: 'blur'});"
      },
      {
        "language": "text",
        "code": "ngNativeValidate"
      }
    ],
    "links": [
      {
        "text": "link",
        "href": "guide/form-validation#validating-form-input"
      },
      {
        "text": "Prerequisites",
        "href": "guide/form-validation#prerequisites"
      },
      {
        "text": "Validating input in template-driven forms",
        "href": "guide/form-validation#validating-input-in-template-driven-forms"
      },
      {
        "text": "Validating input in reactive forms",
        "href": "guide/form-validation#validating-input-in-reactive-forms"
      },
      {
        "text": "Validator functions",
        "href": "guide/form-validation#validator-functions"
      },
      {
        "text": "Built-in validator functions",
        "href": "guide/form-validation#built-in-validator-functions"
      },
      {
        "text": "Defining custom validators",
        "href": "guide/form-validation#defining-custom-validators"
      },
      {
        "text": "Adding custom validators to reactive forms",
        "href": "guide/form-validation#adding-custom-validators-to-reactive-forms"
      },
      {
        "text": "Adding custom validators to template-driven forms",
        "href": "guide/form-validation#adding-custom-validators-to-template-driven-forms"
      },
      {
        "text": "Control status CSS classes",
        "href": "guide/form-validation#control-status-css-classes"
      },
      {
        "text": "Cross-field validation",
        "href": "guide/form-validation#cross-field-validation"
      },
      {
        "text": "Adding cross-validation to reactive forms",
        "href": "guide/form-validation#adding-cross-validation-to-reactive-forms"
      },
      {
        "text": "Adding cross-validation to template-driven forms",
        "href": "guide/form-validation#adding-cross-validation-to-template-driven-forms"
      },
      {
        "text": "Creating asynchronous validators",
        "href": "guide/form-validation#creating-asynchronous-validators"
      },
      {
        "text": "Implementing a custom async validator",
        "href": "guide/form-validation#implementing-a-custom-async-validator"
      },
      {
        "text": "Adding async validators to reactive forms",
        "href": "guide/form-validation#adding-async-validators-to-reactive-forms"
      },
      {
        "text": "Adding async validators to template-driven forms",
        "href": "guide/form-validation#adding-async-validators-to-template-driven-forms"
      },
      {
        "text": "Optimizing performance of async validators",
        "href": "guide/form-validation#optimizing-performance-of-async-validators"
      },
      {
        "text": "Interaction with native HTML form validation",
        "href": "guide/form-validation#interaction-with-native-html-form-validation"
      },
      {
        "text": "link",
        "href": "guide/form-validation#prerequisites"
      },
      {
        "text": "TypeScript",
        "href": "https://www.typescriptlang.org/"
      },
      {
        "text": "Angular application design",
        "href": "guide/architecture"
      },
      {
        "text": "two types of forms that Angular supports",
        "href": "guide/forms-overview"
      },
      {
        "text": "Template-driven Forms",
        "href": "guide/forms"
      },
      {
        "text": "Reactive Forms",
        "href": "guide/reactive-forms"
      },
      {
        "text": "live example",
        "href": "generated/live-examples/form-validation/stackblitz.html"
      },
      {
        "text": "download example",
        "href": "generated/zips/form-validation/form-validation.zip"
      },
      {
        "text": "link",
        "href": "guide/form-validation#validating-input-in-template-driven-forms"
      },
      {
        "text": "native HTML form validation",
        "href": "https://developer.mozilla.org/docs/Web/Guide/HTML/HTML5/Constraint_validation"
      },
      {
        "text": "ngModel",
        "href": "api/forms/NgModel"
      },
      {
        "text": "NgModel",
        "href": "api/forms/NgModel"
      },
      {
        "text": "minlength",
        "href": "api/forms/MinLengthValidator"
      },
      {
        "text": "ngModel",
        "href": "api/forms/NgModel"
      },
      {
        "text": "ngModel",
        "href": "api/forms/NgModel"
      },
      {
        "text": "ngIf",
        "href": "api/common/NgIf"
      },
      {
        "text": "ngIf",
        "href": "api/common/NgIf"
      },
      {
        "text": "ngIf",
        "href": "api/common/NgIf"
      },
      {
        "text": "minlength",
        "href": "api/forms/MinLengthValidator"
      },
      {
        "text": "ngIf",
        "href": "api/common/NgIf"
      },
      {
        "text": "minlength",
        "href": "api/forms/MinLengthValidator"
      },
      {
        "text": "Custom validators",
        "href": "guide/form-validation#custom-validators"
      },
      {
        "text": "ngModel",
        "href": "api/forms/NgModel"
      },
      {
        "text": "NgModel",
        "href": "api/forms/NgModel"
      },
      {
        "text": "NgModel",
        "href": "api/forms/NgModel"
      },
      {
        "text": "FormControl",
        "href": "api/forms/FormControl"
      },
      {
        "text": "AbstractControl",
        "href": "api/forms/AbstractControl"
      },
      {
        "text": "ngIf",
        "href": "api/common/NgIf"
      },
      {
        "text": "minlength",
        "href": "api/forms/MinLengthValidator"
      },
      {
        "text": "link",
        "href": "guide/form-validation#validating-input-in-reactive-forms"
      },
      {
        "text": "link",
        "href": "guide/form-validation#validator-functions"
      },
      {
        "text": "FormControl",
        "href": "api/forms/FormControl"
      },
      {
        "text": "FormControl",
        "href": "api/forms/FormControl"
      },
      {
        "text": "link",
        "href": "guide/form-validation#built-in-validator-functions"
      },
      {
        "text": "write your own validator functions",
        "href": "guide/form-validation#custom-validators"
      },
      {
        "text": "minlength",
        "href": "api/forms/MinLengthValidator"
      },
      {
        "text": "Validators",
        "href": "api/forms/Validators"
      },
      {
        "text": "Validators",
        "href": "api/forms/Validators"
      },
      {
        "text": "FormGroup",
        "href": "api/forms/FormGroup"
      },
      {
        "text": "FormControl",
        "href": "api/forms/FormControl"
      },
      {
        "text": "FormControl",
        "href": "api/forms/FormControl"
      },
      {
        "text": "FormControl",
        "href": "api/forms/FormControl"
      },
      {
        "text": "custom validators",
        "href": "guide/form-validation#custom-validators"
      },
      {
        "text": "formControlName",
        "href": "api/forms/FormControlName"
      },
      {
        "text": "ngIf",
        "href": "api/common/NgIf"
      },
      {
        "text": "ngIf",
        "href": "api/common/NgIf"
      },
      {
        "text": "ngIf",
        "href": "api/common/NgIf"
      },
      {
        "text": "minlength",
        "href": "api/forms/MinLengthValidator"
      },
      {
        "text": "ngIf",
        "href": "api/common/NgIf"
      },
      {
        "text": "link",
        "href": "guide/form-validation#defining-custom-validators"
      },
      {
        "text": "reactive-form examples",
        "href": "guide/form-validation#reactive-component-class"
      },
      {
        "text": "ValidatorFn",
        "href": "api/forms/ValidatorFn"
      },
      {
        "text": "AbstractControl",
        "href": "api/forms/AbstractControl"
      },
      {
        "text": "ValidationErrors",
        "href": "api/forms/ValidationErrors"
      },
      {
        "text": "link",
        "href": "guide/form-validation#adding-custom-validators-to-reactive-forms"
      },
      {
        "text": "FormControl",
        "href": "api/forms/FormControl"
      },
      {
        "text": "FormGroup",
        "href": "api/forms/FormGroup"
      },
      {
        "text": "FormControl",
        "href": "api/forms/FormControl"
      },
      {
        "text": "FormControl",
        "href": "api/forms/FormControl"
      },
      {
        "text": "FormControl",
        "href": "api/forms/FormControl"
      },
      {
        "text": "link",
        "href": "guide/form-validation#adding-custom-validators-to-template-driven-forms"
      },
      {
        "text": "NG_VALIDATORS",
        "href": "api/forms/NG_VALIDATORS"
      },
      {
        "text": "NG_VALIDATORS",
        "href": "api/forms/NG_VALIDATORS"
      },
      {
        "text": "NG_VALIDATORS",
        "href": "api/forms/NG_VALIDATORS"
      },
      {
        "text": "Validator",
        "href": "api/forms/Validator"
      },
      {
        "text": "Directive",
        "href": "api/core/Directive"
      },
      {
        "text": "NG_VALIDATORS",
        "href": "api/forms/NG_VALIDATORS"
      },
      {
        "text": "Validator",
        "href": "api/forms/Validator"
      },
      {
        "text": "Input",
        "href": "api/core/Input"
      },
      {
        "text": "AbstractControl",
        "href": "api/forms/AbstractControl"
      },
      {
        "text": "ValidationErrors",
        "href": "api/forms/ValidationErrors"
      },
      {
        "text": "minlength",
        "href": "api/forms/MinLengthValidator"
      },
      {
        "text": "ngModel",
        "href": "api/forms/NgModel"
      },
      {
        "text": "ngModel",
        "href": "api/forms/NgModel"
      },
      {
        "text": "link",
        "href": "guide/form-validation#control-status-css-classes"
      },
      {
        "text": "link",
        "href": "guide/form-validation#cross-field-validation"
      },
      {
        "text": "custom validator",
        "href": "guide/form-validation#custom-validators"
      },
      {
        "text": "link",
        "href": "guide/form-validation#adding-cross-validation-to-reactive-forms"
      },
      {
        "text": "FormGroup",
        "href": "api/forms/FormGroup"
      },
      {
        "text": "FormControl",
        "href": "api/forms/FormControl"
      },
      {
        "text": "FormControl",
        "href": "api/forms/FormControl"
      },
      {
        "text": "FormControl",
        "href": "api/forms/FormControl"
      },
      {
        "text": "FormGroup",
        "href": "api/forms/FormGroup"
      },
      {
        "text": "FormGroup",
        "href": "api/forms/FormGroup"
      },
      {
        "text": "FormGroup",
        "href": "api/forms/FormGroup"
      },
      {
        "text": "FormGroup",
        "href": "api/forms/FormGroup"
      },
      {
        "text": "FormControl",
        "href": "api/forms/FormControl"
      },
      {
        "text": "FormControl",
        "href": "api/forms/FormControl"
      },
      {
        "text": "FormControl",
        "href": "api/forms/FormControl"
      },
      {
        "text": "ValidatorFn",
        "href": "api/forms/ValidatorFn"
      },
      {
        "text": "AbstractControl",
        "href": "api/forms/AbstractControl"
      },
      {
        "text": "ValidationErrors",
        "href": "api/forms/ValidationErrors"
      },
      {
        "text": "ValidatorFn",
        "href": "api/forms/ValidatorFn"
      },
      {
        "text": "ValidationErrors",
        "href": "api/forms/ValidationErrors"
      },
      {
        "text": "FormGroup",
        "href": "api/forms/FormGroup"
      },
      {
        "text": "get",
        "href": "api/forms/AbstractControl#get"
      },
      {
        "text": "ngIf",
        "href": "api/common/NgIf"
      },
      {
        "text": "ngIf",
        "href": "api/common/NgIf"
      },
      {
        "text": "FormGroup",
        "href": "api/forms/FormGroup"
      },
      {
        "text": "interacting with the form",
        "href": "guide/form-validation#dirty-or-touched"
      },
      {
        "text": "link",
        "href": "guide/form-validation#adding-cross-validation-to-template-driven-forms"
      },
      {
        "text": "NG_VALIDATORS token",
        "href": "guide/form-validation#adding-to-template-driven-forms"
      },
      {
        "text": "Directive",
        "href": "api/core/Directive"
      },
      {
        "text": "NG_VALIDATORS",
        "href": "api/forms/NG_VALIDATORS"
      },
      {
        "text": "Validator",
        "href": "api/forms/Validator"
      },
      {
        "text": "AbstractControl",
        "href": "api/forms/AbstractControl"
      },
      {
        "text": "ValidationErrors",
        "href": "api/forms/ValidationErrors"
      },
      {
        "text": "ngForm",
        "href": "api/forms/NgForm"
      },
      {
        "text": "ngIf",
        "href": "api/common/NgIf"
      },
      {
        "text": "link",
        "href": "guide/form-validation#creating-asynchronous-validators"
      },
      {
        "text": "AsyncValidatorFn",
        "href": "api/forms/AsyncValidatorFn"
      },
      {
        "text": "AsyncValidator",
        "href": "api/forms/AsyncValidator"
      },
      {
        "text": "ngModel",
        "href": "api/forms/NgModel"
      },
      {
        "text": "model",
        "href": "api/core/model"
      },
      {
        "text": "ngModel",
        "href": "api/forms/NgModel"
      },
      {
        "text": "ngIf",
        "href": "api/common/NgIf"
      },
      {
        "text": "link",
        "href": "guide/form-validation#implementing-a-custom-async-validator"
      },
      {
        "text": "AsyncValidator",
        "href": "api/forms/AsyncValidator"
      },
      {
        "text": "Injectable",
        "href": "api/core/Injectable"
      },
      {
        "text": "AsyncValidator",
        "href": "api/forms/AsyncValidator"
      },
      {
        "text": "AbstractControl",
        "href": "api/forms/AbstractControl"
      },
      {
        "text": "ValidationErrors",
        "href": "api/forms/ValidationErrors"
      },
      {
        "text": "ValidationErrors",
        "href": "api/forms/ValidationErrors"
      },
      {
        "text": "link",
        "href": "guide/form-validation#adding-async-validators-to-reactive-forms"
      },
      {
        "text": "FormControl",
        "href": "api/forms/FormControl"
      },
      {
        "text": "FormControl",
        "href": "api/forms/FormControl"
      },
      {
        "text": "AbstractControlOptions",
        "href": "api/forms/AbstractControlOptions"
      },
      {
        "text": "FormControl",
        "href": "api/forms/FormControl"
      },
      {
        "text": "link",
        "href": "guide/form-validation#adding-async-validators-to-template-driven-forms"
      },
      {
        "text": "NG_ASYNC_VALIDATORS",
        "href": "api/forms/NG_ASYNC_VALIDATORS"
      },
      {
        "text": "Directive",
        "href": "api/core/Directive"
      },
      {
        "text": "NG_ASYNC_VALIDATORS",
        "href": "api/forms/NG_ASYNC_VALIDATORS"
      },
      {
        "text": "forwardRef",
        "href": "api/core/forwardRef"
      },
      {
        "text": "AsyncValidator",
        "href": "api/forms/AsyncValidator"
      },
      {
        "text": "AbstractControl",
        "href": "api/forms/AbstractControl"
      },
      {
        "text": "ValidationErrors",
        "href": "api/forms/ValidationErrors"
      },
      {
        "text": "ngModel",
        "href": "api/forms/NgModel"
      },
      {
        "text": "ngModel",
        "href": "api/forms/NgModel"
      },
      {
        "text": "link",
        "href": "guide/form-validation#optimizing-performance-of-async-validators"
      },
      {
        "text": "ngModel",
        "href": "api/forms/NgModel"
      },
      {
        "text": "FormControl",
        "href": "api/forms/FormControl"
      },
      {
        "text": "FormControl",
        "href": "api/forms/FormControl"
      },
      {
        "text": "link",
        "href": "guide/form-validation#interaction-with-native-html-form-validation"
      },
      {
        "text": "native HTML form validation",
        "href": "https://developer.mozilla.org/docs/Web/Guide/HTML/Constraint_validation"
      },
      {
        "text": "API docs",
        "href": "api/forms/NgForm#native-dom-validation-ui"
      }
    ],
    "meta": {
      "description": "",
      "keywords": ""
    },
    "summary": "Validating form inputlink Contents PrerequisitesValidating input in template-driven formsValidating input in reactive formsValidator functionsBuilt-in validator functionsDefining custom validatorsAddi...",
    "tags": [
      "react",
      "vue",
      "angular",
      "javascript",
      "typescript",
      "css",
      "html",
      "formslink",
      "adding",
      "template"
    ],
    "id": "angular-formvalidation-part-1",
    "quality": 90
  },
  {
    "title": "Angular",
    "url": "https://v17.angular.io/guide/understanding-communicating-with-http",
    "category": "angular",
    "content": "Understanding communicating with backend services using HTTPlink Contents PrerequisitesHTTP client service featuresWhat's next Most front-end applications need to communicate with a server over the HTTP protocol, to download or upload data and access other back-end services. Angular provides a client HTTP API for Angular applications, the HttpClient service class in @angular/common/http. Prerequisiteslink Before working with the HttpClientModule, you should have a basic understanding of the following: TypeScript programming Usage of the HTTP protocol Angular application-design fundamentals, as described in Angular Concepts Observable techniques and operators. See the Observables guide. HTTP client service featureslink The HTTP client service offers the following major features. The ability to request typed response objects Streamlined error handling Testability features Request and response interception What's nextlink Setup for server communication Last reviewed on Wed Aug 16 2023",
    "headings": [
      {
        "level": 1,
        "text": "Understanding communicating with backend services using HTTPlink",
        "id": "understanding-communicating-with-backend-services-using-http"
      },
      {
        "level": 2,
        "text": "Prerequisiteslink",
        "id": "prerequisites"
      },
      {
        "level": 2,
        "text": "HTTP client service featureslink",
        "id": "http-client-service-features"
      },
      {
        "level": 2,
        "text": "What's nextlink",
        "id": "whats-next"
      }
    ],
    "codeBlocks": [
      {
        "language": "text",
        "code": "@angular/common/http"
      },
      {
        "language": "text",
        "code": "HttpClientModule"
      }
    ],
    "links": [
      {
        "text": "link",
        "href": "guide/understanding-communicating-with-http#understanding-communicating-with-backend-services-using-http"
      },
      {
        "text": "Prerequisites",
        "href": "guide/understanding-communicating-with-http#prerequisites"
      },
      {
        "text": "HTTP client service features",
        "href": "guide/understanding-communicating-with-http#http-client-service-features"
      },
      {
        "text": "What's next",
        "href": "guide/understanding-communicating-with-http#whats-next"
      },
      {
        "text": "HttpClient",
        "href": "api/common/http/HttpClient"
      },
      {
        "text": "http",
        "href": "api/common/http"
      },
      {
        "text": "link",
        "href": "guide/understanding-communicating-with-http#prerequisites"
      },
      {
        "text": "HttpClientModule",
        "href": "api/common/http/HttpClientModule"
      },
      {
        "text": "Angular Concepts",
        "href": "guide/architecture"
      },
      {
        "text": "Observables guide",
        "href": "guide/observables"
      },
      {
        "text": "link",
        "href": "guide/understanding-communicating-with-http#http-client-service-features"
      },
      {
        "text": "typed response objects",
        "href": "guide/http-request-data-from-server"
      },
      {
        "text": "error handling",
        "href": "guide/http-handle-request-errors"
      },
      {
        "text": "Testability",
        "href": "guide/http-test-requests"
      },
      {
        "text": "interception",
        "href": "guide/http-intercept-requests-and-responses"
      },
      {
        "text": "link",
        "href": "guide/understanding-communicating-with-http#whats-next"
      },
      {
        "text": "Setup for server communication",
        "href": "guide/http-setup-server-communication"
      }
    ],
    "meta": {
      "description": "",
      "keywords": ""
    },
    "summary": "Understanding communicating with backend services using HTTPlink Contents PrerequisitesHTTP client service featuresWhat's next Most front-end applications need to communicate with a server over the HT...",
    "tags": [
      "angular",
      "typescript",
      "node",
      "understanding",
      "communicating",
      "backend",
      "services"
    ],
    "id": "angular-understandingcommunicatingwithhttp",
    "quality": 90
  },
  {
    "title": "Angular",
    "url": "https://v17.angular.io/guide/router",
    "category": "angular",
    "content": "Common Routing Taskslink Contents Generate an applicationAdding components for routingImporting your new componentsDefining a basic routeRoute orderGetting route informationSetting up wildcard routesDisplaying a 404 pageSetting up redirectsNesting routesSetting the page titleUsing relative pathsSpecifying a relative routeAccessing query parameters and fragmentsLazy loadingPreventing unauthorized accessLink parameters arrayLocationStrategy and browser URL stylesChoosing a routing strategybase hrefHTML5 URLs and the base hrefHashLocationStrategy This topic describes how to implement many of the common tasks associated with adding the Angular router to your application. Generate an applicationlink The following command uses the Angular CLI to generate a basic Angular application with application routes. The application name in the following example is routing-app. content_copy ng new routing-app Adding components for routinglink To use the Angular router, an application needs to have at least two components so that it can navigate from one to the other. To create a component using the CLI, enter the following at the command line where first is the name of your component: content_copy ng generate component first Repeat this step for a second component but give it a different name. Here, the new name is second. content_copy ng generate component second The CLI automatically appends Component, so if you were to write first-component, your component would be FirstComponentComponent. This guide works with a CLI-generated Angular application. Importing your new componentslink To use your new components, import them into app.routes.ts at the top of the file, as follows: content_copy import {FirstComponent} from './first/first.component'; import {SecondComponent} from './second/second.component'; Defining a basic routelink There are three fundamental building blocks to creating a route. Import the routes into app.config.ts and add it to the provideRouter function. The Angular CLI performs this step for you. However, if you are creating an application manually or working with an existing, non-CLI application, verify that the imports and configuration are correct. The following is the default ApplicationConfig using the CLI. content_copy export const appConfig: ApplicationConfig = { providers: [provideRouter(routes)] }; Set up a Routes array for your routes The Angular CLI performs this step automatically. content_copy import { Routes } from '@angular/router'; export const routes: Routes = []; Define your routes in your Routes array. Each route in this array is a JavaScript object that contains two properties. The first property, path, defines the URL path for the route. The second property, component, defines the component Angular should use for the corresponding path. content_copy const routes: Routes = [ { path: 'first-component', component: FirstComponent }, { path: 'second-component', component: SecondComponent }, ]; Add your routes to your application. Now that you have defined your routes, add them to your application. First, add links to the two components. Assign the anchor tag that you want to add the route to the routerLink attribute. Set the value of the attribute to the component to show when a user clicks on each link. Next, update your component template to include router-outlet. This element informs Angular to update the application view with the component for the selected route. content_copy h1Angular Router App/h1 nav ul lia routerLink=\"/first-component\" routerLinkActive=\"active\" ariaCurrentWhenActive=\"page\"First Component/a/li lia routerLink=\"/second-component\" routerLinkActive=\"active\" ariaCurrentWhenActive=\"page\"Second Component/a/li /ul /nav !-- The routed views render in the router-outlet-- router-outlet/router-outlet You also need to add the RouterLink, RouterLinkActive, and RouterOutlet to the imports array of AppComponent. content_copy @Component({ selector: 'app-root', standalone: true, imports: [CommonModule, RouterOutlet, RouterLink, RouterLinkActive], templateUrl: './app.component.html', styleUrls: ['./app.component.css'] }) export class AppComponent { title = 'routing-app'; } Route orderlink The order of routes is important because the Router uses a first-match wins strategy when matching routes, so more specific routes should be placed above less specific routes. List routes with a static path first, followed by an empty path route, which matches the default route. The wildcard route comes last because it matches every URL and the Router selects it only if no other routes match first. Getting route informationlink Often, as a user navigates your application, you want to pass information from one component to another. For example, consider an application that displays a shopping list of grocery items. Each item in the list has a unique id. To edit an item, users click an Edit button, which opens an EditGroceryItem component. You want that component to retrieve the id for the grocery item so it can display the right information to the user. Use a route to pass this type of information to your application components. To do so, you use the withComponentInputBinding feature with provideRouter or the bindToComponentInputs option of RouterModule.forRoot. To get information from a route: Add the withComponentInputBinding feature to the provideRouter method. content_copy providers: [ provideRouter(appRoutes, withComponentInputBinding()), ] Update the component to have an Input matching the name of the parameter. content_copy @Input() set id(heroId: string) { this.hero$ = this.service.getHero(heroId); } NOTE: You can bind all route data with key, value pairs to component inputs: static or resolved route data, path parameters, matrix parameters, and query parameters. If you want to use the parent components route info you will need to set the router paramsInheritanceStrategy option: withRouterConfig({paramsInheritanceStrategy: 'always'}) Setting up wildcard routeslink A well-functioning application should gracefully handle when users attempt to navigate to a part of your application that does not exist. To add this functionality to your application, you set up a wildcard route. The Angular router selects this route any time the requested URL doesn't match any router paths. To set up a wildcard route, add the following code to your routes definition. content_copy { path: '**', component: PageNotFoundComponent } The two asterisks, **, indicate to Angular that this routes definition is a wildcard route. For the component property, you can define any component in your application. Common choices include an application-specific PageNotFoundComponent, which you can define to display a 404 page to your users; or a redirect to your application's main component. A wildcard route is the last route because it matches any URL. For more detail on why order matters for routes, see Route order. Displaying a 404 pagelink To display a 404 page, set up a wildcard route with the component property set to the component you'd like to use for your 404 page as follows: content_copy const routes: Routes = [ { path: 'first-component', component: FirstComponent }, { path: 'second-component', component: SecondComponent }, { path: '**', component: PageNotFoundComponent }, // Wildcard route for a 404 page ]; The last route with the path of ** is a wildcard route. The router selects this route if the requested URL doesn't match any of the paths earlier in the list and sends the user to the PageNotFoundComponent. Setting up redirectslink To set up a redirect, configure a route with the path you want to redirect from, the component you want to redirect to, and a pathMatch value that tells the router how to match the URL. content_copy const routes: Routes = [ { path: 'first-component', component: FirstComponent }, { path: 'second-component', component: SecondComponent }, { path: '', redirectTo: '/first-component', pathMatch: 'full' }, // redirect to first-component { path: '**', component: PageNotFoundComponent }, // Wildcard route for a 404 page ]; In this example, the third route is a redirect so that the router defaults to the first-component route. Notice that this redirect precedes the wildcard route. Here, path: '' means to use the initial relative URL (''). For more details on pathMatch see Spotlight on pathMatch. Nesting routeslink As your application grows more complex, you might want to create routes that are relative to a component other than your root component. These types of nested routes are called child routes. This means you're adding a second router-outlet to your app, because it is in addition to the router-outlet in AppComponent. In this example, there are two additional child components, child-a, and child-b. Here, FirstComponent has its own nav and a second router-outlet in addition to the one in AppComponent. content_copy h2First Component/h2 nav ul lia routerLink=\"child-a\"Child A/a/li lia routerLink=\"child-b\"Child B/a/li /ul /nav router-outlet/router-outlet A child route is like any other route, in that it needs both a path and a component. The one difference is that you place child routes in a children array within the parent route. content_copy const routes: Routes = [ { path: 'first-component', component: FirstComponent, // this is the component with the router-outlet in the template children: [ { path: 'child-a', // child route path component: ChildAComponent, // child route component that the router renders }, { path: 'child-b', component: ChildBComponent, // another child route component that the router renders }, ], }, ]; Setting the page titlelink Each page in your application should have a unique title so that they can be identified in the browser history. The Router sets the document's title using the title property from the Route config. content_copy const routes: Routes = [ { path: 'first-component', title: 'First component', component: FirstComponent, // this is the component with the router-outlet in the template children: [ { path: 'child-a', // child route path title: resolvedChildATitle, component: ChildAComponent, // child route component that the router renders }, { path: 'child-b', title: 'child b', component: ChildBComponent, // another child route component that the router renders }, ], }, ]; const resolvedChildATitle: ResolveFnstring = () = Promise.resolve('child a'); NOTE: The title property follows the same rules as static route data and dynamic values that implement ResolveFn. You can also provide a custom title strategy by extending the TitleStrategy. content_copy @Injectable({providedIn: 'root'}) export class TemplatePageTitleStrategy extends TitleStrategy { constructor(private readonly title: Title) { super(); } override updateTitle(routerState: RouterStateSnapshot) { const title = this.buildTitle(routerState); if (title !== undefined) { this.title.setTitle(My Application  ${title}); } } } export const appConfig: ApplicationConfig = { providers: [ provideRouter(routes), {provide: TitleStrategy, useClass: TemplatePageTitleStrategy}, ] }; Using relative pathslink Relative paths let you define paths that are relative to the current URL segment. The following example shows a relative route to another component, second-component. FirstComponent and SecondComponent are at the same level in the tree, however, the link to SecondComponent is situated within the FirstComponent, meaning that the router has to go up a level and then into the second directory to find the SecondComponent. Rather than writing out the whole path to get to SecondComponent, use the ../ notation to go up a level. content_copy h2First Component/h2 nav ul lia routerLink=\"../second-component\"Relative Route to second component/a/li /ul /nav router-outlet/router-outlet In addition to ../, use ./ or no leading slash to specify the current level. Specifying a relative routelink To specify a relative route, use the NavigationExtras relativeTo property. In the component class, import NavigationExtras from the @angular/router. Then use relativeTo in your navigation method. After the link parameters array, which here contains items, add an object with the relativeTo property set to the ActivatedRoute, which is this.route. content_copy goToItems() { this.router.navigate(['items'], { relativeTo: this.route }); } The navigate() arguments configure the router to use the current route as a basis upon which to append items. The goToItems() method interprets the destination URI as relative to the activated route and navigates to the items route. Accessing query parameters and fragmentslink Sometimes, a feature of your application requires accessing a part of a route, such as a query parameter or a fragment. The Tour of Heroes application at this stage in the tutorial uses a list view in which you can click on a hero to see details. The router uses an id to show the correct hero's details. First, import the following members in the component you want to navigate from. content_copy import { ActivatedRoute } from '@angular/router'; import { Observable } from 'rxjs'; import { switchMap } from 'rxjs/operators'; Next inject the activated route service: content_copy constructor(private route: ActivatedRoute) {} Configure the class so that you have an observable, heroes$, a selectedId to hold the id number of the hero, and the heroes in the ngOnInit(), add the following code to get the id of the selected hero. This code snippet assumes that you have a heroes list, a hero service, a function to get your heroes, and the HTML to render your list and details, just as in the Tour of Heroes example. content_copy heroes$: ObservableHero[]; selectedId: number; heroes = HEROES; ngOnInit() { this.heroes$ = this.route.paramMap.pipe( switchMap(params = { this.selectedId = Number(params.get('id')); return this.service.getHeroes(); }) ); } Next, in the component that you want to navigate to, import the following members. content_copy import { Router, ActivatedRoute, ParamMap } from '@angular/router'; import { Observable } from 'rxjs'; Inject ActivatedRoute and Router in the constructor of the component class so they are available to this component: content_copy hero$: ObservableHero; constructor( private route: ActivatedRoute, private router: Router ) {} ngOnInit() { const heroId = this.route.snapshot.paramMap.get('id'); this.hero$ = this.service.getHero(heroId); } gotoItems(hero: Hero) { const heroId = hero ? hero.id : null; // Pass along the hero id if available // so that the HeroList component can select that item. this.router.navigate(['/heroes', { id: heroId }]); } Lazy loadinglink You can configure your routes to be lazy loaded, which means that Angular only loads routes as needed, rather than loading all routes when the application launches. Additionally, preload parts of your application in the background to improve the user experience. For more information on lazy loading and preloading see the dedicated guide Lazy loading. Preventing unauthorized accesslink Use route guards to prevent users from navigating to parts of an application without authorization. The following route guards are available in Angular: canActivate canActivateChild canDeactivate canMatch resolve canLoad To use route guards, consider using component-less routes as this facilitates guarding child routes. Create a file for your guard: content_copy ng generate guard your-guard In your guard file, add the guard functions you want to use. The following example uses canActivateFn to guard the route. content_copy export const yourGuardFunction: CanActivateFn = ( next: ActivatedRouteSnapshot, state: RouterStateSnapshot) = { // your logic goes here } In your routing module, use the appropriate property in your routes configuration. Here, canActivate tells the router to mediate navigation to this particular route. content_copy { path: '/your-path', component: YourComponent, canActivate: [yourGuardFunction], } For more information with a working example, see the routing tutorial section on route guards. Link parameters arraylink A link parameters array holds the following ingredients for router navigation: The path of the route to the destination component Required and optional route parameters that go into the route URL Bind the RouterLink directive to such an array like this: content_copy a [routerLink]=\"['/heroes']\"Heroes/a The following is a two-element array when specifying a route parameter: content_copy a [routerLink]=\"['/hero', hero.id]\" span class=\"badge\"{{ hero.id }}/span{{ hero.name }} /a Provide optional route parameters in an object, as in { foo: 'foo' }: content_copy a [routerLink]=\"['/crisis-center', { foo: 'foo' }]\"Crisis Center/a These three examples cover the needs of an application with one level of routing. However, with a child router, such as in the crisis center, you create new link array possibilities. The following minimal RouterLink example builds upon a specified default child route for the crisis center. content_copy a [routerLink]=\"['/crisis-center']\"Crisis Center/a Review the following: The first item in the array identifies the parent route (/crisis-center) There are no parameters for this parent route There is no default for the child route so you need to pick one You're navigating to the CrisisListComponent, whose route path is /, but you don't need to explicitly add the slash Consider the following router link that navigates from the root of the application down to the Dragon Crisis: content_copy a [routerLink]=\"['/crisis-center', 1]\"Dragon Crisis/a The first item in the array identifies the parent route (/crisis-center) There are no parameters for this parent route The second item identifies the child route details about a particular crisis (/:id) The details child route requires an id route parameter You added the id of the Dragon Crisis as the second item in the array (1) The resulting path is /crisis-center/1 You could also redefine the AppComponent template with Crisis Center routes exclusively: content_copy template:  h1 class=\"title\"Angular Router/h1 nav a [routerLink]=\"['/crisis-center']\"Crisis Center/a a [routerLink]=\"['/crisis-center/1', { foo: 'foo' }]\"Dragon Crisis/a a [routerLink]=\"['/crisis-center/2']\"Shark Crisis/a /nav router-outlet/router-outlet  In summary, you can write applications with one, two or more levels of routing. The link parameters array affords the flexibility to represent any routing depth and any legal sequence of route paths, (required) router parameters, and (optional) route parameter objects. LocationStrategy and browser URL styleslink When the router navigates to a new component view, it updates the browser's location and history with a URL for that view. Modern HTML5 browsers support history.pushState, a technique that changes a browser's location and history without triggering a server page request. The router can compose a \"natural\" URL that is indistinguishable from one that would otherwise require a page load. Here's the Crisis Center URL in this \"HTML5 pushState\" style: content_copy localhost:3002/crisis-center Older browsers send page requests to the server when the location URL changes unless the change occurs after a \"#\" (called the \"hash\"). Routers can take advantage of this exception by composing in-application route URLs with hashes. Here's a \"hash URL\" that routes to the Crisis Center. content_copy localhost:3002/src/#/crisis-center The router supports both styles with two LocationStrategy providers: Providers Details PathLocationStrategy The default \"HTML5 pushState\" style. HashLocationStrategy The \"hash URL\" style. The provideRouter function sets the LocationStrategy to the PathLocationStrategy, which makes it the default strategy. You also have the option of switching to the HashLocationStrategy with an override during the bootstrapping process. For more information on providers and the bootstrap process, see Dependency Injection. Choosing a routing strategylink You must choose a routing strategy early in the development of your project because once the application is in production, visitors to your site use and depend on application URL references. Almost all Angular projects should use the default HTML5 style. It produces URLs that are easier for users to understand and it preserves the option to do server-side rendering. Rendering critical pages on the server is a technique that can greatly improve perceived responsiveness when the application first loads. An application that would otherwise take ten or more seconds to start could be rendered on the server and delivered to the user's device in less than a second. This option is only available if application URLs look like normal web URLs without hash (#) characters in the middle. base hreflink The router uses the browser's history.pushState for navigation. pushState lets you customize in-application URL paths; for example, localhost:4200/crisis-center. The in-application URLs can be indistinguishable from server URLs. Modern HTML5 browsers were the first to support pushState which is why many people refer to these URLs as \"HTML5 style\" URLs. HTML5 style navigation is the router default. In the LocationStrategy and browser URL styles section, learn why HTML5 style is preferable, how to adjust its behavior, and how to switch to the older hash (#) style, if necessary. You must add a base href element to the application's index.html for pushState routing to work. The browser uses the base href value to prefix relative URLs when referencing CSS files, scripts, and images. Add the base element just after the head tag. If the app folder is the application root, as it is for this application, set the href value in index.html as shown here. content_copy base href=\"/\" HTML5 URLs and the base hreflink The guidelines that follow will refer to different parts of a URL. This diagram outlines what those parts refer to: foo://example.com:8042/over/there?name=ferret#nose _/ ______________/_________/ _________/ __/      scheme authority path query fragment While the router uses the HTML5 pushState style by default, you must configure that strategy with a base href. The preferred way to configure the strategy is to add a base href element tag in the head of the index.html. content_copy base href=\"/\" Without that tag, the browser might not be able to load resources (images, CSS, scripts) when \"deep linking\" into the application. Some developers might not be able to add the base element, perhaps because they don't have access to head or the index.html. Those developers can still use HTML5 URLs by taking the following two steps: Provide the router with an appropriate APP_BASE_HREF value. Use root URLs (URLs with an authority) for all web resources: CSS, images, scripts, and template HTML files. The base href path should end with a \"/\", as browsers ignore characters in the path that follow the right-most \"/\" If the base href includes a query part, the query is only used if the path of a link in the page is empty and has no query. This means that a query in the base href is only included when using HashLocationStrategy. If a link in the page is a root URL (has an authority), the base href is not used. In this way, an APP_BASE_HREF with an authority will cause all links created by Angular to ignore the base href value. A fragment in the base href is never persisted For more complete information on how base href is used to construct target URIs, see the RFC section on transforming references. HashLocationStrategylink Use HashLocationStrategy by adding the withHashLocation feature to the provideRouter function of the provideRouter in the ApplicationConfiguration. content_copy providers: [ provideRouter(appRoutes, withHashLocation()) ] When using RouterModule.forRoot, this is configured with the useHash: true in the second argument: RouterModule.forRoot(routes, {useHash: true}). Last reviewed on Tue Oct 24 2023",
    "headings": [
      {
        "level": 1,
        "text": "Common Routing Taskslink",
        "id": "common-routing-tasks"
      },
      {
        "level": 2,
        "text": "Generate an applicationlink",
        "id": "generate-an-application"
      },
      {
        "level": 2,
        "text": "Defining a basic routelink",
        "id": "defining-a-basic-route"
      },
      {
        "level": 2,
        "text": "Getting route informationlink",
        "id": "getting-route-information"
      },
      {
        "level": 2,
        "text": "Setting up wildcard routeslink",
        "id": "setting-up-wildcard-routes"
      },
      {
        "level": 2,
        "text": "Displaying a 404 pagelink",
        "id": "displaying-a-404-page"
      },
      {
        "level": 2,
        "text": "Setting up redirectslink",
        "id": "setting-up-redirects"
      },
      {
        "level": 2,
        "text": "Nesting routeslink",
        "id": "nesting-routes"
      },
      {
        "level": 2,
        "text": "Setting the page titlelink",
        "id": "setting-the-page-title"
      },
      {
        "level": 2,
        "text": "Using relative pathslink",
        "id": "using-relative-paths"
      },
      {
        "level": 2,
        "text": "Accessing query parameters and fragmentslink",
        "id": "accessing-query-parameters-and-fragments"
      },
      {
        "level": 2,
        "text": "Lazy loadinglink",
        "id": "lazy-loading"
      },
      {
        "level": 2,
        "text": "Preventing unauthorized accesslink",
        "id": "preventing-unauthorized-access"
      },
      {
        "level": 2,
        "text": "Link parameters arraylink",
        "id": "link-parameters-array"
      },
      {
        "level": 2,
        "text": "LocationStrategy and browser URL styleslink",
        "id": "locationstrategy-and-browser-url-styles"
      },
      {
        "level": 2,
        "text": "Choosing a routing strategylink",
        "id": "choosing-a-routing-strategy"
      },
      {
        "level": 2,
        "text": "<base href>link",
        "id": "base-href"
      },
      {
        "level": 3,
        "text": "Adding components for routinglink",
        "id": "adding-components-for-routing"
      },
      {
        "level": 3,
        "text": "Importing your new componentslink",
        "id": "importing-your-new-components"
      },
      {
        "level": 3,
        "text": "Route orderlink",
        "id": "route-order"
      },
      {
        "level": 3,
        "text": "Specifying a relative routelink",
        "id": "specifying-a-relative-route"
      },
      {
        "level": 3,
        "text": "HTML5 URLs and the <base href>link",
        "id": "html5-urls-and-the-base-href"
      },
      {
        "level": 3,
        "text": "HashLocationStrategylink",
        "id": "hashlocationstrategy"
      }
    ],
    "codeBlocks": [
      {
        "language": "text",
        "code": "LocationStrategy"
      },
      {
        "language": "text",
        "code": "<base href>"
      },
      {
        "language": "text",
        "code": "<base href>"
      },
      {
        "language": "text",
        "code": "HashLocationStrategy"
      },
      {
        "language": "text",
        "code": "routing-app"
      },
      {
        "language": "text",
        "code": "content_copy\n      \n      ng new routing-app"
      },
      {
        "language": "text",
        "code": "ng new routing-app"
      },
      {
        "language": "text",
        "code": "content_copy\n      \n      ng generate component first"
      },
      {
        "language": "text",
        "code": "ng generate component first"
      },
      {
        "language": "text",
        "code": "content_copy\n      \n      ng generate component second"
      },
      {
        "language": "text",
        "code": "ng generate component second"
      },
      {
        "language": "text",
        "code": "first-component"
      },
      {
        "language": "text",
        "code": "FirstComponentComponent"
      },
      {
        "language": "text",
        "code": "app.routes.ts"
      },
      {
        "language": "text",
        "code": "content_copy\n      \n      import {FirstComponent} from './first/first.component';\nimport {SecondComponent} from './second/second.component';"
      },
      {
        "language": "text",
        "code": "import {FirstComponent} from './first/first.component';\nimport {SecondComponent} from './second/second.component';"
      },
      {
        "language": "text",
        "code": "app.config.ts"
      },
      {
        "language": "text",
        "code": "provideRouter"
      },
      {
        "language": "text",
        "code": "ApplicationConfig"
      },
      {
        "language": "text",
        "code": "content_copy\n      \n      export const appConfig: ApplicationConfig = {\n  providers: [provideRouter(routes)]\n};"
      },
      {
        "language": "text",
        "code": "export const appConfig: ApplicationConfig = {\n  providers: [provideRouter(routes)]\n};"
      },
      {
        "language": "text",
        "code": "content_copy\n      \n      import { Routes } from '@angular/router';\n\nexport const routes: Routes = [];"
      },
      {
        "language": "text",
        "code": "import { Routes } from '@angular/router';\n\nexport const routes: Routes = [];"
      },
      {
        "language": "text",
        "code": "content_copy\n      \n      const routes: Routes = [\n  { path: 'first-component', component: FirstComponent },\n  { path: 'second-component', component: SecondComponent },\n];"
      },
      {
        "language": "text",
        "code": "const routes: Routes = [\n  { path: 'first-component', component: FirstComponent },\n  { path: 'second-component', component: SecondComponent },\n];"
      },
      {
        "language": "text",
        "code": "<router-outlet>"
      },
      {
        "language": "text",
        "code": "content_copy\n      \n      <h1>Angular Router App</h1>\n<nav>\n  <ul>\n    <li><a routerLink=\"/first-component\" routerLinkActive=\"active\" ariaCurrentWhenActive=\"page\">First Component</a></li>\n    <li><a routerLink=\"/second-component\" routerLinkActive=\"active\" ariaCurrentWhenActive=\"page\">Second Component</a></li>\n  </ul>\n</nav>\n<!-- The routed views render in the <router-outlet>-->\n<router-outlet></router-outlet>"
      },
      {
        "language": "text",
        "code": "<h1>Angular Router App</h1>\n<nav>\n  <ul>\n    <li><a routerLink=\"/first-component\" routerLinkActive=\"active\" ariaCurrentWhenActive=\"page\">First Component</a></li>\n    <li><a routerLink=\"/second-component\" routerLinkActive=\"active\" ariaCurrentWhenActive=\"page\">Second Component</a></li>\n  </ul>\n</nav>\n<!-- The routed views render in the <router-outlet>-->\n<router-outlet></router-outlet>"
      },
      {
        "language": "text",
        "code": "RouterLinkActive"
      },
      {
        "language": "text",
        "code": "RouterOutlet"
      },
      {
        "language": "text",
        "code": "AppComponent"
      },
      {
        "language": "text",
        "code": "content_copy\n      \n      @Component({\n  selector: 'app-root',\n  standalone: true,\n  imports: [CommonModule, RouterOutlet, RouterLink, RouterLinkActive],\n  templateUrl: './app.component.html',\n  styleUrls: ['./app.component.css']\n})\nexport class AppComponent {\n  title = 'routing-app';\n}"
      },
      {
        "language": "text",
        "code": "@Component({\n  selector: 'app-root',\n  standalone: true,\n  imports: [CommonModule, RouterOutlet, RouterLink, RouterLinkActive],\n  templateUrl: './app.component.html',\n  styleUrls: ['./app.component.css']\n})\nexport class AppComponent {\n  title = 'routing-app';\n}"
      },
      {
        "language": "text",
        "code": "EditGroceryItem"
      },
      {
        "language": "text",
        "code": "provideRouter"
      },
      {
        "language": "text",
        "code": "bindToComponentInputs"
      },
      {
        "language": "text",
        "code": "RouterModule.forRoot"
      },
      {
        "language": "text",
        "code": "withComponentInputBinding"
      },
      {
        "language": "text",
        "code": "provideRouter"
      },
      {
        "language": "text",
        "code": "content_copy\n      \n      providers: [\n  provideRouter(appRoutes, withComponentInputBinding()),\n]"
      },
      {
        "language": "text",
        "code": "providers: [\n  provideRouter(appRoutes, withComponentInputBinding()),\n]"
      },
      {
        "language": "text",
        "code": "content_copy\n      \n      @Input()\nset id(heroId: string) {\n  this.hero$ = this.service.getHero(heroId);\n}"
      },
      {
        "language": "text",
        "code": "@Input()\nset id(heroId: string) {\n  this.hero$ = this.service.getHero(heroId);\n}"
      },
      {
        "language": "text",
        "code": "paramsInheritanceStrategy"
      },
      {
        "language": "text",
        "code": "withRouterConfig({paramsInheritanceStrategy: 'always'})"
      },
      {
        "language": "text",
        "code": "content_copy\n      \n      { path: '**', component: PageNotFoundComponent }"
      },
      {
        "language": "text",
        "code": "{ path: '**', component: PageNotFoundComponent }"
      },
      {
        "language": "text",
        "code": "PageNotFoundComponent"
      },
      {
        "language": "text",
        "code": "content_copy\n      \n      const routes: Routes = [\n  { path: 'first-component', component: FirstComponent },\n  { path: 'second-component', component: SecondComponent },\n  { path: '**', component: PageNotFoundComponent },  // Wildcard route for a 404 page\n];"
      },
      {
        "language": "text",
        "code": "const routes: Routes = [\n  { path: 'first-component', component: FirstComponent },\n  { path: 'second-component', component: SecondComponent },\n  { path: '**', component: PageNotFoundComponent },  // Wildcard route for a 404 page\n];"
      },
      {
        "language": "text",
        "code": "PageNotFoundComponent"
      },
      {
        "language": "text",
        "code": "content_copy\n      \n      const routes: Routes = [\n  { path: 'first-component', component: FirstComponent },\n  { path: 'second-component', component: SecondComponent },\n  { path: '',   redirectTo: '/first-component', pathMatch: 'full' }, // redirect to `first-component`\n  { path: '**', component: PageNotFoundComponent },  // Wildcard route for a 404 page\n];"
      },
      {
        "language": "text",
        "code": "const routes: Routes = [\n  { path: 'first-component', component: FirstComponent },\n  { path: 'second-component', component: SecondComponent },\n  { path: '',   redirectTo: '/first-component', pathMatch: 'full' }, // redirect to `first-component`\n  { path: '**', component: PageNotFoundComponent },  // Wildcard route for a 404 page\n];"
      },
      {
        "language": "text",
        "code": "first-component"
      },
      {
        "language": "text",
        "code": "<router-outlet>"
      },
      {
        "language": "text",
        "code": "<router-outlet>"
      },
      {
        "language": "text",
        "code": "AppComponent"
      },
      {
        "language": "text",
        "code": "FirstComponent"
      },
      {
        "language": "text",
        "code": "<router-outlet>"
      },
      {
        "language": "text",
        "code": "AppComponent"
      },
      {
        "language": "text",
        "code": "content_copy\n      \n      <h2>First Component</h2>\n\n<nav>\n  <ul>\n    <li><a routerLink=\"child-a\">Child A</a></li>\n    <li><a routerLink=\"child-b\">Child B</a></li>\n  </ul>\n</nav>\n\n<router-outlet></router-outlet>"
      },
      {
        "language": "text",
        "code": "<h2>First Component</h2>\n\n<nav>\n  <ul>\n    <li><a routerLink=\"child-a\">Child A</a></li>\n    <li><a routerLink=\"child-b\">Child B</a></li>\n  </ul>\n</nav>\n\n<router-outlet></router-outlet>"
      },
      {
        "language": "text",
        "code": "content_copy\n      \n      const routes: Routes = [\n  {\n    path: 'first-component',\n    component: FirstComponent, // this is the component with the <router-outlet> in the template\n    children: [\n      {\n        path: 'child-a', // child route path\n        component: ChildAComponent, // child route component that the router renders\n      },\n      {\n        path: 'child-b',\n        component: ChildBComponent, // another child route component that the router renders\n      },\n    ],\n  },\n];"
      },
      {
        "language": "text",
        "code": "const routes: Routes = [\n  {\n    path: 'first-component',\n    component: FirstComponent, // this is the component with the <router-outlet> in the template\n    children: [\n      {\n        path: 'child-a', // child route path\n        component: ChildAComponent, // child route component that the router renders\n      },\n      {\n        path: 'child-b',\n        component: ChildBComponent, // another child route component that the router renders\n      },\n    ],\n  },\n];"
      },
      {
        "language": "text",
        "code": "content_copy\n      \n      const routes: Routes = [\n  {\n    path: 'first-component',\n    title: 'First component',\n    component: FirstComponent,  // this is the component with the <router-outlet> in the template\n    children: [\n      {\n        path: 'child-a',  // child route path\n        title: resolvedChildATitle,\n        component: ChildAComponent,  // child route component that the router renders\n      },\n      {\n        path: 'child-b',\n        title: 'child b',\n        component: ChildBComponent,  // another child route component that the router renders\n      },\n    ],\n  },\n];\n\nconst resolvedChildATitle: ResolveFn<string> = () => Promise.resolve('child a');"
      },
      {
        "language": "text",
        "code": "const routes: Routes = [\n  {\n    path: 'first-component',\n    title: 'First component',\n    component: FirstComponent,  // this is the component with the <router-outlet> in the template\n    children: [\n      {\n        path: 'child-a',  // child route path\n        title: resolvedChildATitle,\n        component: ChildAComponent,  // child route component that the router renders\n      },\n      {\n        path: 'child-b',\n        title: 'child b',\n        component: ChildBComponent,  // another child route component that the router renders\n      },\n    ],\n  },\n];\n\nconst resolvedChildATitle: ResolveFn<string> = () => Promise.resolve('child a');"
      },
      {
        "language": "text",
        "code": "TitleStrategy"
      },
      {
        "language": "text",
        "code": "content_copy\n      \n      @Injectable({providedIn: 'root'})\nexport class TemplatePageTitleStrategy extends TitleStrategy {\n  constructor(private readonly title: Title) {\n    super();\n  }\n\n  override updateTitle(routerState: RouterStateSnapshot) {\n    const title = this.buildTitle(routerState);\n    if (title !== undefined) {\n      this.title.setTitle(`My Application | ${title}`);\n    }\n  }\n}\n\n\nexport const appConfig: ApplicationConfig = {\n  providers: [\n    provideRouter(routes),\n    {provide: TitleStrategy, useClass: TemplatePageTitleStrategy},\n  ]\n};"
      },
      {
        "language": "text",
        "code": "@Injectable({providedIn: 'root'})\nexport class TemplatePageTitleStrategy extends TitleStrategy {\n  constructor(private readonly title: Title) {\n    super();\n  }\n\n  override updateTitle(routerState: RouterStateSnapshot) {\n    const title = this.buildTitle(routerState);\n    if (title !== undefined) {\n      this.title.setTitle(`My Application | ${title}`);\n    }\n  }\n}\n\n\nexport const appConfig: ApplicationConfig = {\n  providers: [\n    provideRouter(routes),\n    {provide: TitleStrategy, useClass: TemplatePageTitleStrategy},\n  ]\n};"
      },
      {
        "language": "text",
        "code": "second-component"
      },
      {
        "language": "text",
        "code": "FirstComponent"
      },
      {
        "language": "text",
        "code": "SecondComponent"
      },
      {
        "language": "text",
        "code": "SecondComponent"
      },
      {
        "language": "text",
        "code": "FirstComponent"
      },
      {
        "language": "text",
        "code": "SecondComponent"
      },
      {
        "language": "text",
        "code": "SecondComponent"
      },
      {
        "language": "text",
        "code": "content_copy\n      \n      <h2>First Component</h2>\n\n<nav>\n  <ul>\n    <li><a routerLink=\"../second-component\">Relative Route to second component</a></li>\n  </ul>\n</nav>\n<router-outlet></router-outlet>"
      },
      {
        "language": "text",
        "code": "<h2>First Component</h2>\n\n<nav>\n  <ul>\n    <li><a routerLink=\"../second-component\">Relative Route to second component</a></li>\n  </ul>\n</nav>\n<router-outlet></router-outlet>"
      },
      {
        "language": "text",
        "code": "NavigationExtras"
      },
      {
        "language": "text",
        "code": "NavigationExtras"
      },
      {
        "language": "text",
        "code": "@angular/router"
      },
      {
        "language": "text",
        "code": "ActivatedRoute"
      },
      {
        "language": "text",
        "code": "content_copy\n      \n      goToItems() {\n  this.router.navigate(['items'], { relativeTo: this.route });\n}"
      },
      {
        "language": "text",
        "code": "goToItems() {\n  this.router.navigate(['items'], { relativeTo: this.route });\n}"
      },
      {
        "language": "text",
        "code": "goToItems()"
      },
      {
        "language": "text",
        "code": "content_copy\n      \n      import { ActivatedRoute } from '@angular/router';\nimport { Observable } from 'rxjs';\nimport { switchMap } from 'rxjs/operators';"
      },
      {
        "language": "text",
        "code": "import { ActivatedRoute } from '@angular/router';\nimport { Observable } from 'rxjs';\nimport { switchMap } from 'rxjs/operators';"
      },
      {
        "language": "text",
        "code": "content_copy\n      \n      constructor(private route: ActivatedRoute) {}"
      },
      {
        "language": "text",
        "code": "constructor(private route: ActivatedRoute) {}"
      },
      {
        "language": "text",
        "code": "content_copy\n      \n      heroes$: Observable<Hero[]>;\nselectedId: number;\nheroes = HEROES;\n\nngOnInit() {\n  this.heroes$ = this.route.paramMap.pipe(\n    switchMap(params => {\n      this.selectedId = Number(params.get('id'));\n      return this.service.getHeroes();\n    })\n  );\n}"
      },
      {
        "language": "text",
        "code": "heroes$: Observable<Hero[]>;\nselectedId: number;\nheroes = HEROES;\n\nngOnInit() {\n  this.heroes$ = this.route.paramMap.pipe(\n    switchMap(params => {\n      this.selectedId = Number(params.get('id'));\n      return this.service.getHeroes();\n    })\n  );\n}"
      },
      {
        "language": "text",
        "code": "content_copy\n      \n      import { Router, ActivatedRoute, ParamMap } from '@angular/router';\nimport { Observable } from 'rxjs';"
      },
      {
        "language": "text",
        "code": "import { Router, ActivatedRoute, ParamMap } from '@angular/router';\nimport { Observable } from 'rxjs';"
      },
      {
        "language": "text",
        "code": "ActivatedRoute"
      },
      {
        "language": "text",
        "code": "content_copy\n      \n      hero$: Observable<Hero>;\n\nconstructor(\n  private route: ActivatedRoute,\n  private router: Router  ) {}\n\nngOnInit() {\n  const heroId = this.route.snapshot.paramMap.get('id');\n  this.hero$ = this.service.getHero(heroId);\n}\n\ngotoItems(hero: Hero) {\n  const heroId = hero ? hero.id : null;\n  // Pass along the hero id if available\n  // so that the HeroList component can select that item.\n  this.router.navigate(['/heroes', { id: heroId }]);\n}"
      },
      {
        "language": "text",
        "code": "hero$: Observable<Hero>;\n\nconstructor(\n  private route: ActivatedRoute,\n  private router: Router  ) {}\n\nngOnInit() {\n  const heroId = this.route.snapshot.paramMap.get('id');\n  this.hero$ = this.service.getHero(heroId);\n}\n\ngotoItems(hero: Hero) {\n  const heroId = hero ? hero.id : null;\n  // Pass along the hero id if available\n  // so that the HeroList component can select that item.\n  this.router.navigate(['/heroes', { id: heroId }]);\n}"
      },
      {
        "language": "text",
        "code": "canActivate"
      },
      {
        "language": "text",
        "code": "canActivateChild"
      },
      {
        "language": "text",
        "code": "canDeactivate"
      },
      {
        "language": "text",
        "code": "content_copy\n      \n      ng generate guard your-guard"
      },
      {
        "language": "text",
        "code": "ng generate guard your-guard"
      },
      {
        "language": "text",
        "code": "canActivateFn"
      },
      {
        "language": "text",
        "code": "content_copy\n      \n      export const yourGuardFunction: CanActivateFn = (\n    next: ActivatedRouteSnapshot,\n    state: RouterStateSnapshot) => {\n      // your  logic goes here\n  }"
      },
      {
        "language": "text",
        "code": "export const yourGuardFunction: CanActivateFn = (\n    next: ActivatedRouteSnapshot,\n    state: RouterStateSnapshot) => {\n      // your  logic goes here\n  }"
      },
      {
        "language": "text",
        "code": "canActivate"
      },
      {
        "language": "text",
        "code": "content_copy\n      \n      {\npath: '/your-path',\ncomponent: YourComponent,\ncanActivate: [yourGuardFunction],\n}"
      },
      {
        "language": "text",
        "code": "{\npath: '/your-path',\ncomponent: YourComponent,\ncanActivate: [yourGuardFunction],\n}"
      },
      {
        "language": "text",
        "code": "content_copy\n      \n      <a [routerLink]=\"['/heroes']\">Heroes</a>"
      },
      {
        "language": "text",
        "code": "<a [routerLink]=\"['/heroes']\">Heroes</a>"
      },
      {
        "language": "text",
        "code": "content_copy\n      \n      <a [routerLink]=\"['/hero', hero.id]\">\n  <span class=\"badge\">{{ hero.id }}</span>{{ hero.name }}\n</a>"
      },
      {
        "language": "text",
        "code": "<a [routerLink]=\"['/hero', hero.id]\">\n  <span class=\"badge\">{{ hero.id }}</span>{{ hero.name }}\n</a>"
      },
      {
        "language": "text",
        "code": "{ foo: 'foo' }"
      },
      {
        "language": "text",
        "code": "content_copy\n      \n      <a [routerLink]=\"['/crisis-center', { foo: 'foo' }]\">Crisis Center</a>"
      },
      {
        "language": "text",
        "code": "<a [routerLink]=\"['/crisis-center', { foo: 'foo' }]\">Crisis Center</a>"
      },
      {
        "language": "text",
        "code": "content_copy\n      \n      <a [routerLink]=\"['/crisis-center']\">Crisis Center</a>"
      },
      {
        "language": "text",
        "code": "<a [routerLink]=\"['/crisis-center']\">Crisis Center</a>"
      },
      {
        "language": "text",
        "code": "/crisis-center"
      },
      {
        "language": "text",
        "code": "CrisisListComponent"
      },
      {
        "language": "text",
        "code": "content_copy\n      \n      <a [routerLink]=\"['/crisis-center', 1]\">Dragon Crisis</a>"
      },
      {
        "language": "text",
        "code": "<a [routerLink]=\"['/crisis-center', 1]\">Dragon Crisis</a>"
      },
      {
        "language": "text",
        "code": "/crisis-center"
      },
      {
        "language": "text",
        "code": "/crisis-center/1"
      },
      {
        "language": "text",
        "code": "AppComponent"
      },
      {
        "language": "text",
        "code": "content_copy\n      \n      template: `\n  <h1 class=\"title\">Angular Router</h1>\n  <nav>\n    <a [routerLink]=\"['/crisis-center']\">Crisis Center</a>\n    <a [routerLink]=\"['/crisis-center/1', { foo: 'foo' }]\">Dragon Crisis</a>\n    <a [routerLink]=\"['/crisis-center/2']\">Shark Crisis</a>\n  </nav>\n  <router-outlet></router-outlet>\n`"
      },
      {
        "language": "text",
        "code": "template: `\n  <h1 class=\"title\">Angular Router</h1>\n  <nav>\n    <a [routerLink]=\"['/crisis-center']\">Crisis Center</a>\n    <a [routerLink]=\"['/crisis-center/1', { foo: 'foo' }]\">Dragon Crisis</a>\n    <a [routerLink]=\"['/crisis-center/2']\">Shark Crisis</a>\n  </nav>\n  <router-outlet></router-outlet>\n`"
      },
      {
        "language": "text",
        "code": "LocationStrategy"
      },
      {
        "language": "text",
        "code": "content_copy\n      \n      localhost:3002/crisis-center"
      },
      {
        "language": "text",
        "code": "localhost:3002/crisis-center"
      },
      {
        "language": "text",
        "code": "content_copy\n      \n      localhost:3002/src/#/crisis-center"
      },
      {
        "language": "text",
        "code": "localhost:3002/src/#/crisis-center"
      },
      {
        "language": "text",
        "code": "LocationStrategy"
      },
      {
        "language": "text",
        "code": "PathLocationStrategy"
      },
      {
        "language": "text",
        "code": "HashLocationStrategy"
      },
      {
        "language": "text",
        "code": "provideRouter"
      },
      {
        "language": "text",
        "code": "LocationStrategy"
      },
      {
        "language": "text",
        "code": "PathLocationStrategy"
      },
      {
        "language": "text",
        "code": "HashLocationStrategy"
      },
      {
        "language": "text",
        "code": "<base href>"
      },
      {
        "language": "text",
        "code": "localhost:4200/crisis-center"
      },
      {
        "language": "text",
        "code": "<base href>"
      },
      {
        "language": "text",
        "code": "<base href>"
      },
      {
        "language": "text",
        "code": "content_copy\n      \n      <base href=\"/\">"
      },
      {
        "language": "text",
        "code": "<base href=\"/\">"
      },
      {
        "language": "text",
        "code": "<base href>"
      },
      {
        "language": "text",
        "code": "foo://example.com:8042/over/there?name=ferret#nose\n\\_/   \\______________/\\_________/ \\_________/ \\__/\n |           |            |            |        |\nscheme    authority      path        query   fragment"
      },
      {
        "language": "text",
        "code": "foo://example.com:8042/over/there?name=ferret#nose\n\\_/   \\______________/\\_________/ \\_________/ \\__/\n |           |            |            |        |\nscheme    authority      path        query   fragment"
      },
      {
        "language": "text",
        "code": "<base href>"
      },
      {
        "language": "text",
        "code": "<base href>"
      },
      {
        "language": "text",
        "code": "content_copy\n      \n      <base href=\"/\">"
      },
      {
        "language": "text",
        "code": "<base href=\"/\">"
      },
      {
        "language": "text",
        "code": "APP_BASE_HREF"
      },
      {
        "language": "text",
        "code": "<base href>"
      },
      {
        "language": "text",
        "code": "<base href>"
      },
      {
        "language": "text",
        "code": "<base href>"
      },
      {
        "language": "text",
        "code": "HashLocationStrategy"
      },
      {
        "language": "text",
        "code": "<base href>"
      },
      {
        "language": "text",
        "code": "APP_BASE_HREF"
      },
      {
        "language": "text",
        "code": "<base href>"
      },
      {
        "language": "text",
        "code": "<base href>"
      },
      {
        "language": "text",
        "code": "<base href>"
      },
      {
        "language": "text",
        "code": "HashLocationStrategy"
      },
      {
        "language": "text",
        "code": "HashLocationStrategy"
      },
      {
        "language": "text",
        "code": "withHashLocation"
      },
      {
        "language": "text",
        "code": "provideRouter"
      },
      {
        "language": "text",
        "code": "provideRouter"
      },
      {
        "language": "text",
        "code": "ApplicationConfiguration"
      },
      {
        "language": "text",
        "code": "content_copy\n      \n      providers: [\n  provideRouter(appRoutes, withHashLocation())\n]"
      },
      {
        "language": "text",
        "code": "providers: [\n  provideRouter(appRoutes, withHashLocation())\n]"
      },
      {
        "language": "text",
        "code": "RouterModule.forRoot"
      },
      {
        "language": "text",
        "code": "useHash: true"
      },
      {
        "language": "text",
        "code": "RouterModule.forRoot(routes, {useHash: true})"
      }
    ],
    "links": [
      {
        "text": "link",
        "href": "guide/router#common-routing-tasks"
      },
      {
        "text": "Generate an application",
        "href": "guide/router#generate-an-application"
      },
      {
        "text": "Adding components for routing",
        "href": "guide/router#adding-components-for-routing"
      },
      {
        "text": "Importing your new components",
        "href": "guide/router#importing-your-new-components"
      },
      {
        "text": "Defining a basic route",
        "href": "guide/router#defining-a-basic-route"
      },
      {
        "text": "Route order",
        "href": "guide/router#route-order"
      },
      {
        "text": "Getting route information",
        "href": "guide/router#getting-route-information"
      },
      {
        "text": "Setting up wildcard routes",
        "href": "guide/router#setting-up-wildcard-routes"
      },
      {
        "text": "Displaying a 404 page",
        "href": "guide/router#displaying-a-404-page"
      },
      {
        "text": "Setting up redirects",
        "href": "guide/router#setting-up-redirects"
      },
      {
        "text": "Nesting routes",
        "href": "guide/router#nesting-routes"
      },
      {
        "text": "Setting the page title",
        "href": "guide/router#setting-the-page-title"
      },
      {
        "text": "Using relative paths",
        "href": "guide/router#using-relative-paths"
      },
      {
        "text": "Specifying a relative route",
        "href": "guide/router#specifying-a-relative-route"
      },
      {
        "text": "Accessing query parameters and fragments",
        "href": "guide/router#accessing-query-parameters-and-fragments"
      },
      {
        "text": "Lazy loading",
        "href": "guide/router#lazy-loading"
      },
      {
        "text": "Preventing unauthorized access",
        "href": "guide/router#preventing-unauthorized-access"
      },
      {
        "text": "Link parameters array",
        "href": "guide/router#link-parameters-array"
      },
      {
        "text": "LocationStrategy and browser URL styles",
        "href": "guide/router#locationstrategy-and-browser-url-styles"
      },
      {
        "text": "Choosing a routing strategy",
        "href": "guide/router#choosing-a-routing-strategy"
      },
      {
        "text": "<base href>",
        "href": "guide/router#base-href"
      },
      {
        "text": "HTML5 URLs and the <base href>",
        "href": "guide/router#html5-urls-and-the-base-href"
      },
      {
        "text": "HashLocationStrategy",
        "href": "guide/router#hashlocationstrategy"
      },
      {
        "text": "link",
        "href": "guide/router#generate-an-application"
      },
      {
        "text": "link",
        "href": "guide/router#adding-components-for-routing"
      },
      {
        "text": "Component",
        "href": "api/core/Component"
      },
      {
        "text": "link",
        "href": "guide/router#importing-your-new-components"
      },
      {
        "text": "link",
        "href": "guide/router#defining-a-basic-route"
      },
      {
        "text": "provideRouter",
        "href": "api/router/provideRouter"
      },
      {
        "text": "ApplicationConfig",
        "href": "api/core/ApplicationConfig"
      },
      {
        "text": "ApplicationConfig",
        "href": "api/core/ApplicationConfig"
      },
      {
        "text": "provideRouter",
        "href": "api/router/provideRouter"
      },
      {
        "text": "Routes",
        "href": "api/router/Routes"
      },
      {
        "text": "Routes",
        "href": "api/router/Routes"
      },
      {
        "text": "Routes",
        "href": "api/router/Routes"
      },
      {
        "text": "Routes",
        "href": "api/router/Routes"
      },
      {
        "text": "Routes",
        "href": "api/router/Routes"
      },
      {
        "text": "routerLink",
        "href": "api/router/RouterLink"
      },
      {
        "text": "router-outlet",
        "href": "api/router/RouterOutlet"
      },
      {
        "text": "Router",
        "href": "api/router/Router"
      },
      {
        "text": "routerLink",
        "href": "api/router/RouterLink"
      },
      {
        "text": "routerLinkActive",
        "href": "api/router/RouterLinkActive"
      },
      {
        "text": "Component",
        "href": "api/core/Component"
      },
      {
        "text": "routerLink",
        "href": "api/router/RouterLink"
      },
      {
        "text": "routerLinkActive",
        "href": "api/router/RouterLinkActive"
      },
      {
        "text": "Component",
        "href": "api/core/Component"
      },
      {
        "text": "router-outlet",
        "href": "api/router/RouterOutlet"
      },
      {
        "text": "router-outlet",
        "href": "api/router/RouterOutlet"
      },
      {
        "text": "router-outlet",
        "href": "api/router/RouterOutlet"
      },
      {
        "text": "RouterLink",
        "href": "api/router/RouterLink"
      },
      {
        "text": "RouterLinkActive",
        "href": "api/router/RouterLinkActive"
      },
      {
        "text": "RouterOutlet",
        "href": "api/router/RouterOutlet"
      },
      {
        "text": "Component",
        "href": "api/core/Component"
      },
      {
        "text": "CommonModule",
        "href": "api/common/CommonModule"
      },
      {
        "text": "RouterOutlet",
        "href": "api/router/RouterOutlet"
      },
      {
        "text": "RouterLink",
        "href": "api/router/RouterLink"
      },
      {
        "text": "RouterLinkActive",
        "href": "api/router/RouterLinkActive"
      },
      {
        "text": "link",
        "href": "guide/router#route-order"
      },
      {
        "text": "Router",
        "href": "api/router/Router"
      },
      {
        "text": "wildcard route",
        "href": "guide/router#setting-up-wildcard-routes"
      },
      {
        "text": "Router",
        "href": "api/router/Router"
      },
      {
        "text": "link",
        "href": "guide/router#getting-route-information"
      },
      {
        "text": "withComponentInputBinding",
        "href": "api/router/withComponentInputBinding"
      },
      {
        "text": "provideRouter",
        "href": "api/router/provideRouter"
      },
      {
        "text": "withComponentInputBinding",
        "href": "api/router/withComponentInputBinding"
      },
      {
        "text": "provideRouter",
        "href": "api/router/provideRouter"
      },
      {
        "text": "provideRouter",
        "href": "api/router/provideRouter"
      },
      {
        "text": "withComponentInputBinding",
        "href": "api/router/withComponentInputBinding"
      },
      {
        "text": "Input",
        "href": "api/core/Input"
      },
      {
        "text": "Input",
        "href": "api/core/Input"
      },
      {
        "text": "paramsInheritanceStrategy",
        "href": "api/router/RouterConfigOptions#paramsInheritanceStrategy"
      },
      {
        "text": "withRouterConfig",
        "href": "api/router/withRouterConfig"
      },
      {
        "text": "link",
        "href": "guide/router#setting-up-wildcard-routes"
      },
      {
        "text": "display a 404 page",
        "href": "guide/router#404-page-how-to"
      },
      {
        "text": "Route order",
        "href": "guide/router#route-order"
      },
      {
        "text": "link",
        "href": "guide/router#displaying-a-404-page"
      },
      {
        "text": "wildcard route",
        "href": "guide/router#wildcard-route-how-to"
      },
      {
        "text": "Routes",
        "href": "api/router/Routes"
      },
      {
        "text": "link",
        "href": "guide/router#setting-up-redirects"
      },
      {
        "text": "Routes",
        "href": "api/router/Routes"
      },
      {
        "text": "Spotlight on pathMatch",
        "href": "guide/router-tutorial-toh#pathmatch"
      },
      {
        "text": "link",
        "href": "guide/router#nesting-routes"
      },
      {
        "text": "router-outlet",
        "href": "api/router/RouterOutlet"
      },
      {
        "text": "router-outlet",
        "href": "api/router/RouterOutlet"
      },
      {
        "text": "router-outlet",
        "href": "api/router/RouterOutlet"
      },
      {
        "text": "Component",
        "href": "api/core/Component"
      },
      {
        "text": "routerLink",
        "href": "api/router/RouterLink"
      },
      {
        "text": "routerLink",
        "href": "api/router/RouterLink"
      },
      {
        "text": "router-outlet",
        "href": "api/router/RouterOutlet"
      },
      {
        "text": "router-outlet",
        "href": "api/router/RouterOutlet"
      },
      {
        "text": "Routes",
        "href": "api/router/Routes"
      },
      {
        "text": "router-outlet",
        "href": "api/router/RouterOutlet"
      },
      {
        "text": "link",
        "href": "guide/router#setting-the-page-title"
      },
      {
        "text": "Router",
        "href": "api/router/Router"
      },
      {
        "text": "Route",
        "href": "api/router/Route"
      },
      {
        "text": "Routes",
        "href": "api/router/Routes"
      },
      {
        "text": "router-outlet",
        "href": "api/router/RouterOutlet"
      },
      {
        "text": "ResolveFn",
        "href": "api/router/ResolveFn"
      },
      {
        "text": "ResolveFn",
        "href": "api/router/ResolveFn"
      },
      {
        "text": "TitleStrategy",
        "href": "api/router/TitleStrategy"
      },
      {
        "text": "Injectable",
        "href": "api/core/Injectable"
      },
      {
        "text": "TitleStrategy",
        "href": "api/router/TitleStrategy"
      },
      {
        "text": "Title",
        "href": "api/platform-browser/Title"
      },
      {
        "text": "RouterStateSnapshot",
        "href": "api/router/RouterStateSnapshot"
      },
      {
        "text": "ApplicationConfig",
        "href": "api/core/ApplicationConfig"
      },
      {
        "text": "provideRouter",
        "href": "api/router/provideRouter"
      },
      {
        "text": "TitleStrategy",
        "href": "api/router/TitleStrategy"
      },
      {
        "text": "link",
        "href": "guide/router#using-relative-paths"
      },
      {
        "text": "Component",
        "href": "api/core/Component"
      },
      {
        "text": "routerLink",
        "href": "api/router/RouterLink"
      },
      {
        "text": "Route",
        "href": "api/router/Route"
      },
      {
        "text": "router-outlet",
        "href": "api/router/RouterOutlet"
      },
      {
        "text": "router-outlet",
        "href": "api/router/RouterOutlet"
      },
      {
        "text": "link",
        "href": "guide/router#specifying-a-relative-route"
      },
      {
        "text": "NavigationExtras",
        "href": "api/router/NavigationExtras"
      },
      {
        "text": "NavigationExtras",
        "href": "api/router/NavigationExtras"
      },
      {
        "text": "ActivatedRoute",
        "href": "api/router/ActivatedRoute"
      },
      {
        "text": "link",
        "href": "guide/router#accessing-query-parameters-and-fragments"
      },
      {
        "text": "ActivatedRoute",
        "href": "api/router/ActivatedRoute"
      },
      {
        "text": "ActivatedRoute",
        "href": "api/router/ActivatedRoute"
      },
      {
        "text": "Router",
        "href": "api/router/Router"
      },
      {
        "text": "ActivatedRoute",
        "href": "api/router/ActivatedRoute"
      },
      {
        "text": "ParamMap",
        "href": "api/router/ParamMap"
      },
      {
        "text": "ActivatedRoute",
        "href": "api/router/ActivatedRoute"
      },
      {
        "text": "Router",
        "href": "api/router/Router"
      },
      {
        "text": "ActivatedRoute",
        "href": "api/router/ActivatedRoute"
      },
      {
        "text": "Router",
        "href": "api/router/Router"
      },
      {
        "text": "link",
        "href": "guide/router#lazy-loading"
      },
      {
        "text": "Lazy loading",
        "href": "guide/lazy-loading-ngmodules"
      },
      {
        "text": "link",
        "href": "guide/router#preventing-unauthorized-access"
      },
      {
        "text": "canActivate",
        "href": "api/router/CanActivateFn"
      },
      {
        "text": "canActivateChild",
        "href": "api/router/CanActivateChildFn"
      },
      {
        "text": "canDeactivate",
        "href": "api/router/CanDeactivateFn"
      },
      {
        "text": "canMatch",
        "href": "api/router/CanMatchFn"
      },
      {
        "text": "resolve",
        "href": "api/router/ResolveFn"
      },
      {
        "text": "canLoad",
        "href": "api/router/CanLoadFn"
      },
      {
        "text": "component-less routes",
        "href": "api/router/Route#componentless-routes"
      },
      {
        "text": "CanActivateFn",
        "href": "api/router/CanActivateFn"
      },
      {
        "text": "ActivatedRouteSnapshot",
        "href": "api/router/ActivatedRouteSnapshot"
      },
      {
        "text": "RouterStateSnapshot",
        "href": "api/router/RouterStateSnapshot"
      },
      {
        "text": "routing tutorial section on route guards",
        "href": "guide/router-tutorial-toh#milestone-5-route-guards"
      },
      {
        "text": "link",
        "href": "guide/router#link-parameters-array"
      },
      {
        "text": "RouterLink",
        "href": "api/router/RouterLink"
      },
      {
        "text": "routerLink",
        "href": "api/router/RouterLink"
      },
      {
        "text": "routerLink",
        "href": "api/router/RouterLink"
      },
      {
        "text": "routerLink",
        "href": "api/router/RouterLink"
      },
      {
        "text": "RouterLink",
        "href": "api/router/RouterLink"
      },
      {
        "text": "default child route",
        "href": "guide/router-tutorial-toh#a-crisis-center-with-child-routes"
      },
      {
        "text": "routerLink",
        "href": "api/router/RouterLink"
      },
      {
        "text": "routerLink",
        "href": "api/router/RouterLink"
      },
      {
        "text": "Router",
        "href": "api/router/Router"
      },
      {
        "text": "routerLink",
        "href": "api/router/RouterLink"
      },
      {
        "text": "routerLink",
        "href": "api/router/RouterLink"
      },
      {
        "text": "routerLink",
        "href": "api/router/RouterLink"
      },
      {
        "text": "router-outlet",
        "href": "api/router/RouterOutlet"
      },
      {
        "text": "router-outlet",
        "href": "api/router/RouterOutlet"
      },
      {
        "text": "LocationStrategy",
        "href": "api/common/LocationStrategy"
      },
      {
        "text": "link",
        "href": "guide/router#locationstrategy-and-browser-url-styles"
      },
      {
        "text": "history.pushState",
        "href": "https://developer.mozilla.org/docs/Web/API/History_API/Working_with_the_History_API#adding_and_modifying_history_entries"
      },
      {
        "text": "LocationStrategy",
        "href": "api/common/LocationStrategy"
      },
      {
        "text": "PathLocationStrategy",
        "href": "api/common/PathLocationStrategy"
      },
      {
        "text": "HashLocationStrategy",
        "href": "api/common/HashLocationStrategy"
      },
      {
        "text": "provideRouter",
        "href": "api/router/provideRouter"
      },
      {
        "text": "LocationStrategy",
        "href": "api/common/LocationStrategy"
      },
      {
        "text": "PathLocationStrategy",
        "href": "api/common/PathLocationStrategy"
      },
      {
        "text": "HashLocationStrategy",
        "href": "api/common/HashLocationStrategy"
      },
      {
        "text": "Dependency Injection",
        "href": "guide/dependency-injection-providers"
      },
      {
        "text": "link",
        "href": "guide/router#choosing-a-routing-strategy"
      },
      {
        "text": "link",
        "href": "guide/router#base-href"
      },
      {
        "text": "history.pushState",
        "href": "https://developer.mozilla.org/docs/Web/API/History_API/Working_with_the_History_API#adding_and_modifying_history_entries"
      },
      {
        "text": "LocationStrategy and browser URL styles",
        "href": "guide/router#browser-url-styles"
      },
      {
        "text": "<base href> element",
        "href": "https://developer.mozilla.org/docs/Web/HTML/Element/base"
      },
      {
        "text": "link",
        "href": "guide/router#html5-urls-and-the-base-href"
      },
      {
        "text": "query",
        "href": "api/animations/query"
      },
      {
        "text": "HTML5 pushState",
        "href": "https://developer.mozilla.org/docs/Web/API/History_API#Adding_and_modifying_history_entries"
      },
      {
        "text": "<base href> element",
        "href": "https://developer.mozilla.org/docs/Web/HTML/Element/base"
      },
      {
        "text": "APP_BASE_HREF",
        "href": "api/common/APP_BASE_HREF"
      },
      {
        "text": "query",
        "href": "api/animations/query"
      },
      {
        "text": "query",
        "href": "api/animations/query"
      },
      {
        "text": "query",
        "href": "api/animations/query"
      },
      {
        "text": "query",
        "href": "api/animations/query"
      },
      {
        "text": "HashLocationStrategy",
        "href": "api/common/HashLocationStrategy"
      },
      {
        "text": "APP_BASE_HREF",
        "href": "api/common/APP_BASE_HREF"
      },
      {
        "text": "RFC",
        "href": "https://tools.ietf.org/html/rfc3986#section-5.2.2"
      },
      {
        "text": "HashLocationStrategy",
        "href": "api/common/HashLocationStrategy"
      },
      {
        "text": "link",
        "href": "guide/router#hashlocationstrategy"
      },
      {
        "text": "HashLocationStrategy",
        "href": "api/common/HashLocationStrategy"
      },
      {
        "text": "withHashLocation",
        "href": "api/router/withHashLocation"
      },
      {
        "text": "provideRouter",
        "href": "api/router/provideRouter"
      },
      {
        "text": "provideRouter",
        "href": "api/router/provideRouter"
      },
      {
        "text": "provideRouter",
        "href": "api/router/provideRouter"
      },
      {
        "text": "withHashLocation",
        "href": "api/router/withHashLocation"
      }
    ],
    "meta": {
      "description": "",
      "keywords": ""
    },
    "summary": "Common Routing Taskslink Contents Generate an applicationAdding components for routingImporting your new componentsDefining a basic routeRoute orderGetting route informationSetting up wildcard routesD...",
    "tags": [
      "react",
      "vue",
      "angular",
      "javascript",
      "typescript",
      "css",
      "html",
      "node",
      "vite",
      "setting"
    ],
    "id": "angular-router-part-1",
    "quality": 90
  }
]