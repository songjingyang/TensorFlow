[
  {
    "title": "useState – React",
    "url": "https://react.dev/reference/react/useState",
    "category": "react",
    "content": "API ReferenceHooksuseStateuseState is a React Hook that lets you add a state variable to your component.const [state, setState] = useState(initialState) Reference useState(initialState) set functions, like setSomething(nextState) Usage Adding state to a component Updating state based on the previous state Updating objects and arrays in state Avoiding recreating the initial state Resetting state with a key Storing information from previous renders Troubleshooting Ive updated the state, but logging gives me the old value Ive updated the state, but the screen doesnt update Im getting an error: Too many re-renders My initializer or updater function runs twice Im trying to set state to a function, but it gets called instead Reference useState(initialState) Call useState at the top level of your component to declare a state variable. import { useState } from 'react';function MyComponent() { const [age, setAge] = useState(28); const [name, setName] = useState('Taylor'); const [todos, setTodos] = useState(() = createTodos()); // ... The convention is to name state variables like [something, setSomething] using array destructuring. See more examples below. Parameters initialState: The value you want the state to be initially. It can be a value of any type, but there is a special behavior for functions. This argument is ignored after the initial render. If you pass a function as initialState, it will be treated as an initializer function. It should be pure, should take no arguments, and should return a value of any type. React will call your initializer function when initializing the component, and store its return value as the initial state. See an example below. Returns useState returns an array with exactly two values: The current state. During the first render, it will match the initialState you have passed. The set function that lets you update the state to a different value and trigger a re-render. Caveats useState is a Hook, so you can only call it at the top level of your component or your own Hooks. You cant call it inside loops or conditions. If you need that, extract a new component and move the state into it. In Strict Mode, React will call your initializer function twice in order to help you find accidental impurities. This is development-only behavior and does not affect production. If your initializer function is pure (as it should be), this should not affect the behavior. The result from one of the calls will be ignored. set functions, like setSomething(nextState) The set function returned by useState lets you update the state to a different value and trigger a re-render. You can pass the next state directly, or a function that calculates it from the previous state: const [name, setName] = useState('Edward');function handleClick() { setName('Taylor'); setAge(a = a + 1); // ... Parameters nextState: The value that you want the state to be. It can be a value of any type, but there is a special behavior for functions. If you pass a function as nextState, it will be treated as an updater function. It must be pure, should take the pending state as its only argument, and should return the next state. React will put your updater function in a queue and re-render your component. During the next render, React will calculate the next state by applying all of the queued updaters to the previous state. See an example below. Returns set functions do not have a return value. Caveats The set function only updates the state variable for the next render. If you read the state variable after calling the set function, you will still get the old value that was on the screen before your call. If the new value you provide is identical to the current state, as determined by an Object.is comparison, React will skip re-rendering the component and its children. This is an optimization. Although in some cases React may still need to call your component before skipping the children, it shouldnt affect your code. React batches state updates. It updates the screen after all the event handlers have run and have called their set functions. This prevents multiple re-renders during a single event. In the rare case that you need to force React to update the screen earlier, for example to access the DOM, you can use flushSync. The set function has a stable identity, so you will often see it omitted from Effect dependencies, but including it will not cause the Effect to fire. If the linter lets you omit a dependency without errors, it is safe to do. Learn more about removing Effect dependencies. Calling the set function during rendering is only allowed from within the currently rendering component. React will discard its output and immediately attempt to render it again with the new state. This pattern is rarely needed, but you can use it to store information from the previous renders. See an example below. In Strict Mode, React will call your updater function twice in order to help you find accidental impurities. This is development-only behavior and does not affect production. If your updater function is pure (as it should be), this should not affect the behavior. The result from one of the calls will be ignored. Usage Adding state to a component Call useState at the top level of your component to declare one or more state variables. import { useState } from 'react';function MyComponent() { const [age, setAge] = useState(42); const [name, setName] = useState('Taylor'); // ... The convention is to name state variables like [something, setSomething] using array destructuring. useState returns an array with exactly two items: The current state of this state variable, initially set to the initial state you provided. The set function that lets you change it to any other value in response to interaction. To update whats on the screen, call the set function with some next state: function handleClick() { setName('Robin');} React will store the next state, render your component again with the new values, and update the UI. PitfallCalling the set function does not change the current state in the already executing code:function handleClick() { setName('Robin'); console.log(name); // Still \"Taylor\"!}It only affects what useState will return starting from the next render. Basic useState examples1. Counter (number) 2. Text field (string) 3. Checkbox (boolean) 4. Form (two variables) Example 1 of 4: Counter (number) In this example, the count state variable holds a number. Clicking the button increments it.App.jsApp.js Download ResetForkimport { useState } from 'react'; export default function Counter() { const [count, setCount] = useState(0); function handleClick() { setCount(count + 1); } return ( button onClick={handleClick} You pressed me {count} times /button ); } Next Example Updating state based on the previous state Suppose the age is 42. This handler calls setAge(age + 1) three times: function handleClick() { setAge(age + 1); // setAge(42 + 1) setAge(age + 1); // setAge(42 + 1) setAge(age + 1); // setAge(42 + 1)} However, after one click, age will only be 43 rather than 45! This is because calling the set function does not update the age state variable in the already running code. So each setAge(age + 1) call becomes setAge(43). To solve this problem, you may pass an updater function to setAge instead of the next state: function handleClick() { setAge(a = a + 1); // setAge(42 = 43) setAge(a = a + 1); // setAge(43 = 44) setAge(a = a + 1); // setAge(44 = 45)} Here, a = a + 1 is your updater function. It takes the pending state and calculates the next state from it. React puts your updater functions in a queue. Then, during the next render, it will call them in the same order: a = a + 1 will receive 42 as the pending state and return 43 as the next state. a = a + 1 will receive 43 as the pending state and return 44 as the next state. a = a + 1 will receive 44 as the pending state and return 45 as the next state. There are no other queued updates, so React will store 45 as the current state in the end. By convention, its common to name the pending state argument for the first letter of the state variable name, like a for age. However, you may also call it like prevAge or something else that you find clearer. React may call your updaters twice in development to verify that they are pure. Deep DiveIs using an updater always preferred? Show DetailsYou might hear a recommendation to always write code like setAge(a = a + 1) if the state youre setting is calculated from the previous state. There is no harm in it, but it is also not always necessary.In most cases, there is no difference between these two approaches. React always makes sure that for intentional user actions, like clicks, the age state variable would be updated before the next click. This means there is no risk of a click handler seeing a stale age at the beginning of the event handler.However, if you do multiple updates within the same event, updaters can be helpful. Theyre also helpful if accessing the state variable itself is inconvenient (you might run into this when optimizing re-renders).If you prefer consistency over slightly more verbose syntax, its reasonable to always write an updater if the state youre setting is calculated from the previous state. If its calculated from the previous state of some other state variable, you might want to combine them into one object and use a reducer. The difference between passing an updater and passing the next state directly1. Passing the updater function 2. Passing the next state directly Example 1 of 2: Passing the updater function This example passes the updater function, so the +3 button works.App.jsApp.js Download ResetForkimport { useState } from 'react'; export default function Counter() { const [age, setAge] = useState(42); function increment() { setAge(a = a + 1); } return (  h1Your age: {age}/h1 button onClick={() = { increment(); increment(); increment(); }}+3/button button onClick={() = { increment(); }}+1/button / ); } Show moreNext Example Updating objects and arrays in state You can put objects and arrays into state. In React, state is considered read-only, so you should replace it rather than mutate your existing objects. For example, if you have a form object in state, dont mutate it: //  Don't mutate an object in state like this:form.firstName = 'Taylor'; Instead, replace the whole object by creating a new one: //  Replace state with a new objectsetForm({ ...form, firstName: 'Taylor'}); Read updating objects in state and updating arrays in state to learn more. Examples of objects and arrays in state1. Form (object) 2. Form (nested object) 3. List (array) 4. Writing concise update logic with Immer Example 1 of 4: Form (object) In this example, the form state variable holds an object. Each input has a change handler that calls setForm with the next state of the entire form. The { ...form } spread syntax ensures that the state object is replaced rather than mutated.App.jsApp.js Download ResetForkimport { useState } from 'react'; export default function Form() { const [form, setForm] = useState({ firstName: 'Barbara', lastName: 'Hepworth', email: 'bhepworth@sculpture.com', }); return (  label First name: input value={form.firstName} onChange={e = { setForm({ ...form, firstName: e.target.value }); }} / /label label Last name: input value={form.lastName} onChange={e = { setForm({ ...form, lastName: e.target.value }); }} / /label label Email: input value={form.email} onChange={e = { setForm({ ...form, email: e.target.value }); }} / /label p {form.firstName}{' '} {form.lastName}{' '} ({form.email}) /p / ); } Show moreNext Example Avoiding recreating the initial state React saves the initial state once and ignores it on the next renders. function TodoList() { const [todos, setTodos] = useState(createInitialTodos()); // ... Although the result of createInitialTodos() is only used for the initial render, youre still calling this function on every render. This can be wasteful if its creating large arrays or performing expensive calculations. To solve this, you may pass it as an initializer function to useState instead: function TodoList() { const [todos, setTodos] = useState(createInitialTodos); // ... Notice that youre passing createInitialTodos, which is the function itself, and not createInitialTodos(), which is the result of calling it. If you pass a function to useState, React will only call it during initialization. React may call your initializers twice in development to verify that they are pure. The difference between passing an initializer and passing the initial state directly1. Passing the initializer function 2. Passing the initial state directly Example 1 of 2: Passing the initializer function This example passes the initializer function, so the createInitialTodos function only runs during initialization. It does not run when component re-renders, such as when you type into the input.App.jsApp.js Download ResetForkimport { useState } from 'react'; function createInitialTodos() { const initialTodos = []; for (let i = 0; i  50; i++) { initialTodos.push({ id: i, text: 'Item ' + (i + 1) }); } return initialTodos; } export default function TodoList() { const [todos, setTodos] = useState(createInitialTodos); const [text, setText] = useState(''); return (  input value={text} onChange={e = setText(e.target.value)} / button onClick={() = { setText(''); setTodos([{ id: todos.length, text: text }, ...todos]); }}Add/button ul {todos.map(item = ( li key={item.id} {item.text} /li ))} /ul / ); } Show moreNext Example Resetting state with a key Youll often encounter the key attribute when rendering lists. However, it also serves another purpose. You can reset a components state by passing a different key to a component. In this example, the Reset button changes the version state variable, which we pass as a key to the Form. When the key changes, React re-creates the Form component (and all of its children) from scratch, so its state gets reset. Read preserving and resetting state to learn more. App.jsApp.js Download ResetForkimport { useState } from 'react'; export default function App() { const [version, setVersion] = useState(0); function handleReset() { setVersion(version + 1); } return (  button onClick={handleReset}Reset/button Form key={version} / / ); } function Form() { const [name, setName] = useState('Taylor'); return (  input value={name} onChange={e = setName(e.target.value)} / pHello, {name}./p / ); } Show more Storing information from previous renders Usually, you will update state in event handlers. However, in rare cases you might want to adjust state in response to rendering  for example, you might want to change a state variable when a prop changes. In most cases, you dont need this: If the value you need can be computed entirely from the current props or other state, remove that redundant state altogether. If youre worried about recomputing too often, the useMemo Hook can help. If you want to reset the entire component trees state, pass a different key to your component. If you can, update all the relevant state in the event handlers. In the rare case that none of these apply, there is a pattern you can use to update state based on the values that have been rendered so far, by calling a set function while your component is rendering. Heres an example. This CountLabel component displays the count prop passed to it: export default function CountLabel({ count }) { return h1{count}/h1} Say you want to show whether the counter has increased or decreased since the last change. The count prop doesnt tell you this  you need to keep track of its previous value. Add the prevCount state variable to track it. Add another state variable called trend to hold whether the count has increased or decreased. Compare prevCount with count, and if theyre not equal, update both prevCount and trend. Now you can show both the current count prop and how it has changed since the last render. App.jsCountLabel.jsCountLabel.js ResetForkimport { useState } from 'react'; export default function CountLabel({ count }) { const [prevCount, setPrevCount] = useState(count); const [trend, setTrend] = useState(null); if (prevCount !== count) { setPrevCount(count); setTrend(count  prevCount ? 'increasing' : 'decreasing'); } return (  h1{count}/h1 {trend && pThe count is {trend}/p} / ); } Show more Note that if you call a set function while rendering, it must be inside a condition like prevCount !== count, and there must be a call like setPrevCount(count) inside of the condition. Otherwise, your component would re-render in a loop until it crashes. Also, you can only update the state of the currently rendering component like this. Calling the set function of another component during rendering is an error. Finally, your set call should still update state without mutation  this doesnt mean you can break other rules of pure functions. This pattern can be hard to understand and is usually best avoided. However, its better than updating state in an effect. When you call the set function during render, React will re-render that component immediately after your component exits with a return statement, and before rendering the children. This way, children dont need to render twice. The rest of your component function will still execute (and the result will be thrown away). If your condition is below all the Hook calls, you may add an early return; to restart rendering earlier. Troubleshooting Ive updated the state, but logging gives me the old value Calling the set function does not change state in the running code: function handleClick() { console.log(count); // 0 setCount(count + 1); // Request a re-render with 1 console.log(count); // Still 0! setTimeout(() = { console.log(count); // Also 0! }, 5000);} This is because states behaves like a snapshot. Updating state requests another render with the new state value, but does not affect the count JavaScript variable in your already-running event handler. If you need to use the next state, you can save it in a variable before passing it to the set function: const nextCount = count + 1;setCount(nextCount);console.log(count); // 0console.log(nextCount); // 1 Ive updated the state, but the screen doesnt update React will ignore your update if the next state is equal to the previous state, as determined by an Object.is comparison. This usually happens when you change an object or an array in state directly: obj.x = 10; //  Wrong: mutating existing objectsetObj(obj); //  Doesn't do anything You mutated an existing obj object and passed it back to setObj, so React ignored the update. To fix this, you need to ensure that youre always replacing objects and arrays in state instead of mutating them: //  Correct: creating a new objectsetObj({ ...obj, x: 10}); Im getting an error: Too many re-renders You might get an error that says: Too many re-renders. React limits the number of renders to prevent an infinite loop. Typically, this means that youre unconditionally setting state during render, so your component enters a loop: render, set state (which causes a render), render, set state (which causes a render), and so on. Very often, this is caused by a mistake in specifying an event handler: //  Wrong: calls the handler during renderreturn button onClick={handleClick()}Click me/button//  Correct: passes down the event handlerreturn button onClick={handleClick}Click me/button//  Correct: passes down an inline functionreturn button onClick={(e) = handleClick(e)}Click me/button If you cant find the cause of this error, click on the arrow next to the error in the console and look through the JavaScript stack to find the specific set function call responsible for the error. My initializer or updater function runs twice In Strict Mode, React will call some of your functions twice instead of once: function TodoList() { // This component function will run twice for every render. const [todos, setTodos] = useState(() = { // This initializer function will run twice during initialization. return createTodos(); }); function handleClick() { setTodos(prevTodos = { // This updater function will run twice for every click. return [...prevTodos, createTodo()]; }); } // ... This is expected and shouldnt break your code. This development-only behavior helps you keep components pure. React uses the result of one of the calls, and ignores the result of the other call. As long as your component, initializer, and updater functions are pure, this shouldnt affect your logic. However, if they are accidentally impure, this helps you notice the mistakes. For example, this impure updater function mutates an array in state: setTodos(prevTodos = { //  Mistake: mutating state prevTodos.push(createTodo());}); Because React calls your updater function twice, youll see the todo was added twice, so youll know that there is a mistake. In this example, you can fix the mistake by replacing the array instead of mutating it: setTodos(prevTodos = { //  Correct: replacing with new state return [...prevTodos, createTodo()];}); Now that this updater function is pure, calling it an extra time doesnt make a difference in behavior. This is why React calling it twice helps you find mistakes. Only component, initializer, and updater functions need to be pure. Event handlers dont need to be pure, so React will never call your event handlers twice. Read keeping components pure to learn more. Im trying to set state to a function, but it gets called instead You cant put a function into state like this: const [fn, setFn] = useState(someFunction);function handleClick() { setFn(someOtherFunction);} Because youre passing a function, React assumes that someFunction is an initializer function, and that someOtherFunction is an updater function, so it tries to call them and store the result. To actually store a function, you have to put () = before them in both cases. Then React will store the functions you pass. const [fn, setFn] = useState(() = someFunction);function handleClick() { setFn(() = someOtherFunction);}PrevioususeRefNextuseSyncExternalStore",
    "headings": [
      {
        "level": 1,
        "text": "useState",
        "id": ""
      },
      {
        "level": 2,
        "text": "Reference",
        "id": "reference"
      },
      {
        "level": 2,
        "text": "Usage",
        "id": "usage"
      },
      {
        "level": 2,
        "text": "Troubleshooting",
        "id": "troubleshooting"
      },
      {
        "level": 3,
        "text": "useState(initialState)",
        "id": "usestate"
      },
      {
        "level": 3,
        "text": "set functions, like setSomething(nextState)",
        "id": "setstate"
      },
      {
        "level": 3,
        "text": "Adding state to a component",
        "id": "adding-state-to-a-component"
      },
      {
        "level": 3,
        "text": "Pitfall",
        "id": ""
      },
      {
        "level": 3,
        "text": "Updating state based on the previous state",
        "id": "updating-state-based-on-the-previous-state"
      },
      {
        "level": 3,
        "text": "Updating objects and arrays in state",
        "id": "updating-objects-and-arrays-in-state"
      },
      {
        "level": 3,
        "text": "Avoiding recreating the initial state",
        "id": "avoiding-recreating-the-initial-state"
      },
      {
        "level": 3,
        "text": "Resetting state with a key",
        "id": "resetting-state-with-a-key"
      },
      {
        "level": 3,
        "text": "Storing information from previous renders",
        "id": "storing-information-from-previous-renders"
      },
      {
        "level": 3,
        "text": "I’ve updated the state, but logging gives me the old value",
        "id": "ive-updated-the-state-but-logging-gives-me-the-old-value"
      },
      {
        "level": 3,
        "text": "I’ve updated the state, but the screen doesn’t update",
        "id": "ive-updated-the-state-but-the-screen-doesnt-update"
      },
      {
        "level": 3,
        "text": "I’m getting an error: “Too many re-renders”",
        "id": "im-getting-an-error-too-many-re-renders"
      },
      {
        "level": 3,
        "text": "My initializer or updater function runs twice",
        "id": "my-initializer-or-updater-function-runs-twice"
      },
      {
        "level": 3,
        "text": "I’m trying to set state to a function, but it gets called instead",
        "id": "im-trying-to-set-state-to-a-function-but-it-gets-called-instead"
      },
      {
        "level": 4,
        "text": "Parameters",
        "id": "parameters"
      },
      {
        "level": 4,
        "text": "Returns",
        "id": "returns"
      },
      {
        "level": 4,
        "text": "Caveats",
        "id": "caveats"
      },
      {
        "level": 4,
        "text": "Parameters",
        "id": "setstate-parameters"
      },
      {
        "level": 4,
        "text": "Returns",
        "id": "setstate-returns"
      },
      {
        "level": 4,
        "text": "Caveats",
        "id": "setstate-caveats"
      },
      {
        "level": 4,
        "text": "Basic useState examples",
        "id": "examples-basic"
      },
      {
        "level": 4,
        "text": "Example 1 of 4: Counter (number)",
        "id": "counter-number"
      },
      {
        "level": 4,
        "text": "Is using an updater always preferred?",
        "id": "is-using-an-updater-always-preferred"
      },
      {
        "level": 4,
        "text": "The difference between passing an updater and passing the next state directly",
        "id": "examples-updater"
      },
      {
        "level": 4,
        "text": "Example 1 of 2: Passing the updater function",
        "id": "passing-the-updater-function"
      },
      {
        "level": 4,
        "text": "Examples of objects and arrays in state",
        "id": "examples-objects"
      },
      {
        "level": 4,
        "text": "Example 1 of 4: Form (object)",
        "id": "form-object"
      },
      {
        "level": 4,
        "text": "The difference between passing an initializer and passing the initial state directly",
        "id": "examples-initializer"
      },
      {
        "level": 4,
        "text": "Example 1 of 2: Passing the initializer function",
        "id": "passing-the-initializer-function"
      },
      {
        "level": 5,
        "text": "Deep Dive",
        "id": ""
      }
    ],
    "codeBlocks": [
      {
        "language": "text",
        "code": "const [state, setState] = useState(initialState)"
      },
      {
        "language": "text",
        "code": "const [state, setState] = useState(initialState)"
      },
      {
        "language": "text",
        "code": "useState(initialState)"
      },
      {
        "language": "text",
        "code": "setSomething(nextState)"
      },
      {
        "language": "text",
        "code": "useState(initialState)"
      },
      {
        "language": "text",
        "code": "import { useState } from 'react';function MyComponent() {  const [age, setAge] = useState(28);  const [name, setName] = useState('Taylor');  const [todos, setTodos] = useState(() => createTodos());  // ..."
      },
      {
        "language": "text",
        "code": "import { useState } from 'react';function MyComponent() {  const [age, setAge] = useState(28);  const [name, setName] = useState('Taylor');  const [todos, setTodos] = useState(() => createTodos());  // ..."
      },
      {
        "language": "text",
        "code": "[something, setSomething]"
      },
      {
        "language": "text",
        "code": "initialState"
      },
      {
        "language": "text",
        "code": "initialState"
      },
      {
        "language": "text",
        "code": "initialState"
      },
      {
        "language": "text",
        "code": "setSomething(nextState)"
      },
      {
        "language": "text",
        "code": "const [name, setName] = useState('Edward');function handleClick() {  setName('Taylor');  setAge(a => a + 1);  // ..."
      },
      {
        "language": "text",
        "code": "const [name, setName] = useState('Edward');function handleClick() {  setName('Taylor');  setAge(a => a + 1);  // ..."
      },
      {
        "language": "text",
        "code": "import { useState } from 'react';function MyComponent() {  const [age, setAge] = useState(42);  const [name, setName] = useState('Taylor');  // ..."
      },
      {
        "language": "text",
        "code": "import { useState } from 'react';function MyComponent() {  const [age, setAge] = useState(42);  const [name, setName] = useState('Taylor');  // ..."
      },
      {
        "language": "text",
        "code": "[something, setSomething]"
      },
      {
        "language": "text",
        "code": "function handleClick() {  setName('Robin');}"
      },
      {
        "language": "text",
        "code": "function handleClick() {  setName('Robin');}"
      },
      {
        "language": "text",
        "code": "function handleClick() {  setName('Robin');  console.log(name); // Still \"Taylor\"!}"
      },
      {
        "language": "text",
        "code": "function handleClick() {  setName('Robin');  console.log(name); // Still \"Taylor\"!}"
      },
      {
        "language": "text",
        "code": "import { useState } from 'react';\n\nexport default function Counter() {\n  const [count, setCount] = useState(0);\n\n  function handleClick() {\n    setCount(count + 1);\n  }\n\n  return (\n    <button onClick={handleClick}>\n      You pressed me {count} times\n    </button>\n  );\n}"
      },
      {
        "language": "text",
        "code": "setAge(age + 1)"
      },
      {
        "language": "text",
        "code": "function handleClick() {  setAge(age + 1); // setAge(42 + 1)  setAge(age + 1); // setAge(42 + 1)  setAge(age + 1); // setAge(42 + 1)}"
      },
      {
        "language": "text",
        "code": "function handleClick() {  setAge(age + 1); // setAge(42 + 1)  setAge(age + 1); // setAge(42 + 1)  setAge(age + 1); // setAge(42 + 1)}"
      },
      {
        "language": "text",
        "code": "setAge(age + 1)"
      },
      {
        "language": "text",
        "code": "function handleClick() {  setAge(a => a + 1); // setAge(42 => 43)  setAge(a => a + 1); // setAge(43 => 44)  setAge(a => a + 1); // setAge(44 => 45)}"
      },
      {
        "language": "text",
        "code": "function handleClick() {  setAge(a => a + 1); // setAge(42 => 43)  setAge(a => a + 1); // setAge(43 => 44)  setAge(a => a + 1); // setAge(44 => 45)}"
      },
      {
        "language": "text",
        "code": "setAge(a => a + 1)"
      },
      {
        "language": "text",
        "code": "import { useState } from 'react';\n\nexport default function Counter() {\n  const [age, setAge] = useState(42);\n\n  function increment() {\n    setAge(a => a + 1);\n  }\n\n  return (\n    <>\n      <h1>Your age: {age}</h1>\n      <button onClick={() => {\n        increment();\n        increment();\n        increment();\n      }}>+3</button>\n      <button onClick={() => {\n        increment();\n      }}>+1</button>\n    </>\n  );\n}"
      },
      {
        "language": "text",
        "code": "// 🚩 Don't mutate an object in state like this:form.firstName = 'Taylor';"
      },
      {
        "language": "text",
        "code": "// 🚩 Don't mutate an object in state like this:form.firstName = 'Taylor';"
      },
      {
        "language": "text",
        "code": "// ✅ Replace state with a new objectsetForm({  ...form,  firstName: 'Taylor'});"
      },
      {
        "language": "text",
        "code": "// ✅ Replace state with a new objectsetForm({  ...form,  firstName: 'Taylor'});"
      },
      {
        "language": "text",
        "code": "{ ...form }"
      },
      {
        "language": "text",
        "code": "import { useState } from 'react';\n\nexport default function Form() {\n  const [form, setForm] = useState({\n    firstName: 'Barbara',\n    lastName: 'Hepworth',\n    email: 'bhepworth@sculpture.com',\n  });\n\n  return (\n    <>\n      <label>\n        First name:\n        <input\n          value={form.firstName}\n          onChange={e => {\n            setForm({\n              ...form,\n              firstName: e.target.value\n            });\n          }}\n        />\n      </label>\n      <label>\n        Last name:\n        <input\n          value={form.lastName}\n          onChange={e => {\n            setForm({\n              ...form,\n              lastName: e.target.value\n            });\n          }}\n        />\n      </label>\n      <label>\n        Email:\n        <input\n          value={form.email}\n          onChange={e => {\n            setForm({\n              ...form,\n              email: e.target.value\n            });\n          }}\n        />\n      </label>\n      <p>\n        {form.firstName}{' '}\n        {form.lastName}{' '}\n        ({form.email})\n      </p>\n    </>\n  );\n}"
      },
      {
        "language": "text",
        "code": "function TodoList() {  const [todos, setTodos] = useState(createInitialTodos());  // ..."
      },
      {
        "language": "text",
        "code": "function TodoList() {  const [todos, setTodos] = useState(createInitialTodos());  // ..."
      },
      {
        "language": "text",
        "code": "createInitialTodos()"
      },
      {
        "language": "text",
        "code": "function TodoList() {  const [todos, setTodos] = useState(createInitialTodos);  // ..."
      },
      {
        "language": "text",
        "code": "function TodoList() {  const [todos, setTodos] = useState(createInitialTodos);  // ..."
      },
      {
        "language": "text",
        "code": "createInitialTodos"
      },
      {
        "language": "text",
        "code": "createInitialTodos()"
      },
      {
        "language": "text",
        "code": "createInitialTodos"
      },
      {
        "language": "text",
        "code": "import { useState } from 'react';\n\nfunction createInitialTodos() {\n  const initialTodos = [];\n  for (let i = 0; i < 50; i++) {\n    initialTodos.push({\n      id: i,\n      text: 'Item ' + (i + 1)\n    });\n  }\n  return initialTodos;\n}\n\nexport default function TodoList() {\n  const [todos, setTodos] = useState(createInitialTodos);\n  const [text, setText] = useState('');\n\n  return (\n    <>\n      <input\n        value={text}\n        onChange={e => setText(e.target.value)}\n      />\n      <button onClick={() => {\n        setText('');\n        setTodos([{\n          id: todos.length,\n          text: text\n        }, ...todos]);\n      }}>Add</button>\n      <ul>\n        {todos.map(item => (\n          <li key={item.id}>\n            {item.text}\n          </li>\n        ))}\n      </ul>\n    </>\n  );\n}"
      },
      {
        "language": "text",
        "code": "import { useState } from 'react';\n\nexport default function App() {\n  const [version, setVersion] = useState(0);\n\n  function handleReset() {\n    setVersion(version + 1);\n  }\n\n  return (\n    <>\n      <button onClick={handleReset}>Reset</button>\n      <Form key={version} />\n    </>\n  );\n}\n\nfunction Form() {\n  const [name, setName] = useState('Taylor');\n\n  return (\n    <>\n      <input\n        value={name}\n        onChange={e => setName(e.target.value)}\n      />\n      <p>Hello, {name}.</p>\n    </>\n  );\n}"
      },
      {
        "language": "text",
        "code": "export default function CountLabel({ count }) {  return <h1>{count}</h1>}"
      },
      {
        "language": "text",
        "code": "export default function CountLabel({ count }) {  return <h1>{count}</h1>}"
      },
      {
        "language": "text",
        "code": "import { useState } from 'react';\n\nexport default function CountLabel({ count }) {\n  const [prevCount, setPrevCount] = useState(count);\n  const [trend, setTrend] = useState(null);\n  if (prevCount !== count) {\n    setPrevCount(count);\n    setTrend(count > prevCount ? 'increasing' : 'decreasing');\n  }\n  return (\n    <>\n      <h1>{count}</h1>\n      {trend && <p>The count is {trend}</p>}\n    </>\n  );\n}"
      },
      {
        "language": "text",
        "code": "prevCount !== count"
      },
      {
        "language": "text",
        "code": "setPrevCount(count)"
      },
      {
        "language": "text",
        "code": "function handleClick() {  console.log(count);  // 0  setCount(count + 1); // Request a re-render with 1  console.log(count);  // Still 0!  setTimeout(() => {    console.log(count); // Also 0!  }, 5000);}"
      },
      {
        "language": "text",
        "code": "function handleClick() {  console.log(count);  // 0  setCount(count + 1); // Request a re-render with 1  console.log(count);  // Still 0!  setTimeout(() => {    console.log(count); // Also 0!  }, 5000);}"
      },
      {
        "language": "text",
        "code": "const nextCount = count + 1;setCount(nextCount);console.log(count);     // 0console.log(nextCount); // 1"
      },
      {
        "language": "text",
        "code": "const nextCount = count + 1;setCount(nextCount);console.log(count);     // 0console.log(nextCount); // 1"
      },
      {
        "language": "text",
        "code": "obj.x = 10;  // 🚩 Wrong: mutating existing objectsetObj(obj); // 🚩 Doesn't do anything"
      },
      {
        "language": "text",
        "code": "obj.x = 10;  // 🚩 Wrong: mutating existing objectsetObj(obj); // 🚩 Doesn't do anything"
      },
      {
        "language": "text",
        "code": "// ✅ Correct: creating a new objectsetObj({  ...obj,  x: 10});"
      },
      {
        "language": "text",
        "code": "// ✅ Correct: creating a new objectsetObj({  ...obj,  x: 10});"
      },
      {
        "language": "text",
        "code": "Too many re-renders. React limits the number of renders to prevent an infinite loop."
      },
      {
        "language": "text",
        "code": "// 🚩 Wrong: calls the handler during renderreturn <button onClick={handleClick()}>Click me</button>// ✅ Correct: passes down the event handlerreturn <button onClick={handleClick}>Click me</button>// ✅ Correct: passes down an inline functionreturn <button onClick={(e) => handleClick(e)}>Click me</button>"
      },
      {
        "language": "text",
        "code": "// 🚩 Wrong: calls the handler during renderreturn <button onClick={handleClick()}>Click me</button>// ✅ Correct: passes down the event handlerreturn <button onClick={handleClick}>Click me</button>// ✅ Correct: passes down an inline functionreturn <button onClick={(e) => handleClick(e)}>Click me</button>"
      },
      {
        "language": "text",
        "code": "function TodoList() {  // This component function will run twice for every render.  const [todos, setTodos] = useState(() => {    // This initializer function will run twice during initialization.    return createTodos();  });  function handleClick() {    setTodos(prevTodos => {      // This updater function will run twice for every click.      return [...prevTodos, createTodo()];    });  }  // ..."
      },
      {
        "language": "text",
        "code": "function TodoList() {  // This component function will run twice for every render.  const [todos, setTodos] = useState(() => {    // This initializer function will run twice during initialization.    return createTodos();  });  function handleClick() {    setTodos(prevTodos => {      // This updater function will run twice for every click.      return [...prevTodos, createTodo()];    });  }  // ..."
      },
      {
        "language": "text",
        "code": "setTodos(prevTodos => {  // 🚩 Mistake: mutating state  prevTodos.push(createTodo());});"
      },
      {
        "language": "text",
        "code": "setTodos(prevTodos => {  // 🚩 Mistake: mutating state  prevTodos.push(createTodo());});"
      },
      {
        "language": "text",
        "code": "setTodos(prevTodos => {  // ✅ Correct: replacing with new state  return [...prevTodos, createTodo()];});"
      },
      {
        "language": "text",
        "code": "setTodos(prevTodos => {  // ✅ Correct: replacing with new state  return [...prevTodos, createTodo()];});"
      },
      {
        "language": "text",
        "code": "const [fn, setFn] = useState(someFunction);function handleClick() {  setFn(someOtherFunction);}"
      },
      {
        "language": "text",
        "code": "const [fn, setFn] = useState(someFunction);function handleClick() {  setFn(someOtherFunction);}"
      },
      {
        "language": "text",
        "code": "someFunction"
      },
      {
        "language": "text",
        "code": "someOtherFunction"
      },
      {
        "language": "text",
        "code": "const [fn, setFn] = useState(() => someFunction);function handleClick() {  setFn(() => someOtherFunction);}"
      },
      {
        "language": "text",
        "code": "const [fn, setFn] = useState(() => someFunction);function handleClick() {  setFn(() => someOtherFunction);}"
      }
    ],
    "links": [
      {
        "text": "API Reference",
        "href": "/reference/react"
      },
      {
        "text": "Hooks",
        "href": "/reference/react/hooks"
      },
      {
        "text": "state variable",
        "href": "/learn/state-a-components-memory"
      },
      {
        "text": "state variable.",
        "href": "/learn/state-a-components-memory"
      },
      {
        "text": "array destructuring.",
        "href": "https://javascript.info/destructuring-assignment"
      },
      {
        "text": "Object.is",
        "href": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/is"
      },
      {
        "text": "batches state updates.",
        "href": "/learn/queueing-a-series-of-state-updates"
      },
      {
        "text": "flushSync.",
        "href": "/reference/react-dom/flushSync"
      },
      {
        "text": "Learn more about removing Effect dependencies.",
        "href": "/learn/removing-effect-dependencies#move-dynamic-objects-and-functions-inside-your-effect"
      },
      {
        "text": "state variables.",
        "href": "/learn/state-a-components-memory"
      },
      {
        "text": "array destructuring.",
        "href": "https://javascript.info/destructuring-assignment"
      },
      {
        "text": "does not update",
        "href": "/learn/state-as-a-snapshot"
      },
      {
        "text": "queue.",
        "href": "/learn/queueing-a-series-of-state-updates"
      },
      {
        "text": "pure.",
        "href": "/learn/keeping-components-pure"
      },
      {
        "text": "use a reducer.",
        "href": "/learn/extracting-state-logic-into-a-reducer"
      },
      {
        "text": "updating objects in state",
        "href": "/learn/updating-objects-in-state"
      },
      {
        "text": "updating arrays in state",
        "href": "/learn/updating-arrays-in-state"
      },
      {
        "text": "pure.",
        "href": "/learn/keeping-components-pure"
      },
      {
        "text": "rendering lists.",
        "href": "/learn/rendering-lists"
      },
      {
        "text": "preserving and resetting state",
        "href": "/learn/preserving-and-resetting-state"
      },
      {
        "text": "remove that redundant state altogether.",
        "href": "/learn/choosing-the-state-structure#avoid-redundant-state"
      },
      {
        "text": "useMemo Hook",
        "href": "/reference/react/useMemo"
      },
      {
        "text": "pure functions.",
        "href": "/learn/keeping-components-pure"
      },
      {
        "text": "states behaves like a snapshot.",
        "href": "/learn/state-as-a-snapshot"
      },
      {
        "text": "Object.is",
        "href": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/is"
      },
      {
        "text": "Strict Mode",
        "href": "/reference/react/StrictMode"
      },
      {
        "text": "keep components pure.",
        "href": "/learn/keeping-components-pure"
      },
      {
        "text": "keeping components pure",
        "href": "/learn/keeping-components-pure"
      },
      {
        "text": "PrevioususeRef",
        "href": "/reference/react/useRef"
      },
      {
        "text": "NextuseSyncExternalStore",
        "href": "/reference/react/useSyncExternalStore"
      }
    ],
    "meta": {
      "description": "",
      "keywords": ""
    },
    "summary": "API ReferenceHooksuseStateuseState is a React Hook that lets you add a state variable to your component",
    "tags": [
      "react",
      "angular",
      "javascript",
      "typescript",
      "html",
      "vite",
      "state",
      "passing",
      "usestate",
      "example"
    ],
    "id": "usestate-react-useState-part-1",
    "quality": 100
  },
  {
    "title": "useEffect – React",
    "url": "https://react.dev/reference/react/useEffect",
    "category": "react",
    "content": "API ReferenceHooksuseEffectuseEffect is a React Hook that lets you synchronize a component with an external system.useEffect(setup, dependencies?) Reference useEffect(setup, dependencies?) Usage Connecting to an external system Wrapping Effects in custom Hooks Controlling a non-React widget Fetching data with Effects Specifying reactive dependencies Updating state based on previous state from an Effect Removing unnecessary object dependencies Removing unnecessary function dependencies Reading the latest props and state from an Effect Displaying different content on the server and the client Troubleshooting My Effect runs twice when the component mounts My Effect runs after every re-render My Effect keeps re-running in an infinite cycle My cleanup logic runs even though my component didnt unmount My Effect does something visual, and I see a flicker before it runs Reference useEffect(setup, dependencies?) Call useEffect at the top level of your component to declare an Effect: import { useState, useEffect } from 'react';import { createConnection } from './chat.js';function ChatRoom({ roomId }) { const [serverUrl, setServerUrl] = useState('https://localhost:1234'); useEffect(() = { const connection = createConnection(serverUrl, roomId); connection.connect(); return () = { connection.disconnect(); }; }, [serverUrl, roomId]); // ...} See more examples below. Parameters setup: The function with your Effects logic. Your setup function may also optionally return a cleanup function. When your component is added to the DOM, React will run your setup function. After every re-render with changed dependencies, React will first run the cleanup function (if you provided it) with the old values, and then run your setup function with the new values. After your component is removed from the DOM, React will run your cleanup function. optional dependencies: The list of all reactive values referenced inside of the setup code. Reactive values include props, state, and all the variables and functions declared directly inside your component body. If your linter is configured for React, it will verify that every reactive value is correctly specified as a dependency. The list of dependencies must have a constant number of items and be written inline like [dep1, dep2, dep3]. React will compare each dependency with its previous value using the Object.is comparison. If you omit this argument, your Effect will re-run after every re-render of the component. See the difference between passing an array of dependencies, an empty array, and no dependencies at all. Returns useEffect returns undefined. Caveats useEffect is a Hook, so you can only call it at the top level of your component or your own Hooks. You cant call it inside loops or conditions. If you need that, extract a new component and move the state into it. If youre not trying to synchronize with some external system, you probably dont need an Effect. When Strict Mode is on, React will run one extra development-only setup+cleanup cycle before the first real setup. This is a stress-test that ensures that your cleanup logic mirrors your setup logic and that it stops or undoes whatever the setup is doing. If this causes a problem, implement the cleanup function. If some of your dependencies are objects or functions defined inside the component, there is a risk that they will cause the Effect to re-run more often than needed. To fix this, remove unnecessary object and function dependencies. You can also extract state updates and non-reactive logic outside of your Effect. If your Effect wasnt caused by an interaction (like a click), React will generally let the browser paint the updated screen first before running your Effect. If your Effect is doing something visual (for example, positioning a tooltip), and the delay is noticeable (for example, it flickers), replace useEffect with useLayoutEffect. If your Effect is caused by an interaction (like a click), React may run your Effect before the browser paints the updated screen. This ensures that the result of the Effect can be observed by the event system. Usually, this works as expected. However, if you must defer the work until after paint, such as an alert(), you can use setTimeout. See reactwg/react-18/128 for more information. Even if your Effect was caused by an interaction (like a click), React may allow the browser to repaint the screen before processing the state updates inside your Effect. Usually, this works as expected. However, if you must block the browser from repainting the screen, you need to replace useEffect with useLayoutEffect. Effects only run on the client. They dont run during server rendering. Usage Connecting to an external system Some components need to stay connected to the network, some browser API, or a third-party library, while they are displayed on the page. These systems arent controlled by React, so they are called external. To connect your component to some external system, call useEffect at the top level of your component: import { useState, useEffect } from 'react';import { createConnection } from './chat.js';function ChatRoom({ roomId }) { const [serverUrl, setServerUrl] = useState('https://localhost:1234'); useEffect(() = { const connection = createConnection(serverUrl, roomId); connection.connect(); return () = { connection.disconnect(); }; }, [serverUrl, roomId]); // ...} You need to pass two arguments to useEffect: A setup function with setup code that connects to that system. It should return a cleanup function with cleanup code that disconnects from that system. A list of dependencies including every value from your component used inside of those functions. React calls your setup and cleanup functions whenever its necessary, which may happen multiple times: Your setup code runs when your component is added to the page (mounts). After every re-render of your component where the dependencies have changed: First, your cleanup code runs with the old props and state. Then, your setup code runs with the new props and state. Your cleanup code runs one final time after your component is removed from the page (unmounts). Lets illustrate this sequence for the example above. When the ChatRoom component above gets added to the page, it will connect to the chat room with the initial serverUrl and roomId. If either serverUrl or roomId change as a result of a re-render (say, if the user picks a different chat room in a dropdown), your Effect will disconnect from the previous room, and connect to the next one. When the ChatRoom component is removed from the page, your Effect will disconnect one last time. To help you find bugs, in development React runs setup and cleanup one extra time before the setup. This is a stress-test that verifies your Effects logic is implemented correctly. If this causes visible issues, your cleanup function is missing some logic. The cleanup function should stop or undo whatever the setup function was doing. The rule of thumb is that the user shouldnt be able to distinguish between the setup being called once (as in production) and a setup  cleanup  setup sequence (as in development). See common solutions. Try to write every Effect as an independent process and think about a single setup/cleanup cycle at a time. It shouldnt matter whether your component is mounting, updating, or unmounting. When your cleanup logic correctly mirrors the setup logic, your Effect is resilient to running setup and cleanup as often as needed. NoteAn Effect lets you keep your component synchronized with some external system (like a chat service). Here, external system means any piece of code thats not controlled by React, such as: A timer managed with setInterval() and clearInterval(). An event subscription using window.addEventListener() and window.removeEventListener(). A third-party animation library with an API like animation.start() and animation.reset(). If youre not connecting to any external system, you probably dont need an Effect. Examples of connecting to an external system1. Connecting to a chat server 2. Listening to a global browser event 3. Triggering an animation 4. Controlling a modal dialog 5. Tracking element visibility Example 1 of 5: Connecting to a chat server In this example, the ChatRoom component uses an Effect to stay connected to an external system defined in chat.js. Press Open chat to make the ChatRoom component appear. This sandbox runs in development mode, so there is an extra connect-and-disconnect cycle, as explained here. Try changing the roomId and serverUrl using the dropdown and the input, and see how the Effect re-connects to the chat. Press Close chat to see the Effect disconnect one last time.App.jschat.jsApp.js ResetForkimport { useState, useEffect } from 'react'; import { createConnection } from './chat.js'; function ChatRoom({ roomId }) { const [serverUrl, setServerUrl] = useState('https://localhost:1234'); useEffect(() = { const connection = createConnection(serverUrl, roomId); connection.connect(); return () = { connection.disconnect(); }; }, [roomId, serverUrl]); return (  label Server URL:{' '} input value={serverUrl} onChange={e = setServerUrl(e.target.value)} / /label h1Welcome to the {roomId} room!/h1 / ); } export default function App() { const [roomId, setRoomId] = useState('general'); const [show, setShow] = useState(false); return (  label Choose the chat room:{' '} select value={roomId} onChange={e = setRoomId(e.target.value)}  option value=\"general\"general/option option value=\"travel\"travel/option option value=\"music\"music/option /select /label button onClick={() = setShow(!show)} {show ? 'Close chat' : 'Open chat'} /button {show && hr /} {show && ChatRoom roomId={roomId} /} / ); } Show moreNext Example Wrapping Effects in custom Hooks Effects are an escape hatch: you use them when you need to step outside React and when there is no better built-in solution for your use case. If you find yourself often needing to manually write Effects, its usually a sign that you need to extract some custom Hooks for common behaviors your components rely on. For example, this useChatRoom custom Hook hides the logic of your Effect behind a more declarative API: function useChatRoom({ serverUrl, roomId }) { useEffect(() = { const options = { serverUrl: serverUrl, roomId: roomId }; const connection = createConnection(options); connection.connect(); return () = connection.disconnect(); }, [roomId, serverUrl]);} Then you can use it from any component like this: function ChatRoom({ roomId }) { const [serverUrl, setServerUrl] = useState('https://localhost:1234'); useChatRoom({ roomId: roomId, serverUrl: serverUrl }); // ... There are also many excellent custom Hooks for every purpose available in the React ecosystem. Learn more about wrapping Effects in custom Hooks. Examples of wrapping Effects in custom Hooks1. Custom useChatRoom Hook 2. Custom useWindowListener Hook 3. Custom useIntersectionObserver Hook Example 1 of 3: Custom useChatRoom Hook This example is identical to one of the earlier examples, but the logic is extracted to a custom Hook.App.jsuseChatRoom.jschat.jsApp.js ResetForkimport { useState } from 'react'; import { useChatRoom } from './useChatRoom.js'; function ChatRoom({ roomId }) { const [serverUrl, setServerUrl] = useState('https://localhost:1234'); useChatRoom({ roomId: roomId, serverUrl: serverUrl }); return (  label Server URL:{' '} input value={serverUrl} onChange={e = setServerUrl(e.target.value)} / /label h1Welcome to the {roomId} room!/h1 / ); } export default function App() { const [roomId, setRoomId] = useState('general'); const [show, setShow] = useState(false); return (  label Choose the chat room:{' '} select value={roomId} onChange={e = setRoomId(e.target.value)}  option value=\"general\"general/option option value=\"travel\"travel/option option value=\"music\"music/option /select /label button onClick={() = setShow(!show)} {show ? 'Close chat' : 'Open chat'} /button {show && hr /} {show && ChatRoom roomId={roomId} /} / ); } Show moreNext Example Controlling a non-React widget Sometimes, you want to keep an external system synchronized to some prop or state of your component. For example, if you have a third-party map widget or a video player component written without React, you can use an Effect to call methods on it that make its state match the current state of your React component. This Effect creates an instance of a MapWidget class defined in map-widget.js. When you change the zoomLevel prop of the Map component, the Effect calls the setZoom() on the class instance to keep it synchronized: App.jsMap.jsmap-widget.jsMap.js ResetForkimport { useRef, useEffect } from 'react'; import { MapWidget } from './map-widget.js'; export default function Map({ zoomLevel }) { const containerRef = useRef(null); const mapRef = useRef(null); useEffect(() = { if (mapRef.current === null) { mapRef.current = new MapWidget(containerRef.current); } const map = mapRef.current; map.setZoom(zoomLevel); }, [zoomLevel]); return ( div style={{ width: 200, height: 200 }} ref={containerRef} / ); } Show more In this example, a cleanup function is not needed because the MapWidget class manages only the DOM node that was passed to it. After the Map React component is removed from the tree, both the DOM node and the MapWidget class instance will be automatically garbage-collected by the browser JavaScript engine. Fetching data with Effects You can use an Effect to fetch data for your component. Note that if you use a framework, using your frameworks data fetching mechanism will be a lot more efficient than writing Effects manually. If you want to fetch data from an Effect manually, your code might look like this: import { useState, useEffect } from 'react';import { fetchBio } from './api.js';export default function Page() { const [person, setPerson] = useState('Alice'); const [bio, setBio] = useState(null); useEffect(() = { let ignore = false; setBio(null); fetchBio(person).then(result = { if (!ignore) { setBio(result); } }); return () = { ignore = true; }; }, [person]); // ... Note the ignore variable which is initialized to false, and is set to true during cleanup. This ensures your code doesnt suffer from race conditions: network responses may arrive in a different order than you sent them. App.jsApp.js ResetForkimport { useState, useEffect } from 'react'; import { fetchBio } from './api.js'; export default function Page() { const [person, setPerson] = useState('Alice'); const [bio, setBio] = useState(null); useEffect(() = { let ignore = false; setBio(null); fetchBio(person).then(result = { if (!ignore) { setBio(result); } }); return () = { ignore = true; } }, [person]); return (  select value={person} onChange={e = { setPerson(e.target.value); }} option value=\"Alice\"Alice/option option value=\"Bob\"Bob/option option value=\"Taylor\"Taylor/option /select hr / pi{bio ?? 'Loading...'}/i/p / ); } Show more You can also rewrite using the async / await syntax, but you still need to provide a cleanup function: App.jsApp.js ResetForkimport { useState, useEffect } from 'react'; import { fetchBio } from './api.js'; export default function Page() { const [person, setPerson] = useState('Alice'); const [bio, setBio] = useState(null); useEffect(() = { async function startFetching() { setBio(null); const result = await fetchBio(person); if (!ignore) { setBio(result); } } let ignore = false; startFetching(); return () = { ignore = true; } }, [person]); return (  select value={person} onChange={e = { setPerson(e.target.value); }} option value=\"Alice\"Alice/option option value=\"Bob\"Bob/option option value=\"Taylor\"Taylor/option /select hr / pi{bio ?? 'Loading...'}/i/p / ); } Show more Writing data fetching directly in Effects gets repetitive and makes it difficult to add optimizations like caching and server rendering later. Its easier to use a custom Hookeither your own or maintained by the community. Deep DiveWhat are good alternatives to data fetching in Effects? Show DetailsWriting fetch calls inside Effects is a popular way to fetch data, especially in fully client-side apps. This is, however, a very manual approach and it has significant downsides: Effects dont run on the server. This means that the initial server-rendered HTML will only include a loading state with no data. The client computer will have to download all JavaScript and render your app only to discover that now it needs to load the data. This is not very efficient. Fetching directly in Effects makes it easy to create network waterfalls. You render the parent component, it fetches some data, renders the child components, and then they start fetching their data. If the network is not very fast, this is significantly slower than fetching all data in parallel. Fetching directly in Effects usually means you dont preload or cache data. For example, if the component unmounts and then mounts again, it would have to fetch the data again. Its not very ergonomic. Theres quite a bit of boilerplate code involved when writing fetch calls in a way that doesnt suffer from bugs like race conditions. This list of downsides is not specific to React. It applies to fetching data on mount with any library. Like with routing, data fetching is not trivial to do well, so we recommend the following approaches: If you use a framework, use its built-in data fetching mechanism. Modern React frameworks have integrated data fetching mechanisms that are efficient and dont suffer from the above pitfalls. Otherwise, consider using or building a client-side cache. Popular open source solutions include React Query, useSWR, and React Router 6.4+. You can build your own solution too, in which case you would use Effects under the hood but also add logic for deduplicating requests, caching responses, and avoiding network waterfalls (by preloading data or hoisting data requirements to routes). You can continue fetching data directly in Effects if neither of these approaches suit you. Specifying reactive dependencies Notice that you cant choose the dependencies of your Effect. Every reactive value used by your Effects code must be declared as a dependency. Your Effects dependency list is determined by the surrounding code: function ChatRoom({ roomId }) { // This is a reactive value const [serverUrl, setServerUrl] = useState('https://localhost:1234'); // This is a reactive value too useEffect(() = { const connection = createConnection(serverUrl, roomId); // This Effect reads these reactive values connection.connect(); return () = connection.disconnect(); }, [serverUrl, roomId]); //  So you must specify them as dependencies of your Effect // ...} If either serverUrl or roomId change, your Effect will reconnect to the chat using the new values. Reactive values include props and all variables and functions declared directly inside of your component. Since roomId and serverUrl are reactive values, you cant remove them from the dependencies. If you try to omit them and your linter is correctly configured for React, the linter will flag this as a mistake you need to fix: function ChatRoom({ roomId }) { const [serverUrl, setServerUrl] = useState('https://localhost:1234'); useEffect(() = { const connection = createConnection(serverUrl, roomId); connection.connect(); return () = connection.disconnect(); }, []); //  React Hook useEffect has missing dependencies: 'roomId' and 'serverUrl' // ...} To remove a dependency, you need to prove to the linter that it doesnt need to be a dependency. For example, you can move serverUrl out of your component to prove that its not reactive and wont change on re-renders: const serverUrl = 'https://localhost:1234'; // Not a reactive value anymorefunction ChatRoom({ roomId }) { useEffect(() = { const connection = createConnection(serverUrl, roomId); connection.connect(); return () = connection.disconnect(); }, [roomId]); //  All dependencies declared // ...} Now that serverUrl is not a reactive value (and cant change on a re-render), it doesnt need to be a dependency. If your Effects code doesnt use any reactive values, its dependency list should be empty ([]): const serverUrl = 'https://localhost:1234'; // Not a reactive value anymoreconst roomId = 'music'; // Not a reactive value anymorefunction ChatRoom() { useEffect(() = { const connection = createConnection(serverUrl, roomId); connection.connect(); return () = connection.disconnect(); }, []); //  All dependencies declared // ...} An Effect with empty dependencies doesnt re-run when any of your components props or state change. PitfallIf you have an existing codebase, you might have some Effects that suppress the linter like this:useEffect(() = { // ... //  Avoid suppressing the linter like this: // eslint-ignore-next-line react-hooks/exhaustive-deps}, []);When dependencies dont match the code, there is a high risk of introducing bugs. By suppressing the linter, you lie to React about the values your Effect depends on. Instead, prove theyre unnecessary. Examples of passing reactive dependencies1. Passing a dependency array 2. Passing an empty dependency array 3. Passing no dependency array at all Example 1 of 3: Passing a dependency array If you specify the dependencies, your Effect runs after the initial render and after re-renders with changed dependencies.useEffect(() = { // ...}, [a, b]); // Runs again if a or b are differentIn the below example, serverUrl and roomId are reactive values, so they both must be specified as dependencies. As a result, selecting a different room in the dropdown or editing the server URL input causes the chat to re-connect. However, since message isnt used in the Effect (and so it isnt a dependency), editing the message doesnt re-connect to the chat.App.jschat.jsApp.js ResetForkimport { useState, useEffect } from 'react'; import { createConnection } from './chat.js'; function ChatRoom({ roomId }) { const [serverUrl, setServerUrl] = useState('https://localhost:1234'); const [message, setMessage] = useState(''); useEffect(() = { const connection = createConnection(serverUrl, roomId); connection.connect(); return () = { connection.disconnect(); }; }, [serverUrl, roomId]); return (  label Server URL:{' '} input value={serverUrl} onChange={e = setServerUrl(e.target.value)} / /label h1Welcome to the {roomId} room!/h1 label Your message:{' '} input value={message} onChange={e = setMessage(e.target.value)} / /label / ); } export default function App() { const [show, setShow] = useState(false); const [roomId, setRoomId] = useState('general'); return (  label Choose the chat room:{' '} select value={roomId} onChange={e = setRoomId(e.target.value)}  option value=\"general\"general/option option value=\"travel\"travel/option option value=\"music\"music/option /select button onClick={() = setShow(!show)} {show ? 'Close chat' : 'Open chat'} /button /label {show && hr /} {show && ChatRoom roomId={roomId}/} / ); } Show moreNext Example Updating state based on previous state from an Effect When you want to update state based on previous state from an Effect, you might run into a problem: function Counter() { const [count, setCount] = useState(0); useEffect(() = { const intervalId = setInterval(() = { setCount(count + 1); // You want to increment the counter every second... }, 1000) return () = clearInterval(intervalId); }, [count]); //  ... but specifying count as a dependency always resets the interval. // ...} Since count is a reactive value, it must be specified in the list of dependencies. However, that causes the Effect to cleanup and setup again every time the count changes. This is not ideal. To fix this, pass the c = c + 1 state updater to setCount: App.jsApp.js Download ResetForkimport { useState, useEffect } from 'react'; export default function Counter() { const [count, setCount] = useState(0); useEffect(() = { const intervalId = setInterval(() = { setCount(c = c + 1); //  Pass a state updater }, 1000); return () = clearInterval(intervalId); }, []); //  Now count is not a dependency return h1{count}/h1; } Now that youre passing c = c + 1 instead of count + 1, your Effect no longer needs to depend on count. As a result of this fix, it wont need to cleanup and setup the interval again every time the count changes. Removing unnecessary object dependencies If your Effect depends on an object or a function created during rendering, it might run too often. For example, this Effect re-connects after every render because the options object is different for every render: const serverUrl = 'https://localhost:1234';function ChatRoom({ roomId }) { const [message, setMessage] = useState(''); const options = { //  This object is created from scratch on every re-render serverUrl: serverUrl, roomId: roomId }; useEffect(() = { const connection = createConnection(options); // It's used inside the Effect connection.connect(); return () = connection.disconnect(); }, [options]); //  As a result, these dependencies are always different on a re-render // ... Avoid using an object created during rendering as a dependency. Instead, create the object inside the Effect: App.jschat.jsApp.js ResetForkimport { useState, useEffect } from 'react'; import { createConnection } from './chat.js'; const serverUrl = 'https://localhost:1234'; function ChatRoom({ roomId }) { const [message, setMessage] = useState(''); useEffect(() = { const options = { serverUrl: serverUrl, roomId: roomId }; const connection = createConnection(options); connection.connect(); return () = connection.disconnect(); }, [roomId]); return (  h1Welcome to the {roomId} room!/h1 input value={message} onChange={e = setMessage(e.target.value)} / / ); } export default function App() { const [roomId, setRoomId] = useState('general'); return (  label Choose the chat room:{' '} select value={roomId} onChange={e = setRoomId(e.target.value)}  option value=\"general\"general/option option value=\"travel\"travel/option option value=\"music\"music/option /select /label hr / ChatRoom roomId={roomId} / / ); } Show more Now that you create the options object inside the Effect, the Effect itself only depends on the roomId string. With this fix, typing into the input doesnt reconnect the chat. Unlike an object which gets re-created, a string like roomId doesnt change unless you set it to another value. Read more about removing dependencies. Removing unnecessary function dependencies If your Effect depends on an object or a function created during rendering, it might run too often. For example, this Effect re-connects after every render because the createOptions function is different for every render: function ChatRoom({ roomId }) { const [message, setMessage] = useState(''); function createOptions() { //  This function is created from scratch on every re-render return { serverUrl: serverUrl, roomId: roomId }; } useEffect(() = { const options = createOptions(); // It's used inside the Effect const connection = createConnection(); connection.connect(); return () = connection.disconnect(); }, [createOptions]); //  As a result, these dependencies are always different on a re-render // ... By itself, creating a function from scratch on every re-render is not a problem. You dont need to optimize that. However, if you use it as a dependency of your Effect, it will cause your Effect to re-run after every re-render. Avoid using a function created during rendering as a dependency. Instead, declare it inside the Effect: App.jschat.jsApp.js ResetForkimport { useState, useEffect } from 'react'; import { createConnection } from './chat.js'; const serverUrl = 'https://localhost:1234'; function ChatRoom({ roomId }) { const [message, setMessage] = useState(''); useEffect(() = { function createOptions() { return { serverUrl: serverUrl, roomId: roomId }; } const options = createOptions(); const connection = createConnection(options); connection.connect(); return () = connection.disconnect(); }, [roomId]); return (  h1Welcome to the {roomId} room!/h1 input value={message} onChange={e = setMessage(e.target.value)} / / ); } export default function App() { const [roomId, setRoomId] = useState('general'); return (  label Choose the chat room:{' '} select value={roomId} onChange={e = setRoomId(e.target.value)}  option value=\"general\"general/option option value=\"travel\"travel/option option value=\"music\"music/option /select /label hr / ChatRoom roomId={roomId} / / ); } Show more Now that you define the createOptions function inside the Effect, the Effect itself only depends on the roomId string. With this fix, typing into the input doesnt reconnect the chat. Unlike a function which gets re-created, a string like roomId doesnt change unless you set it to another value. Read more about removing dependencies. Reading the latest props and state from an Effect Under ConstructionThis section describes an experimental API that has not yet been released in a stable version of React. By default, when you read a reactive value from an Effect, you have to add it as a dependency. This ensures that your Effect reacts to every change of that value. For most dependencies, thats the behavior you want. However, sometimes youll want to read the latest props and state from an Effect without reacting to them. For example, imagine you want to log the number of the items in the shopping cart for every page visit: function Page({ url, shoppingCart }) { useEffect(() = { logVisit(url, shoppingCart.length); }, [url, shoppingCart]); //  All dependencies declared // ...} What if you want to log a new page visit after every url change, but not if only the shoppingCart changes? You cant exclude shoppingCart from dependencies without breaking the reactivity rules. However, you can express that you dont want a piece of code to react to changes even though it is called from inside an Effect. Declare an Effect Event with the useEffectEvent Hook, and move the code reading shoppingCart inside of it: function Page({ url, shoppingCart }) { const onVisit = useEffectEvent(visitedUrl = { logVisit(visitedUrl, shoppingCart.length) }); useEffect(() = { onVisit(url); }, [url]); //  All dependencies declared // ...} Effect Events are not reactive and must always be omitted from dependencies of your Effect. This is what lets you put non-reactive code (where you can read the latest value of some props and state) inside of them. By reading shoppingCart inside of onVisit, you ensure that shoppingCart wont re-run your Effect. Read more about how Effect Events let you separate reactive and non-reactive code. Displaying different content on the server and the client If your app uses server rendering (either directly or via a framework), your component will render in two different environments. On the server, it will render to produce the initial HTML. On the client, React will run the rendering code again so that it can attach your event handlers to that HTML. This is why, for hydration to work, your initial render output must be identical on the client and the server. In rare cases, you might need to display different content on the client. For example, if your app reads some data from localStorage, it cant possibly do that on the server. Here is how you could implement this: function MyComponent() { const [didMount, setDidMount] = useState(false); useEffect(() = { setDidMount(true); }, []); if (didMount) { // ... return client-only JSX ... } else { // ... return initial JSX ... }} While the app is loading, the user will see the initial render output. Then, when its loaded and hydrated, your Effect will run and set didMount to true, triggering a re-render. This will switch to the client-only render output. Effects dont run on the server, so this is why didMount was false during the initial server render. Use this pattern sparingly. Keep in mind that users with a slow connection will see the initial content for quite a bit of timepotentially, many secondsso you dont want to make jarring changes to your components appearance. In many cases, you can avoid the need for this by conditionally showing different things with CSS. Troubleshooting My Effect runs twice when the component mounts When Strict Mode is on, in development, React runs setup and cleanup one extra time before the actual setup. This is a stress-test that verifies your Effects logic is implemented correctly. If this causes visible issues, your cleanup function is missing some logic. The cleanup function should stop or undo whatever the setup function was doing. The rule of thumb is that the user shouldnt be able to distinguish between the setup being called once (as in production) and a setup  cleanup  setup sequence (as in development). Read more about how this helps find bugs and how to fix your logic. My Effect runs after every re-render First, check that you havent forgotten to specify the dependency array: useEffect(() = { // ...}); //  No dependency array: re-runs after every render! If youve specified the dependency array but your Effect still re-runs in a loop, its because one of your dependencies is different on every re-render. You can debug this problem by manually logging your dependencies to the console: useEffect(() = { // .. }, [serverUrl, roomId]); console.log([serverUrl, roomId]); You can then right-click on the arrays from different re-renders in the console and select Store as a global variable for both of them. Assuming the first one got saved as temp1 and the second one got saved as temp2, you can then use the browser console to check whether each dependency in both arrays is the same: Object.is(temp1[0], temp2[0]); // Is the first dependency the same between the arrays?Object.is(temp1[1], temp2[1]); // Is the second dependency the same between the arrays?Object.is(temp1[2], temp2[2]); // ... and so on for every dependency ... When you find the dependency that is different on every re-render, you can usually fix it in one of these ways: Updating state based on previous state from an Effect Removing unnecessary object dependencies Removing unnecessary function dependencies Reading the latest props and state from an Effect As a last resort (if these methods didnt help), wrap its creation with useMemo or useCallback (for functions). My Effect keeps re-running in an infinite cycle If your Effect runs in an infinite cycle, these two things must be true: Your Effect is updating some state. That state leads to a re-render, which causes the Effects dependencies to change. Before you start fixing the problem, ask yourself whether your Effect is connecting to some external system (like DOM, network, a third-party widget, and so on). Why does your Effect need to set state? Does it synchronize with that external system? Or are you trying to manage your applications data flow with it? If there is no external system, consider whether removing the Effect altogether would simplify your logic. If youre genuinely synchronizing with some external system, think about why and under what conditions your Effect should update the state. Has something changed that affects your components visual output? If you need to keep track of some data that isnt used by rendering, a ref (which doesnt trigger re-renders) might be more appropriate. Verify your Effect doesnt update the state (and trigger re-renders) more than needed. Finally, if your Effect is updating the state at the right time, but there is still a loop, its because that state update leads to one of the Effects dependencies changing. Read how to debug dependency changes. My cleanup logic runs even though my component didnt unmount The cleanup function runs not only during unmount, but before every re-render with changed dependencies. Additionally, in development, React runs setup+cleanup one extra time immediately after component mounts. If you have cleanup code without corresponding setup code, its usually a code smell: useEffect(() = { //  Avoid: Cleanup logic without corresponding setup logic return () = { doSomething(); };}, []); Your cleanup logic should be symmetrical to the setup logic, and should stop or undo whatever setup did: useEffect(() = { const connection = createConnection(serverUrl, roomId); connection.connect(); return () = { connection.disconnect(); }; }, [serverUrl, roomId]); Learn how the Effect lifecycle is different from the components lifecycle. My Effect does something visual, and I see a flicker before it runs If your Effect must block the browser from painting the screen, replace useEffect with useLayoutEffect. Note that this shouldnt be needed for the vast majority of Effects. Youll only need this if its crucial to run your Effect before the browser paint: for example, to measure and position a tooltip before the user sees it.PrevioususeDeferredValueNextuseId",
    "headings": [
      {
        "level": 1,
        "text": "useEffect",
        "id": ""
      },
      {
        "level": 2,
        "text": "Reference",
        "id": "reference"
      },
      {
        "level": 2,
        "text": "Usage",
        "id": "usage"
      },
      {
        "level": 2,
        "text": "Troubleshooting",
        "id": "troubleshooting"
      },
      {
        "level": 3,
        "text": "useEffect(setup, dependencies?)",
        "id": "useeffect"
      },
      {
        "level": 3,
        "text": "Connecting to an external system",
        "id": "connecting-to-an-external-system"
      },
      {
        "level": 3,
        "text": "Note",
        "id": ""
      },
      {
        "level": 3,
        "text": "Wrapping Effects in custom Hooks",
        "id": "wrapping-effects-in-custom-hooks"
      },
      {
        "level": 3,
        "text": "Controlling a non-React widget",
        "id": "controlling-a-non-react-widget"
      },
      {
        "level": 3,
        "text": "Fetching data with Effects",
        "id": "fetching-data-with-effects"
      },
      {
        "level": 3,
        "text": "Specifying reactive dependencies",
        "id": "specifying-reactive-dependencies"
      },
      {
        "level": 3,
        "text": "Pitfall",
        "id": ""
      },
      {
        "level": 3,
        "text": "Updating state based on previous state from an Effect",
        "id": "updating-state-based-on-previous-state-from-an-effect"
      },
      {
        "level": 3,
        "text": "Removing unnecessary object dependencies",
        "id": "removing-unnecessary-object-dependencies"
      },
      {
        "level": 3,
        "text": "Removing unnecessary function dependencies",
        "id": "removing-unnecessary-function-dependencies"
      },
      {
        "level": 3,
        "text": "Reading the latest props and state from an Effect",
        "id": "reading-the-latest-props-and-state-from-an-effect"
      },
      {
        "level": 3,
        "text": "Under Construction",
        "id": ""
      },
      {
        "level": 3,
        "text": "Displaying different content on the server and the client",
        "id": "displaying-different-content-on-the-server-and-the-client"
      },
      {
        "level": 3,
        "text": "My Effect runs twice when the component mounts",
        "id": "my-effect-runs-twice-when-the-component-mounts"
      },
      {
        "level": 3,
        "text": "My Effect runs after every re-render",
        "id": "my-effect-runs-after-every-re-render"
      },
      {
        "level": 3,
        "text": "My Effect keeps re-running in an infinite cycle",
        "id": "my-effect-keeps-re-running-in-an-infinite-cycle"
      },
      {
        "level": 3,
        "text": "My cleanup logic runs even though my component didn’t unmount",
        "id": "my-cleanup-logic-runs-even-though-my-component-didnt-unmount"
      },
      {
        "level": 3,
        "text": "My Effect does something visual, and I see a flicker before it runs",
        "id": "my-effect-does-something-visual-and-i-see-a-flicker-before-it-runs"
      },
      {
        "level": 4,
        "text": "Parameters",
        "id": "parameters"
      },
      {
        "level": 4,
        "text": "Returns",
        "id": "returns"
      },
      {
        "level": 4,
        "text": "Caveats",
        "id": "caveats"
      },
      {
        "level": 4,
        "text": "Examples of connecting to an external system",
        "id": "examples-connecting"
      },
      {
        "level": 4,
        "text": "Example 1 of 5: Connecting to a chat server",
        "id": "connecting-to-a-chat-server"
      },
      {
        "level": 4,
        "text": "Examples of wrapping Effects in custom Hooks",
        "id": "examples-custom-hooks"
      },
      {
        "level": 4,
        "text": "Example 1 of 3: Custom useChatRoom Hook",
        "id": "custom-usechatroom-hook"
      },
      {
        "level": 4,
        "text": "What are good alternatives to data fetching in Effects?",
        "id": "what-are-good-alternatives-to-data-fetching-in-effects"
      },
      {
        "level": 4,
        "text": "Examples of passing reactive dependencies",
        "id": "examples-dependencies"
      },
      {
        "level": 4,
        "text": "Example 1 of 3: Passing a dependency array",
        "id": "passing-a-dependency-array"
      },
      {
        "level": 5,
        "text": "Deep Dive",
        "id": ""
      }
    ],
    "codeBlocks": [
      {
        "language": "text",
        "code": "useEffect(setup, dependencies?)"
      },
      {
        "language": "text",
        "code": "useEffect(setup, dependencies?)"
      },
      {
        "language": "text",
        "code": "useEffect(setup, dependencies?)"
      },
      {
        "language": "text",
        "code": "useEffect(setup, dependencies?)"
      },
      {
        "language": "text",
        "code": "import { useState, useEffect } from 'react';import { createConnection } from './chat.js';function ChatRoom({ roomId }) {  const [serverUrl, setServerUrl] = useState('https://localhost:1234');  useEffect(() => {    const connection = createConnection(serverUrl, roomId);    connection.connect();    return () => {      connection.disconnect();    };  }, [serverUrl, roomId]);  // ...}"
      },
      {
        "language": "text",
        "code": "import { useState, useEffect } from 'react';import { createConnection } from './chat.js';function ChatRoom({ roomId }) {  const [serverUrl, setServerUrl] = useState('https://localhost:1234');  useEffect(() => {    const connection = createConnection(serverUrl, roomId);    connection.connect();    return () => {      connection.disconnect();    };  }, [serverUrl, roomId]);  // ...}"
      },
      {
        "language": "text",
        "code": "dependencies"
      },
      {
        "language": "text",
        "code": "[dep1, dep2, dep3]"
      },
      {
        "language": "text",
        "code": "useLayoutEffect"
      },
      {
        "language": "text",
        "code": "useLayoutEffect"
      },
      {
        "language": "text",
        "code": "import { useState, useEffect } from 'react';import { createConnection } from './chat.js';function ChatRoom({ roomId }) {  const [serverUrl, setServerUrl] = useState('https://localhost:1234');  useEffect(() => {  \tconst connection = createConnection(serverUrl, roomId);    connection.connect();  \treturn () => {      connection.disconnect();  \t};  }, [serverUrl, roomId]);  // ...}"
      },
      {
        "language": "text",
        "code": "import { useState, useEffect } from 'react';import { createConnection } from './chat.js';function ChatRoom({ roomId }) {  const [serverUrl, setServerUrl] = useState('https://localhost:1234');  useEffect(() => {  \tconst connection = createConnection(serverUrl, roomId);    connection.connect();  \treturn () => {      connection.disconnect();  \t};  }, [serverUrl, roomId]);  // ...}"
      },
      {
        "language": "text",
        "code": "setInterval()"
      },
      {
        "language": "text",
        "code": "clearInterval()"
      },
      {
        "language": "text",
        "code": "window.addEventListener()"
      },
      {
        "language": "text",
        "code": "window.removeEventListener()"
      },
      {
        "language": "text",
        "code": "animation.start()"
      },
      {
        "language": "text",
        "code": "animation.reset()"
      },
      {
        "language": "text",
        "code": "import { useState, useEffect } from 'react';\nimport { createConnection } from './chat.js';\n\nfunction ChatRoom({ roomId }) {\n  const [serverUrl, setServerUrl] = useState('https://localhost:1234');\n\n  useEffect(() => {\n    const connection = createConnection(serverUrl, roomId);\n    connection.connect();\n    return () => {\n      connection.disconnect();\n    };\n  }, [roomId, serverUrl]);\n\n  return (\n    <>\n      <label>\n        Server URL:{' '}\n        <input\n          value={serverUrl}\n          onChange={e => setServerUrl(e.target.value)}\n        />\n      </label>\n      <h1>Welcome to the {roomId} room!</h1>\n    </>\n  );\n}\n\nexport default function App() {\n  const [roomId, setRoomId] = useState('general');\n  const [show, setShow] = useState(false);\n  return (\n    <>\n      <label>\n        Choose the chat room:{' '}\n        <select\n          value={roomId}\n          onChange={e => setRoomId(e.target.value)}\n        >\n          <option value=\"general\">general</option>\n          <option value=\"travel\">travel</option>\n          <option value=\"music\">music</option>\n        </select>\n      </label>\n      <button onClick={() => setShow(!show)}>\n        {show ? 'Close chat' : 'Open chat'}\n      </button>\n      {show && <hr />}\n      {show && <ChatRoom roomId={roomId} />}\n    </>\n  );\n}"
      },
      {
        "language": "text",
        "code": "useChatRoom"
      },
      {
        "language": "text",
        "code": "function useChatRoom({ serverUrl, roomId }) {  useEffect(() => {    const options = {      serverUrl: serverUrl,      roomId: roomId    };    const connection = createConnection(options);    connection.connect();    return () => connection.disconnect();  }, [roomId, serverUrl]);}"
      },
      {
        "language": "text",
        "code": "function useChatRoom({ serverUrl, roomId }) {  useEffect(() => {    const options = {      serverUrl: serverUrl,      roomId: roomId    };    const connection = createConnection(options);    connection.connect();    return () => connection.disconnect();  }, [roomId, serverUrl]);}"
      },
      {
        "language": "text",
        "code": "function ChatRoom({ roomId }) {  const [serverUrl, setServerUrl] = useState('https://localhost:1234');  useChatRoom({    roomId: roomId,    serverUrl: serverUrl  });  // ..."
      },
      {
        "language": "text",
        "code": "function ChatRoom({ roomId }) {  const [serverUrl, setServerUrl] = useState('https://localhost:1234');  useChatRoom({    roomId: roomId,    serverUrl: serverUrl  });  // ..."
      },
      {
        "language": "text",
        "code": "useChatRoom"
      },
      {
        "language": "text",
        "code": "useWindowListener"
      },
      {
        "language": "text",
        "code": "useIntersectionObserver"
      },
      {
        "language": "text",
        "code": "useChatRoom"
      },
      {
        "language": "text",
        "code": "import { useState } from 'react';\nimport { useChatRoom } from './useChatRoom.js';\n\nfunction ChatRoom({ roomId }) {\n  const [serverUrl, setServerUrl] = useState('https://localhost:1234');\n\n  useChatRoom({\n    roomId: roomId,\n    serverUrl: serverUrl\n  });\n\n  return (\n    <>\n      <label>\n        Server URL:{' '}\n        <input\n          value={serverUrl}\n          onChange={e => setServerUrl(e.target.value)}\n        />\n      </label>\n      <h1>Welcome to the {roomId} room!</h1>\n    </>\n  );\n}\n\nexport default function App() {\n  const [roomId, setRoomId] = useState('general');\n  const [show, setShow] = useState(false);\n  return (\n    <>\n      <label>\n        Choose the chat room:{' '}\n        <select\n          value={roomId}\n          onChange={e => setRoomId(e.target.value)}\n        >\n          <option value=\"general\">general</option>\n          <option value=\"travel\">travel</option>\n          <option value=\"music\">music</option>\n        </select>\n      </label>\n      <button onClick={() => setShow(!show)}>\n        {show ? 'Close chat' : 'Open chat'}\n      </button>\n      {show && <hr />}\n      {show && <ChatRoom roomId={roomId} />}\n    </>\n  );\n}"
      },
      {
        "language": "text",
        "code": "map-widget.js"
      },
      {
        "language": "text",
        "code": "import { useRef, useEffect } from 'react';\nimport { MapWidget } from './map-widget.js';\n\nexport default function Map({ zoomLevel }) {\n  const containerRef = useRef(null);\n  const mapRef = useRef(null);\n\n  useEffect(() => {\n    if (mapRef.current === null) {\n      mapRef.current = new MapWidget(containerRef.current);\n    }\n\n    const map = mapRef.current;\n    map.setZoom(zoomLevel);\n  }, [zoomLevel]);\n\n  return (\n    <div\n      style={{ width: 200, height: 200 }}\n      ref={containerRef}\n    />\n  );\n}"
      },
      {
        "language": "text",
        "code": "import { useState, useEffect } from 'react';import { fetchBio } from './api.js';export default function Page() {  const [person, setPerson] = useState('Alice');  const [bio, setBio] = useState(null);  useEffect(() => {    let ignore = false;    setBio(null);    fetchBio(person).then(result => {      if (!ignore) {        setBio(result);      }    });    return () => {      ignore = true;    };  }, [person]);  // ..."
      },
      {
        "language": "text",
        "code": "import { useState, useEffect } from 'react';import { fetchBio } from './api.js';export default function Page() {  const [person, setPerson] = useState('Alice');  const [bio, setBio] = useState(null);  useEffect(() => {    let ignore = false;    setBio(null);    fetchBio(person).then(result => {      if (!ignore) {        setBio(result);      }    });    return () => {      ignore = true;    };  }, [person]);  // ..."
      },
      {
        "language": "text",
        "code": "import { useState, useEffect } from 'react';\nimport { fetchBio } from './api.js';\n\nexport default function Page() {\n  const [person, setPerson] = useState('Alice');\n  const [bio, setBio] = useState(null);\n  useEffect(() => {\n    let ignore = false;\n    setBio(null);\n    fetchBio(person).then(result => {\n      if (!ignore) {\n        setBio(result);\n      }\n    });\n    return () => {\n      ignore = true;\n    }\n  }, [person]);\n\n  return (\n    <>\n      <select value={person} onChange={e => {\n        setPerson(e.target.value);\n      }}>\n        <option value=\"Alice\">Alice</option>\n        <option value=\"Bob\">Bob</option>\n        <option value=\"Taylor\">Taylor</option>\n      </select>\n      <hr />\n      <p><i>{bio ?? 'Loading...'}</i></p>\n    </>\n  );\n}"
      },
      {
        "language": "text",
        "code": "import { useState, useEffect } from 'react';\nimport { fetchBio } from './api.js';\n\nexport default function Page() {\n  const [person, setPerson] = useState('Alice');\n  const [bio, setBio] = useState(null);\n  useEffect(() => {\n    async function startFetching() {\n      setBio(null);\n      const result = await fetchBio(person);\n      if (!ignore) {\n        setBio(result);\n      }\n    }\n\n    let ignore = false;\n    startFetching();\n    return () => {\n      ignore = true;\n    }\n  }, [person]);\n\n  return (\n    <>\n      <select value={person} onChange={e => {\n        setPerson(e.target.value);\n      }}>\n        <option value=\"Alice\">Alice</option>\n        <option value=\"Bob\">Bob</option>\n        <option value=\"Taylor\">Taylor</option>\n      </select>\n      <hr />\n      <p><i>{bio ?? 'Loading...'}</i></p>\n    </>\n  );\n}"
      },
      {
        "language": "text",
        "code": "function ChatRoom({ roomId }) { // This is a reactive value  const [serverUrl, setServerUrl] = useState('https://localhost:1234'); // This is a reactive value too  useEffect(() => {    const connection = createConnection(serverUrl, roomId); // This Effect reads these reactive values    connection.connect();    return () => connection.disconnect();  }, [serverUrl, roomId]); // ✅ So you must specify them as dependencies of your Effect  // ...}"
      },
      {
        "language": "text",
        "code": "function ChatRoom({ roomId }) { // This is a reactive value  const [serverUrl, setServerUrl] = useState('https://localhost:1234'); // This is a reactive value too  useEffect(() => {    const connection = createConnection(serverUrl, roomId); // This Effect reads these reactive values    connection.connect();    return () => connection.disconnect();  }, [serverUrl, roomId]); // ✅ So you must specify them as dependencies of your Effect  // ...}"
      },
      {
        "language": "text",
        "code": "function ChatRoom({ roomId }) {  const [serverUrl, setServerUrl] = useState('https://localhost:1234');    useEffect(() => {    const connection = createConnection(serverUrl, roomId);    connection.connect();    return () => connection.disconnect();  }, []); // 🔴 React Hook useEffect has missing dependencies: 'roomId' and 'serverUrl'  // ...}"
      },
      {
        "language": "text",
        "code": "function ChatRoom({ roomId }) {  const [serverUrl, setServerUrl] = useState('https://localhost:1234');    useEffect(() => {    const connection = createConnection(serverUrl, roomId);    connection.connect();    return () => connection.disconnect();  }, []); // 🔴 React Hook useEffect has missing dependencies: 'roomId' and 'serverUrl'  // ...}"
      },
      {
        "language": "text",
        "code": "const serverUrl = 'https://localhost:1234'; // Not a reactive value anymorefunction ChatRoom({ roomId }) {  useEffect(() => {    const connection = createConnection(serverUrl, roomId);    connection.connect();    return () => connection.disconnect();  }, [roomId]); // ✅ All dependencies declared  // ...}"
      },
      {
        "language": "text",
        "code": "const serverUrl = 'https://localhost:1234'; // Not a reactive value anymorefunction ChatRoom({ roomId }) {  useEffect(() => {    const connection = createConnection(serverUrl, roomId);    connection.connect();    return () => connection.disconnect();  }, [roomId]); // ✅ All dependencies declared  // ...}"
      },
      {
        "language": "text",
        "code": "const serverUrl = 'https://localhost:1234'; // Not a reactive value anymoreconst roomId = 'music'; // Not a reactive value anymorefunction ChatRoom() {  useEffect(() => {    const connection = createConnection(serverUrl, roomId);    connection.connect();    return () => connection.disconnect();  }, []); // ✅ All dependencies declared  // ...}"
      },
      {
        "language": "text",
        "code": "const serverUrl = 'https://localhost:1234'; // Not a reactive value anymoreconst roomId = 'music'; // Not a reactive value anymorefunction ChatRoom() {  useEffect(() => {    const connection = createConnection(serverUrl, roomId);    connection.connect();    return () => connection.disconnect();  }, []); // ✅ All dependencies declared  // ...}"
      },
      {
        "language": "text",
        "code": "useEffect(() => {  // ...  // 🔴 Avoid suppressing the linter like this:  // eslint-ignore-next-line react-hooks/exhaustive-deps}, []);"
      },
      {
        "language": "text",
        "code": "useEffect(() => {  // ...  // 🔴 Avoid suppressing the linter like this:  // eslint-ignore-next-line react-hooks/exhaustive-deps}, []);"
      },
      {
        "language": "text",
        "code": "useEffect(() => {  // ...}, [a, b]); // Runs again if a or b are different"
      },
      {
        "language": "text",
        "code": "useEffect(() => {  // ...}, [a, b]); // Runs again if a or b are different"
      },
      {
        "language": "text",
        "code": "import { useState, useEffect } from 'react';\nimport { createConnection } from './chat.js';\n\nfunction ChatRoom({ roomId }) {\n  const [serverUrl, setServerUrl] = useState('https://localhost:1234');\n  const [message, setMessage] = useState('');\n\n  useEffect(() => {\n    const connection = createConnection(serverUrl, roomId);\n    connection.connect();\n    return () => {\n      connection.disconnect();\n    };\n  }, [serverUrl, roomId]);\n\n  return (\n    <>\n      <label>\n        Server URL:{' '}\n        <input\n          value={serverUrl}\n          onChange={e => setServerUrl(e.target.value)}\n        />\n      </label>\n      <h1>Welcome to the {roomId} room!</h1>\n      <label>\n        Your message:{' '}\n        <input value={message} onChange={e => setMessage(e.target.value)} />\n      </label>\n    </>\n  );\n}\n\nexport default function App() {\n  const [show, setShow] = useState(false);\n  const [roomId, setRoomId] = useState('general');\n  return (\n    <>\n      <label>\n        Choose the chat room:{' '}\n        <select\n          value={roomId}\n          onChange={e => setRoomId(e.target.value)}\n        >\n          <option value=\"general\">general</option>\n          <option value=\"travel\">travel</option>\n          <option value=\"music\">music</option>\n        </select>\n        <button onClick={() => setShow(!show)}>\n          {show ? 'Close chat' : 'Open chat'}\n        </button>\n      </label>\n      {show && <hr />}\n      {show && <ChatRoom roomId={roomId}/>}\n    </>\n  );\n}"
      },
      {
        "language": "text",
        "code": "function Counter() {  const [count, setCount] = useState(0);  useEffect(() => {    const intervalId = setInterval(() => {      setCount(count + 1); // You want to increment the counter every second...    }, 1000)    return () => clearInterval(intervalId);  }, [count]); // 🚩 ... but specifying `count` as a dependency always resets the interval.  // ...}"
      },
      {
        "language": "text",
        "code": "function Counter() {  const [count, setCount] = useState(0);  useEffect(() => {    const intervalId = setInterval(() => {      setCount(count + 1); // You want to increment the counter every second...    }, 1000)    return () => clearInterval(intervalId);  }, [count]); // 🚩 ... but specifying `count` as a dependency always resets the interval.  // ...}"
      },
      {
        "language": "text",
        "code": "import { useState, useEffect } from 'react';\n\nexport default function Counter() {\n  const [count, setCount] = useState(0);\n\n  useEffect(() => {\n    const intervalId = setInterval(() => {\n      setCount(c => c + 1); // ✅ Pass a state updater\n    }, 1000);\n    return () => clearInterval(intervalId);\n  }, []); // ✅ Now count is not a dependency\n\n  return <h1>{count}</h1>;\n}"
      },
      {
        "language": "text",
        "code": "const serverUrl = 'https://localhost:1234';function ChatRoom({ roomId }) {  const [message, setMessage] = useState('');  const options = { // 🚩 This object is created from scratch on every re-render    serverUrl: serverUrl,    roomId: roomId  };  useEffect(() => {    const connection = createConnection(options); // It's used inside the Effect    connection.connect();    return () => connection.disconnect();  }, [options]); // 🚩 As a result, these dependencies are always different on a re-render  // ..."
      },
      {
        "language": "text",
        "code": "const serverUrl = 'https://localhost:1234';function ChatRoom({ roomId }) {  const [message, setMessage] = useState('');  const options = { // 🚩 This object is created from scratch on every re-render    serverUrl: serverUrl,    roomId: roomId  };  useEffect(() => {    const connection = createConnection(options); // It's used inside the Effect    connection.connect();    return () => connection.disconnect();  }, [options]); // 🚩 As a result, these dependencies are always different on a re-render  // ..."
      },
      {
        "language": "text",
        "code": "import { useState, useEffect } from 'react';\nimport { createConnection } from './chat.js';\n\nconst serverUrl = 'https://localhost:1234';\n\nfunction ChatRoom({ roomId }) {\n  const [message, setMessage] = useState('');\n\n  useEffect(() => {\n    const options = {\n      serverUrl: serverUrl,\n      roomId: roomId\n    };\n    const connection = createConnection(options);\n    connection.connect();\n    return () => connection.disconnect();\n  }, [roomId]);\n\n  return (\n    <>\n      <h1>Welcome to the {roomId} room!</h1>\n      <input value={message} onChange={e => setMessage(e.target.value)} />\n    </>\n  );\n}\n\nexport default function App() {\n  const [roomId, setRoomId] = useState('general');\n  return (\n    <>\n      <label>\n        Choose the chat room:{' '}\n        <select\n          value={roomId}\n          onChange={e => setRoomId(e.target.value)}\n        >\n          <option value=\"general\">general</option>\n          <option value=\"travel\">travel</option>\n          <option value=\"music\">music</option>\n        </select>\n      </label>\n      <hr />\n      <ChatRoom roomId={roomId} />\n    </>\n  );\n}"
      },
      {
        "language": "text",
        "code": "createOptions"
      },
      {
        "language": "text",
        "code": "function ChatRoom({ roomId }) {  const [message, setMessage] = useState('');  function createOptions() { // 🚩 This function is created from scratch on every re-render    return {      serverUrl: serverUrl,      roomId: roomId    };  }  useEffect(() => {    const options = createOptions(); // It's used inside the Effect    const connection = createConnection();    connection.connect();    return () => connection.disconnect();  }, [createOptions]); // 🚩 As a result, these dependencies are always different on a re-render  // ..."
      },
      {
        "language": "text",
        "code": "function ChatRoom({ roomId }) {  const [message, setMessage] = useState('');  function createOptions() { // 🚩 This function is created from scratch on every re-render    return {      serverUrl: serverUrl,      roomId: roomId    };  }  useEffect(() => {    const options = createOptions(); // It's used inside the Effect    const connection = createConnection();    connection.connect();    return () => connection.disconnect();  }, [createOptions]); // 🚩 As a result, these dependencies are always different on a re-render  // ..."
      },
      {
        "language": "text",
        "code": "import { useState, useEffect } from 'react';\nimport { createConnection } from './chat.js';\n\nconst serverUrl = 'https://localhost:1234';\n\nfunction ChatRoom({ roomId }) {\n  const [message, setMessage] = useState('');\n\n  useEffect(() => {\n    function createOptions() {\n      return {\n        serverUrl: serverUrl,\n        roomId: roomId\n      };\n    }\n\n    const options = createOptions();\n    const connection = createConnection(options);\n    connection.connect();\n    return () => connection.disconnect();\n  }, [roomId]);\n\n  return (\n    <>\n      <h1>Welcome to the {roomId} room!</h1>\n      <input value={message} onChange={e => setMessage(e.target.value)} />\n    </>\n  );\n}\n\nexport default function App() {\n  const [roomId, setRoomId] = useState('general');\n  return (\n    <>\n      <label>\n        Choose the chat room:{' '}\n        <select\n          value={roomId}\n          onChange={e => setRoomId(e.target.value)}\n        >\n          <option value=\"general\">general</option>\n          <option value=\"travel\">travel</option>\n          <option value=\"music\">music</option>\n        </select>\n      </label>\n      <hr />\n      <ChatRoom roomId={roomId} />\n    </>\n  );\n}"
      },
      {
        "language": "text",
        "code": "createOptions"
      },
      {
        "language": "text",
        "code": "function Page({ url, shoppingCart }) {  useEffect(() => {    logVisit(url, shoppingCart.length);  }, [url, shoppingCart]); // ✅ All dependencies declared  // ...}"
      },
      {
        "language": "text",
        "code": "function Page({ url, shoppingCart }) {  useEffect(() => {    logVisit(url, shoppingCart.length);  }, [url, shoppingCart]); // ✅ All dependencies declared  // ...}"
      },
      {
        "language": "text",
        "code": "shoppingCart"
      },
      {
        "language": "text",
        "code": "shoppingCart"
      },
      {
        "language": "text",
        "code": "useEffectEvent"
      },
      {
        "language": "text",
        "code": "shoppingCart"
      },
      {
        "language": "text",
        "code": "function Page({ url, shoppingCart }) {  const onVisit = useEffectEvent(visitedUrl => {    logVisit(visitedUrl, shoppingCart.length)  });  useEffect(() => {    onVisit(url);  }, [url]); // ✅ All dependencies declared  // ...}"
      },
      {
        "language": "text",
        "code": "function Page({ url, shoppingCart }) {  const onVisit = useEffectEvent(visitedUrl => {    logVisit(visitedUrl, shoppingCart.length)  });  useEffect(() => {    onVisit(url);  }, [url]); // ✅ All dependencies declared  // ...}"
      },
      {
        "language": "text",
        "code": "shoppingCart"
      },
      {
        "language": "text",
        "code": "shoppingCart"
      },
      {
        "language": "text",
        "code": "localStorage"
      },
      {
        "language": "text",
        "code": "function MyComponent() {  const [didMount, setDidMount] = useState(false);  useEffect(() => {    setDidMount(true);  }, []);  if (didMount) {    // ... return client-only JSX ...  }  else {    // ... return initial JSX ...  }}"
      },
      {
        "language": "text",
        "code": "function MyComponent() {  const [didMount, setDidMount] = useState(false);  useEffect(() => {    setDidMount(true);  }, []);  if (didMount) {    // ... return client-only JSX ...  }  else {    // ... return initial JSX ...  }}"
      },
      {
        "language": "text",
        "code": "useEffect(() => {  // ...}); // 🚩 No dependency array: re-runs after every render!"
      },
      {
        "language": "text",
        "code": "useEffect(() => {  // ...}); // 🚩 No dependency array: re-runs after every render!"
      },
      {
        "language": "text",
        "code": "useEffect(() => {    // ..  }, [serverUrl, roomId]);  console.log([serverUrl, roomId]);"
      },
      {
        "language": "text",
        "code": "useEffect(() => {    // ..  }, [serverUrl, roomId]);  console.log([serverUrl, roomId]);"
      },
      {
        "language": "text",
        "code": "Object.is(temp1[0], temp2[0]); // Is the first dependency the same between the arrays?Object.is(temp1[1], temp2[1]); // Is the second dependency the same between the arrays?Object.is(temp1[2], temp2[2]); // ... and so on for every dependency ..."
      },
      {
        "language": "text",
        "code": "Object.is(temp1[0], temp2[0]); // Is the first dependency the same between the arrays?Object.is(temp1[1], temp2[1]); // Is the second dependency the same between the arrays?Object.is(temp1[2], temp2[2]); // ... and so on for every dependency ..."
      },
      {
        "language": "text",
        "code": "useCallback"
      },
      {
        "language": "text",
        "code": "useEffect(() => {  // 🔴 Avoid: Cleanup logic without corresponding setup logic  return () => {    doSomething();  };}, []);"
      },
      {
        "language": "text",
        "code": "useEffect(() => {  // 🔴 Avoid: Cleanup logic without corresponding setup logic  return () => {    doSomething();  };}, []);"
      },
      {
        "language": "text",
        "code": "useEffect(() => {    const connection = createConnection(serverUrl, roomId);    connection.connect();    return () => {      connection.disconnect();    };  }, [serverUrl, roomId]);"
      },
      {
        "language": "text",
        "code": "useEffect(() => {    const connection = createConnection(serverUrl, roomId);    connection.connect();    return () => {      connection.disconnect();    };  }, [serverUrl, roomId]);"
      },
      {
        "language": "text",
        "code": "useLayoutEffect"
      }
    ],
    "links": [
      {
        "text": "API Reference",
        "href": "/reference/react"
      },
      {
        "text": "Hooks",
        "href": "/reference/react/hooks"
      },
      {
        "text": "synchronize a component with an external system.",
        "href": "/learn/synchronizing-with-effects"
      },
      {
        "text": "configured for React",
        "href": "/learn/editor-setup#linting"
      },
      {
        "text": "Object.is",
        "href": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/is"
      },
      {
        "text": "you probably don’t need an Effect.",
        "href": "/learn/you-might-not-need-an-effect"
      },
      {
        "text": "implement the cleanup function.",
        "href": "/learn/synchronizing-with-effects#how-to-handle-the-effect-firing-twice-in-development"
      },
      {
        "text": "useLayoutEffect.",
        "href": "/reference/react/useLayoutEffect"
      },
      {
        "text": "reactwg/react-18/128",
        "href": "https://github.com/reactwg/react-18/discussions/128"
      },
      {
        "text": "useLayoutEffect.",
        "href": "/reference/react/useLayoutEffect"
      },
      {
        "text": "connect your component to some external system,",
        "href": "/learn/synchronizing-with-effects"
      },
      {
        "text": "help you find bugs,",
        "href": "/learn/synchronizing-with-effects#step-3-add-cleanup-if-needed"
      },
      {
        "text": "See common solutions.",
        "href": "/learn/synchronizing-with-effects#how-to-handle-the-effect-firing-twice-in-development"
      },
      {
        "text": "write every Effect as an independent process",
        "href": "/learn/lifecycle-of-reactive-effects#each-effect-represents-a-separate-synchronization-process"
      },
      {
        "text": "think about a single setup/cleanup cycle at a time.",
        "href": "/learn/lifecycle-of-reactive-effects#thinking-from-the-effects-perspective"
      },
      {
        "text": "keep your component synchronized",
        "href": "/learn/synchronizing-with-effects"
      },
      {
        "text": "setInterval()",
        "href": "https://developer.mozilla.org/en-US/docs/Web/API/setInterval"
      },
      {
        "text": "clearInterval()",
        "href": "https://developer.mozilla.org/en-US/docs/Web/API/clearInterval"
      },
      {
        "text": "window.addEventListener()",
        "href": "https://developer.mozilla.org/en-US/docs/Web/API/EventTarget/addEventListener"
      },
      {
        "text": "window.removeEventListener()",
        "href": "https://developer.mozilla.org/en-US/docs/Web/API/EventTarget/removeEventListener"
      },
      {
        "text": "you probably don’t need an Effect.",
        "href": "/learn/you-might-not-need-an-effect"
      },
      {
        "text": "explained here.",
        "href": "/learn/synchronizing-with-effects#step-3-add-cleanup-if-needed"
      },
      {
        "text": "“escape hatch”:",
        "href": "/learn/escape-hatches"
      },
      {
        "text": "custom Hooks",
        "href": "/learn/reusing-logic-with-custom-hooks"
      },
      {
        "text": "Learn more about wrapping Effects in custom Hooks.",
        "href": "/learn/reusing-logic-with-custom-hooks"
      },
      {
        "text": "if you use a framework,",
        "href": "/learn/start-a-new-react-project#full-stack-frameworks"
      },
      {
        "text": "your code doesn’t suffer from “race conditions”:",
        "href": "https://maxrozen.com/race-conditions-fetching-data-react-with-useeffect"
      },
      {
        "text": "async / await",
        "href": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Statements/async_function"
      },
      {
        "text": "It’s easier to use a custom Hook—either your own or maintained by the community.",
        "href": "/learn/reusing-logic-with-custom-hooks#when-to-use-custom-hooks"
      },
      {
        "text": "popular way to fetch data",
        "href": "https://www.robinwieruch.de/react-hooks-fetch-data/"
      },
      {
        "text": "race conditions.",
        "href": "https://maxrozen.com/race-conditions-fetching-data-react-with-useeffect"
      },
      {
        "text": "framework",
        "href": "/learn/start-a-new-react-project#full-stack-frameworks"
      },
      {
        "text": "React Query",
        "href": "https://tanstack.com/query/latest/"
      },
      {
        "text": "useSWR",
        "href": "https://swr.vercel.app/"
      },
      {
        "text": "React Router 6.4+.",
        "href": "https://beta.reactrouter.com/en/main/start/overview"
      },
      {
        "text": "Reactive values",
        "href": "/learn/lifecycle-of-reactive-effects#effects-react-to-reactive-values"
      },
      {
        "text": "your linter is correctly configured for React,",
        "href": "/learn/editor-setup#linting"
      },
      {
        "text": "“prove” to the linter that it doesn’t need to be a dependency.",
        "href": "/learn/removing-effect-dependencies#removing-unnecessary-dependencies"
      },
      {
        "text": "An Effect with empty dependencies",
        "href": "/learn/lifecycle-of-reactive-effects#what-an-effect-with-empty-dependencies-means"
      },
      {
        "text": "Instead, prove they’re unnecessary.",
        "href": "/learn/removing-effect-dependencies#removing-unnecessary-dependencies"
      },
      {
        "text": "reactive values,",
        "href": "/learn/lifecycle-of-reactive-effects#effects-react-to-reactive-values"
      },
      {
        "text": "pass the c => c + 1 state updater",
        "href": "/reference/react/useState#updating-state-based-on-the-previous-state"
      },
      {
        "text": "your Effect no longer needs to depend on count.",
        "href": "/learn/removing-effect-dependencies#are-you-reading-some-state-to-calculate-the-next-state"
      },
      {
        "text": "different for every render:",
        "href": "/learn/removing-effect-dependencies#does-some-reactive-value-change-unintentionally"
      },
      {
        "text": "Read more about removing dependencies.",
        "href": "/learn/removing-effect-dependencies"
      },
      {
        "text": "different for every render:",
        "href": "/learn/removing-effect-dependencies#does-some-reactive-value-change-unintentionally"
      },
      {
        "text": "Read more about removing dependencies.",
        "href": "/learn/removing-effect-dependencies"
      },
      {
        "text": "Declare an Effect Event",
        "href": "/learn/separating-events-from-effects#declaring-an-effect-event"
      },
      {
        "text": "useEffectEvent",
        "href": "/reference/react/experimental_useEffectEvent"
      },
      {
        "text": "Read more about how Effect Events let you separate reactive and non-reactive code.",
        "href": "/learn/separating-events-from-effects#reading-latest-props-and-state-with-effect-events"
      },
      {
        "text": "directly",
        "href": "/reference/react-dom/server"
      },
      {
        "text": "framework",
        "href": "/learn/start-a-new-react-project#full-stack-frameworks"
      },
      {
        "text": "hydration",
        "href": "/reference/react-dom/client/hydrateRoot#hydrating-server-rendered-html"
      },
      {
        "text": "localStorage",
        "href": "https://developer.mozilla.org/en-US/docs/Web/API/Window/localStorage"
      },
      {
        "text": "how this helps find bugs",
        "href": "/learn/synchronizing-with-effects#step-3-add-cleanup-if-needed"
      },
      {
        "text": "how to fix your logic.",
        "href": "/learn/synchronizing-with-effects#how-to-handle-the-effect-firing-twice-in-development"
      },
      {
        "text": "useMemo",
        "href": "/reference/react/useMemo#memoizing-a-dependency-of-another-hook"
      },
      {
        "text": "useCallback",
        "href": "/reference/react/useCallback#preventing-an-effect-from-firing-too-often"
      },
      {
        "text": "removing the Effect altogether",
        "href": "/learn/you-might-not-need-an-effect"
      },
      {
        "text": "ref",
        "href": "/reference/react/useRef#referencing-a-value-with-a-ref"
      },
      {
        "text": "Read how to debug dependency changes.",
        "href": "/reference/react/useEffect#my-effect-runs-after-every-re-render"
      },
      {
        "text": "Learn how the Effect lifecycle is different from the component’s lifecycle.",
        "href": "/learn/lifecycle-of-reactive-effects#the-lifecycle-of-an-effect"
      },
      {
        "text": "painting the screen,",
        "href": "/learn/render-and-commit#epilogue-browser-paint"
      },
      {
        "text": "useLayoutEffect",
        "href": "/reference/react/useLayoutEffect"
      },
      {
        "text": "PrevioususeDeferredValue",
        "href": "/reference/react/useDeferredValue"
      },
      {
        "text": "NextuseId",
        "href": "/reference/react/useId"
      }
    ],
    "meta": {
      "description": "",
      "keywords": ""
    },
    "summary": "API ReferenceHooksuseEffectuseEffect is a React Hook that lets you synchronize a component with an external system. useEffect(setup, dependencies. ) Reference useEffect(setup, dependencies",
    "tags": [
      "react",
      "vue",
      "angular",
      "javascript",
      "typescript",
      "css",
      "html",
      "node",
      "vite",
      "effect"
    ],
    "id": "useeffect-react-useEffect-part-1",
    "quality": 100
  },
  {
    "title": "useContext – React",
    "url": "https://react.dev/reference/react/useContext",
    "category": "react",
    "content": "API ReferenceHooksuseContextuseContext is a React Hook that lets you read and subscribe to context from your component.const value = useContext(SomeContext) Reference useContext(SomeContext) Usage Passing data deeply into the tree Updating data passed via context Specifying a fallback default value Overriding context for a part of the tree Optimizing re-renders when passing objects and functions Troubleshooting My component doesnt see the value from my provider I am always getting undefined from my context although the default value is different Reference useContext(SomeContext) Call useContext at the top level of your component to read and subscribe to context. import { useContext } from 'react';function MyComponent() { const theme = useContext(ThemeContext); // ... See more examples below. Parameters SomeContext: The context that youve previously created with createContext. The context itself does not hold the information, it only represents the kind of information you can provide or read from components. Returns useContext returns the context value for the calling component. It is determined as the value passed to the closest SomeContext above the calling component in the tree. If there is no such provider, then the returned value will be the defaultValue you have passed to createContext for that context. The returned value is always up-to-date. React automatically re-renders components that read some context if it changes. Caveats useContext() call in a component is not affected by providers returned from the same component. The corresponding Context needs to be above the component doing the useContext() call. React automatically re-renders all the children that use a particular context starting from the provider that receives a different value. The previous and the next values are compared with the Object.is comparison. Skipping re-renders with memo does not prevent the children receiving fresh context values. If your build system produces duplicates modules in the output (which can happen with symlinks), this can break context. Passing something via context only works if SomeContext that you use to provide context and SomeContext that you use to read it are exactly the same object, as determined by a === comparison. Usage Passing data deeply into the tree Call useContext at the top level of your component to read and subscribe to context. import { useContext } from 'react';function Button() { const theme = useContext(ThemeContext); // ... useContext returns the context value for the context you passed. To determine the context value, React searches the component tree and finds the closest context provider above for that particular context. To pass context to a Button, wrap it or one of its parent components into the corresponding context provider: function MyPage() { return ( ThemeContext value=\"dark\" Form / /ThemeContext );}function Form() { // ... renders buttons inside ...} It doesnt matter how many layers of components there are between the provider and the Button. When a Button anywhere inside of Form calls useContext(ThemeContext), it will receive \"dark\" as the value. PitfalluseContext() always looks for the closest provider above the component that calls it. It searches upwards and does not consider providers in the component from which youre calling useContext(). App.jsApp.js Download ResetForkimport { createContext, useContext } from 'react'; const ThemeContext = createContext(null); export default function MyApp() { return ( ThemeContext value=\"dark\" Form / /ThemeContext ) } function Form() { return ( Panel title=\"Welcome\" ButtonSign up/Button ButtonLog in/Button /Panel ); } function Panel({ title, children }) { const theme = useContext(ThemeContext); const className = 'panel-' + theme; return ( section className={className} h1{title}/h1 {children} /section ) } function Button({ children }) { const theme = useContext(ThemeContext); const className = 'button-' + theme; return ( button className={className} {children} /button ); } Show more Updating data passed via context Often, youll want the context to change over time. To update context, combine it with state. Declare a state variable in the parent component, and pass the current state down as the context value to the provider. function MyPage() { const [theme, setTheme] = useState('dark'); return ( ThemeContext value={theme} Form / Button onClick={() = { setTheme('light'); }} Switch to light theme /Button /ThemeContext );} Now any Button inside of the provider will receive the current theme value. If you call setTheme to update the theme value that you pass to the provider, all Button components will re-render with the new 'light' value. Examples of updating context1. Updating a value via context 2. Updating an object via context 3. Multiple contexts 4. Extracting providers to a component 5. Scaling up with context and a reducer Example 1 of 5: Updating a value via context In this example, the MyApp component holds a state variable which is then passed to the ThemeContext provider. Checking the Dark mode checkbox updates the state. Changing the provided value re-renders all the components using that context.App.jsApp.js Download ResetForkimport { createContext, useContext, useState } from 'react'; const ThemeContext = createContext(null); export default function MyApp() { const [theme, setTheme] = useState('light'); return ( ThemeContext value={theme} Form / label input type=\"checkbox\" checked={theme === 'dark'} onChange={(e) = { setTheme(e.target.checked ? 'dark' : 'light') }} / Use dark mode /label /ThemeContext ) } function Form({ children }) { return ( Panel title=\"Welcome\" ButtonSign up/Button ButtonLog in/Button /Panel ); } function Panel({ title, children }) { const theme = useContext(ThemeContext); const className = 'panel-' + theme; return ( section className={className} h1{title}/h1 {children} /section ) } function Button({ children }) { const theme = useContext(ThemeContext); const className = 'button-' + theme; return ( button className={className} {children} /button ); } Show moreNote that value=\"dark\" passes the \"dark\" string, but value={theme} passes the value of the JavaScript theme variable with JSX curly braces. Curly braces also let you pass context values that arent strings.Next Example Specifying a fallback default value If React cant find any providers of that particular context in the parent tree, the context value returned by useContext() will be equal to the default value that you specified when you created that context: const ThemeContext = createContext(null); The default value never changes. If you want to update context, use it with state as described above. Often, instead of null, there is some more meaningful value you can use as a default, for example: const ThemeContext = createContext('light'); This way, if you accidentally render some component without a corresponding provider, it wont break. This also helps your components work well in a test environment without setting up a lot of providers in the tests. In the example below, the Toggle theme button is always light because its outside any theme context provider and the default context theme value is 'light'. Try editing the default theme to be 'dark'. App.jsApp.js Download ResetForkimport { createContext, useContext, useState } from 'react'; const ThemeContext = createContext('light'); export default function MyApp() { const [theme, setTheme] = useState('light'); return (  ThemeContext value={theme} Form / /ThemeContext Button onClick={() = { setTheme(theme === 'dark' ? 'light' : 'dark'); }} Toggle theme /Button / ) } function Form({ children }) { return ( Panel title=\"Welcome\" ButtonSign up/Button ButtonLog in/Button /Panel ); } function Panel({ title, children }) { const theme = useContext(ThemeContext); const className = 'panel-' + theme; return ( section className={className} h1{title}/h1 {children} /section ) } function Button({ children, onClick }) { const theme = useContext(ThemeContext); const className = 'button-' + theme; return ( button className={className} onClick={onClick} {children} /button ); } Show more Overriding context for a part of the tree You can override the context for a part of the tree by wrapping that part in a provider with a different value. ThemeContext value=\"dark\" ... ThemeContext value=\"light\" Footer / /ThemeContext .../ThemeContext You can nest and override providers as many times as you need. Examples of overriding context1. Overriding a theme 2. Automatically nested headings Example 1 of 2: Overriding a theme Here, the button inside the Footer receives a different context value (\"light\") than the buttons outside (\"dark\").App.jsApp.js Download ResetForkimport { createContext, useContext } from 'react'; const ThemeContext = createContext(null); export default function MyApp() { return ( ThemeContext value=\"dark\" Form / /ThemeContext ) } function Form() { return ( Panel title=\"Welcome\" ButtonSign up/Button ButtonLog in/Button ThemeContext value=\"light\" Footer / /ThemeContext /Panel ); } function Footer() { return ( footer ButtonSettings/Button /footer ); } function Panel({ title, children }) { const theme = useContext(ThemeContext); const className = 'panel-' + theme; return ( section className={className} {title && h1{title}/h1} {children} /section ) } function Button({ children }) { const theme = useContext(ThemeContext); const className = 'button-' + theme; return ( button className={className} {children} /button ); } Show moreNext Example Optimizing re-renders when passing objects and functions You can pass any values via context, including objects and functions. function MyApp() { const [currentUser, setCurrentUser] = useState(null); function login(response) { storeCredentials(response.credentials); setCurrentUser(response.user); } return ( AuthContext value={{ currentUser, login }} Page / /AuthContext );} Here, the context value is a JavaScript object with two properties, one of which is a function. Whenever MyApp re-renders (for example, on a route update), this will be a different object pointing at a different function, so React will also have to re-render all components deep in the tree that call useContext(AuthContext). In smaller apps, this is not a problem. However, there is no need to re-render them if the underlying data, like currentUser, has not changed. To help React take advantage of that fact, you may wrap the login function with useCallback and wrap the object creation into useMemo. This is a performance optimization: import { useCallback, useMemo } from 'react';function MyApp() { const [currentUser, setCurrentUser] = useState(null); const login = useCallback((response) = { storeCredentials(response.credentials); setCurrentUser(response.user); }, []); const contextValue = useMemo(() = ({ currentUser, login }), [currentUser, login]); return ( AuthContext value={contextValue} Page / /AuthContext );} As a result of this change, even if MyApp needs to re-render, the components calling useContext(AuthContext) wont need to re-render unless currentUser has changed. Read more about useMemo and useCallback. Troubleshooting My component doesnt see the value from my provider There are a few common ways that this can happen: Youre rendering SomeContext in the same component (or below) as where youre calling useContext(). Move SomeContext above and outside the component calling useContext(). You may have forgotten to wrap your component with SomeContext, or you might have put it in a different part of the tree than you thought. Check whether the hierarchy is right using React DevTools. You might be running into some build issue with your tooling that causes SomeContext as seen from the providing component and SomeContext as seen by the reading component to be two different objects. This can happen if you use symlinks, for example. You can verify this by assigning them to globals like window.SomeContext1 and window.SomeContext2 and then checking whether window.SomeContext1 === window.SomeContext2 in the console. If theyre not the same, fix that issue on the build tool level. I am always getting undefined from my context although the default value is different You might have a provider without a value in the tree: //  Doesn't work: no value propThemeContext Button //ThemeContext If you forget to specify value, its like passing value={undefined}. You may have also mistakingly used a different prop name by mistake: //  Doesn't work: prop should be called \"value\"ThemeContext theme={theme} Button //ThemeContext In both of these cases you should see a warning from React in the console. To fix them, call the prop value: //  Passing the value propThemeContext value={theme} Button //ThemeContext Note that the default value from your createContext(defaultValue) call is only used if there is no matching provider above at all. If there is a SomeContext value={undefined} component somewhere in the parent tree, the component calling useContext(SomeContext) will receive undefined as the context value.PrevioususeCallbackNextuseDebugValue",
    "headings": [
      {
        "level": 1,
        "text": "useContext",
        "id": ""
      },
      {
        "level": 2,
        "text": "Reference",
        "id": "reference"
      },
      {
        "level": 2,
        "text": "Usage",
        "id": "usage"
      },
      {
        "level": 2,
        "text": "Troubleshooting",
        "id": "troubleshooting"
      },
      {
        "level": 3,
        "text": "useContext(SomeContext)",
        "id": "usecontext"
      },
      {
        "level": 3,
        "text": "Passing data deeply into the tree",
        "id": "passing-data-deeply-into-the-tree"
      },
      {
        "level": 3,
        "text": "Pitfall",
        "id": ""
      },
      {
        "level": 3,
        "text": "Updating data passed via context",
        "id": "updating-data-passed-via-context"
      },
      {
        "level": 3,
        "text": "Specifying a fallback default value",
        "id": "specifying-a-fallback-default-value"
      },
      {
        "level": 3,
        "text": "Overriding context for a part of the tree",
        "id": "overriding-context-for-a-part-of-the-tree"
      },
      {
        "level": 3,
        "text": "Optimizing re-renders when passing objects and functions",
        "id": "optimizing-re-renders-when-passing-objects-and-functions"
      },
      {
        "level": 3,
        "text": "My component doesn’t see the value from my provider",
        "id": "my-component-doesnt-see-the-value-from-my-provider"
      },
      {
        "level": 3,
        "text": "I am always getting undefined from my context although the default value is different",
        "id": "i-am-always-getting-undefined-from-my-context-although-the-default-value-is-different"
      },
      {
        "level": 4,
        "text": "Parameters",
        "id": "parameters"
      },
      {
        "level": 4,
        "text": "Returns",
        "id": "returns"
      },
      {
        "level": 4,
        "text": "Caveats",
        "id": "caveats"
      },
      {
        "level": 4,
        "text": "Examples of updating context",
        "id": "examples-basic"
      },
      {
        "level": 4,
        "text": "Example 1 of 5: Updating a value via context",
        "id": "updating-a-value-via-context"
      },
      {
        "level": 4,
        "text": "Examples of overriding context",
        "id": "examples"
      },
      {
        "level": 4,
        "text": "Example 1 of 2: Overriding a theme",
        "id": "overriding-a-theme"
      }
    ],
    "codeBlocks": [
      {
        "language": "text",
        "code": "const value = useContext(SomeContext)"
      },
      {
        "language": "text",
        "code": "const value = useContext(SomeContext)"
      },
      {
        "language": "text",
        "code": "useContext(SomeContext)"
      },
      {
        "language": "text",
        "code": "useContext(SomeContext)"
      },
      {
        "language": "text",
        "code": "import { useContext } from 'react';function MyComponent() {  const theme = useContext(ThemeContext);  // ..."
      },
      {
        "language": "text",
        "code": "import { useContext } from 'react';function MyComponent() {  const theme = useContext(ThemeContext);  // ..."
      },
      {
        "language": "text",
        "code": "SomeContext"
      },
      {
        "language": "text",
        "code": "createContext"
      },
      {
        "language": "text",
        "code": "SomeContext"
      },
      {
        "language": "text",
        "code": "defaultValue"
      },
      {
        "language": "text",
        "code": "createContext"
      },
      {
        "language": "text",
        "code": "useContext()"
      },
      {
        "language": "text",
        "code": "useContext()"
      },
      {
        "language": "text",
        "code": "SomeContext"
      },
      {
        "language": "text",
        "code": "SomeContext"
      },
      {
        "language": "text",
        "code": "import { useContext } from 'react';function Button() {  const theme = useContext(ThemeContext);  // ..."
      },
      {
        "language": "text",
        "code": "import { useContext } from 'react';function Button() {  const theme = useContext(ThemeContext);  // ..."
      },
      {
        "language": "text",
        "code": "function MyPage() {  return (    <ThemeContext value=\"dark\">      <Form />    </ThemeContext>  );}function Form() {  // ... renders buttons inside ...}"
      },
      {
        "language": "text",
        "code": "function MyPage() {  return (    <ThemeContext value=\"dark\">      <Form />    </ThemeContext>  );}function Form() {  // ... renders buttons inside ...}"
      },
      {
        "language": "text",
        "code": "useContext(ThemeContext)"
      },
      {
        "language": "text",
        "code": "useContext()"
      },
      {
        "language": "text",
        "code": "useContext()"
      },
      {
        "language": "text",
        "code": "import { createContext, useContext } from 'react';\n\nconst ThemeContext = createContext(null);\n\nexport default function MyApp() {\n  return (\n    <ThemeContext value=\"dark\">\n      <Form />\n    </ThemeContext>\n  )\n}\n\nfunction Form() {\n  return (\n    <Panel title=\"Welcome\">\n      <Button>Sign up</Button>\n      <Button>Log in</Button>\n    </Panel>\n  );\n}\n\nfunction Panel({ title, children }) {\n  const theme = useContext(ThemeContext);\n  const className = 'panel-' + theme;\n  return (\n    <section className={className}>\n      <h1>{title}</h1>\n      {children}\n    </section>\n  )\n}\n\nfunction Button({ children }) {\n  const theme = useContext(ThemeContext);\n  const className = 'button-' + theme;\n  return (\n    <button className={className}>\n      {children}\n    </button>\n  );\n}"
      },
      {
        "language": "text",
        "code": "function MyPage() {  const [theme, setTheme] = useState('dark');  return (    <ThemeContext value={theme}>      <Form />      <Button onClick={() => {        setTheme('light');      }}>        Switch to light theme      </Button>    </ThemeContext>  );}"
      },
      {
        "language": "text",
        "code": "function MyPage() {  const [theme, setTheme] = useState('dark');  return (    <ThemeContext value={theme}>      <Form />      <Button onClick={() => {        setTheme('light');      }}>        Switch to light theme      </Button>    </ThemeContext>  );}"
      },
      {
        "language": "text",
        "code": "ThemeContext"
      },
      {
        "language": "text",
        "code": "import { createContext, useContext, useState } from 'react';\n\nconst ThemeContext = createContext(null);\n\nexport default function MyApp() {\n  const [theme, setTheme] = useState('light');\n  return (\n    <ThemeContext value={theme}>\n      <Form />\n      <label>\n        <input\n          type=\"checkbox\"\n          checked={theme === 'dark'}\n          onChange={(e) => {\n            setTheme(e.target.checked ? 'dark' : 'light')\n          }}\n        />\n        Use dark mode\n      </label>\n    </ThemeContext>\n  )\n}\n\nfunction Form({ children }) {\n  return (\n    <Panel title=\"Welcome\">\n      <Button>Sign up</Button>\n      <Button>Log in</Button>\n    </Panel>\n  );\n}\n\nfunction Panel({ title, children }) {\n  const theme = useContext(ThemeContext);\n  const className = 'panel-' + theme;\n  return (\n    <section className={className}>\n      <h1>{title}</h1>\n      {children}\n    </section>\n  )\n}\n\nfunction Button({ children }) {\n  const theme = useContext(ThemeContext);\n  const className = 'button-' + theme;\n  return (\n    <button className={className}>\n      {children}\n    </button>\n  );\n}"
      },
      {
        "language": "text",
        "code": "value=\"dark\""
      },
      {
        "language": "text",
        "code": "value={theme}"
      },
      {
        "language": "text",
        "code": "useContext()"
      },
      {
        "language": "text",
        "code": "const ThemeContext = createContext(null);"
      },
      {
        "language": "text",
        "code": "const ThemeContext = createContext(null);"
      },
      {
        "language": "text",
        "code": "const ThemeContext = createContext('light');"
      },
      {
        "language": "text",
        "code": "const ThemeContext = createContext('light');"
      },
      {
        "language": "text",
        "code": "import { createContext, useContext, useState } from 'react';\n\nconst ThemeContext = createContext('light');\n\nexport default function MyApp() {\n  const [theme, setTheme] = useState('light');\n  return (\n    <>\n      <ThemeContext value={theme}>\n        <Form />\n      </ThemeContext>\n      <Button onClick={() => {\n        setTheme(theme === 'dark' ? 'light' : 'dark');\n      }}>\n        Toggle theme\n      </Button>\n    </>\n  )\n}\n\nfunction Form({ children }) {\n  return (\n    <Panel title=\"Welcome\">\n      <Button>Sign up</Button>\n      <Button>Log in</Button>\n    </Panel>\n  );\n}\n\nfunction Panel({ title, children }) {\n  const theme = useContext(ThemeContext);\n  const className = 'panel-' + theme;\n  return (\n    <section className={className}>\n      <h1>{title}</h1>\n      {children}\n    </section>\n  )\n}\n\nfunction Button({ children, onClick }) {\n  const theme = useContext(ThemeContext);\n  const className = 'button-' + theme;\n  return (\n    <button className={className} onClick={onClick}>\n      {children}\n    </button>\n  );\n}"
      },
      {
        "language": "text",
        "code": "<ThemeContext value=\"dark\">  ...  <ThemeContext value=\"light\">    <Footer />  </ThemeContext>  ...</ThemeContext>"
      },
      {
        "language": "text",
        "code": "<ThemeContext value=\"dark\">  ...  <ThemeContext value=\"light\">    <Footer />  </ThemeContext>  ...</ThemeContext>"
      },
      {
        "language": "text",
        "code": "import { createContext, useContext } from 'react';\n\nconst ThemeContext = createContext(null);\n\nexport default function MyApp() {\n  return (\n    <ThemeContext value=\"dark\">\n      <Form />\n    </ThemeContext>\n  )\n}\n\nfunction Form() {\n  return (\n    <Panel title=\"Welcome\">\n      <Button>Sign up</Button>\n      <Button>Log in</Button>\n      <ThemeContext value=\"light\">\n        <Footer />\n      </ThemeContext>\n    </Panel>\n  );\n}\n\nfunction Footer() {\n  return (\n    <footer>\n      <Button>Settings</Button>\n    </footer>\n  );\n}\n\nfunction Panel({ title, children }) {\n  const theme = useContext(ThemeContext);\n  const className = 'panel-' + theme;\n  return (\n    <section className={className}>\n      {title && <h1>{title}</h1>}\n      {children}\n    </section>\n  )\n}\n\nfunction Button({ children }) {\n  const theme = useContext(ThemeContext);\n  const className = 'button-' + theme;\n  return (\n    <button className={className}>\n      {children}\n    </button>\n  );\n}"
      },
      {
        "language": "text",
        "code": "function MyApp() {  const [currentUser, setCurrentUser] = useState(null);  function login(response) {    storeCredentials(response.credentials);    setCurrentUser(response.user);  }  return (    <AuthContext value={{ currentUser, login }}>      <Page />    </AuthContext>  );}"
      },
      {
        "language": "text",
        "code": "function MyApp() {  const [currentUser, setCurrentUser] = useState(null);  function login(response) {    storeCredentials(response.credentials);    setCurrentUser(response.user);  }  return (    <AuthContext value={{ currentUser, login }}>      <Page />    </AuthContext>  );}"
      },
      {
        "language": "text",
        "code": "useContext(AuthContext)"
      },
      {
        "language": "text",
        "code": "currentUser"
      },
      {
        "language": "text",
        "code": "useCallback"
      },
      {
        "language": "text",
        "code": "import { useCallback, useMemo } from 'react';function MyApp() {  const [currentUser, setCurrentUser] = useState(null);  const login = useCallback((response) => {    storeCredentials(response.credentials);    setCurrentUser(response.user);  }, []);  const contextValue = useMemo(() => ({    currentUser,    login  }), [currentUser, login]);  return (    <AuthContext value={contextValue}>      <Page />    </AuthContext>  );}"
      },
      {
        "language": "text",
        "code": "import { useCallback, useMemo } from 'react';function MyApp() {  const [currentUser, setCurrentUser] = useState(null);  const login = useCallback((response) => {    storeCredentials(response.credentials);    setCurrentUser(response.user);  }, []);  const contextValue = useMemo(() => ({    currentUser,    login  }), [currentUser, login]);  return (    <AuthContext value={contextValue}>      <Page />    </AuthContext>  );}"
      },
      {
        "language": "text",
        "code": "useContext(AuthContext)"
      },
      {
        "language": "text",
        "code": "currentUser"
      },
      {
        "language": "text",
        "code": "useCallback"
      },
      {
        "language": "text",
        "code": "<SomeContext>"
      },
      {
        "language": "text",
        "code": "useContext()"
      },
      {
        "language": "text",
        "code": "<SomeContext>"
      },
      {
        "language": "text",
        "code": "useContext()"
      },
      {
        "language": "text",
        "code": "<SomeContext>"
      },
      {
        "language": "text",
        "code": "SomeContext"
      },
      {
        "language": "text",
        "code": "SomeContext"
      },
      {
        "language": "text",
        "code": "window.SomeContext1"
      },
      {
        "language": "text",
        "code": "window.SomeContext2"
      },
      {
        "language": "text",
        "code": "window.SomeContext1 === window.SomeContext2"
      },
      {
        "language": "text",
        "code": "// 🚩 Doesn't work: no value prop<ThemeContext>   <Button /></ThemeContext>"
      },
      {
        "language": "text",
        "code": "// 🚩 Doesn't work: no value prop<ThemeContext>   <Button /></ThemeContext>"
      },
      {
        "language": "text",
        "code": "value={undefined}"
      },
      {
        "language": "text",
        "code": "// 🚩 Doesn't work: prop should be called \"value\"<ThemeContext theme={theme}>   <Button /></ThemeContext>"
      },
      {
        "language": "text",
        "code": "// 🚩 Doesn't work: prop should be called \"value\"<ThemeContext theme={theme}>   <Button /></ThemeContext>"
      },
      {
        "language": "text",
        "code": "// ✅ Passing the value prop<ThemeContext value={theme}>   <Button /></ThemeContext>"
      },
      {
        "language": "text",
        "code": "// ✅ Passing the value prop<ThemeContext value={theme}>   <Button /></ThemeContext>"
      },
      {
        "language": "text",
        "code": "createContext(defaultValue)"
      },
      {
        "language": "text",
        "code": "<SomeContext value={undefined}>"
      },
      {
        "language": "text",
        "code": "useContext(SomeContext)"
      }
    ],
    "links": [
      {
        "text": "API Reference",
        "href": "/reference/react"
      },
      {
        "text": "Hooks",
        "href": "/reference/react/hooks"
      },
      {
        "text": "context",
        "href": "/learn/passing-data-deeply-with-context"
      },
      {
        "text": "context.",
        "href": "/learn/passing-data-deeply-with-context"
      },
      {
        "text": "createContext",
        "href": "/reference/react/createContext"
      },
      {
        "text": "createContext",
        "href": "/reference/react/createContext"
      },
      {
        "text": "Object.is",
        "href": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/is"
      },
      {
        "text": "memo",
        "href": "/reference/react/memo"
      },
      {
        "text": "context.",
        "href": "/learn/passing-data-deeply-with-context"
      },
      {
        "text": "state.",
        "href": "/reference/react/useState"
      },
      {
        "text": "JSX curly braces.",
        "href": "/learn/javascript-in-jsx-with-curly-braces"
      },
      {
        "text": "created that context",
        "href": "/reference/react/createContext"
      },
      {
        "text": "useCallback",
        "href": "/reference/react/useCallback"
      },
      {
        "text": "useMemo",
        "href": "/reference/react/useMemo"
      },
      {
        "text": "useMemo",
        "href": "/reference/react/useMemo#skipping-re-rendering-of-components"
      },
      {
        "text": "useCallback.",
        "href": "/reference/react/useCallback#skipping-re-rendering-of-components"
      },
      {
        "text": "React DevTools.",
        "href": "/learn/react-developer-tools"
      },
      {
        "text": "PrevioususeCallback",
        "href": "/reference/react/useCallback"
      },
      {
        "text": "NextuseDebugValue",
        "href": "/reference/react/useDebugValue"
      }
    ],
    "meta": {
      "description": "",
      "keywords": ""
    },
    "summary": "API ReferenceHooksuseContextuseContext is a React Hook that lets you read and subscribe to context from your component",
    "tags": [
      "react",
      "angular",
      "javascript",
      "typescript",
      "html",
      "node",
      "vite",
      "context",
      "value",
      "usecontext"
    ],
    "id": "usecontext-react-useContext-part-1",
    "quality": 100
  },
  {
    "title": "useReducer – React",
    "url": "https://react.dev/reference/react/useReducer",
    "category": "react",
    "content": "API ReferenceHooksuseReduceruseReducer is a React Hook that lets you add a reducer to your component.const [state, dispatch] = useReducer(reducer, initialArg, init?) Reference useReducer(reducer, initialArg, init?) dispatch function Usage Adding a reducer to a component Writing the reducer function Avoiding recreating the initial state Troubleshooting Ive dispatched an action, but logging gives me the old state value Ive dispatched an action, but the screen doesnt update A part of my reducer state becomes undefined after dispatching My entire reducer state becomes undefined after dispatching Im getting an error: Too many re-renders My reducer or initializer function runs twice Reference useReducer(reducer, initialArg, init?) Call useReducer at the top level of your component to manage its state with a reducer. import { useReducer } from 'react';function reducer(state, action) { // ...}function MyComponent() { const [state, dispatch] = useReducer(reducer, { age: 42 }); // ... See more examples below. Parameters reducer: The reducer function that specifies how the state gets updated. It must be pure, should take the state and action as arguments, and should return the next state. State and action can be of any types. initialArg: The value from which the initial state is calculated. It can be a value of any type. How the initial state is calculated from it depends on the next init argument. optional init: The initializer function that should return the initial state. If its not specified, the initial state is set to initialArg. Otherwise, the initial state is set to the result of calling init(initialArg). Returns useReducer returns an array with exactly two values: The current state. During the first render, its set to init(initialArg) or initialArg (if theres no init). The dispatch function that lets you update the state to a different value and trigger a re-render. Caveats useReducer is a Hook, so you can only call it at the top level of your component or your own Hooks. You cant call it inside loops or conditions. If you need that, extract a new component and move the state into it. The dispatch function has a stable identity, so you will often see it omitted from Effect dependencies, but including it will not cause the Effect to fire. If the linter lets you omit a dependency without errors, it is safe to do. Learn more about removing Effect dependencies. In Strict Mode, React will call your reducer and initializer twice in order to help you find accidental impurities. This is development-only behavior and does not affect production. If your reducer and initializer are pure (as they should be), this should not affect your logic. The result from one of the calls is ignored. dispatch function The dispatch function returned by useReducer lets you update the state to a different value and trigger a re-render. You need to pass the action as the only argument to the dispatch function: const [state, dispatch] = useReducer(reducer, { age: 42 });function handleClick() { dispatch({ type: 'incremented_age' }); // ... React will set the next state to the result of calling the reducer function youve provided with the current state and the action youve passed to dispatch. Parameters action: The action performed by the user. It can be a value of any type. By convention, an action is usually an object with a type property identifying it and, optionally, other properties with additional information. Returns dispatch functions do not have a return value. Caveats The dispatch function only updates the state variable for the next render. If you read the state variable after calling the dispatch function, you will still get the old value that was on the screen before your call. If the new value you provide is identical to the current state, as determined by an Object.is comparison, React will skip re-rendering the component and its children. This is an optimization. React may still need to call your component before ignoring the result, but it shouldnt affect your code. React batches state updates. It updates the screen after all the event handlers have run and have called their set functions. This prevents multiple re-renders during a single event. In the rare case that you need to force React to update the screen earlier, for example to access the DOM, you can use flushSync. Usage Adding a reducer to a component Call useReducer at the top level of your component to manage state with a reducer. import { useReducer } from 'react';function reducer(state, action) { // ...}function MyComponent() { const [state, dispatch] = useReducer(reducer, { age: 42 }); // ... useReducer returns an array with exactly two items: The current state of this state variable, initially set to the initial state you provided. The dispatch function that lets you change it in response to interaction. To update whats on the screen, call dispatch with an object representing what the user did, called an action: function handleClick() { dispatch({ type: 'incremented_age' });} React will pass the current state and the action to your reducer function. Your reducer will calculate and return the next state. React will store that next state, render your component with it, and update the UI. App.jsApp.js Download ResetForkimport { useReducer } from 'react'; function reducer(state, action) { if (action.type === 'incremented_age') { return { age: state.age + 1 }; } throw Error('Unknown action.'); } export default function Counter() { const [state, dispatch] = useReducer(reducer, { age: 42 }); return (  button onClick={() = { dispatch({ type: 'incremented_age' }) }} Increment age /button pHello! You are {state.age}./p / ); } Show more useReducer is very similar to useState, but it lets you move the state update logic from event handlers into a single function outside of your component. Read more about choosing between useState and useReducer. Writing the reducer function A reducer function is declared like this: function reducer(state, action) { // ...} Then you need to fill in the code that will calculate and return the next state. By convention, it is common to write it as a switch statement. For each case in the switch, calculate and return some next state. function reducer(state, action) { switch (action.type) { case 'incremented_age': { return { name: state.name, age: state.age + 1 }; } case 'changed_name': { return { name: action.nextName, age: state.age }; } } throw Error('Unknown action: ' + action.type);} Actions can have any shape. By convention, its common to pass objects with a type property identifying the action. It should include the minimal necessary information that the reducer needs to compute the next state. function Form() { const [state, dispatch] = useReducer(reducer, { name: 'Taylor', age: 42 }); function handleButtonClick() { dispatch({ type: 'incremented_age' }); } function handleInputChange(e) { dispatch({ type: 'changed_name', nextName: e.target.value }); } // ... The action type names are local to your component. Each action describes a single interaction, even if that leads to multiple changes in data. The shape of the state is arbitrary, but usually itll be an object or an array. Read extracting state logic into a reducer to learn more. PitfallState is read-only. Dont modify any objects or arrays in state:function reducer(state, action) { switch (action.type) { case 'incremented_age': { //  Don't mutate an object in state like this: state.age = state.age + 1; return state; }Instead, always return new objects from your reducer:function reducer(state, action) { switch (action.type) { case 'incremented_age': { //  Instead, return a new object return { ...state, age: state.age + 1 }; }Read updating objects in state and updating arrays in state to learn more. Basic useReducer examples1. Form (object) 2. Todo list (array) 3. Writing concise update logic with Immer Example 1 of 3: Form (object) In this example, the reducer manages a state object with two fields: name and age.App.jsApp.js Download ResetForkimport { useReducer } from 'react'; function reducer(state, action) { switch (action.type) { case 'incremented_age': { return { name: state.name, age: state.age + 1 }; } case 'changed_name': { return { name: action.nextName, age: state.age }; } } throw Error('Unknown action: ' + action.type); } const initialState = { name: 'Taylor', age: 42 }; export default function Form() { const [state, dispatch] = useReducer(reducer, initialState); function handleButtonClick() { dispatch({ type: 'incremented_age' }); } function handleInputChange(e) { dispatch({ type: 'changed_name', nextName: e.target.value }); } return (  input value={state.name} onChange={handleInputChange} / button onClick={handleButtonClick} Increment age /button pHello, {state.name}. You are {state.age}./p / ); } Show moreNext Example Avoiding recreating the initial state React saves the initial state once and ignores it on the next renders. function createInitialState(username) { // ...}function TodoList({ username }) { const [state, dispatch] = useReducer(reducer, createInitialState(username)); // ... Although the result of createInitialState(username) is only used for the initial render, youre still calling this function on every render. This can be wasteful if its creating large arrays or performing expensive calculations. To solve this, you may pass it as an initializer function to useReducer as the third argument instead: function createInitialState(username) { // ...}function TodoList({ username }) { const [state, dispatch] = useReducer(reducer, username, createInitialState); // ... Notice that youre passing createInitialState, which is the function itself, and not createInitialState(), which is the result of calling it. This way, the initial state does not get re-created after initialization. In the above example, createInitialState takes a username argument. If your initializer doesnt need any information to compute the initial state, you may pass null as the second argument to useReducer. The difference between passing an initializer and passing the initial state directly1. Passing the initializer function 2. Passing the initial state directly Example 1 of 2: Passing the initializer function This example passes the initializer function, so the createInitialState function only runs during initialization. It does not run when component re-renders, such as when you type into the input.TodoList.jsTodoList.js ResetForkimport { useReducer } from 'react'; function createInitialState(username) { const initialTodos = []; for (let i = 0; i  50; i++) { initialTodos.push({ id: i, text: username + \"'s task #\" + (i + 1) }); } return { draft: '', todos: initialTodos, }; } function reducer(state, action) { switch (action.type) { case 'changed_draft': { return { draft: action.nextDraft, todos: state.todos, }; }; case 'added_todo': { return { draft: '', todos: [{ id: state.todos.length, text: state.draft }, ...state.todos] } } } throw Error('Unknown action: ' + action.type); } export default function TodoList({ username }) { const [state, dispatch] = useReducer( reducer, username, createInitialState ); return (  input value={state.draft} onChange={e = { dispatch({ type: 'changed_draft', nextDraft: e.target.value }) }} / button onClick={() = { dispatch({ type: 'added_todo' }); }}Add/button ul {state.todos.map(item = ( li key={item.id} {item.text} /li ))} /ul / ); } Show moreNext Example Troubleshooting Ive dispatched an action, but logging gives me the old state value Calling the dispatch function does not change state in the running code: function handleClick() { console.log(state.age); // 42 dispatch({ type: 'incremented_age' }); // Request a re-render with 43 console.log(state.age); // Still 42! setTimeout(() = { console.log(state.age); // Also 42! }, 5000);} This is because states behaves like a snapshot. Updating state requests another render with the new state value, but does not affect the state JavaScript variable in your already-running event handler. If you need to guess the next state value, you can calculate it manually by calling the reducer yourself: const action = { type: 'incremented_age' };dispatch(action);const nextState = reducer(state, action);console.log(state); // { age: 42 }console.log(nextState); // { age: 43 } Ive dispatched an action, but the screen doesnt update React will ignore your update if the next state is equal to the previous state, as determined by an Object.is comparison. This usually happens when you change an object or an array in state directly: function reducer(state, action) { switch (action.type) { case 'incremented_age': { //  Wrong: mutating existing object state.age++; return state; } case 'changed_name': { //  Wrong: mutating existing object state.name = action.nextName; return state; } // ... }} You mutated an existing state object and returned it, so React ignored the update. To fix this, you need to ensure that youre always updating objects in state and updating arrays in state instead of mutating them: function reducer(state, action) { switch (action.type) { case 'incremented_age': { //  Correct: creating a new object return { ...state, age: state.age + 1 }; } case 'changed_name': { //  Correct: creating a new object return { ...state, name: action.nextName }; } // ... }} A part of my reducer state becomes undefined after dispatching Make sure that every case branch copies all of the existing fields when returning the new state: function reducer(state, action) { switch (action.type) { case 'incremented_age': { return { ...state, // Don't forget this! age: state.age + 1 }; } // ... Without ...state above, the returned next state would only contain the age field and nothing else. My entire reducer state becomes undefined after dispatching If your state unexpectedly becomes undefined, youre likely forgetting to return state in one of the cases, or your action type doesnt match any of the case statements. To find why, throw an error outside the switch: function reducer(state, action) { switch (action.type) { case 'incremented_age': { // ... } case 'edited_name': { // ... } } throw Error('Unknown action: ' + action.type);} You can also use a static type checker like TypeScript to catch such mistakes. Im getting an error: Too many re-renders You might get an error that says: Too many re-renders. React limits the number of renders to prevent an infinite loop. Typically, this means that youre unconditionally dispatching an action during render, so your component enters a loop: render, dispatch (which causes a render), render, dispatch (which causes a render), and so on. Very often, this is caused by a mistake in specifying an event handler: //  Wrong: calls the handler during renderreturn button onClick={handleClick()}Click me/button//  Correct: passes down the event handlerreturn button onClick={handleClick}Click me/button//  Correct: passes down an inline functionreturn button onClick={(e) = handleClick(e)}Click me/button If you cant find the cause of this error, click on the arrow next to the error in the console and look through the JavaScript stack to find the specific dispatch function call responsible for the error. My reducer or initializer function runs twice In Strict Mode, React will call your reducer and initializer functions twice. This shouldnt break your code. This development-only behavior helps you keep components pure. React uses the result of one of the calls, and ignores the result of the other call. As long as your component, initializer, and reducer functions are pure, this shouldnt affect your logic. However, if they are accidentally impure, this helps you notice the mistakes. For example, this impure reducer function mutates an array in state: function reducer(state, action) { switch (action.type) { case 'added_todo': { //  Mistake: mutating state state.todos.push({ id: nextId++, text: action.text }); return state; } // ... }} Because React calls your reducer function twice, youll see the todo was added twice, so youll know that there is a mistake. In this example, you can fix the mistake by replacing the array instead of mutating it: function reducer(state, action) { switch (action.type) { case 'added_todo': { //  Correct: replacing with new state return { ...state, todos: [ ...state.todos, { id: nextId++, text: action.text } ] }; } // ... }} Now that this reducer function is pure, calling it an extra time doesnt make a difference in behavior. This is why React calling it twice helps you find mistakes. Only component, initializer, and reducer functions need to be pure. Event handlers dont need to be pure, so React will never call your event handlers twice. Read keeping components pure to learn more.PrevioususeOptimisticNextuseRef",
    "headings": [
      {
        "level": 1,
        "text": "useReducer",
        "id": ""
      },
      {
        "level": 2,
        "text": "Reference",
        "id": "reference"
      },
      {
        "level": 2,
        "text": "Usage",
        "id": "usage"
      },
      {
        "level": 2,
        "text": "Troubleshooting",
        "id": "troubleshooting"
      },
      {
        "level": 3,
        "text": "useReducer(reducer, initialArg, init?)",
        "id": "usereducer"
      },
      {
        "level": 3,
        "text": "dispatch function",
        "id": "dispatch"
      },
      {
        "level": 3,
        "text": "Adding a reducer to a component",
        "id": "adding-a-reducer-to-a-component"
      },
      {
        "level": 3,
        "text": "Writing the reducer function",
        "id": "writing-the-reducer-function"
      },
      {
        "level": 3,
        "text": "Pitfall",
        "id": ""
      },
      {
        "level": 3,
        "text": "Avoiding recreating the initial state",
        "id": "avoiding-recreating-the-initial-state"
      },
      {
        "level": 3,
        "text": "I’ve dispatched an action, but logging gives me the old state value",
        "id": "ive-dispatched-an-action-but-logging-gives-me-the-old-state-value"
      },
      {
        "level": 3,
        "text": "I’ve dispatched an action, but the screen doesn’t update",
        "id": "ive-dispatched-an-action-but-the-screen-doesnt-update"
      },
      {
        "level": 3,
        "text": "A part of my reducer state becomes undefined after dispatching",
        "id": "a-part-of-my-reducer-state-becomes-undefined-after-dispatching"
      },
      {
        "level": 3,
        "text": "My entire reducer state becomes undefined after dispatching",
        "id": "my-entire-reducer-state-becomes-undefined-after-dispatching"
      },
      {
        "level": 3,
        "text": "I’m getting an error: “Too many re-renders”",
        "id": "im-getting-an-error-too-many-re-renders"
      },
      {
        "level": 3,
        "text": "My reducer or initializer function runs twice",
        "id": "my-reducer-or-initializer-function-runs-twice"
      },
      {
        "level": 4,
        "text": "Parameters",
        "id": "parameters"
      },
      {
        "level": 4,
        "text": "Returns",
        "id": "returns"
      },
      {
        "level": 4,
        "text": "Caveats",
        "id": "caveats"
      },
      {
        "level": 4,
        "text": "Parameters",
        "id": "dispatch-parameters"
      },
      {
        "level": 4,
        "text": "Returns",
        "id": "dispatch-returns"
      },
      {
        "level": 4,
        "text": "Caveats",
        "id": "setstate-caveats"
      },
      {
        "level": 4,
        "text": "Basic useReducer examples",
        "id": "examples-basic"
      },
      {
        "level": 4,
        "text": "Example 1 of 3: Form (object)",
        "id": "form-object"
      },
      {
        "level": 4,
        "text": "The difference between passing an initializer and passing the initial state directly",
        "id": "examples-initializer"
      },
      {
        "level": 4,
        "text": "Example 1 of 2: Passing the initializer function",
        "id": "passing-the-initializer-function"
      }
    ],
    "codeBlocks": [
      {
        "language": "text",
        "code": "const [state, dispatch] = useReducer(reducer, initialArg, init?)"
      },
      {
        "language": "text",
        "code": "const [state, dispatch] = useReducer(reducer, initialArg, init?)"
      },
      {
        "language": "text",
        "code": "useReducer(reducer, initialArg, init?)"
      },
      {
        "language": "text",
        "code": "useReducer(reducer, initialArg, init?)"
      },
      {
        "language": "text",
        "code": "import { useReducer } from 'react';function reducer(state, action) {  // ...}function MyComponent() {  const [state, dispatch] = useReducer(reducer, { age: 42 });  // ..."
      },
      {
        "language": "text",
        "code": "import { useReducer } from 'react';function reducer(state, action) {  // ...}function MyComponent() {  const [state, dispatch] = useReducer(reducer, { age: 42 });  // ..."
      },
      {
        "language": "text",
        "code": "init(initialArg)"
      },
      {
        "language": "text",
        "code": "init(initialArg)"
      },
      {
        "language": "text",
        "code": "const [state, dispatch] = useReducer(reducer, { age: 42 });function handleClick() {  dispatch({ type: 'incremented_age' });  // ..."
      },
      {
        "language": "text",
        "code": "const [state, dispatch] = useReducer(reducer, { age: 42 });function handleClick() {  dispatch({ type: 'incremented_age' });  // ..."
      },
      {
        "language": "text",
        "code": "import { useReducer } from 'react';function reducer(state, action) {  // ...}function MyComponent() {  const [state, dispatch] = useReducer(reducer, { age: 42 });  // ..."
      },
      {
        "language": "text",
        "code": "import { useReducer } from 'react';function reducer(state, action) {  // ...}function MyComponent() {  const [state, dispatch] = useReducer(reducer, { age: 42 });  // ..."
      },
      {
        "language": "text",
        "code": "function handleClick() {  dispatch({ type: 'incremented_age' });}"
      },
      {
        "language": "text",
        "code": "function handleClick() {  dispatch({ type: 'incremented_age' });}"
      },
      {
        "language": "text",
        "code": "import { useReducer } from 'react';\n\nfunction reducer(state, action) {\n  if (action.type === 'incremented_age') {\n    return {\n      age: state.age + 1\n    };\n  }\n  throw Error('Unknown action.');\n}\n\nexport default function Counter() {\n  const [state, dispatch] = useReducer(reducer, { age: 42 });\n\n  return (\n    <>\n      <button onClick={() => {\n        dispatch({ type: 'incremented_age' })\n      }}>\n        Increment age\n      </button>\n      <p>Hello! You are {state.age}.</p>\n    </>\n  );\n}"
      },
      {
        "language": "text",
        "code": "function reducer(state, action) {  // ...}"
      },
      {
        "language": "text",
        "code": "function reducer(state, action) {  // ...}"
      },
      {
        "language": "text",
        "code": "function reducer(state, action) {  switch (action.type) {    case 'incremented_age': {      return {        name: state.name,        age: state.age + 1      };    }    case 'changed_name': {      return {        name: action.nextName,        age: state.age      };    }  }  throw Error('Unknown action: ' + action.type);}"
      },
      {
        "language": "text",
        "code": "function reducer(state, action) {  switch (action.type) {    case 'incremented_age': {      return {        name: state.name,        age: state.age + 1      };    }    case 'changed_name': {      return {        name: action.nextName,        age: state.age      };    }  }  throw Error('Unknown action: ' + action.type);}"
      },
      {
        "language": "text",
        "code": "function Form() {  const [state, dispatch] = useReducer(reducer, { name: 'Taylor', age: 42 });    function handleButtonClick() {    dispatch({ type: 'incremented_age' });  }  function handleInputChange(e) {    dispatch({      type: 'changed_name',      nextName: e.target.value    });  }  // ..."
      },
      {
        "language": "text",
        "code": "function Form() {  const [state, dispatch] = useReducer(reducer, { name: 'Taylor', age: 42 });    function handleButtonClick() {    dispatch({ type: 'incremented_age' });  }  function handleInputChange(e) {    dispatch({      type: 'changed_name',      nextName: e.target.value    });  }  // ..."
      },
      {
        "language": "text",
        "code": "function reducer(state, action) {  switch (action.type) {    case 'incremented_age': {      // 🚩 Don't mutate an object in state like this:      state.age = state.age + 1;      return state;    }"
      },
      {
        "language": "text",
        "code": "function reducer(state, action) {  switch (action.type) {    case 'incremented_age': {      // 🚩 Don't mutate an object in state like this:      state.age = state.age + 1;      return state;    }"
      },
      {
        "language": "text",
        "code": "function reducer(state, action) {  switch (action.type) {    case 'incremented_age': {      // ✅ Instead, return a new object      return {        ...state,        age: state.age + 1      };    }"
      },
      {
        "language": "text",
        "code": "function reducer(state, action) {  switch (action.type) {    case 'incremented_age': {      // ✅ Instead, return a new object      return {        ...state,        age: state.age + 1      };    }"
      },
      {
        "language": "text",
        "code": "import { useReducer } from 'react';\n\nfunction reducer(state, action) {\n  switch (action.type) {\n    case 'incremented_age': {\n      return {\n        name: state.name,\n        age: state.age + 1\n      };\n    }\n    case 'changed_name': {\n      return {\n        name: action.nextName,\n        age: state.age\n      };\n    }\n  }\n  throw Error('Unknown action: ' + action.type);\n}\n\nconst initialState = { name: 'Taylor', age: 42 };\n\nexport default function Form() {\n  const [state, dispatch] = useReducer(reducer, initialState);\n\n  function handleButtonClick() {\n    dispatch({ type: 'incremented_age' });\n  }\n\n  function handleInputChange(e) {\n    dispatch({\n      type: 'changed_name',\n      nextName: e.target.value\n    }); \n  }\n\n  return (\n    <>\n      <input\n        value={state.name}\n        onChange={handleInputChange}\n      />\n      <button onClick={handleButtonClick}>\n        Increment age\n      </button>\n      <p>Hello, {state.name}. You are {state.age}.</p>\n    </>\n  );\n}"
      },
      {
        "language": "text",
        "code": "function createInitialState(username) {  // ...}function TodoList({ username }) {  const [state, dispatch] = useReducer(reducer, createInitialState(username));  // ..."
      },
      {
        "language": "text",
        "code": "function createInitialState(username) {  // ...}function TodoList({ username }) {  const [state, dispatch] = useReducer(reducer, createInitialState(username));  // ..."
      },
      {
        "language": "text",
        "code": "createInitialState(username)"
      },
      {
        "language": "text",
        "code": "function createInitialState(username) {  // ...}function TodoList({ username }) {  const [state, dispatch] = useReducer(reducer, username, createInitialState);  // ..."
      },
      {
        "language": "text",
        "code": "function createInitialState(username) {  // ...}function TodoList({ username }) {  const [state, dispatch] = useReducer(reducer, username, createInitialState);  // ..."
      },
      {
        "language": "text",
        "code": "createInitialState"
      },
      {
        "language": "text",
        "code": "createInitialState()"
      },
      {
        "language": "text",
        "code": "createInitialState"
      },
      {
        "language": "text",
        "code": "createInitialState"
      },
      {
        "language": "text",
        "code": "import { useReducer } from 'react';\n\nfunction createInitialState(username) {\n  const initialTodos = [];\n  for (let i = 0; i < 50; i++) {\n    initialTodos.push({\n      id: i,\n      text: username + \"'s task #\" + (i + 1)\n    });\n  }\n  return {\n    draft: '',\n    todos: initialTodos,\n  };\n}\n\nfunction reducer(state, action) {\n  switch (action.type) {\n    case 'changed_draft': {\n      return {\n        draft: action.nextDraft,\n        todos: state.todos,\n      };\n    };\n    case 'added_todo': {\n      return {\n        draft: '',\n        todos: [{\n          id: state.todos.length,\n          text: state.draft\n        }, ...state.todos]\n      }\n    }\n  }\n  throw Error('Unknown action: ' + action.type);\n}\n\nexport default function TodoList({ username }) {\n  const [state, dispatch] = useReducer(\n    reducer,\n    username,\n    createInitialState\n  );\n  return (\n    <>\n      <input\n        value={state.draft}\n        onChange={e => {\n          dispatch({\n            type: 'changed_draft',\n            nextDraft: e.target.value\n          })\n        }}\n      />\n      <button onClick={() => {\n        dispatch({ type: 'added_todo' });\n      }}>Add</button>\n      <ul>\n        {state.todos.map(item => (\n          <li key={item.id}>\n            {item.text}\n          </li>\n        ))}\n      </ul>\n    </>\n  );\n}"
      },
      {
        "language": "text",
        "code": "function handleClick() {  console.log(state.age);  // 42  dispatch({ type: 'incremented_age' }); // Request a re-render with 43  console.log(state.age);  // Still 42!  setTimeout(() => {    console.log(state.age); // Also 42!  }, 5000);}"
      },
      {
        "language": "text",
        "code": "function handleClick() {  console.log(state.age);  // 42  dispatch({ type: 'incremented_age' }); // Request a re-render with 43  console.log(state.age);  // Still 42!  setTimeout(() => {    console.log(state.age); // Also 42!  }, 5000);}"
      },
      {
        "language": "text",
        "code": "const action = { type: 'incremented_age' };dispatch(action);const nextState = reducer(state, action);console.log(state);     // { age: 42 }console.log(nextState); // { age: 43 }"
      },
      {
        "language": "text",
        "code": "const action = { type: 'incremented_age' };dispatch(action);const nextState = reducer(state, action);console.log(state);     // { age: 42 }console.log(nextState); // { age: 43 }"
      },
      {
        "language": "text",
        "code": "function reducer(state, action) {  switch (action.type) {    case 'incremented_age': {      // 🚩 Wrong: mutating existing object      state.age++;      return state;    }    case 'changed_name': {      // 🚩 Wrong: mutating existing object      state.name = action.nextName;      return state;    }    // ...  }}"
      },
      {
        "language": "text",
        "code": "function reducer(state, action) {  switch (action.type) {    case 'incremented_age': {      // 🚩 Wrong: mutating existing object      state.age++;      return state;    }    case 'changed_name': {      // 🚩 Wrong: mutating existing object      state.name = action.nextName;      return state;    }    // ...  }}"
      },
      {
        "language": "text",
        "code": "function reducer(state, action) {  switch (action.type) {    case 'incremented_age': {      // ✅ Correct: creating a new object      return {        ...state,        age: state.age + 1      };    }    case 'changed_name': {      // ✅ Correct: creating a new object      return {        ...state,        name: action.nextName      };    }    // ...  }}"
      },
      {
        "language": "text",
        "code": "function reducer(state, action) {  switch (action.type) {    case 'incremented_age': {      // ✅ Correct: creating a new object      return {        ...state,        age: state.age + 1      };    }    case 'changed_name': {      // ✅ Correct: creating a new object      return {        ...state,        name: action.nextName      };    }    // ...  }}"
      },
      {
        "language": "text",
        "code": "function reducer(state, action) {  switch (action.type) {    case 'incremented_age': {      return {        ...state, // Don't forget this!        age: state.age + 1      };    }    // ..."
      },
      {
        "language": "text",
        "code": "function reducer(state, action) {  switch (action.type) {    case 'incremented_age': {      return {        ...state, // Don't forget this!        age: state.age + 1      };    }    // ..."
      },
      {
        "language": "text",
        "code": "function reducer(state, action) {  switch (action.type) {    case 'incremented_age': {      // ...    }    case 'edited_name': {      // ...    }  }  throw Error('Unknown action: ' + action.type);}"
      },
      {
        "language": "text",
        "code": "function reducer(state, action) {  switch (action.type) {    case 'incremented_age': {      // ...    }    case 'edited_name': {      // ...    }  }  throw Error('Unknown action: ' + action.type);}"
      },
      {
        "language": "text",
        "code": "Too many re-renders. React limits the number of renders to prevent an infinite loop."
      },
      {
        "language": "text",
        "code": "// 🚩 Wrong: calls the handler during renderreturn <button onClick={handleClick()}>Click me</button>// ✅ Correct: passes down the event handlerreturn <button onClick={handleClick}>Click me</button>// ✅ Correct: passes down an inline functionreturn <button onClick={(e) => handleClick(e)}>Click me</button>"
      },
      {
        "language": "text",
        "code": "// 🚩 Wrong: calls the handler during renderreturn <button onClick={handleClick()}>Click me</button>// ✅ Correct: passes down the event handlerreturn <button onClick={handleClick}>Click me</button>// ✅ Correct: passes down an inline functionreturn <button onClick={(e) => handleClick(e)}>Click me</button>"
      },
      {
        "language": "text",
        "code": "function reducer(state, action) {  switch (action.type) {    case 'added_todo': {      // 🚩 Mistake: mutating state      state.todos.push({ id: nextId++, text: action.text });      return state;    }    // ...  }}"
      },
      {
        "language": "text",
        "code": "function reducer(state, action) {  switch (action.type) {    case 'added_todo': {      // 🚩 Mistake: mutating state      state.todos.push({ id: nextId++, text: action.text });      return state;    }    // ...  }}"
      },
      {
        "language": "text",
        "code": "function reducer(state, action) {  switch (action.type) {    case 'added_todo': {      // ✅ Correct: replacing with new state      return {        ...state,        todos: [          ...state.todos,          { id: nextId++, text: action.text }        ]      };    }    // ...  }}"
      },
      {
        "language": "text",
        "code": "function reducer(state, action) {  switch (action.type) {    case 'added_todo': {      // ✅ Correct: replacing with new state      return {        ...state,        todos: [          ...state.todos,          { id: nextId++, text: action.text }        ]      };    }    // ...  }}"
      }
    ],
    "links": [
      {
        "text": "API Reference",
        "href": "/reference/react"
      },
      {
        "text": "Hooks",
        "href": "/reference/react/hooks"
      },
      {
        "text": "reducer",
        "href": "/learn/extracting-state-logic-into-a-reducer"
      },
      {
        "text": "reducer.",
        "href": "/learn/extracting-state-logic-into-a-reducer"
      },
      {
        "text": "Learn more about removing Effect dependencies.",
        "href": "/learn/removing-effect-dependencies#move-dynamic-objects-and-functions-inside-your-effect"
      },
      {
        "text": "Object.is",
        "href": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/is"
      },
      {
        "text": "batches state updates.",
        "href": "/learn/queueing-a-series-of-state-updates"
      },
      {
        "text": "flushSync.",
        "href": "/reference/react-dom/flushSync"
      },
      {
        "text": "reducer.",
        "href": "/learn/extracting-state-logic-into-a-reducer"
      },
      {
        "text": "useState",
        "href": "/reference/react/useState"
      },
      {
        "text": "choosing between useState and useReducer.",
        "href": "/learn/extracting-state-logic-into-a-reducer#comparing-usestate-and-usereducer"
      },
      {
        "text": "switch statement.",
        "href": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Statements/switch"
      },
      {
        "text": "Each action describes a single interaction, even if that leads to multiple changes in data.",
        "href": "/learn/extracting-state-logic-into-a-reducer#writing-reducers-well"
      },
      {
        "text": "extracting state logic into a reducer",
        "href": "/learn/extracting-state-logic-into-a-reducer"
      },
      {
        "text": "updating objects in state",
        "href": "/learn/updating-objects-in-state"
      },
      {
        "text": "updating arrays in state",
        "href": "/learn/updating-arrays-in-state"
      },
      {
        "text": "states behaves like a snapshot.",
        "href": "/learn/state-as-a-snapshot"
      },
      {
        "text": "Object.is",
        "href": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/is"
      },
      {
        "text": "updating objects in state",
        "href": "/learn/updating-objects-in-state"
      },
      {
        "text": "updating arrays in state",
        "href": "/learn/updating-arrays-in-state"
      },
      {
        "text": "Strict Mode",
        "href": "/reference/react/StrictMode"
      },
      {
        "text": "keep components pure.",
        "href": "/learn/keeping-components-pure"
      },
      {
        "text": "replacing the array instead of mutating it",
        "href": "/learn/updating-arrays-in-state#adding-to-an-array"
      },
      {
        "text": "keeping components pure",
        "href": "/learn/keeping-components-pure"
      },
      {
        "text": "PrevioususeOptimistic",
        "href": "/reference/react/useOptimistic"
      },
      {
        "text": "NextuseRef",
        "href": "/reference/react/useRef"
      }
    ],
    "meta": {
      "description": "",
      "keywords": ""
    },
    "summary": "API ReferenceHooksuseReduceruseReducer is a React Hook that lets you add a reducer to your component. const [state, dispatch] = useReducer(reducer, initialArg, init",
    "tags": [
      "react",
      "angular",
      "javascript",
      "typescript",
      "html",
      "vite",
      "reducer",
      "state",
      "usereducer",
      "function"
    ],
    "id": "usereducer-react-useReducer-part-1",
    "quality": 100
  },
  {
    "title": "useMemo – React",
    "url": "https://react.dev/reference/react/useMemo",
    "category": "react",
    "content": "API ReferenceHooksuseMemouseMemo is a React Hook that lets you cache the result of a calculation between re-renders.const cachedValue = useMemo(calculateValue, dependencies) NoteReact Compiler automatically memoizes values and functions, reducing the need for manual useMemo calls. You can use the compiler to handle memoization automatically. Reference useMemo(calculateValue, dependencies) Usage Skipping expensive recalculations Skipping re-rendering of components Preventing an Effect from firing too often Memoizing a dependency of another Hook Memoizing a function Troubleshooting My calculation runs twice on every re-render My useMemo call is supposed to return an object, but returns undefined Every time my component renders, the calculation in useMemo re-runs I need to call useMemo for each list item in a loop, but its not allowed Reference useMemo(calculateValue, dependencies) Call useMemo at the top level of your component to cache a calculation between re-renders: import { useMemo } from 'react';function TodoList({ todos, tab }) { const visibleTodos = useMemo( () = filterTodos(todos, tab), [todos, tab] ); // ...} See more examples below. Parameters calculateValue: The function calculating the value that you want to cache. It should be pure, should take no arguments, and should return a value of any type. React will call your function during the initial render. On next renders, React will return the same value again if the dependencies have not changed since the last render. Otherwise, it will call calculateValue, return its result, and store it so it can be reused later. dependencies: The list of all reactive values referenced inside of the calculateValue code. Reactive values include props, state, and all the variables and functions declared directly inside your component body. If your linter is configured for React, it will verify that every reactive value is correctly specified as a dependency. The list of dependencies must have a constant number of items and be written inline like [dep1, dep2, dep3]. React will compare each dependency with its previous value using the Object.is comparison. Returns On the initial render, useMemo returns the result of calling calculateValue with no arguments. During next renders, it will either return an already stored value from the last render (if the dependencies havent changed), or call calculateValue again, and return the result that calculateValue has returned. Caveats useMemo is a Hook, so you can only call it at the top level of your component or your own Hooks. You cant call it inside loops or conditions. If you need that, extract a new component and move the state into it. In Strict Mode, React will call your calculation function twice in order to help you find accidental impurities. This is development-only behavior and does not affect production. If your calculation function is pure (as it should be), this should not affect your logic. The result from one of the calls will be ignored. React will not throw away the cached value unless there is a specific reason to do that. For example, in development, React throws away the cache when you edit the file of your component. Both in development and in production, React will throw away the cache if your component suspends during the initial mount. In the future, React may add more features that take advantage of throwing away the cachefor example, if React adds built-in support for virtualized lists in the future, it would make sense to throw away the cache for items that scroll out of the virtualized table viewport. This should be fine if you rely on useMemo solely as a performance optimization. Otherwise, a state variable or a ref may be more appropriate. NoteCaching return values like this is also known as memoization, which is why this Hook is called useMemo. Usage Skipping expensive recalculations To cache a calculation between re-renders, wrap it in a useMemo call at the top level of your component: import { useMemo } from 'react';function TodoList({ todos, tab, theme }) { const visibleTodos = useMemo(() = filterTodos(todos, tab), [todos, tab]); // ...} You need to pass two things to useMemo: A calculation function that takes no arguments, like () =, and returns what you wanted to calculate. A list of dependencies including every value within your component thats used inside your calculation. On the initial render, the value youll get from useMemo will be the result of calling your calculation. On every subsequent render, React will compare the dependencies with the dependencies you passed during the last render. If none of the dependencies have changed (compared with Object.is), useMemo will return the value you already calculated before. Otherwise, React will re-run your calculation and return the new value. In other words, useMemo caches a calculation result between re-renders until its dependencies change. Lets walk through an example to see when this is useful. By default, React will re-run the entire body of your component every time that it re-renders. For example, if this TodoList updates its state or receives new props from its parent, the filterTodos function will re-run: function TodoList({ todos, tab, theme }) { const visibleTodos = filterTodos(todos, tab); // ...} Usually, this isnt a problem because most calculations are very fast. However, if youre filtering or transforming a large array, or doing some expensive computation, you might want to skip doing it again if data hasnt changed. If both todos and tab are the same as they were during the last render, wrapping the calculation in useMemo like earlier lets you reuse visibleTodos youve already calculated before. This type of caching is called memoization. NoteYou should only rely on useMemo as a performance optimization. If your code doesnt work without it, find the underlying problem and fix it first. Then you may add useMemo to improve performance. Deep DiveHow to tell if a calculation is expensive? Show DetailsIn general, unless youre creating or looping over thousands of objects, its probably not expensive. If you want to get more confidence, you can add a console log to measure the time spent in a piece of code:console.time('filter array');const visibleTodos = filterTodos(todos, tab);console.timeEnd('filter array');Perform the interaction youre measuring (for example, typing into the input). You will then see logs like filter array: 0.15ms in your console. If the overall logged time adds up to a significant amount (say, 1ms or more), it might make sense to memoize that calculation. As an experiment, you can then wrap the calculation in useMemo to verify whether the total logged time has decreased for that interaction or not:console.time('filter array');const visibleTodos = useMemo(() = { return filterTodos(todos, tab); // Skipped if todos and tab haven't changed}, [todos, tab]);console.timeEnd('filter array');useMemo wont make the first render faster. It only helps you skip unnecessary work on updates.Keep in mind that your machine is probably faster than your users so its a good idea to test the performance with an artificial slowdown. For example, Chrome offers a CPU Throttling option for this.Also note that measuring performance in development will not give you the most accurate results. (For example, when Strict Mode is on, you will see each component render twice rather than once.) To get the most accurate timings, build your app for production and test it on a device like your users have. Deep DiveShould you add useMemo everywhere? Show DetailsIf your app is like this site, and most interactions are coarse (like replacing a page or an entire section), memoization is usually unnecessary. On the other hand, if your app is more like a drawing editor, and most interactions are granular (like moving shapes), then you might find memoization very helpful.Optimizing with useMemo is only valuable in a few cases: The calculation youre putting in useMemo is noticeably slow, and its dependencies rarely change. You pass it as a prop to a component wrapped in memo. You want to skip re-rendering if the value hasnt changed. Memoization lets your component re-render only when dependencies arent the same. The value youre passing is later used as a dependency of some Hook. For example, maybe another useMemo calculation value depends on it. Or maybe you are depending on this value from useEffect. There is no benefit to wrapping a calculation in useMemo in other cases. There is no significant harm to doing that either, so some teams choose to not think about individual cases, and memoize as much as possible. The downside of this approach is that code becomes less readable. Also, not all memoization is effective: a single value thats always new is enough to break memoization for an entire component.In practice, you can make a lot of memoization unnecessary by following a few principles: When a component visually wraps other components, let it accept JSX as children. This way, when the wrapper component updates its own state, React knows that its children dont need to re-render. Prefer local state and dont lift state up any further than necessary. For example, dont keep transient state like forms and whether an item is hovered at the top of your tree or in a global state library. Keep your rendering logic pure. If re-rendering a component causes a problem or produces some noticeable visual artifact, its a bug in your component! Fix the bug instead of adding memoization. Avoid unnecessary Effects that update state. Most performance problems in React apps are caused by chains of updates originating from Effects that cause your components to render over and over. Try to remove unnecessary dependencies from your Effects. For example, instead of memoization, its often simpler to move some object or a function inside an Effect or outside the component. If a specific interaction still feels laggy, use the React Developer Tools profiler to see which components would benefit the most from memoization, and add memoization where needed. These principles make your components easier to debug and understand, so its good to follow them in any case. In the long term, were researching doing granular memoization automatically to solve this once and for all. The difference between useMemo and calculating a value directly1. Skipping recalculation with useMemo 2. Always recalculating a value Example 1 of 2: Skipping recalculation with useMemo In this example, the filterTodos implementation is artificially slowed down so that you can see what happens when some JavaScript function youre calling during rendering is genuinely slow. Try switching the tabs and toggling the theme.Switching the tabs feels slow because it forces the slowed down filterTodos to re-execute. Thats expected because the tab has changed, and so the entire calculation needs to re-run. (If youre curious why it runs twice, its explained here.)Toggle the theme. Thanks to useMemo, its fast despite the artificial slowdown! The slow filterTodos call was skipped because both todos and tab (which you pass as dependencies to useMemo) havent changed since the last render.App.jsTodoList.jsutils.jsTodoList.js ResetForkimport { useMemo } from 'react'; import { filterTodos } from './utils.js' export default function TodoList({ todos, theme, tab }) { const visibleTodos = useMemo( () = filterTodos(todos, tab), [todos, tab] ); return ( div className={theme} pbNote: codefilterTodos/code is artificially slowed down!/b/p ul {visibleTodos.map(todo = ( li key={todo.id} {todo.completed ? s{todo.text}/s : todo.text } /li ))} /ul /div ); } Show moreNext Example Skipping re-rendering of components In some cases, useMemo can also help you optimize performance of re-rendering child components. To illustrate this, lets say this TodoList component passes the visibleTodos as a prop to the child List component: export default function TodoList({ todos, tab, theme }) { // ... return ( div className={theme} List items={visibleTodos} / /div );} Youve noticed that toggling the theme prop freezes the app for a moment, but if you remove List / from your JSX, it feels fast. This tells you that its worth trying to optimize the List component. By default, when a component re-renders, React re-renders all of its children recursively. This is why, when TodoList re-renders with a different theme, the List component also re-renders. This is fine for components that dont require much calculation to re-render. But if youve verified that a re-render is slow, you can tell List to skip re-rendering when its props are the same as on last render by wrapping it in memo: import { memo } from 'react';const List = memo(function List({ items }) { // ...}); With this change, List will skip re-rendering if all of its props are the same as on the last render. This is where caching the calculation becomes important! Imagine that you calculated visibleTodos without useMemo: export default function TodoList({ todos, tab, theme }) { // Every time the theme changes, this will be a different array... const visibleTodos = filterTodos(todos, tab); return ( div className={theme} {/* ... so List's props will never be the same, and it will re-render every time */} List items={visibleTodos} / /div );} In the above example, the filterTodos function always creates a different array, similar to how the {} object literal always creates a new object. Normally, this wouldnt be a problem, but it means that List props will never be the same, and your memo optimization wont work. This is where useMemo comes in handy: export default function TodoList({ todos, tab, theme }) { // Tell React to cache your calculation between re-renders... const visibleTodos = useMemo( () = filterTodos(todos, tab), [todos, tab] // ...so as long as these dependencies don't change... ); return ( div className={theme} {/* ...List will receive the same props and can skip re-rendering */} List items={visibleTodos} / /div );} By wrapping the visibleTodos calculation in useMemo, you ensure that it has the same value between the re-renders (until dependencies change). You dont have to wrap a calculation in useMemo unless you do it for some specific reason. In this example, the reason is that you pass it to a component wrapped in memo, and this lets it skip re-rendering. There are a few other reasons to add useMemo which are described further on this page. Deep DiveMemoizing individual JSX nodes Show DetailsInstead of wrapping List in memo, you could wrap the List / JSX node itself in useMemo:export default function TodoList({ todos, tab, theme }) { const visibleTodos = useMemo(() = filterTodos(todos, tab), [todos, tab]); const children = useMemo(() = List items={visibleTodos} /, [visibleTodos]); return ( div className={theme} {children} /div );}The behavior would be the same. If the visibleTodos havent changed, List wont be re-rendered.A JSX node like List items={visibleTodos} / is an object like { type: List, props: { items: visibleTodos } }. Creating this object is very cheap, but React doesnt know whether its contents is the same as last time or not. This is why by default, React will re-render the List component.However, if React sees the same exact JSX as during the previous render, it wont try to re-render your component. This is because JSX nodes are immutable. A JSX node object could not have changed over time, so React knows its safe to skip a re-render. However, for this to work, the node has to actually be the same object, not merely look the same in code. This is what useMemo does in this example.Manually wrapping JSX nodes into useMemo is not convenient. For example, you cant do this conditionally. This is usually why you would wrap components with memo instead of wrapping JSX nodes. The difference between skipping re-renders and always re-rendering1. Skipping re-rendering with useMemo and memo 2. Always re-rendering a component Example 1 of 2: Skipping re-rendering with useMemo and memo In this example, the List component is artificially slowed down so that you can see what happens when a React component youre rendering is genuinely slow. Try switching the tabs and toggling the theme.Switching the tabs feels slow because it forces the slowed down List to re-render. Thats expected because the tab has changed, and so you need to reflect the users new choice on the screen.Next, try toggling the theme. Thanks to useMemo together with memo, its fast despite the artificial slowdown! The List skipped re-rendering because the visibleTodos array has not changed since the last render. The visibleTodos array has not changed because both todos and tab (which you pass as dependencies to useMemo) havent changed since the last render.App.jsTodoList.jsList.jsutils.jsTodoList.js ResetForkimport { useMemo } from 'react'; import List from './List.js'; import { filterTodos } from './utils.js' export default function TodoList({ todos, theme, tab }) { const visibleTodos = useMemo( () = filterTodos(todos, tab), [todos, tab] ); return ( div className={theme} pbNote: codeList/code is artificially slowed down!/b/p List items={visibleTodos} / /div ); } Show moreNext Example Preventing an Effect from firing too often Sometimes, you might want to use a value inside an Effect: function ChatRoom({ roomId }) { const [message, setMessage] = useState(''); const options = { serverUrl: 'https://localhost:1234', roomId: roomId } useEffect(() = { const connection = createConnection(options); connection.connect(); // ... This creates a problem. Every reactive value must be declared as a dependency of your Effect. However, if you declare options as a dependency, it will cause your Effect to constantly reconnect to the chat room: useEffect(() = { const connection = createConnection(options); connection.connect(); return () = connection.disconnect(); }, [options]); //  Problem: This dependency changes on every render // ... To solve this, you can wrap the object you need to call from an Effect in useMemo: function ChatRoom({ roomId }) { const [message, setMessage] = useState(''); const options = useMemo(() = { return { serverUrl: 'https://localhost:1234', roomId: roomId }; }, [roomId]); //  Only changes when roomId changes useEffect(() = { const connection = createConnection(options); connection.connect(); return () = connection.disconnect(); }, [options]); //  Only changes when options changes // ... This ensures that the options object is the same between re-renders if useMemo returns the cached object. However, since useMemo is performance optimization, not a semantic guarantee, React may throw away the cached value if there is a specific reason to do that. This will also cause the effect to re-fire, so its even better to remove the need for a function dependency by moving your object inside the Effect: function ChatRoom({ roomId }) { const [message, setMessage] = useState(''); useEffect(() = { const options = { //  No need for useMemo or object dependencies! serverUrl: 'https://localhost:1234', roomId: roomId } const connection = createConnection(options); connection.connect(); return () = connection.disconnect(); }, [roomId]); //  Only changes when roomId changes // ... Now your code is simpler and doesnt need useMemo. Learn more about removing Effect dependencies. Memoizing a dependency of another Hook Suppose you have a calculation that depends on an object created directly in the component body: function Dropdown({ allItems, text }) { const searchOptions = { matchMode: 'whole-word', text }; const visibleItems = useMemo(() = { return searchItems(allItems, searchOptions); }, [allItems, searchOptions]); //  Caution: Dependency on an object created in the component body // ... Depending on an object like this defeats the point of memoization. When a component re-renders, all of the code directly inside the component body runs again. The lines of code creating the searchOptions object will also run on every re-render. Since searchOptions is a dependency of your useMemo call, and its different every time, React knows the dependencies are different, and recalculate searchItems every time. To fix this, you could memoize the searchOptions object itself before passing it as a dependency: function Dropdown({ allItems, text }) { const searchOptions = useMemo(() = { return { matchMode: 'whole-word', text }; }, [text]); //  Only changes when text changes const visibleItems = useMemo(() = { return searchItems(allItems, searchOptions); }, [allItems, searchOptions]); //  Only changes when allItems or searchOptions changes // ... In the example above, if the text did not change, the searchOptions object also wont change. However, an even better fix is to move the searchOptions object declaration inside of the useMemo calculation function: function Dropdown({ allItems, text }) { const visibleItems = useMemo(() = { const searchOptions = { matchMode: 'whole-word', text }; return searchItems(allItems, searchOptions); }, [allItems, text]); //  Only changes when allItems or text changes // ... Now your calculation depends on text directly (which is a string and cant accidentally become different). Memoizing a function Suppose the Form component is wrapped in memo. You want to pass a function to it as a prop: export default function ProductPage({ productId, referrer }) { function handleSubmit(orderDetails) { post('/product/' + productId + '/buy', { referrer, orderDetails }); } return Form onSubmit={handleSubmit} /;} Just as {} creates a different object, function declarations like function() {} and expressions like () = {} produce a different function on every re-render. By itself, creating a new function is not a problem. This is not something to avoid! However, if the Form component is memoized, presumably you want to skip re-rendering it when no props have changed. A prop that is always different would defeat the point of memoization. To memoize a function with useMemo, your calculation function would have to return another function: export default function Page({ productId, referrer }) { const handleSubmit = useMemo(() = { return (orderDetails) = { post('/product/' + productId + '/buy', { referrer, orderDetails }); }; }, [productId, referrer]); return Form onSubmit={handleSubmit} /;} This looks clunky! Memoizing functions is common enough that React has a built-in Hook specifically for that. Wrap your functions into useCallback instead of useMemo to avoid having to write an extra nested function: export default function Page({ productId, referrer }) { const handleSubmit = useCallback((orderDetails) = { post('/product/' + productId + '/buy', { referrer, orderDetails }); }, [productId, referrer]); return Form onSubmit={handleSubmit} /;} The two examples above are completely equivalent. The only benefit to useCallback is that it lets you avoid writing an extra nested function inside. It doesnt do anything else. Read more about useCallback. Troubleshooting My calculation runs twice on every re-render In Strict Mode, React will call some of your functions twice instead of once: function TodoList({ todos, tab }) { // This component function will run twice for every render. const visibleTodos = useMemo(() = { // This calculation will run twice if any of the dependencies change. return filterTodos(todos, tab); }, [todos, tab]); // ... This is expected and shouldnt break your code. This development-only behavior helps you keep components pure. React uses the result of one of the calls, and ignores the result of the other call. As long as your component and calculation functions are pure, this shouldnt affect your logic. However, if they are accidentally impure, this helps you notice and fix the mistake. For example, this impure calculation function mutates an array you received as a prop: const visibleTodos = useMemo(() = { //  Mistake: mutating a prop todos.push({ id: 'last', text: 'Go for a walk!' }); const filtered = filterTodos(todos, tab); return filtered; }, [todos, tab]); React calls your function twice, so youd notice the todo is added twice. Your calculation shouldnt change any existing objects, but its okay to change any new objects you created during the calculation. For example, if the filterTodos function always returns a different array, you can mutate that array instead: const visibleTodos = useMemo(() = { const filtered = filterTodos(todos, tab); //  Correct: mutating an object you created during the calculation filtered.push({ id: 'last', text: 'Go for a walk!' }); return filtered; }, [todos, tab]); Read keeping components pure to learn more about purity. Also, check out the guides on updating objects and updating arrays without mutation. My useMemo call is supposed to return an object, but returns undefined This code doesnt work: //  You can't return an object from an arrow function with () = { const searchOptions = useMemo(() = { matchMode: 'whole-word', text: text }, [text]); In JavaScript, () = { starts the arrow function body, so the { brace is not a part of your object. This is why it doesnt return an object, and leads to mistakes. You could fix it by adding parentheses like ({ and }): // This works, but is easy for someone to break again const searchOptions = useMemo(() = ({ matchMode: 'whole-word', text: text }), [text]); However, this is still confusing and too easy for someone to break by removing the parentheses. To avoid this mistake, write a return statement explicitly: //  This works and is explicit const searchOptions = useMemo(() = { return { matchMode: 'whole-word', text: text }; }, [text]); Every time my component renders, the calculation in useMemo re-runs Make sure youve specified the dependency array as a second argument! If you forget the dependency array, useMemo will re-run the calculation every time: function TodoList({ todos, tab }) { //  Recalculates every time: no dependency array const visibleTodos = useMemo(() = filterTodos(todos, tab)); // ... This is the corrected version passing the dependency array as a second argument: function TodoList({ todos, tab }) { //  Does not recalculate unnecessarily const visibleTodos = useMemo(() = filterTodos(todos, tab), [todos, tab]); // ... If this doesnt help, then the problem is that at least one of your dependencies is different from the previous render. You can debug this problem by manually logging your dependencies to the console: const visibleTodos = useMemo(() = filterTodos(todos, tab), [todos, tab]); console.log([todos, tab]); You can then right-click on the arrays from different re-renders in the console and select Store as a global variable for both of them. Assuming the first one got saved as temp1 and the second one got saved as temp2, you can then use the browser console to check whether each dependency in both arrays is the same: Object.is(temp1[0], temp2[0]); // Is the first dependency the same between the arrays?Object.is(temp1[1], temp2[1]); // Is the second dependency the same between the arrays?Object.is(temp1[2], temp2[2]); // ... and so on for every dependency ... When you find which dependency breaks memoization, either find a way to remove it, or memoize it as well. I need to call useMemo for each list item in a loop, but its not allowed Suppose the Chart component is wrapped in memo. You want to skip re-rendering every Chart in the list when the ReportList component re-renders. However, you cant call useMemo in a loop: function ReportList({ items }) { return ( article {items.map(item = { //  You can't call useMemo in a loop like this: const data = useMemo(() = calculateReport(item), [item]); return ( figure key={item.id} Chart data={data} / /figure ); })} /article );} Instead, extract a component for each item and memoize data for individual items: function ReportList({ items }) { return ( article {items.map(item = Report key={item.id} item={item} / )} /article );}function Report({ item }) { //  Call useMemo at the top level: const data = useMemo(() = calculateReport(item), [item]); return ( figure Chart data={data} / /figure );} Alternatively, you could remove useMemo and instead wrap Report itself in memo. If the item prop does not change, Report will skip re-rendering, so Chart will skip re-rendering too: function ReportList({ items }) { // ...}const Report = memo(function Report({ item }) { const data = calculateReport(item); return ( figure Chart data={data} / /figure );});PrevioususeLayoutEffectNextuseOptimistic",
    "headings": [
      {
        "level": 1,
        "text": "useMemo",
        "id": ""
      },
      {
        "level": 2,
        "text": "Reference",
        "id": "reference"
      },
      {
        "level": 2,
        "text": "Usage",
        "id": "usage"
      },
      {
        "level": 2,
        "text": "Troubleshooting",
        "id": "troubleshooting"
      },
      {
        "level": 3,
        "text": "Note",
        "id": ""
      },
      {
        "level": 3,
        "text": "useMemo(calculateValue, dependencies)",
        "id": "usememo"
      },
      {
        "level": 3,
        "text": "Note",
        "id": ""
      },
      {
        "level": 3,
        "text": "Skipping expensive recalculations",
        "id": "skipping-expensive-recalculations"
      },
      {
        "level": 3,
        "text": "Note",
        "id": ""
      },
      {
        "level": 3,
        "text": "Skipping re-rendering of components",
        "id": "skipping-re-rendering-of-components"
      },
      {
        "level": 3,
        "text": "Preventing an Effect from firing too often",
        "id": "preventing-an-effect-from-firing-too-often"
      },
      {
        "level": 3,
        "text": "Memoizing a dependency of another Hook",
        "id": "memoizing-a-dependency-of-another-hook"
      },
      {
        "level": 3,
        "text": "Memoizing a function",
        "id": "memoizing-a-function"
      },
      {
        "level": 3,
        "text": "My calculation runs twice on every re-render",
        "id": "my-calculation-runs-twice-on-every-re-render"
      },
      {
        "level": 3,
        "text": "My useMemo call is supposed to return an object, but returns undefined",
        "id": "my-usememo-call-is-supposed-to-return-an-object-but-returns-undefined"
      },
      {
        "level": 3,
        "text": "Every time my component renders, the calculation in useMemo re-runs",
        "id": "every-time-my-component-renders-the-calculation-in-usememo-re-runs"
      },
      {
        "level": 3,
        "text": "I need to call useMemo for each list item in a loop, but it’s not allowed",
        "id": "i-need-to-call-usememo-for-each-list-item-in-a-loop-but-its-not-allowed"
      },
      {
        "level": 4,
        "text": "Parameters",
        "id": "parameters"
      },
      {
        "level": 4,
        "text": "Returns",
        "id": "returns"
      },
      {
        "level": 4,
        "text": "Caveats",
        "id": "caveats"
      },
      {
        "level": 4,
        "text": "How to tell if a calculation is expensive?",
        "id": "how-to-tell-if-a-calculation-is-expensive"
      },
      {
        "level": 4,
        "text": "Should you add useMemo everywhere?",
        "id": "should-you-add-usememo-everywhere"
      },
      {
        "level": 4,
        "text": "The difference between useMemo and calculating a value directly",
        "id": "examples-recalculation"
      },
      {
        "level": 4,
        "text": "Example 1 of 2: Skipping recalculation with useMemo",
        "id": "skipping-recalculation-with-usememo"
      },
      {
        "level": 4,
        "text": "Memoizing individual JSX nodes",
        "id": "memoizing-individual-jsx-nodes"
      },
      {
        "level": 4,
        "text": "The difference between skipping re-renders and always re-rendering",
        "id": "examples-rerendering"
      },
      {
        "level": 4,
        "text": "Example 1 of 2: Skipping re-rendering with useMemo and memo",
        "id": "skipping-re-rendering-with-usememo-and-memo"
      },
      {
        "level": 5,
        "text": "Deep Dive",
        "id": ""
      },
      {
        "level": 5,
        "text": "Deep Dive",
        "id": ""
      },
      {
        "level": 5,
        "text": "Deep Dive",
        "id": ""
      }
    ],
    "codeBlocks": [
      {
        "language": "text",
        "code": "const cachedValue = useMemo(calculateValue, dependencies)"
      },
      {
        "language": "text",
        "code": "const cachedValue = useMemo(calculateValue, dependencies)"
      },
      {
        "language": "text",
        "code": "useMemo(calculateValue, dependencies)"
      },
      {
        "language": "text",
        "code": "useMemo(calculateValue, dependencies)"
      },
      {
        "language": "text",
        "code": "import { useMemo } from 'react';function TodoList({ todos, tab }) {  const visibleTodos = useMemo(    () => filterTodos(todos, tab),    [todos, tab]  );  // ...}"
      },
      {
        "language": "text",
        "code": "import { useMemo } from 'react';function TodoList({ todos, tab }) {  const visibleTodos = useMemo(    () => filterTodos(todos, tab),    [todos, tab]  );  // ...}"
      },
      {
        "language": "text",
        "code": "calculateValue"
      },
      {
        "language": "text",
        "code": "dependencies"
      },
      {
        "language": "text",
        "code": "calculateValue"
      },
      {
        "language": "text",
        "code": "dependencies"
      },
      {
        "language": "text",
        "code": "calculateValue"
      },
      {
        "language": "text",
        "code": "[dep1, dep2, dep3]"
      },
      {
        "language": "text",
        "code": "calculateValue"
      },
      {
        "language": "text",
        "code": "calculateValue"
      },
      {
        "language": "text",
        "code": "calculateValue"
      },
      {
        "language": "text",
        "code": "import { useMemo } from 'react';function TodoList({ todos, tab, theme }) {  const visibleTodos = useMemo(() => filterTodos(todos, tab), [todos, tab]);  // ...}"
      },
      {
        "language": "text",
        "code": "import { useMemo } from 'react';function TodoList({ todos, tab, theme }) {  const visibleTodos = useMemo(() => filterTodos(todos, tab), [todos, tab]);  // ...}"
      },
      {
        "language": "text",
        "code": "filterTodos"
      },
      {
        "language": "text",
        "code": "function TodoList({ todos, tab, theme }) {  const visibleTodos = filterTodos(todos, tab);  // ...}"
      },
      {
        "language": "text",
        "code": "function TodoList({ todos, tab, theme }) {  const visibleTodos = filterTodos(todos, tab);  // ...}"
      },
      {
        "language": "text",
        "code": "visibleTodos"
      },
      {
        "language": "text",
        "code": "console.time('filter array');const visibleTodos = filterTodos(todos, tab);console.timeEnd('filter array');"
      },
      {
        "language": "text",
        "code": "console.time('filter array');const visibleTodos = filterTodos(todos, tab);console.timeEnd('filter array');"
      },
      {
        "language": "text",
        "code": "filter array: 0.15ms"
      },
      {
        "language": "text",
        "code": "console.time('filter array');const visibleTodos = useMemo(() => {  return filterTodos(todos, tab); // Skipped if todos and tab haven't changed}, [todos, tab]);console.timeEnd('filter array');"
      },
      {
        "language": "text",
        "code": "console.time('filter array');const visibleTodos = useMemo(() => {  return filterTodos(todos, tab); // Skipped if todos and tab haven't changed}, [todos, tab]);console.timeEnd('filter array');"
      },
      {
        "language": "text",
        "code": "filterTodos"
      },
      {
        "language": "text",
        "code": "filterTodos"
      },
      {
        "language": "text",
        "code": "filterTodos"
      },
      {
        "language": "text",
        "code": "import { useMemo } from 'react';\nimport { filterTodos } from './utils.js'\n\nexport default function TodoList({ todos, theme, tab }) {\n  const visibleTodos = useMemo(\n    () => filterTodos(todos, tab),\n    [todos, tab]\n  );\n  return (\n    <div className={theme}>\n      <p><b>Note: <code>filterTodos</code> is artificially slowed down!</b></p>\n      <ul>\n        {visibleTodos.map(todo => (\n          <li key={todo.id}>\n            {todo.completed ?\n              <s>{todo.text}</s> :\n              todo.text\n            }\n          </li>\n        ))}\n      </ul>\n    </div>\n  );\n}"
      },
      {
        "language": "text",
        "code": "visibleTodos"
      },
      {
        "language": "text",
        "code": "export default function TodoList({ todos, tab, theme }) {  // ...  return (    <div className={theme}>      <List items={visibleTodos} />    </div>  );}"
      },
      {
        "language": "text",
        "code": "export default function TodoList({ todos, tab, theme }) {  // ...  return (    <div className={theme}>      <List items={visibleTodos} />    </div>  );}"
      },
      {
        "language": "text",
        "code": "import { memo } from 'react';const List = memo(function List({ items }) {  // ...});"
      },
      {
        "language": "text",
        "code": "import { memo } from 'react';const List = memo(function List({ items }) {  // ...});"
      },
      {
        "language": "text",
        "code": "visibleTodos"
      },
      {
        "language": "text",
        "code": "export default function TodoList({ todos, tab, theme }) {  // Every time the theme changes, this will be a different array...  const visibleTodos = filterTodos(todos, tab);  return (    <div className={theme}>      {/* ... so List's props will never be the same, and it will re-render every time */}      <List items={visibleTodos} />    </div>  );}"
      },
      {
        "language": "text",
        "code": "export default function TodoList({ todos, tab, theme }) {  // Every time the theme changes, this will be a different array...  const visibleTodos = filterTodos(todos, tab);  return (    <div className={theme}>      {/* ... so List's props will never be the same, and it will re-render every time */}      <List items={visibleTodos} />    </div>  );}"
      },
      {
        "language": "text",
        "code": "filterTodos"
      },
      {
        "language": "text",
        "code": "export default function TodoList({ todos, tab, theme }) {  // Tell React to cache your calculation between re-renders...  const visibleTodos = useMemo(    () => filterTodos(todos, tab),    [todos, tab] // ...so as long as these dependencies don't change...  );  return (    <div className={theme}>      {/* ...List will receive the same props and can skip re-rendering */}      <List items={visibleTodos} />    </div>  );}"
      },
      {
        "language": "text",
        "code": "export default function TodoList({ todos, tab, theme }) {  // Tell React to cache your calculation between re-renders...  const visibleTodos = useMemo(    () => filterTodos(todos, tab),    [todos, tab] // ...so as long as these dependencies don't change...  );  return (    <div className={theme}>      {/* ...List will receive the same props and can skip re-rendering */}      <List items={visibleTodos} />    </div>  );}"
      },
      {
        "language": "text",
        "code": "visibleTodos"
      },
      {
        "language": "text",
        "code": "export default function TodoList({ todos, tab, theme }) {  const visibleTodos = useMemo(() => filterTodos(todos, tab), [todos, tab]);  const children = useMemo(() => <List items={visibleTodos} />, [visibleTodos]);  return (    <div className={theme}>      {children}    </div>  );}"
      },
      {
        "language": "text",
        "code": "export default function TodoList({ todos, tab, theme }) {  const visibleTodos = useMemo(() => filterTodos(todos, tab), [todos, tab]);  const children = useMemo(() => <List items={visibleTodos} />, [visibleTodos]);  return (    <div className={theme}>      {children}    </div>  );}"
      },
      {
        "language": "text",
        "code": "visibleTodos"
      },
      {
        "language": "text",
        "code": "<List items={visibleTodos} />"
      },
      {
        "language": "text",
        "code": "{ type: List, props: { items: visibleTodos } }"
      },
      {
        "language": "text",
        "code": "visibleTodos"
      },
      {
        "language": "text",
        "code": "visibleTodos"
      },
      {
        "language": "text",
        "code": "import { useMemo } from 'react';\nimport List from './List.js';\nimport { filterTodos } from './utils.js'\n\nexport default function TodoList({ todos, theme, tab }) {\n  const visibleTodos = useMemo(\n    () => filterTodos(todos, tab),\n    [todos, tab]\n  );\n  return (\n    <div className={theme}>\n      <p><b>Note: <code>List</code> is artificially slowed down!</b></p>\n      <List items={visibleTodos} />\n    </div>\n  );\n}"
      },
      {
        "language": "text",
        "code": "function ChatRoom({ roomId }) {  const [message, setMessage] = useState('');  const options = {    serverUrl: 'https://localhost:1234',    roomId: roomId  }  useEffect(() => {    const connection = createConnection(options);    connection.connect();    // ..."
      },
      {
        "language": "text",
        "code": "function ChatRoom({ roomId }) {  const [message, setMessage] = useState('');  const options = {    serverUrl: 'https://localhost:1234',    roomId: roomId  }  useEffect(() => {    const connection = createConnection(options);    connection.connect();    // ..."
      },
      {
        "language": "text",
        "code": "useEffect(() => {    const connection = createConnection(options);    connection.connect();    return () => connection.disconnect();  }, [options]); // 🔴 Problem: This dependency changes on every render  // ..."
      },
      {
        "language": "text",
        "code": "useEffect(() => {    const connection = createConnection(options);    connection.connect();    return () => connection.disconnect();  }, [options]); // 🔴 Problem: This dependency changes on every render  // ..."
      },
      {
        "language": "text",
        "code": "function ChatRoom({ roomId }) {  const [message, setMessage] = useState('');  const options = useMemo(() => {    return {      serverUrl: 'https://localhost:1234',      roomId: roomId    };  }, [roomId]); // ✅ Only changes when roomId changes  useEffect(() => {    const connection = createConnection(options);    connection.connect();    return () => connection.disconnect();  }, [options]); // ✅ Only changes when options changes  // ..."
      },
      {
        "language": "text",
        "code": "function ChatRoom({ roomId }) {  const [message, setMessage] = useState('');  const options = useMemo(() => {    return {      serverUrl: 'https://localhost:1234',      roomId: roomId    };  }, [roomId]); // ✅ Only changes when roomId changes  useEffect(() => {    const connection = createConnection(options);    connection.connect();    return () => connection.disconnect();  }, [options]); // ✅ Only changes when options changes  // ..."
      },
      {
        "language": "text",
        "code": "function ChatRoom({ roomId }) {  const [message, setMessage] = useState('');  useEffect(() => {    const options = { // ✅ No need for useMemo or object dependencies!      serverUrl: 'https://localhost:1234',      roomId: roomId    }        const connection = createConnection(options);    connection.connect();    return () => connection.disconnect();  }, [roomId]); // ✅ Only changes when roomId changes  // ..."
      },
      {
        "language": "text",
        "code": "function ChatRoom({ roomId }) {  const [message, setMessage] = useState('');  useEffect(() => {    const options = { // ✅ No need for useMemo or object dependencies!      serverUrl: 'https://localhost:1234',      roomId: roomId    }        const connection = createConnection(options);    connection.connect();    return () => connection.disconnect();  }, [roomId]); // ✅ Only changes when roomId changes  // ..."
      },
      {
        "language": "text",
        "code": "function Dropdown({ allItems, text }) {  const searchOptions = { matchMode: 'whole-word', text };  const visibleItems = useMemo(() => {    return searchItems(allItems, searchOptions);  }, [allItems, searchOptions]); // 🚩 Caution: Dependency on an object created in the component body  // ..."
      },
      {
        "language": "text",
        "code": "function Dropdown({ allItems, text }) {  const searchOptions = { matchMode: 'whole-word', text };  const visibleItems = useMemo(() => {    return searchItems(allItems, searchOptions);  }, [allItems, searchOptions]); // 🚩 Caution: Dependency on an object created in the component body  // ..."
      },
      {
        "language": "text",
        "code": "searchOptions"
      },
      {
        "language": "text",
        "code": "searchOptions"
      },
      {
        "language": "text",
        "code": "searchItems"
      },
      {
        "language": "text",
        "code": "searchOptions"
      },
      {
        "language": "text",
        "code": "function Dropdown({ allItems, text }) {  const searchOptions = useMemo(() => {    return { matchMode: 'whole-word', text };  }, [text]); // ✅ Only changes when text changes  const visibleItems = useMemo(() => {    return searchItems(allItems, searchOptions);  }, [allItems, searchOptions]); // ✅ Only changes when allItems or searchOptions changes  // ..."
      },
      {
        "language": "text",
        "code": "function Dropdown({ allItems, text }) {  const searchOptions = useMemo(() => {    return { matchMode: 'whole-word', text };  }, [text]); // ✅ Only changes when text changes  const visibleItems = useMemo(() => {    return searchItems(allItems, searchOptions);  }, [allItems, searchOptions]); // ✅ Only changes when allItems or searchOptions changes  // ..."
      },
      {
        "language": "text",
        "code": "searchOptions"
      },
      {
        "language": "text",
        "code": "searchOptions"
      },
      {
        "language": "text",
        "code": "function Dropdown({ allItems, text }) {  const visibleItems = useMemo(() => {    const searchOptions = { matchMode: 'whole-word', text };    return searchItems(allItems, searchOptions);  }, [allItems, text]); // ✅ Only changes when allItems or text changes  // ..."
      },
      {
        "language": "text",
        "code": "function Dropdown({ allItems, text }) {  const visibleItems = useMemo(() => {    const searchOptions = { matchMode: 'whole-word', text };    return searchItems(allItems, searchOptions);  }, [allItems, text]); // ✅ Only changes when allItems or text changes  // ..."
      },
      {
        "language": "text",
        "code": "export default function ProductPage({ productId, referrer }) {  function handleSubmit(orderDetails) {    post('/product/' + productId + '/buy', {      referrer,      orderDetails    });  }  return <Form onSubmit={handleSubmit} />;}"
      },
      {
        "language": "text",
        "code": "export default function ProductPage({ productId, referrer }) {  function handleSubmit(orderDetails) {    post('/product/' + productId + '/buy', {      referrer,      orderDetails    });  }  return <Form onSubmit={handleSubmit} />;}"
      },
      {
        "language": "text",
        "code": "function() {}"
      },
      {
        "language": "text",
        "code": "export default function Page({ productId, referrer }) {  const handleSubmit = useMemo(() => {    return (orderDetails) => {      post('/product/' + productId + '/buy', {        referrer,        orderDetails      });    };  }, [productId, referrer]);  return <Form onSubmit={handleSubmit} />;}"
      },
      {
        "language": "text",
        "code": "export default function Page({ productId, referrer }) {  const handleSubmit = useMemo(() => {    return (orderDetails) => {      post('/product/' + productId + '/buy', {        referrer,        orderDetails      });    };  }, [productId, referrer]);  return <Form onSubmit={handleSubmit} />;}"
      },
      {
        "language": "text",
        "code": "useCallback"
      },
      {
        "language": "text",
        "code": "export default function Page({ productId, referrer }) {  const handleSubmit = useCallback((orderDetails) => {    post('/product/' + productId + '/buy', {      referrer,      orderDetails    });  }, [productId, referrer]);  return <Form onSubmit={handleSubmit} />;}"
      },
      {
        "language": "text",
        "code": "export default function Page({ productId, referrer }) {  const handleSubmit = useCallback((orderDetails) => {    post('/product/' + productId + '/buy', {      referrer,      orderDetails    });  }, [productId, referrer]);  return <Form onSubmit={handleSubmit} />;}"
      },
      {
        "language": "text",
        "code": "useCallback"
      },
      {
        "language": "text",
        "code": "useCallback"
      },
      {
        "language": "text",
        "code": "function TodoList({ todos, tab }) {  // This component function will run twice for every render.  const visibleTodos = useMemo(() => {    // This calculation will run twice if any of the dependencies change.    return filterTodos(todos, tab);  }, [todos, tab]);  // ..."
      },
      {
        "language": "text",
        "code": "function TodoList({ todos, tab }) {  // This component function will run twice for every render.  const visibleTodos = useMemo(() => {    // This calculation will run twice if any of the dependencies change.    return filterTodos(todos, tab);  }, [todos, tab]);  // ..."
      },
      {
        "language": "text",
        "code": "const visibleTodos = useMemo(() => {    // 🚩 Mistake: mutating a prop    todos.push({ id: 'last', text: 'Go for a walk!' });    const filtered = filterTodos(todos, tab);    return filtered;  }, [todos, tab]);"
      },
      {
        "language": "text",
        "code": "const visibleTodos = useMemo(() => {    // 🚩 Mistake: mutating a prop    todos.push({ id: 'last', text: 'Go for a walk!' });    const filtered = filterTodos(todos, tab);    return filtered;  }, [todos, tab]);"
      },
      {
        "language": "text",
        "code": "filterTodos"
      },
      {
        "language": "text",
        "code": "const visibleTodos = useMemo(() => {    const filtered = filterTodos(todos, tab);    // ✅ Correct: mutating an object you created during the calculation    filtered.push({ id: 'last', text: 'Go for a walk!' });    return filtered;  }, [todos, tab]);"
      },
      {
        "language": "text",
        "code": "const visibleTodos = useMemo(() => {    const filtered = filterTodos(todos, tab);    // ✅ Correct: mutating an object you created during the calculation    filtered.push({ id: 'last', text: 'Go for a walk!' });    return filtered;  }, [todos, tab]);"
      },
      {
        "language": "text",
        "code": "// 🔴 You can't return an object from an arrow function with () => {  const searchOptions = useMemo(() => {    matchMode: 'whole-word',    text: text  }, [text]);"
      },
      {
        "language": "text",
        "code": "// 🔴 You can't return an object from an arrow function with () => {  const searchOptions = useMemo(() => {    matchMode: 'whole-word',    text: text  }, [text]);"
      },
      {
        "language": "text",
        "code": "// This works, but is easy for someone to break again  const searchOptions = useMemo(() => ({    matchMode: 'whole-word',    text: text  }), [text]);"
      },
      {
        "language": "text",
        "code": "// This works, but is easy for someone to break again  const searchOptions = useMemo(() => ({    matchMode: 'whole-word',    text: text  }), [text]);"
      },
      {
        "language": "text",
        "code": "// ✅ This works and is explicit  const searchOptions = useMemo(() => {    return {      matchMode: 'whole-word',      text: text    };  }, [text]);"
      },
      {
        "language": "text",
        "code": "// ✅ This works and is explicit  const searchOptions = useMemo(() => {    return {      matchMode: 'whole-word',      text: text    };  }, [text]);"
      },
      {
        "language": "text",
        "code": "function TodoList({ todos, tab }) {  // 🔴 Recalculates every time: no dependency array  const visibleTodos = useMemo(() => filterTodos(todos, tab));  // ..."
      },
      {
        "language": "text",
        "code": "function TodoList({ todos, tab }) {  // 🔴 Recalculates every time: no dependency array  const visibleTodos = useMemo(() => filterTodos(todos, tab));  // ..."
      },
      {
        "language": "text",
        "code": "function TodoList({ todos, tab }) {  // ✅ Does not recalculate unnecessarily  const visibleTodos = useMemo(() => filterTodos(todos, tab), [todos, tab]);  // ..."
      },
      {
        "language": "text",
        "code": "function TodoList({ todos, tab }) {  // ✅ Does not recalculate unnecessarily  const visibleTodos = useMemo(() => filterTodos(todos, tab), [todos, tab]);  // ..."
      },
      {
        "language": "text",
        "code": "const visibleTodos = useMemo(() => filterTodos(todos, tab), [todos, tab]);  console.log([todos, tab]);"
      },
      {
        "language": "text",
        "code": "const visibleTodos = useMemo(() => filterTodos(todos, tab), [todos, tab]);  console.log([todos, tab]);"
      },
      {
        "language": "text",
        "code": "Object.is(temp1[0], temp2[0]); // Is the first dependency the same between the arrays?Object.is(temp1[1], temp2[1]); // Is the second dependency the same between the arrays?Object.is(temp1[2], temp2[2]); // ... and so on for every dependency ..."
      },
      {
        "language": "text",
        "code": "Object.is(temp1[0], temp2[0]); // Is the first dependency the same between the arrays?Object.is(temp1[1], temp2[1]); // Is the second dependency the same between the arrays?Object.is(temp1[2], temp2[2]); // ... and so on for every dependency ..."
      },
      {
        "language": "text",
        "code": "function ReportList({ items }) {  return (    <article>      {items.map(item => {        // 🔴 You can't call useMemo in a loop like this:        const data = useMemo(() => calculateReport(item), [item]);        return (          <figure key={item.id}>            <Chart data={data} />          </figure>        );      })}    </article>  );}"
      },
      {
        "language": "text",
        "code": "function ReportList({ items }) {  return (    <article>      {items.map(item => {        // 🔴 You can't call useMemo in a loop like this:        const data = useMemo(() => calculateReport(item), [item]);        return (          <figure key={item.id}>            <Chart data={data} />          </figure>        );      })}    </article>  );}"
      },
      {
        "language": "text",
        "code": "function ReportList({ items }) {  return (    <article>      {items.map(item =>        <Report key={item.id} item={item} />      )}    </article>  );}function Report({ item }) {  // ✅ Call useMemo at the top level:  const data = useMemo(() => calculateReport(item), [item]);  return (    <figure>      <Chart data={data} />    </figure>  );}"
      },
      {
        "language": "text",
        "code": "function ReportList({ items }) {  return (    <article>      {items.map(item =>        <Report key={item.id} item={item} />      )}    </article>  );}function Report({ item }) {  // ✅ Call useMemo at the top level:  const data = useMemo(() => calculateReport(item), [item]);  return (    <figure>      <Chart data={data} />    </figure>  );}"
      },
      {
        "language": "text",
        "code": "function ReportList({ items }) {  // ...}const Report = memo(function Report({ item }) {  const data = calculateReport(item);  return (    <figure>      <Chart data={data} />    </figure>  );});"
      },
      {
        "language": "text",
        "code": "function ReportList({ items }) {  // ...}const Report = memo(function Report({ item }) {  const data = calculateReport(item);  return (    <figure>      <Chart data={data} />    </figure>  );});"
      }
    ],
    "links": [
      {
        "text": "API Reference",
        "href": "/reference/react"
      },
      {
        "text": "Hooks",
        "href": "/reference/react/hooks"
      },
      {
        "text": "React Compiler",
        "href": "/learn/react-compiler"
      },
      {
        "text": "configured for React",
        "href": "/learn/editor-setup#linting"
      },
      {
        "text": "Object.is",
        "href": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/is"
      },
      {
        "text": "state variable",
        "href": "/reference/react/useState#avoiding-recreating-the-initial-state"
      },
      {
        "text": "ref",
        "href": "/reference/react/useRef#avoiding-recreating-the-ref-contents"
      },
      {
        "text": "memoization,",
        "href": "https://en.wikipedia.org/wiki/Memoization"
      },
      {
        "text": "Object.is",
        "href": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/is"
      },
      {
        "text": "memoization.",
        "href": "https://en.wikipedia.org/wiki/Memoization"
      },
      {
        "text": "CPU Throttling",
        "href": "https://developer.chrome.com/blog/new-in-devtools-61/#throttling"
      },
      {
        "text": "Strict Mode",
        "href": "/reference/react/StrictMode"
      },
      {
        "text": "memo.",
        "href": "/reference/react/memo"
      },
      {
        "text": "useEffect.",
        "href": "/reference/react/useEffect"
      },
      {
        "text": "accept JSX as children.",
        "href": "/learn/passing-props-to-a-component#passing-jsx-as-children"
      },
      {
        "text": "lift state up",
        "href": "/learn/sharing-state-between-components"
      },
      {
        "text": "rendering logic pure.",
        "href": "/learn/keeping-components-pure"
      },
      {
        "text": "unnecessary Effects that update state.",
        "href": "/learn/you-might-not-need-an-effect"
      },
      {
        "text": "remove unnecessary dependencies from your Effects.",
        "href": "/learn/removing-effect-dependencies"
      },
      {
        "text": "use the React Developer Tools profiler",
        "href": "https://legacy.reactjs.org/blog/2018/09/10/introducing-the-react-profiler.html"
      },
      {
        "text": "doing granular memoization automatically",
        "href": "https://www.youtube.com/watch?v=lGEMwh32soc"
      },
      {
        "text": "Fork",
        "href": "https://codesandbox.io/api/v1/sandboxes/define?undefined&environment=create-react-app"
      },
      {
        "text": "memo:",
        "href": "/reference/react/memo"
      },
      {
        "text": "memo",
        "href": "/reference/react/memo"
      },
      {
        "text": "memo,",
        "href": "/reference/react/memo"
      },
      {
        "text": "memo",
        "href": "/reference/react/memo"
      },
      {
        "text": "immutable.",
        "href": "https://en.wikipedia.org/wiki/Immutable_object"
      },
      {
        "text": "memo",
        "href": "/reference/react/memo"
      },
      {
        "text": "memo",
        "href": "/reference/react/memo"
      },
      {
        "text": "Fork",
        "href": "https://codesandbox.io/api/v1/sandboxes/define?undefined&environment=create-react-app"
      },
      {
        "text": "Effect:",
        "href": "/learn/synchronizing-with-effects"
      },
      {
        "text": "Every reactive value must be declared as a dependency of your Effect.",
        "href": "/learn/lifecycle-of-reactive-effects#react-verifies-that-you-specified-every-reactive-value-as-a-dependency"
      },
      {
        "text": "Learn more about removing Effect dependencies.",
        "href": "/learn/removing-effect-dependencies#move-dynamic-objects-and-functions-inside-your-effect"
      },
      {
        "text": "memo.",
        "href": "/reference/react/memo"
      },
      {
        "text": "useCallback",
        "href": "/reference/react/useCallback"
      },
      {
        "text": "Read more about useCallback.",
        "href": "/reference/react/useCallback"
      },
      {
        "text": "Strict Mode",
        "href": "/reference/react/StrictMode"
      },
      {
        "text": "keep components pure.",
        "href": "/learn/keeping-components-pure"
      },
      {
        "text": "keeping components pure",
        "href": "/learn/keeping-components-pure"
      },
      {
        "text": "updating objects",
        "href": "/learn/updating-objects-in-state"
      },
      {
        "text": "updating arrays",
        "href": "/learn/updating-arrays-in-state"
      },
      {
        "text": "memo",
        "href": "/reference/react/memo"
      },
      {
        "text": "memo.",
        "href": "/reference/react/memo"
      },
      {
        "text": "PrevioususeLayoutEffect",
        "href": "/reference/react/useLayoutEffect"
      },
      {
        "text": "NextuseOptimistic",
        "href": "/reference/react/useOptimistic"
      }
    ],
    "meta": {
      "description": "",
      "keywords": ""
    },
    "summary": "API ReferenceHooksuseMemouseMemo is a React Hook that lets you cache the result of a calculation between re-renders",
    "tags": [
      "react",
      "vue",
      "angular",
      "javascript",
      "typescript",
      "html",
      "node",
      "vite",
      "usememo",
      "skipping"
    ],
    "id": "usememo-react-useMemo-part-1",
    "quality": 100
  },
  {
    "title": "useCallback – React",
    "url": "https://react.dev/reference/react/useCallback",
    "category": "react",
    "content": "API ReferenceHooksuseCallbackuseCallback is a React Hook that lets you cache a function definition between re-renders.const cachedFn = useCallback(fn, dependencies) NoteReact Compiler automatically memoizes values and functions, reducing the need for manual useCallback calls. You can use the compiler to handle memoization automatically. Reference useCallback(fn, dependencies) Usage Skipping re-rendering of components Updating state from a memoized callback Preventing an Effect from firing too often Optimizing a custom Hook Troubleshooting Every time my component renders, useCallback returns a different function I need to call useCallback for each list item in a loop, but its not allowed Reference useCallback(fn, dependencies) Call useCallback at the top level of your component to cache a function definition between re-renders: import { useCallback } from 'react';export default function ProductPage({ productId, referrer, theme }) { const handleSubmit = useCallback((orderDetails) = { post('/product/' + productId + '/buy', { referrer, orderDetails, }); }, [productId, referrer]); See more examples below. Parameters fn: The function value that you want to cache. It can take any arguments and return any values. React will return (not call!) your function back to you during the initial render. On next renders, React will give you the same function again if the dependencies have not changed since the last render. Otherwise, it will give you the function that you have passed during the current render, and store it in case it can be reused later. React will not call your function. The function is returned to you so you can decide when and whether to call it. dependencies: The list of all reactive values referenced inside of the fn code. Reactive values include props, state, and all the variables and functions declared directly inside your component body. If your linter is configured for React, it will verify that every reactive value is correctly specified as a dependency. The list of dependencies must have a constant number of items and be written inline like [dep1, dep2, dep3]. React will compare each dependency with its previous value using the Object.is comparison algorithm. Returns On the initial render, useCallback returns the fn function you have passed. During subsequent renders, it will either return an already stored fn function from the last render (if the dependencies havent changed), or return the fn function you have passed during this render. Caveats useCallback is a Hook, so you can only call it at the top level of your component or your own Hooks. You cant call it inside loops or conditions. If you need that, extract a new component and move the state into it. React will not throw away the cached function unless there is a specific reason to do that. For example, in development, React throws away the cache when you edit the file of your component. Both in development and in production, React will throw away the cache if your component suspends during the initial mount. In the future, React may add more features that take advantage of throwing away the cachefor example, if React adds built-in support for virtualized lists in the future, it would make sense to throw away the cache for items that scroll out of the virtualized table viewport. This should match your expectations if you rely on useCallback as a performance optimization. Otherwise, a state variable or a ref may be more appropriate. Usage Skipping re-rendering of components When you optimize rendering performance, you will sometimes need to cache the functions that you pass to child components. Lets first look at the syntax for how to do this, and then see in which cases its useful. To cache a function between re-renders of your component, wrap its definition into the useCallback Hook: import { useCallback } from 'react';function ProductPage({ productId, referrer, theme }) { const handleSubmit = useCallback((orderDetails) = { post('/product/' + productId + '/buy', { referrer, orderDetails, }); }, [productId, referrer]); // ... You need to pass two things to useCallback: A function definition that you want to cache between re-renders. A list of dependencies including every value within your component thats used inside your function. On the initial render, the returned function youll get from useCallback will be the function you passed. On the following renders, React will compare the dependencies with the dependencies you passed during the previous render. If none of the dependencies have changed (compared with Object.is), useCallback will return the same function as before. Otherwise, useCallback will return the function you passed on this render. In other words, useCallback caches a function between re-renders until its dependencies change. Lets walk through an example to see when this is useful. Say youre passing a handleSubmit function down from the ProductPage to the ShippingForm component: function ProductPage({ productId, referrer, theme }) { // ... return ( div className={theme} ShippingForm onSubmit={handleSubmit} / /div ); Youve noticed that toggling the theme prop freezes the app for a moment, but if you remove ShippingForm / from your JSX, it feels fast. This tells you that its worth trying to optimize the ShippingForm component. By default, when a component re-renders, React re-renders all of its children recursively. This is why, when ProductPage re-renders with a different theme, the ShippingForm component also re-renders. This is fine for components that dont require much calculation to re-render. But if you verified a re-render is slow, you can tell ShippingForm to skip re-rendering when its props are the same as on last render by wrapping it in memo: import { memo } from 'react';const ShippingForm = memo(function ShippingForm({ onSubmit }) { // ...}); With this change, ShippingForm will skip re-rendering if all of its props are the same as on the last render. This is when caching a function becomes important! Lets say you defined handleSubmit without useCallback: function ProductPage({ productId, referrer, theme }) { // Every time the theme changes, this will be a different function... function handleSubmit(orderDetails) { post('/product/' + productId + '/buy', { referrer, orderDetails, }); } return ( div className={theme} {/* ... so ShippingForm's props will never be the same, and it will re-render every time */} ShippingForm onSubmit={handleSubmit} / /div );} In JavaScript, a function () {} or () = {} always creates a different function, similar to how the {} object literal always creates a new object. Normally, this wouldnt be a problem, but it means that ShippingForm props will never be the same, and your memo optimization wont work. This is where useCallback comes in handy: function ProductPage({ productId, referrer, theme }) { // Tell React to cache your function between re-renders... const handleSubmit = useCallback((orderDetails) = { post('/product/' + productId + '/buy', { referrer, orderDetails, }); }, [productId, referrer]); // ...so as long as these dependencies don't change... return ( div className={theme} {/* ...ShippingForm will receive the same props and can skip re-rendering */} ShippingForm onSubmit={handleSubmit} / /div );} By wrapping handleSubmit in useCallback, you ensure that its the same function between the re-renders (until dependencies change). You dont have to wrap a function in useCallback unless you do it for some specific reason. In this example, the reason is that you pass it to a component wrapped in memo, and this lets it skip re-rendering. There are other reasons you might need useCallback which are described further on this page. NoteYou should only rely on useCallback as a performance optimization. If your code doesnt work without it, find the underlying problem and fix it first. Then you may add useCallback back. Deep DiveHow is useCallback related to useMemo? Show DetailsYou will often see useMemo alongside useCallback. They are both useful when youre trying to optimize a child component. They let you memoize (or, in other words, cache) something youre passing down:import { useMemo, useCallback } from 'react';function ProductPage({ productId, referrer }) { const product = useData('/product/' + productId); const requirements = useMemo(() = { // Calls your function and caches its result return computeRequirements(product); }, [product]); const handleSubmit = useCallback((orderDetails) = { // Caches your function itself post('/product/' + productId + '/buy', { referrer, orderDetails, }); }, [productId, referrer]); return ( div className={theme} ShippingForm requirements={requirements} onSubmit={handleSubmit} / /div );}The difference is in what theyre letting you cache: useMemo caches the result of calling your function. In this example, it caches the result of calling computeRequirements(product) so that it doesnt change unless product has changed. This lets you pass the requirements object down without unnecessarily re-rendering ShippingForm. When necessary, React will call the function youve passed during rendering to calculate the result. useCallback caches the function itself. Unlike useMemo, it does not call the function you provide. Instead, it caches the function you provided so that handleSubmit itself doesnt change unless productId or referrer has changed. This lets you pass the handleSubmit function down without unnecessarily re-rendering ShippingForm. Your code wont run until the user submits the form. If youre already familiar with useMemo, you might find it helpful to think of useCallback as this:// Simplified implementation (inside React)function useCallback(fn, dependencies) { return useMemo(() = fn, dependencies);}Read more about the difference between useMemo and useCallback. Deep DiveShould you add useCallback everywhere? Show DetailsIf your app is like this site, and most interactions are coarse (like replacing a page or an entire section), memoization is usually unnecessary. On the other hand, if your app is more like a drawing editor, and most interactions are granular (like moving shapes), then you might find memoization very helpful.Caching a function with useCallback is only valuable in a few cases: You pass it as a prop to a component wrapped in memo. You want to skip re-rendering if the value hasnt changed. Memoization lets your component re-render only if dependencies changed. The function youre passing is later used as a dependency of some Hook. For example, another function wrapped in useCallback depends on it, or you depend on this function from useEffect. There is no benefit to wrapping a function in useCallback in other cases. There is no significant harm to doing that either, so some teams choose to not think about individual cases, and memoize as much as possible. The downside is that code becomes less readable. Also, not all memoization is effective: a single value thats always new is enough to break memoization for an entire component.Note that useCallback does not prevent creating the function. Youre always creating a function (and thats fine!), but React ignores it and gives you back a cached function if nothing changed.In practice, you can make a lot of memoization unnecessary by following a few principles: When a component visually wraps other components, let it accept JSX as children. Then, if the wrapper component updates its own state, React knows that its children dont need to re-render. Prefer local state and dont lift state up any further than necessary. Dont keep transient state like forms and whether an item is hovered at the top of your tree or in a global state library. Keep your rendering logic pure. If re-rendering a component causes a problem or produces some noticeable visual artifact, its a bug in your component! Fix the bug instead of adding memoization. Avoid unnecessary Effects that update state. Most performance problems in React apps are caused by chains of updates originating from Effects that cause your components to render over and over. Try to remove unnecessary dependencies from your Effects. For example, instead of memoization, its often simpler to move some object or a function inside an Effect or outside the component. If a specific interaction still feels laggy, use the React Developer Tools profiler to see which components benefit the most from memoization, and add memoization where needed. These principles make your components easier to debug and understand, so its good to follow them in any case. In long term, were researching doing memoization automatically to solve this once and for all. The difference between useCallback and declaring a function directly1. Skipping re-rendering with useCallback and memo 2. Always re-rendering a component Example 1 of 2: Skipping re-rendering with useCallback and memo In this example, the ShippingForm component is artificially slowed down so that you can see what happens when a React component youre rendering is genuinely slow. Try incrementing the counter and toggling the theme.Incrementing the counter feels slow because it forces the slowed down ShippingForm to re-render. Thats expected because the counter has changed, and so you need to reflect the users new choice on the screen.Next, try toggling the theme. Thanks to useCallback together with memo, its fast despite the artificial slowdown! ShippingForm skipped re-rendering because the handleSubmit function has not changed. The handleSubmit function has not changed because both productId and referrer (your useCallback dependencies) havent changed since last render.App.jsProductPage.jsShippingForm.jsProductPage.js ResetForkimport { useCallback } from 'react'; import ShippingForm from './ShippingForm.js'; export default function ProductPage({ productId, referrer, theme }) { const handleSubmit = useCallback((orderDetails) = { post('/product/' + productId + '/buy', { referrer, orderDetails, }); }, [productId, referrer]); return ( div className={theme} ShippingForm onSubmit={handleSubmit} / /div ); } function post(url, data) { // Imagine this sends a request... console.log('POST /' + url); console.log(data); } Show moreNext Example Updating state from a memoized callback Sometimes, you might need to update state based on previous state from a memoized callback. This handleAddTodo function specifies todos as a dependency because it computes the next todos from it: function TodoList() { const [todos, setTodos] = useState([]); const handleAddTodo = useCallback((text) = { const newTodo = { id: nextId++, text }; setTodos([...todos, newTodo]); }, [todos]); // ... Youll usually want memoized functions to have as few dependencies as possible. When you read some state only to calculate the next state, you can remove that dependency by passing an updater function instead: function TodoList() { const [todos, setTodos] = useState([]); const handleAddTodo = useCallback((text) = { const newTodo = { id: nextId++, text }; setTodos(todos = [...todos, newTodo]); }, []); //  No need for the todos dependency // ... Here, instead of making todos a dependency and reading it inside, you pass an instruction about how to update the state (todos = [...todos, newTodo]) to React. Read more about updater functions. Preventing an Effect from firing too often Sometimes, you might want to call a function from inside an Effect: function ChatRoom({ roomId }) { const [message, setMessage] = useState(''); function createOptions() { return { serverUrl: 'https://localhost:1234', roomId: roomId }; } useEffect(() = { const options = createOptions(); const connection = createConnection(options); connection.connect(); // ... This creates a problem. Every reactive value must be declared as a dependency of your Effect. However, if you declare createOptions as a dependency, it will cause your Effect to constantly reconnect to the chat room: useEffect(() = { const options = createOptions(); const connection = createConnection(options); connection.connect(); return () = connection.disconnect(); }, [createOptions]); //  Problem: This dependency changes on every render // ... To solve this, you can wrap the function you need to call from an Effect into useCallback: function ChatRoom({ roomId }) { const [message, setMessage] = useState(''); const createOptions = useCallback(() = { return { serverUrl: 'https://localhost:1234', roomId: roomId }; }, [roomId]); //  Only changes when roomId changes useEffect(() = { const options = createOptions(); const connection = createConnection(options); connection.connect(); return () = connection.disconnect(); }, [createOptions]); //  Only changes when createOptions changes // ... This ensures that the createOptions function is the same between re-renders if the roomId is the same. However, its even better to remove the need for a function dependency. Move your function inside the Effect: function ChatRoom({ roomId }) { const [message, setMessage] = useState(''); useEffect(() = { function createOptions() { //  No need for useCallback or function dependencies! return { serverUrl: 'https://localhost:1234', roomId: roomId }; } const options = createOptions(); const connection = createConnection(options); connection.connect(); return () = connection.disconnect(); }, [roomId]); //  Only changes when roomId changes // ... Now your code is simpler and doesnt need useCallback. Learn more about removing Effect dependencies. Optimizing a custom Hook If youre writing a custom Hook, its recommended to wrap any functions that it returns into useCallback: function useRouter() { const { dispatch } = useContext(RouterStateContext); const navigate = useCallback((url) = { dispatch({ type: 'navigate', url }); }, [dispatch]); const goBack = useCallback(() = { dispatch({ type: 'back' }); }, [dispatch]); return { navigate, goBack, };} This ensures that the consumers of your Hook can optimize their own code when needed. Troubleshooting Every time my component renders, useCallback returns a different function Make sure youve specified the dependency array as a second argument! If you forget the dependency array, useCallback will return a new function every time: function ProductPage({ productId, referrer }) { const handleSubmit = useCallback((orderDetails) = { post('/product/' + productId + '/buy', { referrer, orderDetails, }); }); //  Returns a new function every time: no dependency array // ... This is the corrected version passing the dependency array as a second argument: function ProductPage({ productId, referrer }) { const handleSubmit = useCallback((orderDetails) = { post('/product/' + productId + '/buy', { referrer, orderDetails, }); }, [productId, referrer]); //  Does not return a new function unnecessarily // ... If this doesnt help, then the problem is that at least one of your dependencies is different from the previous render. You can debug this problem by manually logging your dependencies to the console: const handleSubmit = useCallback((orderDetails) = { // .. }, [productId, referrer]); console.log([productId, referrer]); You can then right-click on the arrays from different re-renders in the console and select Store as a global variable for both of them. Assuming the first one got saved as temp1 and the second one got saved as temp2, you can then use the browser console to check whether each dependency in both arrays is the same: Object.is(temp1[0], temp2[0]); // Is the first dependency the same between the arrays?Object.is(temp1[1], temp2[1]); // Is the second dependency the same between the arrays?Object.is(temp1[2], temp2[2]); // ... and so on for every dependency ... When you find which dependency is breaking memoization, either find a way to remove it, or memoize it as well. I need to call useCallback for each list item in a loop, but its not allowed Suppose the Chart component is wrapped in memo. You want to skip re-rendering every Chart in the list when the ReportList component re-renders. However, you cant call useCallback in a loop: function ReportList({ items }) { return ( article {items.map(item = { //  You can't call useCallback in a loop like this: const handleClick = useCallback(() = { sendReport(item) }, [item]); return ( figure key={item.id} Chart onClick={handleClick} / /figure ); })} /article );} Instead, extract a component for an individual item, and put useCallback there: function ReportList({ items }) { return ( article {items.map(item = Report key={item.id} item={item} / )} /article );}function Report({ item }) { //  Call useCallback at the top level: const handleClick = useCallback(() = { sendReport(item) }, [item]); return ( figure Chart onClick={handleClick} / /figure );} Alternatively, you could remove useCallback in the last snippet and instead wrap Report itself in memo. If the item prop does not change, Report will skip re-rendering, so Chart will skip re-rendering too: function ReportList({ items }) { // ...}const Report = memo(function Report({ item }) { function handleClick() { sendReport(item); } return ( figure Chart onClick={handleClick} / /figure );});PrevioususeActionStateNextuseContext",
    "headings": [
      {
        "level": 1,
        "text": "useCallback",
        "id": ""
      },
      {
        "level": 2,
        "text": "Reference",
        "id": "reference"
      },
      {
        "level": 2,
        "text": "Usage",
        "id": "usage"
      },
      {
        "level": 2,
        "text": "Troubleshooting",
        "id": "troubleshooting"
      },
      {
        "level": 3,
        "text": "Note",
        "id": ""
      },
      {
        "level": 3,
        "text": "useCallback(fn, dependencies)",
        "id": "usecallback"
      },
      {
        "level": 3,
        "text": "Skipping re-rendering of components",
        "id": "skipping-re-rendering-of-components"
      },
      {
        "level": 3,
        "text": "Note",
        "id": ""
      },
      {
        "level": 3,
        "text": "Updating state from a memoized callback",
        "id": "updating-state-from-a-memoized-callback"
      },
      {
        "level": 3,
        "text": "Preventing an Effect from firing too often",
        "id": "preventing-an-effect-from-firing-too-often"
      },
      {
        "level": 3,
        "text": "Optimizing a custom Hook",
        "id": "optimizing-a-custom-hook"
      },
      {
        "level": 3,
        "text": "Every time my component renders, useCallback returns a different function",
        "id": "every-time-my-component-renders-usecallback-returns-a-different-function"
      },
      {
        "level": 3,
        "text": "I need to call useCallback for each list item in a loop, but it’s not allowed",
        "id": "i-need-to-call-usememo-for-each-list-item-in-a-loop-but-its-not-allowed"
      },
      {
        "level": 4,
        "text": "Parameters",
        "id": "parameters"
      },
      {
        "level": 4,
        "text": "Returns",
        "id": "returns"
      },
      {
        "level": 4,
        "text": "Caveats",
        "id": "caveats"
      },
      {
        "level": 4,
        "text": "How is useCallback related to useMemo?",
        "id": "how-is-usecallback-related-to-usememo"
      },
      {
        "level": 4,
        "text": "Should you add useCallback everywhere?",
        "id": "should-you-add-usecallback-everywhere"
      },
      {
        "level": 4,
        "text": "The difference between useCallback and declaring a function directly",
        "id": "examples-rerendering"
      },
      {
        "level": 4,
        "text": "Example 1 of 2: Skipping re-rendering with useCallback and memo",
        "id": "skipping-re-rendering-with-usecallback-and-memo"
      },
      {
        "level": 5,
        "text": "Deep Dive",
        "id": ""
      },
      {
        "level": 5,
        "text": "Deep Dive",
        "id": ""
      }
    ],
    "codeBlocks": [
      {
        "language": "text",
        "code": "useCallback"
      },
      {
        "language": "text",
        "code": "const cachedFn = useCallback(fn, dependencies)"
      },
      {
        "language": "text",
        "code": "const cachedFn = useCallback(fn, dependencies)"
      },
      {
        "language": "text",
        "code": "useCallback"
      },
      {
        "language": "text",
        "code": "useCallback(fn, dependencies)"
      },
      {
        "language": "text",
        "code": "useCallback"
      },
      {
        "language": "text",
        "code": "useCallback"
      },
      {
        "language": "text",
        "code": "useCallback(fn, dependencies)"
      },
      {
        "language": "text",
        "code": "useCallback"
      },
      {
        "language": "text",
        "code": "import { useCallback } from 'react';export default function ProductPage({ productId, referrer, theme }) {  const handleSubmit = useCallback((orderDetails) => {    post('/product/' + productId + '/buy', {      referrer,      orderDetails,    });  }, [productId, referrer]);"
      },
      {
        "language": "text",
        "code": "import { useCallback } from 'react';export default function ProductPage({ productId, referrer, theme }) {  const handleSubmit = useCallback((orderDetails) => {    post('/product/' + productId + '/buy', {      referrer,      orderDetails,    });  }, [productId, referrer]);"
      },
      {
        "language": "text",
        "code": "dependencies"
      },
      {
        "language": "text",
        "code": "dependencies"
      },
      {
        "language": "text",
        "code": "[dep1, dep2, dep3]"
      },
      {
        "language": "text",
        "code": "useCallback"
      },
      {
        "language": "text",
        "code": "useCallback"
      },
      {
        "language": "text",
        "code": "useCallback"
      },
      {
        "language": "text",
        "code": "useCallback"
      },
      {
        "language": "text",
        "code": "import { useCallback } from 'react';function ProductPage({ productId, referrer, theme }) {  const handleSubmit = useCallback((orderDetails) => {    post('/product/' + productId + '/buy', {      referrer,      orderDetails,    });  }, [productId, referrer]);  // ..."
      },
      {
        "language": "text",
        "code": "import { useCallback } from 'react';function ProductPage({ productId, referrer, theme }) {  const handleSubmit = useCallback((orderDetails) => {    post('/product/' + productId + '/buy', {      referrer,      orderDetails,    });  }, [productId, referrer]);  // ..."
      },
      {
        "language": "text",
        "code": "useCallback"
      },
      {
        "language": "text",
        "code": "useCallback"
      },
      {
        "language": "text",
        "code": "useCallback"
      },
      {
        "language": "text",
        "code": "useCallback"
      },
      {
        "language": "text",
        "code": "useCallback"
      },
      {
        "language": "text",
        "code": "handleSubmit"
      },
      {
        "language": "text",
        "code": "ProductPage"
      },
      {
        "language": "text",
        "code": "ShippingForm"
      },
      {
        "language": "text",
        "code": "function ProductPage({ productId, referrer, theme }) {  // ...  return (    <div className={theme}>      <ShippingForm onSubmit={handleSubmit} />    </div>  );"
      },
      {
        "language": "text",
        "code": "function ProductPage({ productId, referrer, theme }) {  // ...  return (    <div className={theme}>      <ShippingForm onSubmit={handleSubmit} />    </div>  );"
      },
      {
        "language": "text",
        "code": "<ShippingForm />"
      },
      {
        "language": "text",
        "code": "ShippingForm"
      },
      {
        "language": "text",
        "code": "ProductPage"
      },
      {
        "language": "text",
        "code": "ShippingForm"
      },
      {
        "language": "text",
        "code": "ShippingForm"
      },
      {
        "language": "text",
        "code": "import { memo } from 'react';const ShippingForm = memo(function ShippingForm({ onSubmit }) {  // ...});"
      },
      {
        "language": "text",
        "code": "import { memo } from 'react';const ShippingForm = memo(function ShippingForm({ onSubmit }) {  // ...});"
      },
      {
        "language": "text",
        "code": "ShippingForm"
      },
      {
        "language": "text",
        "code": "handleSubmit"
      },
      {
        "language": "text",
        "code": "useCallback"
      },
      {
        "language": "text",
        "code": "function ProductPage({ productId, referrer, theme }) {  // Every time the theme changes, this will be a different function...  function handleSubmit(orderDetails) {    post('/product/' + productId + '/buy', {      referrer,      orderDetails,    });  }    return (    <div className={theme}>      {/* ... so ShippingForm's props will never be the same, and it will re-render every time */}      <ShippingForm onSubmit={handleSubmit} />    </div>  );}"
      },
      {
        "language": "text",
        "code": "function ProductPage({ productId, referrer, theme }) {  // Every time the theme changes, this will be a different function...  function handleSubmit(orderDetails) {    post('/product/' + productId + '/buy', {      referrer,      orderDetails,    });  }    return (    <div className={theme}>      {/* ... so ShippingForm's props will never be the same, and it will re-render every time */}      <ShippingForm onSubmit={handleSubmit} />    </div>  );}"
      },
      {
        "language": "text",
        "code": "function () {}"
      },
      {
        "language": "text",
        "code": "ShippingForm"
      },
      {
        "language": "text",
        "code": "useCallback"
      },
      {
        "language": "text",
        "code": "function ProductPage({ productId, referrer, theme }) {  // Tell React to cache your function between re-renders...  const handleSubmit = useCallback((orderDetails) => {    post('/product/' + productId + '/buy', {      referrer,      orderDetails,    });  }, [productId, referrer]); // ...so as long as these dependencies don't change...  return (    <div className={theme}>      {/* ...ShippingForm will receive the same props and can skip re-rendering */}      <ShippingForm onSubmit={handleSubmit} />    </div>  );}"
      },
      {
        "language": "text",
        "code": "function ProductPage({ productId, referrer, theme }) {  // Tell React to cache your function between re-renders...  const handleSubmit = useCallback((orderDetails) => {    post('/product/' + productId + '/buy', {      referrer,      orderDetails,    });  }, [productId, referrer]); // ...so as long as these dependencies don't change...  return (    <div className={theme}>      {/* ...ShippingForm will receive the same props and can skip re-rendering */}      <ShippingForm onSubmit={handleSubmit} />    </div>  );}"
      },
      {
        "language": "text",
        "code": "handleSubmit"
      },
      {
        "language": "text",
        "code": "useCallback"
      },
      {
        "language": "text",
        "code": "useCallback"
      },
      {
        "language": "text",
        "code": "useCallback"
      },
      {
        "language": "text",
        "code": "useCallback"
      },
      {
        "language": "text",
        "code": "useCallback"
      },
      {
        "language": "text",
        "code": "useCallback"
      },
      {
        "language": "text",
        "code": "import { useMemo, useCallback } from 'react';function ProductPage({ productId, referrer }) {  const product = useData('/product/' + productId);  const requirements = useMemo(() => { // Calls your function and caches its result    return computeRequirements(product);  }, [product]);  const handleSubmit = useCallback((orderDetails) => { // Caches your function itself    post('/product/' + productId + '/buy', {      referrer,      orderDetails,    });  }, [productId, referrer]);  return (    <div className={theme}>      <ShippingForm requirements={requirements} onSubmit={handleSubmit} />    </div>  );}"
      },
      {
        "language": "text",
        "code": "import { useMemo, useCallback } from 'react';function ProductPage({ productId, referrer }) {  const product = useData('/product/' + productId);  const requirements = useMemo(() => { // Calls your function and caches its result    return computeRequirements(product);  }, [product]);  const handleSubmit = useCallback((orderDetails) => { // Caches your function itself    post('/product/' + productId + '/buy', {      referrer,      orderDetails,    });  }, [productId, referrer]);  return (    <div className={theme}>      <ShippingForm requirements={requirements} onSubmit={handleSubmit} />    </div>  );}"
      },
      {
        "language": "text",
        "code": "computeRequirements(product)"
      },
      {
        "language": "text",
        "code": "requirements"
      },
      {
        "language": "text",
        "code": "ShippingForm"
      },
      {
        "language": "text",
        "code": "useCallback"
      },
      {
        "language": "text",
        "code": "handleSubmit"
      },
      {
        "language": "text",
        "code": "handleSubmit"
      },
      {
        "language": "text",
        "code": "ShippingForm"
      },
      {
        "language": "text",
        "code": "useCallback"
      },
      {
        "language": "text",
        "code": "// Simplified implementation (inside React)function useCallback(fn, dependencies) {  return useMemo(() => fn, dependencies);}"
      },
      {
        "language": "text",
        "code": "// Simplified implementation (inside React)function useCallback(fn, dependencies) {  return useMemo(() => fn, dependencies);}"
      },
      {
        "language": "text",
        "code": "useCallback"
      },
      {
        "language": "text",
        "code": "useCallback"
      },
      {
        "language": "text",
        "code": "useCallback"
      },
      {
        "language": "text",
        "code": "useCallback"
      },
      {
        "language": "text",
        "code": "useCallback"
      },
      {
        "language": "text",
        "code": "useCallback"
      },
      {
        "language": "text",
        "code": "useCallback"
      },
      {
        "language": "text",
        "code": "ShippingForm"
      },
      {
        "language": "text",
        "code": "ShippingForm"
      },
      {
        "language": "text",
        "code": "useCallback"
      },
      {
        "language": "text",
        "code": "ShippingForm"
      },
      {
        "language": "text",
        "code": "handleSubmit"
      },
      {
        "language": "text",
        "code": "handleSubmit"
      },
      {
        "language": "text",
        "code": "useCallback"
      },
      {
        "language": "text",
        "code": "import { useCallback } from 'react';\nimport ShippingForm from './ShippingForm.js';\n\nexport default function ProductPage({ productId, referrer, theme }) {\n  const handleSubmit = useCallback((orderDetails) => {\n    post('/product/' + productId + '/buy', {\n      referrer,\n      orderDetails,\n    });\n  }, [productId, referrer]);\n\n  return (\n    <div className={theme}>\n      <ShippingForm onSubmit={handleSubmit} />\n    </div>\n  );\n}\n\nfunction post(url, data) {\n  // Imagine this sends a request...\n  console.log('POST /' + url);\n  console.log(data);\n}"
      },
      {
        "language": "text",
        "code": "handleAddTodo"
      },
      {
        "language": "text",
        "code": "function TodoList() {  const [todos, setTodos] = useState([]);  const handleAddTodo = useCallback((text) => {    const newTodo = { id: nextId++, text };    setTodos([...todos, newTodo]);  }, [todos]);  // ..."
      },
      {
        "language": "text",
        "code": "function TodoList() {  const [todos, setTodos] = useState([]);  const handleAddTodo = useCallback((text) => {    const newTodo = { id: nextId++, text };    setTodos([...todos, newTodo]);  }, [todos]);  // ..."
      },
      {
        "language": "text",
        "code": "function TodoList() {  const [todos, setTodos] = useState([]);  const handleAddTodo = useCallback((text) => {    const newTodo = { id: nextId++, text };    setTodos(todos => [...todos, newTodo]);  }, []); // ✅ No need for the todos dependency  // ..."
      },
      {
        "language": "text",
        "code": "function TodoList() {  const [todos, setTodos] = useState([]);  const handleAddTodo = useCallback((text) => {    const newTodo = { id: nextId++, text };    setTodos(todos => [...todos, newTodo]);  }, []); // ✅ No need for the todos dependency  // ..."
      },
      {
        "language": "text",
        "code": "todos => [...todos, newTodo]"
      },
      {
        "language": "text",
        "code": "function ChatRoom({ roomId }) {  const [message, setMessage] = useState('');  function createOptions() {    return {      serverUrl: 'https://localhost:1234',      roomId: roomId    };  }  useEffect(() => {    const options = createOptions();    const connection = createConnection(options);    connection.connect();    // ..."
      },
      {
        "language": "text",
        "code": "function ChatRoom({ roomId }) {  const [message, setMessage] = useState('');  function createOptions() {    return {      serverUrl: 'https://localhost:1234',      roomId: roomId    };  }  useEffect(() => {    const options = createOptions();    const connection = createConnection(options);    connection.connect();    // ..."
      },
      {
        "language": "text",
        "code": "createOptions"
      },
      {
        "language": "text",
        "code": "useEffect(() => {    const options = createOptions();    const connection = createConnection(options);    connection.connect();    return () => connection.disconnect();  }, [createOptions]); // 🔴 Problem: This dependency changes on every render  // ..."
      },
      {
        "language": "text",
        "code": "useEffect(() => {    const options = createOptions();    const connection = createConnection(options);    connection.connect();    return () => connection.disconnect();  }, [createOptions]); // 🔴 Problem: This dependency changes on every render  // ..."
      },
      {
        "language": "text",
        "code": "useCallback"
      },
      {
        "language": "text",
        "code": "function ChatRoom({ roomId }) {  const [message, setMessage] = useState('');  const createOptions = useCallback(() => {    return {      serverUrl: 'https://localhost:1234',      roomId: roomId    };  }, [roomId]); // ✅ Only changes when roomId changes  useEffect(() => {    const options = createOptions();    const connection = createConnection(options);    connection.connect();    return () => connection.disconnect();  }, [createOptions]); // ✅ Only changes when createOptions changes  // ..."
      },
      {
        "language": "text",
        "code": "function ChatRoom({ roomId }) {  const [message, setMessage] = useState('');  const createOptions = useCallback(() => {    return {      serverUrl: 'https://localhost:1234',      roomId: roomId    };  }, [roomId]); // ✅ Only changes when roomId changes  useEffect(() => {    const options = createOptions();    const connection = createConnection(options);    connection.connect();    return () => connection.disconnect();  }, [createOptions]); // ✅ Only changes when createOptions changes  // ..."
      },
      {
        "language": "text",
        "code": "createOptions"
      },
      {
        "language": "text",
        "code": "function ChatRoom({ roomId }) {  const [message, setMessage] = useState('');  useEffect(() => {    function createOptions() { // ✅ No need for useCallback or function dependencies!      return {        serverUrl: 'https://localhost:1234',        roomId: roomId      };    }    const options = createOptions();    const connection = createConnection(options);    connection.connect();    return () => connection.disconnect();  }, [roomId]); // ✅ Only changes when roomId changes  // ..."
      },
      {
        "language": "text",
        "code": "function ChatRoom({ roomId }) {  const [message, setMessage] = useState('');  useEffect(() => {    function createOptions() { // ✅ No need for useCallback or function dependencies!      return {        serverUrl: 'https://localhost:1234',        roomId: roomId      };    }    const options = createOptions();    const connection = createConnection(options);    connection.connect();    return () => connection.disconnect();  }, [roomId]); // ✅ Only changes when roomId changes  // ..."
      },
      {
        "language": "text",
        "code": "useCallback"
      },
      {
        "language": "text",
        "code": "useCallback"
      },
      {
        "language": "text",
        "code": "function useRouter() {  const { dispatch } = useContext(RouterStateContext);  const navigate = useCallback((url) => {    dispatch({ type: 'navigate', url });  }, [dispatch]);  const goBack = useCallback(() => {    dispatch({ type: 'back' });  }, [dispatch]);  return {    navigate,    goBack,  };}"
      },
      {
        "language": "text",
        "code": "function useRouter() {  const { dispatch } = useContext(RouterStateContext);  const navigate = useCallback((url) => {    dispatch({ type: 'navigate', url });  }, [dispatch]);  const goBack = useCallback(() => {    dispatch({ type: 'back' });  }, [dispatch]);  return {    navigate,    goBack,  };}"
      },
      {
        "language": "text",
        "code": "useCallback"
      },
      {
        "language": "text",
        "code": "useCallback"
      },
      {
        "language": "text",
        "code": "function ProductPage({ productId, referrer }) {  const handleSubmit = useCallback((orderDetails) => {    post('/product/' + productId + '/buy', {      referrer,      orderDetails,    });  }); // 🔴 Returns a new function every time: no dependency array  // ..."
      },
      {
        "language": "text",
        "code": "function ProductPage({ productId, referrer }) {  const handleSubmit = useCallback((orderDetails) => {    post('/product/' + productId + '/buy', {      referrer,      orderDetails,    });  }); // 🔴 Returns a new function every time: no dependency array  // ..."
      },
      {
        "language": "text",
        "code": "function ProductPage({ productId, referrer }) {  const handleSubmit = useCallback((orderDetails) => {    post('/product/' + productId + '/buy', {      referrer,      orderDetails,    });  }, [productId, referrer]); // ✅ Does not return a new function unnecessarily  // ..."
      },
      {
        "language": "text",
        "code": "function ProductPage({ productId, referrer }) {  const handleSubmit = useCallback((orderDetails) => {    post('/product/' + productId + '/buy', {      referrer,      orderDetails,    });  }, [productId, referrer]); // ✅ Does not return a new function unnecessarily  // ..."
      },
      {
        "language": "text",
        "code": "const handleSubmit = useCallback((orderDetails) => {    // ..  }, [productId, referrer]);  console.log([productId, referrer]);"
      },
      {
        "language": "text",
        "code": "const handleSubmit = useCallback((orderDetails) => {    // ..  }, [productId, referrer]);  console.log([productId, referrer]);"
      },
      {
        "language": "text",
        "code": "Object.is(temp1[0], temp2[0]); // Is the first dependency the same between the arrays?Object.is(temp1[1], temp2[1]); // Is the second dependency the same between the arrays?Object.is(temp1[2], temp2[2]); // ... and so on for every dependency ..."
      },
      {
        "language": "text",
        "code": "Object.is(temp1[0], temp2[0]); // Is the first dependency the same between the arrays?Object.is(temp1[1], temp2[1]); // Is the second dependency the same between the arrays?Object.is(temp1[2], temp2[2]); // ... and so on for every dependency ..."
      },
      {
        "language": "text",
        "code": "useCallback"
      },
      {
        "language": "text",
        "code": "useCallback"
      },
      {
        "language": "text",
        "code": "function ReportList({ items }) {  return (    <article>      {items.map(item => {        // 🔴 You can't call useCallback in a loop like this:        const handleClick = useCallback(() => {          sendReport(item)        }, [item]);        return (          <figure key={item.id}>            <Chart onClick={handleClick} />          </figure>        );      })}    </article>  );}"
      },
      {
        "language": "text",
        "code": "function ReportList({ items }) {  return (    <article>      {items.map(item => {        // 🔴 You can't call useCallback in a loop like this:        const handleClick = useCallback(() => {          sendReport(item)        }, [item]);        return (          <figure key={item.id}>            <Chart onClick={handleClick} />          </figure>        );      })}    </article>  );}"
      },
      {
        "language": "text",
        "code": "useCallback"
      },
      {
        "language": "text",
        "code": "function ReportList({ items }) {  return (    <article>      {items.map(item =>        <Report key={item.id} item={item} />      )}    </article>  );}function Report({ item }) {  // ✅ Call useCallback at the top level:  const handleClick = useCallback(() => {    sendReport(item)  }, [item]);  return (    <figure>      <Chart onClick={handleClick} />    </figure>  );}"
      },
      {
        "language": "text",
        "code": "function ReportList({ items }) {  return (    <article>      {items.map(item =>        <Report key={item.id} item={item} />      )}    </article>  );}function Report({ item }) {  // ✅ Call useCallback at the top level:  const handleClick = useCallback(() => {    sendReport(item)  }, [item]);  return (    <figure>      <Chart onClick={handleClick} />    </figure>  );}"
      },
      {
        "language": "text",
        "code": "useCallback"
      },
      {
        "language": "text",
        "code": "function ReportList({ items }) {  // ...}const Report = memo(function Report({ item }) {  function handleClick() {    sendReport(item);  }  return (    <figure>      <Chart onClick={handleClick} />    </figure>  );});"
      },
      {
        "language": "text",
        "code": "function ReportList({ items }) {  // ...}const Report = memo(function Report({ item }) {  function handleClick() {    sendReport(item);  }  return (    <figure>      <Chart onClick={handleClick} />    </figure>  );});"
      }
    ],
    "links": [
      {
        "text": "API Reference",
        "href": "/reference/react"
      },
      {
        "text": "Hooks",
        "href": "/reference/react/hooks"
      },
      {
        "text": "React Compiler",
        "href": "/learn/react-compiler"
      },
      {
        "text": "configured for React",
        "href": "/learn/editor-setup#linting"
      },
      {
        "text": "Object.is",
        "href": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/is"
      },
      {
        "text": "state variable",
        "href": "/reference/react/useState#im-trying-to-set-state-to-a-function-but-it-gets-called-instead"
      },
      {
        "text": "ref",
        "href": "/reference/react/useRef#avoiding-recreating-the-ref-contents"
      },
      {
        "text": "Object.is",
        "href": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/is"
      },
      {
        "text": "memo:",
        "href": "/reference/react/memo"
      },
      {
        "text": "memo",
        "href": "/reference/react/memo"
      },
      {
        "text": "memo,",
        "href": "/reference/react/memo"
      },
      {
        "text": "useMemo",
        "href": "/reference/react/useMemo"
      },
      {
        "text": "memoize",
        "href": "https://en.wikipedia.org/wiki/Memoization"
      },
      {
        "text": "useMemo",
        "href": "/reference/react/useMemo"
      },
      {
        "text": "useMemo,",
        "href": "/reference/react/useMemo"
      },
      {
        "text": "Read more about the difference between useMemo and useCallback.",
        "href": "/reference/react/useMemo#memoizing-a-function"
      },
      {
        "text": "memo.",
        "href": "/reference/react/memo"
      },
      {
        "text": "useEffect.",
        "href": "/reference/react/useEffect"
      },
      {
        "text": "accept JSX as children.",
        "href": "/learn/passing-props-to-a-component#passing-jsx-as-children"
      },
      {
        "text": "lift state up",
        "href": "/learn/sharing-state-between-components"
      },
      {
        "text": "rendering logic pure.",
        "href": "/learn/keeping-components-pure"
      },
      {
        "text": "unnecessary Effects that update state.",
        "href": "/learn/you-might-not-need-an-effect"
      },
      {
        "text": "remove unnecessary dependencies from your Effects.",
        "href": "/learn/removing-effect-dependencies"
      },
      {
        "text": "use the React Developer Tools profiler",
        "href": "https://legacy.reactjs.org/blog/2018/09/10/introducing-the-react-profiler.html"
      },
      {
        "text": "doing memoization automatically",
        "href": "https://www.youtube.com/watch?v=lGEMwh32soc"
      },
      {
        "text": "memo",
        "href": "/reference/react/memo"
      },
      {
        "text": "updater function",
        "href": "/reference/react/useState#updating-state-based-on-the-previous-state"
      },
      {
        "text": "Read more about updater functions.",
        "href": "/reference/react/useState#updating-state-based-on-the-previous-state"
      },
      {
        "text": "Effect:",
        "href": "/learn/synchronizing-with-effects"
      },
      {
        "text": "Every reactive value must be declared as a dependency of your Effect.",
        "href": "/learn/lifecycle-of-reactive-effects#react-verifies-that-you-specified-every-reactive-value-as-a-dependency"
      },
      {
        "text": "Learn more about removing Effect dependencies.",
        "href": "/learn/removing-effect-dependencies#move-dynamic-objects-and-functions-inside-your-effect"
      },
      {
        "text": "custom Hook,",
        "href": "/learn/reusing-logic-with-custom-hooks"
      },
      {
        "text": "memoize it as well.",
        "href": "/reference/react/useMemo#memoizing-a-dependency-of-another-hook"
      },
      {
        "text": "memo",
        "href": "/reference/react/memo"
      },
      {
        "text": "memo.",
        "href": "/reference/react/memo"
      },
      {
        "text": "PrevioususeActionState",
        "href": "/reference/react/useActionState"
      },
      {
        "text": "NextuseContext",
        "href": "/reference/react/useContext"
      }
    ],
    "meta": {
      "description": "",
      "keywords": ""
    },
    "summary": "API ReferenceHooksuseCallbackuseCallback is a React Hook that lets you cache a function definition between re-renders",
    "tags": [
      "react",
      "vue",
      "angular",
      "javascript",
      "typescript",
      "html",
      "node",
      "vite",
      "usecallback",
      "note"
    ],
    "id": "usecallback-react-useCallback-part-1",
    "quality": 100
  },
  {
    "title": "useRef – React",
    "url": "https://react.dev/reference/react/useRef",
    "category": "react",
    "content": "API ReferenceHooksuseRefuseRef is a React Hook that lets you reference a value thats not needed for rendering.const ref = useRef(initialValue) Reference useRef(initialValue) Usage Referencing a value with a ref Manipulating the DOM with a ref Avoiding recreating the ref contents Troubleshooting I cant get a ref to a custom component Reference useRef(initialValue) Call useRef at the top level of your component to declare a ref. import { useRef } from 'react';function MyComponent() { const intervalRef = useRef(0); const inputRef = useRef(null); // ... See more examples below. Parameters initialValue: The value you want the ref objects current property to be initially. It can be a value of any type. This argument is ignored after the initial render. Returns useRef returns an object with a single property: current: Initially, its set to the initialValue you have passed. You can later set it to something else. If you pass the ref object to React as a ref attribute to a JSX node, React will set its current property. On the next renders, useRef will return the same object. Caveats You can mutate the ref.current property. Unlike state, it is mutable. However, if it holds an object that is used for rendering (for example, a piece of your state), then you shouldnt mutate that object. When you change the ref.current property, React does not re-render your component. React is not aware of when you change it because a ref is a plain JavaScript object. Do not write or read ref.current during rendering, except for initialization. This makes your components behavior unpredictable. In Strict Mode, React will call your component function twice in order to help you find accidental impurities. This is development-only behavior and does not affect production. Each ref object will be created twice, but one of the versions will be discarded. If your component function is pure (as it should be), this should not affect the behavior. Usage Referencing a value with a ref Call useRef at the top level of your component to declare one or more refs. import { useRef } from 'react';function Stopwatch() { const intervalRef = useRef(0); // ... useRef returns a ref object with a single current property initially set to the initial value you provided. On the next renders, useRef will return the same object. You can change its current property to store information and read it later. This might remind you of state, but there is an important difference. Changing a ref does not trigger a re-render. This means refs are perfect for storing information that doesnt affect the visual output of your component. For example, if you need to store an interval ID and retrieve it later, you can put it in a ref. To update the value inside the ref, you need to manually change its current property: function handleStartClick() { const intervalId = setInterval(() = { // ... }, 1000); intervalRef.current = intervalId;} Later, you can read that interval ID from the ref so that you can call clear that interval: function handleStopClick() { const intervalId = intervalRef.current; clearInterval(intervalId);} By using a ref, you ensure that: You can store information between re-renders (unlike regular variables, which reset on every render). Changing it does not trigger a re-render (unlike state variables, which trigger a re-render). The information is local to each copy of your component (unlike the variables outside, which are shared). Changing a ref does not trigger a re-render, so refs are not appropriate for storing information you want to display on the screen. Use state for that instead. Read more about choosing between useRef and useState. Examples of referencing a value with useRef1. Click counter 2. A stopwatch Example 1 of 2: Click counter This component uses a ref to keep track of how many times the button was clicked. Note that its okay to use a ref instead of state here because the click count is only read and written in an event handler.App.jsApp.js Download ResetForkimport { useRef } from 'react'; export default function Counter() { let ref = useRef(0); function handleClick() { ref.current = ref.current + 1; alert('You clicked ' + ref.current + ' times!'); } return ( button onClick={handleClick} Click me! /button ); } Show moreIf you show {ref.current} in the JSX, the number wont update on click. This is because setting ref.current does not trigger a re-render. Information thats used for rendering should be state instead.Next Example PitfallDo not write or read ref.current during rendering.React expects that the body of your component behaves like a pure function: If the inputs (props, state, and context) are the same, it should return exactly the same JSX. Calling it in a different order or with different arguments should not affect the results of other calls. Reading or writing a ref during rendering breaks these expectations.function MyComponent() { // ... //  Don't write a ref during rendering myRef.current = 123; // ... //  Don't read a ref during rendering return h1{myOtherRef.current}/h1;}You can read or write refs from event handlers or effects instead.function MyComponent() { // ... useEffect(() = { //  You can read or write refs in effects myRef.current = 123; }); // ... function handleClick() { //  You can read or write refs in event handlers doSomething(myOtherRef.current); } // ...}If you have to read or write something during rendering, use state instead.When you break these rules, your component might still work, but most of the newer features were adding to React will rely on these expectations. Read more about keeping your components pure. Manipulating the DOM with a ref Its particularly common to use a ref to manipulate the DOM. React has built-in support for this. First, declare a ref object with an initial value of null: import { useRef } from 'react';function MyComponent() { const inputRef = useRef(null); // ... Then pass your ref object as the ref attribute to the JSX of the DOM node you want to manipulate: // ... return input ref={inputRef} /; After React creates the DOM node and puts it on the screen, React will set the current property of your ref object to that DOM node. Now you can access the inputs DOM node and call methods like focus(): function handleClick() { inputRef.current.focus(); } React will set the current property back to null when the node is removed from the screen. Read more about manipulating the DOM with refs. Examples of manipulating the DOM with useRef1. Focusing a text input 2. Scrolling an image into view 3. Playing and pausing a video 4. Exposing a ref to your own component Example 1 of 4: Focusing a text input In this example, clicking the button will focus the input:App.jsApp.js Download ResetForkimport { useRef } from 'react'; export default function Form() { const inputRef = useRef(null); function handleClick() { inputRef.current.focus(); } return (  input ref={inputRef} / button onClick={handleClick} Focus the input /button / ); } Show moreNext Example Avoiding recreating the ref contents React saves the initial ref value once and ignores it on the next renders. function Video() { const playerRef = useRef(new VideoPlayer()); // ... Although the result of new VideoPlayer() is only used for the initial render, youre still calling this function on every render. This can be wasteful if its creating expensive objects. To solve it, you may initialize the ref like this instead: function Video() { const playerRef = useRef(null); if (playerRef.current === null) { playerRef.current = new VideoPlayer(); } // ... Normally, writing or reading ref.current during render is not allowed. However, its fine in this case because the result is always the same, and the condition only executes during initialization so its fully predictable. Deep DiveHow to avoid null checks when initializing useRef later Show DetailsIf you use a type checker and dont want to always check for null, you can try a pattern like this instead:function Video() { const playerRef = useRef(null); function getPlayer() { if (playerRef.current !== null) { return playerRef.current; } const player = new VideoPlayer(); playerRef.current = player; return player; } // ...Here, the playerRef itself is nullable. However, you should be able to convince your type checker that there is no case in which getPlayer() returns null. Then use getPlayer() in your event handlers. Troubleshooting I cant get a ref to a custom component If you try to pass a ref to your own component like this: const inputRef = useRef(null);return MyInput ref={inputRef} /; You might get an error in the console: ConsoleTypeError: Cannot read properties of null By default, your own components dont expose refs to the DOM nodes inside them. To fix this, find the component that you want to get a ref to: export default function MyInput({ value, onChange }) { return ( input value={value} onChange={onChange} / );} And then add ref to the list of props your component accepts and pass ref as a prop to the relevent child built-in component like this: function MyInput({ value, onChange, ref }) { return ( input value={value} onChange={onChange} ref={ref} / );};export default MyInput; Then the parent component can get a ref to it. Read more about accessing another components DOM nodes.PrevioususeReducerNextuseState",
    "headings": [
      {
        "level": 1,
        "text": "useRef",
        "id": ""
      },
      {
        "level": 2,
        "text": "Reference",
        "id": "reference"
      },
      {
        "level": 2,
        "text": "Usage",
        "id": "usage"
      },
      {
        "level": 2,
        "text": "Troubleshooting",
        "id": "troubleshooting"
      },
      {
        "level": 3,
        "text": "useRef(initialValue)",
        "id": "useref"
      },
      {
        "level": 3,
        "text": "Referencing a value with a ref",
        "id": "referencing-a-value-with-a-ref"
      },
      {
        "level": 3,
        "text": "Pitfall",
        "id": ""
      },
      {
        "level": 3,
        "text": "Manipulating the DOM with a ref",
        "id": "manipulating-the-dom-with-a-ref"
      },
      {
        "level": 3,
        "text": "Avoiding recreating the ref contents",
        "id": "avoiding-recreating-the-ref-contents"
      },
      {
        "level": 3,
        "text": "I can’t get a ref to a custom component",
        "id": "i-cant-get-a-ref-to-a-custom-component"
      },
      {
        "level": 4,
        "text": "Parameters",
        "id": "parameters"
      },
      {
        "level": 4,
        "text": "Returns",
        "id": "returns"
      },
      {
        "level": 4,
        "text": "Caveats",
        "id": "caveats"
      },
      {
        "level": 4,
        "text": "Examples of referencing a value with useRef",
        "id": "examples-value"
      },
      {
        "level": 4,
        "text": "Example 1 of 2: Click counter",
        "id": "click-counter"
      },
      {
        "level": 4,
        "text": "Examples of manipulating the DOM with useRef",
        "id": "examples-dom"
      },
      {
        "level": 4,
        "text": "Example 1 of 4: Focusing a text input",
        "id": "focusing-a-text-input"
      },
      {
        "level": 4,
        "text": "How to avoid null checks when initializing useRef later",
        "id": "how-to-avoid-null-checks-when-initializing-use-ref-later"
      },
      {
        "level": 5,
        "text": "Deep Dive",
        "id": ""
      }
    ],
    "codeBlocks": [
      {
        "language": "text",
        "code": "const ref = useRef(initialValue)"
      },
      {
        "language": "text",
        "code": "const ref = useRef(initialValue)"
      },
      {
        "language": "text",
        "code": "useRef(initialValue)"
      },
      {
        "language": "text",
        "code": "useRef(initialValue)"
      },
      {
        "language": "text",
        "code": "import { useRef } from 'react';function MyComponent() {  const intervalRef = useRef(0);  const inputRef = useRef(null);  // ..."
      },
      {
        "language": "text",
        "code": "import { useRef } from 'react';function MyComponent() {  const intervalRef = useRef(0);  const inputRef = useRef(null);  // ..."
      },
      {
        "language": "text",
        "code": "initialValue"
      },
      {
        "language": "text",
        "code": "initialValue"
      },
      {
        "language": "text",
        "code": "ref.current"
      },
      {
        "language": "text",
        "code": "ref.current"
      },
      {
        "language": "text",
        "code": "ref.current"
      },
      {
        "language": "text",
        "code": "import { useRef } from 'react';function Stopwatch() {  const intervalRef = useRef(0);  // ..."
      },
      {
        "language": "text",
        "code": "import { useRef } from 'react';function Stopwatch() {  const intervalRef = useRef(0);  // ..."
      },
      {
        "language": "text",
        "code": "function handleStartClick() {  const intervalId = setInterval(() => {    // ...  }, 1000);  intervalRef.current = intervalId;}"
      },
      {
        "language": "text",
        "code": "function handleStartClick() {  const intervalId = setInterval(() => {    // ...  }, 1000);  intervalRef.current = intervalId;}"
      },
      {
        "language": "text",
        "code": "function handleStopClick() {  const intervalId = intervalRef.current;  clearInterval(intervalId);}"
      },
      {
        "language": "text",
        "code": "function handleStopClick() {  const intervalId = intervalRef.current;  clearInterval(intervalId);}"
      },
      {
        "language": "text",
        "code": "import { useRef } from 'react';\n\nexport default function Counter() {\n  let ref = useRef(0);\n\n  function handleClick() {\n    ref.current = ref.current + 1;\n    alert('You clicked ' + ref.current + ' times!');\n  }\n\n  return (\n    <button onClick={handleClick}>\n      Click me!\n    </button>\n  );\n}"
      },
      {
        "language": "text",
        "code": "{ref.current}"
      },
      {
        "language": "text",
        "code": "ref.current"
      },
      {
        "language": "text",
        "code": "ref.current"
      },
      {
        "language": "text",
        "code": "function MyComponent() {  // ...  // 🚩 Don't write a ref during rendering  myRef.current = 123;  // ...  // 🚩 Don't read a ref during rendering  return <h1>{myOtherRef.current}</h1>;}"
      },
      {
        "language": "text",
        "code": "function MyComponent() {  // ...  // 🚩 Don't write a ref during rendering  myRef.current = 123;  // ...  // 🚩 Don't read a ref during rendering  return <h1>{myOtherRef.current}</h1>;}"
      },
      {
        "language": "text",
        "code": "function MyComponent() {  // ...  useEffect(() => {    // ✅ You can read or write refs in effects    myRef.current = 123;  });  // ...  function handleClick() {    // ✅ You can read or write refs in event handlers    doSomething(myOtherRef.current);  }  // ...}"
      },
      {
        "language": "text",
        "code": "function MyComponent() {  // ...  useEffect(() => {    // ✅ You can read or write refs in effects    myRef.current = 123;  });  // ...  function handleClick() {    // ✅ You can read or write refs in event handlers    doSomething(myOtherRef.current);  }  // ...}"
      },
      {
        "language": "text",
        "code": "import { useRef } from 'react';function MyComponent() {  const inputRef = useRef(null);  // ..."
      },
      {
        "language": "text",
        "code": "import { useRef } from 'react';function MyComponent() {  const inputRef = useRef(null);  // ..."
      },
      {
        "language": "text",
        "code": "// ...  return <input ref={inputRef} />;"
      },
      {
        "language": "text",
        "code": "// ...  return <input ref={inputRef} />;"
      },
      {
        "language": "text",
        "code": "function handleClick() {    inputRef.current.focus();  }"
      },
      {
        "language": "text",
        "code": "function handleClick() {    inputRef.current.focus();  }"
      },
      {
        "language": "text",
        "code": "import { useRef } from 'react';\n\nexport default function Form() {\n  const inputRef = useRef(null);\n\n  function handleClick() {\n    inputRef.current.focus();\n  }\n\n  return (\n    <>\n      <input ref={inputRef} />\n      <button onClick={handleClick}>\n        Focus the input\n      </button>\n    </>\n  );\n}"
      },
      {
        "language": "text",
        "code": "function Video() {  const playerRef = useRef(new VideoPlayer());  // ..."
      },
      {
        "language": "text",
        "code": "function Video() {  const playerRef = useRef(new VideoPlayer());  // ..."
      },
      {
        "language": "text",
        "code": "new VideoPlayer()"
      },
      {
        "language": "text",
        "code": "function Video() {  const playerRef = useRef(null);  if (playerRef.current === null) {    playerRef.current = new VideoPlayer();  }  // ..."
      },
      {
        "language": "text",
        "code": "function Video() {  const playerRef = useRef(null);  if (playerRef.current === null) {    playerRef.current = new VideoPlayer();  }  // ..."
      },
      {
        "language": "text",
        "code": "ref.current"
      },
      {
        "language": "text",
        "code": "function Video() {  const playerRef = useRef(null);  function getPlayer() {    if (playerRef.current !== null) {      return playerRef.current;    }    const player = new VideoPlayer();    playerRef.current = player;    return player;  }  // ..."
      },
      {
        "language": "text",
        "code": "function Video() {  const playerRef = useRef(null);  function getPlayer() {    if (playerRef.current !== null) {      return playerRef.current;    }    const player = new VideoPlayer();    playerRef.current = player;    return player;  }  // ..."
      },
      {
        "language": "text",
        "code": "getPlayer()"
      },
      {
        "language": "text",
        "code": "getPlayer()"
      },
      {
        "language": "text",
        "code": "const inputRef = useRef(null);return <MyInput ref={inputRef} />;"
      },
      {
        "language": "text",
        "code": "const inputRef = useRef(null);return <MyInput ref={inputRef} />;"
      },
      {
        "language": "text",
        "code": "export default function MyInput({ value, onChange }) {  return (    <input      value={value}      onChange={onChange}    />  );}"
      },
      {
        "language": "text",
        "code": "export default function MyInput({ value, onChange }) {  return (    <input      value={value}      onChange={onChange}    />  );}"
      },
      {
        "language": "text",
        "code": "function MyInput({ value, onChange, ref }) {  return (    <input      value={value}      onChange={onChange}      ref={ref}    />  );};export default MyInput;"
      },
      {
        "language": "text",
        "code": "function MyInput({ value, onChange, ref }) {  return (    <input      value={value}      onChange={onChange}      ref={ref}    />  );};export default MyInput;"
      }
    ],
    "links": [
      {
        "text": "API Reference",
        "href": "/reference/react"
      },
      {
        "text": "Hooks",
        "href": "/reference/react/hooks"
      },
      {
        "text": "ref.",
        "href": "/learn/referencing-values-with-refs"
      },
      {
        "text": "help you find accidental impurities.",
        "href": "/reference/react/useState#my-initializer-or-updater-function-runs-twice"
      },
      {
        "text": "refs.",
        "href": "/learn/referencing-values-with-refs"
      },
      {
        "text": "state",
        "href": "/reference/react/useState"
      },
      {
        "text": "interval ID",
        "href": "https://developer.mozilla.org/en-US/docs/Web/API/setInterval"
      },
      {
        "text": "clear that interval",
        "href": "https://developer.mozilla.org/en-US/docs/Web/API/clearInterval"
      },
      {
        "text": "choosing between useRef and useState.",
        "href": "/learn/referencing-values-with-refs#differences-between-refs-and-state"
      },
      {
        "text": "behaves like a pure function",
        "href": "/learn/keeping-components-pure"
      },
      {
        "text": "props",
        "href": "/learn/passing-props-to-a-component"
      },
      {
        "text": "state",
        "href": "/learn/state-a-components-memory"
      },
      {
        "text": "context",
        "href": "/learn/passing-data-deeply-with-context"
      },
      {
        "text": "or write",
        "href": "/reference/react/useState#storing-information-from-previous-renders"
      },
      {
        "text": "use state",
        "href": "/reference/react/useState"
      },
      {
        "text": "keeping your components pure.",
        "href": "/learn/keeping-components-pure#where-you-_can_-cause-side-effects"
      },
      {
        "text": "DOM.",
        "href": "https://developer.mozilla.org/en-US/docs/Web/API/HTML_DOM_API"
      },
      {
        "text": "focus()",
        "href": "https://developer.mozilla.org/en-US/docs/Web/API/HTMLElement/focus"
      },
      {
        "text": "manipulating the DOM with refs.",
        "href": "/learn/manipulating-the-dom-with-refs"
      },
      {
        "text": "built-in component",
        "href": "/reference/react-dom/components/common"
      },
      {
        "text": "accessing another component’s DOM nodes.",
        "href": "/learn/manipulating-the-dom-with-refs#accessing-another-components-dom-nodes"
      },
      {
        "text": "PrevioususeReducer",
        "href": "/reference/react/useReducer"
      },
      {
        "text": "NextuseState",
        "href": "/reference/react/useState"
      }
    ],
    "meta": {
      "description": "",
      "keywords": ""
    },
    "summary": "API ReferenceHooksuseRefuseRef is a React Hook that lets you reference a value thats not needed for rendering",
    "tags": [
      "react",
      "angular",
      "javascript",
      "typescript",
      "html",
      "node",
      "vite",
      "useref",
      "ref",
      "referencing"
    ],
    "id": "useref-react-useRef-part-1",
    "quality": 100
  },
  {
    "title": "Describing the UI – React",
    "url": "https://react.dev/learn/describing-the-ui",
    "category": "react",
    "content": "Learn ReactDescribing the UIReact is a JavaScript library for rendering user interfaces (UI). UI is built from small units like buttons, text, and images. React lets you combine them into reusable, nestable components. From web sites to phone apps, everything on the screen can be broken down into components. In this chapter, youll learn to create, customize, and conditionally display React components. In this chapter How to write your first React component When and how to create multi-component files How to add markup to JavaScript with JSX How to use curly braces with JSX to access JavaScript functionality from your components How to configure components with props How to conditionally render components How to render multiple components at a time How to avoid confusing bugs by keeping components pure Why understanding your UI as trees is useful Your first component React applications are built from isolated pieces of UI called components. A React component is a JavaScript function that you can sprinkle with markup. Components can be as small as a button, or as large as an entire page. Here is a Gallery component rendering three Profile components: App.jsApp.js Download ResetForkfunction Profile() { return ( img src=\"https://i.imgur.com/MK3eW3As.jpg\" alt=\"Katherine Johnson\" / ); } export default function Gallery() { return ( section h1Amazing scientists/h1 Profile / Profile / Profile / /section ); } Show more Ready to learn this topic?Read Your First Component to learn how to declare and use React components.Read More Importing and exporting components You can declare many components in one file, but large files can get difficult to navigate. To solve this, you can export a component into its own file, and then import that component from another file: Gallery.jsProfile.jsGallery.js ResetForkimport Profile from './Profile.js'; export default function Gallery() { return ( section h1Amazing scientists/h1 Profile / Profile / Profile / /section ); } Ready to learn this topic?Read Importing and Exporting Components to learn how to split components into their own files.Read More Writing markup with JSX Each React component is a JavaScript function that may contain some markup that React renders into the browser. React components use a syntax extension called JSX to represent that markup. JSX looks a lot like HTML, but it is a bit stricter and can display dynamic information. If we paste existing HTML markup into a React component, it wont always work: App.jsApp.js Download ResetForkexport default function TodoList() { return ( // This doesn't quite work! h1Hedy Lamarr's Todos/h1 img src=\"https://i.imgur.com/yXOvdOSs.jpg\" alt=\"Hedy Lamarr\" class=\"photo\"  ul liInvent new traffic lights liRehearse a movie scene liImprove spectrum technology /ul Show more If you have existing HTML like this, you can fix it using a converter: App.jsApp.js Download ResetForkexport default function TodoList() { return (  h1Hedy Lamarr's Todos/h1 img src=\"https://i.imgur.com/yXOvdOSs.jpg\" alt=\"Hedy Lamarr\" className=\"photo\" / ul liInvent new traffic lights/li liRehearse a movie scene/li liImprove spectrum technology/li /ul / ); } Show more Ready to learn this topic?Read Writing Markup with JSX to learn how to write valid JSX.Read More JavaScript in JSX with curly braces JSX lets you write HTML-like markup inside a JavaScript file, keeping rendering logic and content in the same place. Sometimes you will want to add a little JavaScript logic or reference a dynamic property inside that markup. In this situation, you can use curly braces in your JSX to open a window to JavaScript: App.jsApp.js Download ResetForkconst person = { name: 'Gregorio Y. Zara', theme: { backgroundColor: 'black', color: 'pink' } }; export default function TodoList() { return ( div style={person.theme} h1{person.name}'s Todos/h1 img className=\"avatar\" src=\"https://i.imgur.com/7vQD0fPs.jpg\" alt=\"Gregorio Y. Zara\" / ul liImprove the videophone/li liPrepare aeronautics lectures/li liWork on the alcohol-fuelled engine/li /ul /div ); } Show more Ready to learn this topic?Read JavaScript in JSX with Curly Braces to learn how to access JavaScript data from JSX.Read More Passing props to a component React components use props to communicate with each other. Every parent component can pass some information to its child components by giving them props. Props might remind you of HTML attributes, but you can pass any JavaScript value through them, including objects, arrays, functions, and even JSX! App.jsutils.jsApp.js ResetForkimport { getImageUrl } from './utils.js' export default function Profile() { return ( Card Avatar size={100} person={{ name: 'Katsuko Saruhashi', imageId: 'YfeOqp2' }} / /Card ); } function Avatar({ person, size }) { return ( img className=\"avatar\" src={getImageUrl(person)} alt={person.name} width={size} height={size} / ); } function Card({ children }) { return ( div className=\"card\" {children} /div ); } Show more Ready to learn this topic?Read Passing Props to a Component to learn how to pass and read props.Read More Conditional rendering Your components will often need to display different things depending on different conditions. In React, you can conditionally render JSX using JavaScript syntax like if statements, &&, and ? : operators. In this example, the JavaScript && operator is used to conditionally render a checkmark: App.jsApp.js Download ResetForkfunction Item({ name, isPacked }) { return ( li className=\"item\" {name} {isPacked && ''} /li ); } export default function PackingList() { return ( section h1Sally Ride's Packing List/h1 ul Item isPacked={true} name=\"Space suit\" / Item isPacked={true} name=\"Helmet with a golden leaf\" / Item isPacked={false} name=\"Photo of Tam\" / /ul /section ); } Show more Ready to learn this topic?Read Conditional Rendering to learn the different ways to render content conditionally.Read More Rendering lists You will often want to display multiple similar components from a collection of data. You can use JavaScripts filter() and map() with React to filter and transform your array of data into an array of components. For each array item, you will need to specify a key. Usually, you will want to use an ID from the database as a key. Keys let React keep track of each items place in the list even if the list changes. App.jsdata.jsutils.jsApp.js ResetForkimport { people } from './data.js'; import { getImageUrl } from './utils.js'; export default function List() { const listItems = people.map(person = li key={person.id} img src={getImageUrl(person)} alt={person.name} / p b{person.name}:/b {' ' + person.profession + ' '} known for {person.accomplishment} /p /li ); return ( article h1Scientists/h1 ul{listItems}/ul /article ); } Show more Ready to learn this topic?Read Rendering Lists to learn how to render a list of components, and how to choose a key.Read More Keeping components pure Some JavaScript functions are pure. A pure function: Minds its own business. It does not change any objects or variables that existed before it was called. Same inputs, same output. Given the same inputs, a pure function should always return the same result. By strictly only writing your components as pure functions, you can avoid an entire class of baffling bugs and unpredictable behavior as your codebase grows. Here is an example of an impure component: App.jsApp.js Download ResetForklet guest = 0; function Cup() { // Bad: changing a preexisting variable! guest = guest + 1; return h2Tea cup for guest #{guest}/h2; } export default function TeaSet() { return (  Cup / Cup / Cup / / ); } Show more You can make this component pure by passing a prop instead of modifying a preexisting variable: App.jsApp.js Download ResetForkfunction Cup({ guest }) { return h2Tea cup for guest #{guest}/h2; } export default function TeaSet() { return (  Cup guest={1} / Cup guest={2} / Cup guest={3} / / ); } Ready to learn this topic?Read Keeping Components Pure to learn how to write components as pure, predictable functions.Read More Your UI as a tree React uses trees to model the relationships between components and modules. A React render tree is a representation of the parent and child relationship between components. An example React render tree. Components near the top of the tree, near the root component, are considered top-level components. Components with no child components are leaf components. This categorization of components is useful for understanding data flow and rendering performance. Modelling the relationship between JavaScript modules is another useful way to understand your app. We refer to it as a module dependency tree. An example module dependency tree. A dependency tree is often used by build tools to bundle all the relevant JavaScript code for the client to download and render. A large bundle size regresses user experience for React apps. Understanding the module dependency tree is helpful to debug such issues. Ready to learn this topic?Read Your UI as a Tree to learn how to create a render and module dependency trees for a React app and how theyre useful mental models for improving user experience and performance.Read More Whats next? Head over to Your First Component to start reading this chapter page by page! Or, if youre already familiar with these topics, why not read about Adding Interactivity?NextYour First Component",
    "headings": [
      {
        "level": 1,
        "text": "Describing the UI",
        "id": ""
      },
      {
        "level": 2,
        "text": "Your first component",
        "id": "your-first-component"
      },
      {
        "level": 2,
        "text": "Ready to learn this topic?",
        "id": ""
      },
      {
        "level": 2,
        "text": "Importing and exporting components",
        "id": "importing-and-exporting-components"
      },
      {
        "level": 2,
        "text": "Ready to learn this topic?",
        "id": ""
      },
      {
        "level": 2,
        "text": "Writing markup with JSX",
        "id": "writing-markup-with-jsx"
      },
      {
        "level": 2,
        "text": "Ready to learn this topic?",
        "id": ""
      },
      {
        "level": 2,
        "text": "JavaScript in JSX with curly braces",
        "id": "javascript-in-jsx-with-curly-braces"
      },
      {
        "level": 2,
        "text": "Ready to learn this topic?",
        "id": ""
      },
      {
        "level": 2,
        "text": "Passing props to a component",
        "id": "passing-props-to-a-component"
      },
      {
        "level": 2,
        "text": "Ready to learn this topic?",
        "id": ""
      },
      {
        "level": 2,
        "text": "Conditional rendering",
        "id": "conditional-rendering"
      },
      {
        "level": 2,
        "text": "Ready to learn this topic?",
        "id": ""
      },
      {
        "level": 2,
        "text": "Rendering lists",
        "id": "rendering-lists"
      },
      {
        "level": 2,
        "text": "Ready to learn this topic?",
        "id": ""
      },
      {
        "level": 2,
        "text": "Keeping components pure",
        "id": "keeping-components-pure"
      },
      {
        "level": 2,
        "text": "Ready to learn this topic?",
        "id": ""
      },
      {
        "level": 2,
        "text": "Your UI as a tree",
        "id": "your-ui-as-a-tree"
      },
      {
        "level": 2,
        "text": "Ready to learn this topic?",
        "id": ""
      },
      {
        "level": 2,
        "text": "What’s next?",
        "id": "whats-next"
      },
      {
        "level": 3,
        "text": "In this chapter",
        "id": ""
      }
    ],
    "codeBlocks": [
      {
        "language": "text",
        "code": "function Profile() {\n  return (\n    <img\n      src=\"https://i.imgur.com/MK3eW3As.jpg\"\n      alt=\"Katherine Johnson\"\n    />\n  );\n}\n\nexport default function Gallery() {\n  return (\n    <section>\n      <h1>Amazing scientists</h1>\n      <Profile />\n      <Profile />\n      <Profile />\n    </section>\n  );\n}"
      },
      {
        "language": "text",
        "code": "import Profile from './Profile.js';\n\nexport default function Gallery() {\n  return (\n    <section>\n      <h1>Amazing scientists</h1>\n      <Profile />\n      <Profile />\n      <Profile />\n    </section>\n  );\n}"
      },
      {
        "language": "text",
        "code": "export default function TodoList() {\n  return (\n    // This doesn't quite work!\n    <h1>Hedy Lamarr's Todos</h1>\n    <img\n      src=\"https://i.imgur.com/yXOvdOSs.jpg\"\n      alt=\"Hedy Lamarr\"\n      class=\"photo\"\n    >\n    <ul>\n      <li>Invent new traffic lights\n      <li>Rehearse a movie scene\n      <li>Improve spectrum technology\n    </ul>"
      },
      {
        "language": "text",
        "code": "export default function TodoList() {\n  return (\n    <>\n      <h1>Hedy Lamarr's Todos</h1>\n      <img\n        src=\"https://i.imgur.com/yXOvdOSs.jpg\"\n        alt=\"Hedy Lamarr\"\n        className=\"photo\"\n      />\n      <ul>\n        <li>Invent new traffic lights</li>\n        <li>Rehearse a movie scene</li>\n        <li>Improve spectrum technology</li>\n      </ul>\n    </>\n  );\n}"
      },
      {
        "language": "text",
        "code": "const person = {\n  name: 'Gregorio Y. Zara',\n  theme: {\n    backgroundColor: 'black',\n    color: 'pink'\n  }\n};\n\nexport default function TodoList() {\n  return (\n    <div style={person.theme}>\n      <h1>{person.name}'s Todos</h1>\n      <img\n        className=\"avatar\"\n        src=\"https://i.imgur.com/7vQD0fPs.jpg\"\n        alt=\"Gregorio Y. Zara\"\n      />\n      <ul>\n        <li>Improve the videophone</li>\n        <li>Prepare aeronautics lectures</li>\n        <li>Work on the alcohol-fuelled engine</li>\n      </ul>\n    </div>\n  );\n}"
      },
      {
        "language": "text",
        "code": "import { getImageUrl } from './utils.js'\n\nexport default function Profile() {\n  return (\n    <Card>\n      <Avatar\n        size={100}\n        person={{\n          name: 'Katsuko Saruhashi',\n          imageId: 'YfeOqp2'\n        }}\n      />\n    </Card>\n  );\n}\n\nfunction Avatar({ person, size }) {\n  return (\n    <img\n      className=\"avatar\"\n      src={getImageUrl(person)}\n      alt={person.name}\n      width={size}\n      height={size}\n    />\n  );\n}\n\nfunction Card({ children }) {\n  return (\n    <div className=\"card\">\n      {children}\n    </div>\n  );\n}"
      },
      {
        "language": "text",
        "code": "function Item({ name, isPacked }) {\n  return (\n    <li className=\"item\">\n      {name} {isPacked && '✅'}\n    </li>\n  );\n}\n\nexport default function PackingList() {\n  return (\n    <section>\n      <h1>Sally Ride's Packing List</h1>\n      <ul>\n        <Item\n          isPacked={true}\n          name=\"Space suit\"\n        />\n        <Item\n          isPacked={true}\n          name=\"Helmet with a golden leaf\"\n        />\n        <Item\n          isPacked={false}\n          name=\"Photo of Tam\"\n        />\n      </ul>\n    </section>\n  );\n}"
      },
      {
        "language": "text",
        "code": "import { people } from './data.js';\nimport { getImageUrl } from './utils.js';\n\nexport default function List() {\n  const listItems = people.map(person =>\n    <li key={person.id}>\n      <img\n        src={getImageUrl(person)}\n        alt={person.name}\n      />\n      <p>\n        <b>{person.name}:</b>\n        {' ' + person.profession + ' '}\n        known for {person.accomplishment}\n      </p>\n    </li>\n  );\n  return (\n    <article>\n      <h1>Scientists</h1>\n      <ul>{listItems}</ul>\n    </article>\n  );\n}"
      },
      {
        "language": "text",
        "code": "let guest = 0;\n\nfunction Cup() {\n  // Bad: changing a preexisting variable!\n  guest = guest + 1;\n  return <h2>Tea cup for guest #{guest}</h2>;\n}\n\nexport default function TeaSet() {\n  return (\n    <>\n      <Cup />\n      <Cup />\n      <Cup />\n    </>\n  );\n}"
      },
      {
        "language": "text",
        "code": "function Cup({ guest }) {\n  return <h2>Tea cup for guest #{guest}</h2>;\n}\n\nexport default function TeaSet() {\n  return (\n    <>\n      <Cup guest={1} />\n      <Cup guest={2} />\n      <Cup guest={3} />\n    </>\n  );\n}"
      }
    ],
    "links": [
      {
        "text": "Learn React",
        "href": "/learn"
      },
      {
        "text": "How to write your first React component",
        "href": "/learn/your-first-component"
      },
      {
        "text": "When and how to create multi-component files",
        "href": "/learn/importing-and-exporting-components"
      },
      {
        "text": "How to add markup to JavaScript with JSX",
        "href": "/learn/writing-markup-with-jsx"
      },
      {
        "text": "How to use curly braces with JSX to access JavaScript functionality from your components",
        "href": "/learn/javascript-in-jsx-with-curly-braces"
      },
      {
        "text": "How to configure components with props",
        "href": "/learn/passing-props-to-a-component"
      },
      {
        "text": "How to conditionally render components",
        "href": "/learn/conditional-rendering"
      },
      {
        "text": "How to render multiple components at a time",
        "href": "/learn/rendering-lists"
      },
      {
        "text": "How to avoid confusing bugs by keeping components pure",
        "href": "/learn/keeping-components-pure"
      },
      {
        "text": "Why understanding your UI as trees is useful",
        "href": "/learn/understanding-your-ui-as-a-tree"
      },
      {
        "text": "Your First Component",
        "href": "/learn/your-first-component"
      },
      {
        "text": "Read More",
        "href": "/learn/your-first-component"
      },
      {
        "text": "Importing and Exporting Components",
        "href": "/learn/importing-and-exporting-components"
      },
      {
        "text": "Read More",
        "href": "/learn/importing-and-exporting-components"
      },
      {
        "text": "converter",
        "href": "https://transform.tools/html-to-jsx"
      },
      {
        "text": "Writing Markup with JSX",
        "href": "/learn/writing-markup-with-jsx"
      },
      {
        "text": "Read More",
        "href": "/learn/writing-markup-with-jsx"
      },
      {
        "text": "JavaScript in JSX with Curly Braces",
        "href": "/learn/javascript-in-jsx-with-curly-braces"
      },
      {
        "text": "Read More",
        "href": "/learn/javascript-in-jsx-with-curly-braces"
      },
      {
        "text": "Passing Props to a Component",
        "href": "/learn/passing-props-to-a-component"
      },
      {
        "text": "Read More",
        "href": "/learn/passing-props-to-a-component"
      },
      {
        "text": "Conditional Rendering",
        "href": "/learn/conditional-rendering"
      },
      {
        "text": "Read More",
        "href": "/learn/conditional-rendering"
      },
      {
        "text": "Rendering Lists",
        "href": "/learn/rendering-lists"
      },
      {
        "text": "Read More",
        "href": "/learn/rendering-lists"
      },
      {
        "text": "Keeping Components Pure",
        "href": "/learn/keeping-components-pure"
      },
      {
        "text": "Read More",
        "href": "/learn/keeping-components-pure"
      },
      {
        "text": "Your UI as a Tree",
        "href": "/learn/understanding-your-ui-as-a-tree"
      },
      {
        "text": "Read More",
        "href": "/learn/understanding-your-ui-as-a-tree"
      },
      {
        "text": "Your First Component",
        "href": "/learn/your-first-component"
      },
      {
        "text": "Adding Interactivity",
        "href": "/learn/adding-interactivity"
      },
      {
        "text": "NextYour First Component",
        "href": "/learn/your-first-component"
      }
    ],
    "meta": {
      "description": "",
      "keywords": ""
    },
    "summary": "Learn ReactDescribing the UIReact is a JavaScript library for rendering user interfaces (UI). UI is built from small units like buttons, text, and images",
    "tags": [
      "react",
      "angular",
      "javascript",
      "typescript",
      "css",
      "html",
      "node",
      "webpack",
      "vite",
      "this"
    ],
    "id": "describing-the-ui-react-describingtheui-part-1",
    "quality": 100
  },
  {
    "title": "Adding Interactivity – React",
    "url": "https://react.dev/learn/adding-interactivity",
    "category": "react",
    "content": "Learn ReactAdding InteractivitySome things on the screen update in response to user input. For example, clicking an image gallery switches the active image. In React, data that changes over time is called state. You can add state to any component, and update it as needed. In this chapter, youll learn how to write components that handle interactions, update their state, and display different output over time. In this chapter How to handle user-initiated events How to make components remember information with state How React updates the UI in two phases Why state doesnt update right after you change it How to queue multiple state updates How to update an object in state How to update an array in state Responding to events React lets you add event handlers to your JSX. Event handlers are your own functions that will be triggered in response to user interactions like clicking, hovering, focusing on form inputs, and so on. Built-in components like button only support built-in browser events like onClick. However, you can also create your own components, and give their event handler props any application-specific names that you like. App.jsApp.js Download ResetForkexport default function App() { return ( Toolbar onPlayMovie={() = alert('Playing!')} onUploadImage={() = alert('Uploading!')} / ); } function Toolbar({ onPlayMovie, onUploadImage }) { return ( div Button onClick={onPlayMovie} Play Movie /Button Button onClick={onUploadImage} Upload Image /Button /div ); } function Button({ onClick, children }) { return ( button onClick={onClick} {children} /button ); } Open on CodeSandboxOpen SandboxShow more Ready to learn this topic?Read Responding to Events to learn how to add event handlers.Read More State: a components memory Components often need to change whats on the screen as a result of an interaction. Typing into the form should update the input field, clicking next on an image carousel should change which image is displayed, clicking buy puts a product in the shopping cart. Components need to remember things: the current input value, the current image, the shopping cart. In React, this kind of component-specific memory is called state. You can add state to a component with a useState Hook. Hooks are special functions that let your components use React features (state is one of those features). The useState Hook lets you declare a state variable. It takes the initial state and returns a pair of values: the current state, and a state setter function that lets you update it. const [index, setIndex] = useState(0);const [showMore, setShowMore] = useState(false); Here is how an image gallery uses and updates state on click: App.jsdata.jsApp.js ResetForkimport { useState } from 'react'; import { sculptureList } from './data.js'; export default function Gallery() { const [index, setIndex] = useState(0); const [showMore, setShowMore] = useState(false); const hasNext = index  sculptureList.length - 1; function handleNextClick() { if (hasNext) { setIndex(index + 1); } else { setIndex(0); } } function handleMoreClick() { setShowMore(!showMore); } let sculpture = sculptureList[index]; return (  button onClick={handleNextClick} Next /button h2 i{sculpture.name} /i by {sculpture.artist} /h2 h3 ({index + 1} of {sculptureList.length}) /h3 button onClick={handleMoreClick} {showMore ? 'Hide' : 'Show'} details /button {showMore && p{sculpture.description}/p} img src={sculpture.url} alt={sculpture.alt} / / ); } Show more Ready to learn this topic?Read State: A Components Memory to learn how to remember a value and update it on interaction.Read More Render and commit Before your components are displayed on the screen, they must be rendered by React. Understanding the steps in this process will help you think about how your code executes and explain its behavior. Imagine that your components are cooks in the kitchen, assembling tasty dishes from ingredients. In this scenario, React is the waiter who puts in requests from customers and brings them their orders. This process of requesting and serving UI has three steps: Triggering a render (delivering the diners order to the kitchen) Rendering the component (preparing the order in the kitchen) Committing to the DOM (placing the order on the table) TriggerRenderCommitIllustrated by Rachel Lee Nabors Ready to learn this topic?Read Render and Commit to learn the lifecycle of a UI update.Read More State as a snapshot Unlike regular JavaScript variables, React state behaves more like a snapshot. Setting it does not change the state variable you already have, but instead triggers a re-render. This can be surprising at first! console.log(count); // 0setCount(count + 1); // Request a re-render with 1console.log(count); // Still 0! This behavior helps you avoid subtle bugs. Here is a little chat app. Try to guess what happens if you press Send first and then change the recipient to Bob. Whose name will appear in the alert five seconds later? App.jsApp.js Download ResetForkimport { useState } from 'react'; export default function Form() { const [to, setTo] = useState('Alice'); const [message, setMessage] = useState('Hello'); function handleSubmit(e) { e.preventDefault(); setTimeout(() = { alert(You said ${message} to ${to}); }, 5000); } return ( form onSubmit={handleSubmit} label To:{' '} select value={to} onChange={e = setTo(e.target.value)} option value=\"Alice\"Alice/option option value=\"Bob\"Bob/option /select /label textarea placeholder=\"Message\" value={message} onChange={e = setMessage(e.target.value)} / button type=\"submit\"Send/button /form ); } Show more Ready to learn this topic?Read State as a Snapshot to learn why state appears fixed and unchanging inside the event handlers.Read More Queueing a series of state updates This component is buggy: clicking +3 increments the score only once. App.jsApp.js Download ResetForkimport { useState } from 'react'; export default function Counter() { const [score, setScore] = useState(0); function increment() { setScore(score + 1); } return (  button onClick={() = increment()}+1/button button onClick={() = { increment(); increment(); increment(); }}+3/button h1Score: {score}/h1 / ) } Show more State as a Snapshot explains why this is happening. Setting state requests a new re-render, but does not change it in the already running code. So score continues to be 0 right after you call setScore(score + 1). console.log(score); // 0setScore(score + 1); // setScore(0 + 1);console.log(score); // 0setScore(score + 1); // setScore(0 + 1);console.log(score); // 0setScore(score + 1); // setScore(0 + 1);console.log(score); // 0 You can fix this by passing an updater function when setting state. Notice how replacing setScore(score + 1) with setScore(s = s + 1) fixes the +3 button. This lets you queue multiple state updates. App.jsApp.js Download ResetForkimport { useState } from 'react'; export default function Counter() { const [score, setScore] = useState(0); function increment() { setScore(s = s + 1); } return (  button onClick={() = increment()}+1/button button onClick={() = { increment(); increment(); increment(); }}+3/button h1Score: {score}/h1 / ) } Show more Ready to learn this topic?Read Queueing a Series of State Updates to learn how to queue a sequence of state updates.Read More Updating objects in state State can hold any kind of JavaScript value, including objects. But you shouldnt change objects and arrays that you hold in the React state directly. Instead, when you want to update an object and array, you need to create a new one (or make a copy of an existing one), and then update the state to use that copy. Usually, you will use the ... spread syntax to copy objects and arrays that you want to change. For example, updating a nested object could look like this: App.jsApp.js Download ResetForkimport { useState } from 'react'; export default function Form() { const [person, setPerson] = useState({ name: 'Niki de Saint Phalle', artwork: { title: 'Blue Nana', city: 'Hamburg', image: 'https://i.imgur.com/Sd1AgUOm.jpg', } }); function handleNameChange(e) { setPerson({ ...person, name: e.target.value }); } function handleTitleChange(e) { setPerson({ ...person, artwork: { ...person.artwork, title: e.target.value } }); } function handleCityChange(e) { setPerson({ ...person, artwork: { ...person.artwork, city: e.target.value } }); } function handleImageChange(e) { setPerson({ ...person, artwork: { ...person.artwork, image: e.target.value } }); } return (  label Name: input value={person.name} onChange={handleNameChange} / /label label Title: input value={person.artwork.title} onChange={handleTitleChange} / /label label City: input value={person.artwork.city} onChange={handleCityChange} / /label label Image: input value={person.artwork.image} onChange={handleImageChange} / /label p i{person.artwork.title}/i {' by '} {person.name} br / (located in {person.artwork.city}) /p img src={person.artwork.image} alt={person.artwork.title} / / ); } Show more If copying objects in code gets tedious, you can use a library like Immer to reduce repetitive code: package.jsonApp.jspackage.json ResetFork{ \"dependencies\": { \"immer\": \"1.7.3\", \"react\": \"latest\", \"react-dom\": \"latest\", \"react-scripts\": \"latest\", \"use-immer\": \"0.5.1\" }, \"scripts\": { \"start\": \"react-scripts start\", \"build\": \"react-scripts build\", \"test\": \"react-scripts test --env=jsdom\", \"eject\": \"react-scripts eject\" }, \"devDependencies\": {} } Ready to learn this topic?Read Updating Objects in State to learn how to update objects correctly.Read More Updating arrays in state Arrays are another type of mutable JavaScript objects you can store in state and should treat as read-only. Just like with objects, when you want to update an array stored in state, you need to create a new one (or make a copy of an existing one), and then set state to use the new array: App.jsApp.js Download ResetForkimport { useState } from 'react'; const initialList = [ { id: 0, title: 'Big Bellies', seen: false }, { id: 1, title: 'Lunar Landscape', seen: false }, { id: 2, title: 'Terracotta Army', seen: true }, ]; export default function BucketList() { const [list, setList] = useState( initialList ); function handleToggle(artworkId, nextSeen) { setList(list.map(artwork = { if (artwork.id === artworkId) { return { ...artwork, seen: nextSeen }; } else { return artwork; } })); } return (  h1Art Bucket List/h1 h2My list of art to see:/h2 ItemList artworks={list} onToggle={handleToggle} / / ); } function ItemList({ artworks, onToggle }) { return ( ul {artworks.map(artwork = ( li key={artwork.id} label input type=\"checkbox\" checked={artwork.seen} onChange={e = { onToggle( artwork.id, e.target.checked ); }} / {artwork.title} /label /li ))} /ul ); } Show more If copying arrays in code gets tedious, you can use a library like Immer to reduce repetitive code: package.jsonApp.jspackage.json ResetFork{ \"dependencies\": { \"immer\": \"1.7.3\", \"react\": \"latest\", \"react-dom\": \"latest\", \"react-scripts\": \"latest\", \"use-immer\": \"0.5.1\" }, \"scripts\": { \"start\": \"react-scripts start\", \"build\": \"react-scripts build\", \"test\": \"react-scripts test --env=jsdom\", \"eject\": \"react-scripts eject\" }, \"devDependencies\": {} } Ready to learn this topic?Read Updating Arrays in State to learn how to update arrays correctly.Read More Whats next? Head over to Responding to Events to start reading this chapter page by page! Or, if youre already familiar with these topics, why not read about Managing State?PreviousYour UI as a TreeNextResponding to Events",
    "headings": [
      {
        "level": 1,
        "text": "Adding Interactivity",
        "id": ""
      },
      {
        "level": 2,
        "text": "Responding to events",
        "id": "responding-to-events"
      },
      {
        "level": 2,
        "text": "Ready to learn this topic?",
        "id": ""
      },
      {
        "level": 2,
        "text": "State: a component’s memory",
        "id": "state-a-components-memory"
      },
      {
        "level": 2,
        "text": "Ready to learn this topic?",
        "id": ""
      },
      {
        "level": 2,
        "text": "Render and commit",
        "id": "render-and-commit"
      },
      {
        "level": 2,
        "text": "Ready to learn this topic?",
        "id": ""
      },
      {
        "level": 2,
        "text": "State as a snapshot",
        "id": "state-as-a-snapshot"
      },
      {
        "level": 2,
        "text": "Ready to learn this topic?",
        "id": ""
      },
      {
        "level": 2,
        "text": "Queueing a series of state updates",
        "id": "queueing-a-series-of-state-updates"
      },
      {
        "level": 2,
        "text": "Ready to learn this topic?",
        "id": ""
      },
      {
        "level": 2,
        "text": "Updating objects in state",
        "id": "updating-objects-in-state"
      },
      {
        "level": 2,
        "text": "Ready to learn this topic?",
        "id": ""
      },
      {
        "level": 2,
        "text": "Updating arrays in state",
        "id": "updating-arrays-in-state"
      },
      {
        "level": 2,
        "text": "Ready to learn this topic?",
        "id": ""
      },
      {
        "level": 2,
        "text": "What’s next?",
        "id": "whats-next"
      },
      {
        "level": 3,
        "text": "In this chapter",
        "id": ""
      }
    ],
    "codeBlocks": [
      {
        "language": "text",
        "code": "export default function App() {\n  return (\n    <Toolbar\n      onPlayMovie={() => alert('Playing!')}\n      onUploadImage={() => alert('Uploading!')}\n    />\n  );\n}\n\nfunction Toolbar({ onPlayMovie, onUploadImage }) {\n  return (\n    <div>\n      <Button onClick={onPlayMovie}>\n        Play Movie\n      </Button>\n      <Button onClick={onUploadImage}>\n        Upload Image\n      </Button>\n    </div>\n  );\n}\n\nfunction Button({ onClick, children }) {\n  return (\n    <button onClick={onClick}>\n      {children}\n    </button>\n  );\n}"
      },
      {
        "language": "text",
        "code": "const [index, setIndex] = useState(0);const [showMore, setShowMore] = useState(false);"
      },
      {
        "language": "text",
        "code": "const [index, setIndex] = useState(0);const [showMore, setShowMore] = useState(false);"
      },
      {
        "language": "text",
        "code": "import { useState } from 'react';\nimport { sculptureList } from './data.js';\n\nexport default function Gallery() {\n  const [index, setIndex] = useState(0);\n  const [showMore, setShowMore] = useState(false);\n  const hasNext = index < sculptureList.length - 1;\n\n  function handleNextClick() {\n    if (hasNext) {\n      setIndex(index + 1);\n    } else {\n      setIndex(0);\n    }\n  }\n\n  function handleMoreClick() {\n    setShowMore(!showMore);\n  }\n\n  let sculpture = sculptureList[index];\n  return (\n    <>\n      <button onClick={handleNextClick}>\n        Next\n      </button>\n      <h2>\n        <i>{sculpture.name} </i>\n        by {sculpture.artist}\n      </h2>\n      <h3>\n        ({index + 1} of {sculptureList.length})\n      </h3>\n      <button onClick={handleMoreClick}>\n        {showMore ? 'Hide' : 'Show'} details\n      </button>\n      {showMore && <p>{sculpture.description}</p>}\n      <img\n        src={sculpture.url}\n        alt={sculpture.alt}\n      />\n    </>\n  );\n}"
      },
      {
        "language": "text",
        "code": "console.log(count);  // 0setCount(count + 1); // Request a re-render with 1console.log(count);  // Still 0!"
      },
      {
        "language": "text",
        "code": "console.log(count);  // 0setCount(count + 1); // Request a re-render with 1console.log(count);  // Still 0!"
      },
      {
        "language": "text",
        "code": "import { useState } from 'react';\n\nexport default function Form() {\n  const [to, setTo] = useState('Alice');\n  const [message, setMessage] = useState('Hello');\n\n  function handleSubmit(e) {\n    e.preventDefault();\n    setTimeout(() => {\n      alert(`You said ${message} to ${to}`);\n    }, 5000);\n  }\n\n  return (\n    <form onSubmit={handleSubmit}>\n      <label>\n        To:{' '}\n        <select\n          value={to}\n          onChange={e => setTo(e.target.value)}>\n          <option value=\"Alice\">Alice</option>\n          <option value=\"Bob\">Bob</option>\n        </select>\n      </label>\n      <textarea\n        placeholder=\"Message\"\n        value={message}\n        onChange={e => setMessage(e.target.value)}\n      />\n      <button type=\"submit\">Send</button>\n    </form>\n  );\n}"
      },
      {
        "language": "text",
        "code": "import { useState } from 'react';\n\nexport default function Counter() {\n  const [score, setScore] = useState(0);\n\n  function increment() {\n    setScore(score + 1);\n  }\n\n  return (\n    <>\n      <button onClick={() => increment()}>+1</button>\n      <button onClick={() => {\n        increment();\n        increment();\n        increment();\n      }}>+3</button>\n      <h1>Score: {score}</h1>\n    </>\n  )\n}"
      },
      {
        "language": "text",
        "code": "setScore(score + 1)"
      },
      {
        "language": "text",
        "code": "console.log(score);  // 0setScore(score + 1); // setScore(0 + 1);console.log(score);  // 0setScore(score + 1); // setScore(0 + 1);console.log(score);  // 0setScore(score + 1); // setScore(0 + 1);console.log(score);  // 0"
      },
      {
        "language": "text",
        "code": "console.log(score);  // 0setScore(score + 1); // setScore(0 + 1);console.log(score);  // 0setScore(score + 1); // setScore(0 + 1);console.log(score);  // 0setScore(score + 1); // setScore(0 + 1);console.log(score);  // 0"
      },
      {
        "language": "text",
        "code": "setScore(score + 1)"
      },
      {
        "language": "text",
        "code": "setScore(s => s + 1)"
      },
      {
        "language": "text",
        "code": "import { useState } from 'react';\n\nexport default function Counter() {\n  const [score, setScore] = useState(0);\n\n  function increment() {\n    setScore(s => s + 1);\n  }\n\n  return (\n    <>\n      <button onClick={() => increment()}>+1</button>\n      <button onClick={() => {\n        increment();\n        increment();\n        increment();\n      }}>+3</button>\n      <h1>Score: {score}</h1>\n    </>\n  )\n}"
      },
      {
        "language": "text",
        "code": "import { useState } from 'react';\n\nexport default function Form() {\n  const [person, setPerson] = useState({\n    name: 'Niki de Saint Phalle',\n    artwork: {\n      title: 'Blue Nana',\n      city: 'Hamburg',\n      image: 'https://i.imgur.com/Sd1AgUOm.jpg',\n    }\n  });\n\n  function handleNameChange(e) {\n    setPerson({\n      ...person,\n      name: e.target.value\n    });\n  }\n\n  function handleTitleChange(e) {\n    setPerson({\n      ...person,\n      artwork: {\n        ...person.artwork,\n        title: e.target.value\n      }\n    });\n  }\n\n  function handleCityChange(e) {\n    setPerson({\n      ...person,\n      artwork: {\n        ...person.artwork,\n        city: e.target.value\n      }\n    });\n  }\n\n  function handleImageChange(e) {\n    setPerson({\n      ...person,\n      artwork: {\n        ...person.artwork,\n        image: e.target.value\n      }\n    });\n  }\n\n  return (\n    <>\n      <label>\n        Name:\n        <input\n          value={person.name}\n          onChange={handleNameChange}\n        />\n      </label>\n      <label>\n        Title:\n        <input\n          value={person.artwork.title}\n          onChange={handleTitleChange}\n        />\n      </label>\n      <label>\n        City:\n        <input\n          value={person.artwork.city}\n          onChange={handleCityChange}\n        />\n      </label>\n      <label>\n        Image:\n        <input\n          value={person.artwork.image}\n          onChange={handleImageChange}\n        />\n      </label>\n      <p>\n        <i>{person.artwork.title}</i>\n        {' by '}\n        {person.name}\n        <br />\n        (located in {person.artwork.city})\n      </p>\n      <img\n        src={person.artwork.image}\n        alt={person.artwork.title}\n      />\n    </>\n  );\n}"
      },
      {
        "language": "text",
        "code": "{\n  \"dependencies\": {\n    \"immer\": \"1.7.3\",\n    \"react\": \"latest\",\n    \"react-dom\": \"latest\",\n    \"react-scripts\": \"latest\",\n    \"use-immer\": \"0.5.1\"\n  },\n  \"scripts\": {\n    \"start\": \"react-scripts start\",\n    \"build\": \"react-scripts build\",\n    \"test\": \"react-scripts test --env=jsdom\",\n    \"eject\": \"react-scripts eject\"\n  },\n  \"devDependencies\": {}\n}"
      },
      {
        "language": "text",
        "code": "import { useState } from 'react';\n\nconst initialList = [\n  { id: 0, title: 'Big Bellies', seen: false },\n  { id: 1, title: 'Lunar Landscape', seen: false },\n  { id: 2, title: 'Terracotta Army', seen: true },\n];\n\nexport default function BucketList() {\n  const [list, setList] = useState(\n    initialList\n  );\n\n  function handleToggle(artworkId, nextSeen) {\n    setList(list.map(artwork => {\n      if (artwork.id === artworkId) {\n        return { ...artwork, seen: nextSeen };\n      } else {\n        return artwork;\n      }\n    }));\n  }\n\n  return (\n    <>\n      <h1>Art Bucket List</h1>\n      <h2>My list of art to see:</h2>\n      <ItemList\n        artworks={list}\n        onToggle={handleToggle} />\n    </>\n  );\n}\n\nfunction ItemList({ artworks, onToggle }) {\n  return (\n    <ul>\n      {artworks.map(artwork => (\n        <li key={artwork.id}>\n          <label>\n            <input\n              type=\"checkbox\"\n              checked={artwork.seen}\n              onChange={e => {\n                onToggle(\n                  artwork.id,\n                  e.target.checked\n                );\n              }}\n            />\n            {artwork.title}\n          </label>\n        </li>\n      ))}\n    </ul>\n  );\n}"
      },
      {
        "language": "text",
        "code": "{\n  \"dependencies\": {\n    \"immer\": \"1.7.3\",\n    \"react\": \"latest\",\n    \"react-dom\": \"latest\",\n    \"react-scripts\": \"latest\",\n    \"use-immer\": \"0.5.1\"\n  },\n  \"scripts\": {\n    \"start\": \"react-scripts start\",\n    \"build\": \"react-scripts build\",\n    \"test\": \"react-scripts test --env=jsdom\",\n    \"eject\": \"react-scripts eject\"\n  },\n  \"devDependencies\": {}\n}"
      }
    ],
    "links": [
      {
        "text": "Learn React",
        "href": "/learn"
      },
      {
        "text": "How to handle user-initiated events",
        "href": "/learn/responding-to-events"
      },
      {
        "text": "How to make components “remember” information with state",
        "href": "/learn/state-a-components-memory"
      },
      {
        "text": "How React updates the UI in two phases",
        "href": "/learn/render-and-commit"
      },
      {
        "text": "Why state doesn’t update right after you change it",
        "href": "/learn/state-as-a-snapshot"
      },
      {
        "text": "How to queue multiple state updates",
        "href": "/learn/queueing-a-series-of-state-updates"
      },
      {
        "text": "How to update an object in state",
        "href": "/learn/updating-objects-in-state"
      },
      {
        "text": "How to update an array in state",
        "href": "/learn/updating-arrays-in-state"
      },
      {
        "text": "Responding to Events",
        "href": "/learn/responding-to-events"
      },
      {
        "text": "Read More",
        "href": "/learn/responding-to-events"
      },
      {
        "text": "useState",
        "href": "/reference/react/useState"
      },
      {
        "text": "State: A Component’s Memory",
        "href": "/learn/state-a-components-memory"
      },
      {
        "text": "Read More",
        "href": "/learn/state-a-components-memory"
      },
      {
        "text": "Rachel Lee Nabors",
        "href": "https://nearestnabors.com/"
      },
      {
        "text": "Render and Commit",
        "href": "/learn/render-and-commit"
      },
      {
        "text": "Read More",
        "href": "/learn/render-and-commit"
      },
      {
        "text": "State as a Snapshot",
        "href": "/learn/state-as-a-snapshot"
      },
      {
        "text": "Read More",
        "href": "/learn/state-as-a-snapshot"
      },
      {
        "text": "State as a Snapshot",
        "href": "/learn/state-as-a-snapshot"
      },
      {
        "text": "Queueing a Series of State Updates",
        "href": "/learn/queueing-a-series-of-state-updates"
      },
      {
        "text": "Read More",
        "href": "/learn/queueing-a-series-of-state-updates"
      },
      {
        "text": "Immer",
        "href": "https://github.com/immerjs/use-immer"
      },
      {
        "text": "Updating Objects in State",
        "href": "/learn/updating-objects-in-state"
      },
      {
        "text": "Read More",
        "href": "/learn/updating-objects-in-state"
      },
      {
        "text": "Immer",
        "href": "https://github.com/immerjs/use-immer"
      },
      {
        "text": "Updating Arrays in State",
        "href": "/learn/updating-arrays-in-state"
      },
      {
        "text": "Read More",
        "href": "/learn/updating-arrays-in-state"
      },
      {
        "text": "Responding to Events",
        "href": "/learn/responding-to-events"
      },
      {
        "text": "Managing State",
        "href": "/learn/managing-state"
      },
      {
        "text": "PreviousYour UI as a Tree",
        "href": "/learn/understanding-your-ui-as-a-tree"
      },
      {
        "text": "NextResponding to Events",
        "href": "/learn/responding-to-events"
      }
    ],
    "meta": {
      "description": "",
      "keywords": ""
    },
    "summary": "Learn ReactAdding InteractivitySome things on the screen update in response to user input. For example, clicking an image gallery switches the active image",
    "tags": [
      "react",
      "angular",
      "javascript",
      "typescript",
      "html",
      "vite",
      "this",
      "ready",
      "learn",
      "topic"
    ],
    "id": "adding-interactivity-react-addinginteractivity-part-1",
    "quality": 100
  },
  {
    "title": "Managing State – React",
    "url": "https://react.dev/learn/managing-state",
    "category": "react",
    "content": "Learn ReactManaging StateIntermediateAs your application grows, it helps to be more intentional about how your state is organized and how the data flows between your components. Redundant or duplicate state is a common source of bugs. In this chapter, youll learn how to structure your state well, how to keep your state update logic maintainable, and how to share state between distant components. In this chapter How to think about UI changes as state changes How to structure state well How to lift state up to share it between components How to control whether the state gets preserved or reset How to consolidate complex state logic in a function How to pass information without prop drilling How to scale state management as your app grows Reacting to input with state With React, you wont modify the UI from code directly. For example, you wont write commands like disable the button, enable the button, show the success message, etc. Instead, you will describe the UI you want to see for the different visual states of your component (initial state, typing state, success state), and then trigger the state changes in response to user input. This is similar to how designers think about UI. Here is a quiz form built using React. Note how it uses the status state variable to determine whether to enable or disable the submit button, and whether to show the success message instead. App.jsApp.js Download ResetForkimport { useState } from 'react'; export default function Form() { const [answer, setAnswer] = useState(''); const [error, setError] = useState(null); const [status, setStatus] = useState('typing'); if (status === 'success') { return h1That's right!/h1 } async function handleSubmit(e) { e.preventDefault(); setStatus('submitting'); try { await submitForm(answer); setStatus('success'); } catch (err) { setStatus('typing'); setError(err); } } function handleTextareaChange(e) { setAnswer(e.target.value); } return (  h2City quiz/h2 p In which city is there a billboard that turns air into drinkable water? /p form onSubmit={handleSubmit} textarea value={answer} onChange={handleTextareaChange} disabled={status === 'submitting'} / br / button disabled={ answer.length === 0  status === 'submitting' } Submit /button {error !== null && p className=\"Error\" {error.message} /p } /form / ); } function submitForm(answer) { // Pretend it's hitting the network. return new Promise((resolve, reject) = { setTimeout(() = { let shouldError = answer.toLowerCase() !== 'lima' if (shouldError) { reject(new Error('Good guess but a wrong answer. Try again!')); } else { resolve(); } }, 1500); }); } Show more Ready to learn this topic?Read Reacting to Input with State to learn how to approach interactions with a state-driven mindset.Read More Choosing the state structure Structuring state well can make a difference between a component that is pleasant to modify and debug, and one that is a constant source of bugs. The most important principle is that state shouldnt contain redundant or duplicated information. If theres unnecessary state, its easy to forget to update it, and introduce bugs! For example, this form has a redundant fullName state variable: App.jsApp.js Download ResetForkimport { useState } from 'react'; export default function Form() { const [firstName, setFirstName] = useState(''); const [lastName, setLastName] = useState(''); const [fullName, setFullName] = useState(''); function handleFirstNameChange(e) { setFirstName(e.target.value); setFullName(e.target.value + ' ' + lastName); } function handleLastNameChange(e) { setLastName(e.target.value); setFullName(firstName + ' ' + e.target.value); } return (  h2Lets check you in/h2 label First name:{' '} input value={firstName} onChange={handleFirstNameChange} / /label label Last name:{' '} input value={lastName} onChange={handleLastNameChange} / /label p Your ticket will be issued to: b{fullName}/b /p / ); } Show more You can remove it and simplify the code by calculating fullName while the component is rendering: App.jsApp.js Download ResetForkimport { useState } from 'react'; export default function Form() { const [firstName, setFirstName] = useState(''); const [lastName, setLastName] = useState(''); const fullName = firstName + ' ' + lastName; function handleFirstNameChange(e) { setFirstName(e.target.value); } function handleLastNameChange(e) { setLastName(e.target.value); } return (  h2Lets check you in/h2 label First name:{' '} input value={firstName} onChange={handleFirstNameChange} / /label label Last name:{' '} input value={lastName} onChange={handleLastNameChange} / /label p Your ticket will be issued to: b{fullName}/b /p / ); } Show more This might seem like a small change, but many bugs in React apps are fixed this way. Ready to learn this topic?Read Choosing the State Structure to learn how to design the state shape to avoid bugs.Read More Sharing state between components Sometimes, you want the state of two components to always change together. To do it, remove state from both of them, move it to their closest common parent, and then pass it down to them via props. This is known as lifting state up, and its one of the most common things you will do writing React code. In this example, only one panel should be active at a time. To achieve this, instead of keeping the active state inside each individual panel, the parent component holds the state and specifies the props for its children. App.jsApp.js Download ResetForkimport { useState } from 'react'; export default function Accordion() { const [activeIndex, setActiveIndex] = useState(0); return (  h2Almaty, Kazakhstan/h2 Panel title=\"About\" isActive={activeIndex === 0} onShow={() = setActiveIndex(0)}  With a population of about 2 million, Almaty is Kazakhstan's largest city. From 1929 to 1997, it was its capital city. /Panel Panel title=\"Etymology\" isActive={activeIndex === 1} onShow={() = setActiveIndex(1)}  The name comes from span lang=\"kk-KZ\"/span, the Kazakh word for \"apple\" and is often translated as \"full of apples\". In fact, the region surrounding Almaty is thought to be the ancestral home of the apple, and the wild i lang=\"la\"Malus sieversii/i is considered a likely candidate for the ancestor of the modern domestic apple. /Panel / ); } function Panel({ title, children, isActive, onShow }) { return ( section className=\"panel\" h3{title}/h3 {isActive ? ( p{children}/p ) : ( button onClick={onShow} Show /button )} /section ); } Show more Ready to learn this topic?Read Sharing State Between Components to learn how to lift state up and keep components in sync.Read More Preserving and resetting state When you re-render a component, React needs to decide which parts of the tree to keep (and update), and which parts to discard or re-create from scratch. In most cases, Reacts automatic behavior works well enough. By default, React preserves the parts of the tree that match up with the previously rendered component tree. However, sometimes this is not what you want. In this chat app, typing a message and then switching the recipient does not reset the input. This can make the user accidentally send a message to the wrong person: App.jsContactList.jsChat.jsApp.js ResetForkimport { useState } from 'react'; import Chat from './Chat.js'; import ContactList from './ContactList.js'; export default function Messenger() { const [to, setTo] = useState(contacts[0]); return ( div ContactList contacts={contacts} selectedContact={to} onSelect={contact = setTo(contact)} / Chat contact={to} / /div ) } const contacts = [ { name: 'Taylor', email: 'taylor@mail.com' }, { name: 'Alice', email: 'alice@mail.com' }, { name: 'Bob', email: 'bob@mail.com' } ]; Show more React lets you override the default behavior, and force a component to reset its state by passing it a different key, like Chat key={email} /. This tells React that if the recipient is different, it should be considered a different Chat component that needs to be re-created from scratch with the new data (and UI like inputs). Now switching between the recipients resets the input fieldeven though you render the same component. App.jsContactList.jsChat.jsApp.js ResetForkimport { useState } from 'react'; import Chat from './Chat.js'; import ContactList from './ContactList.js'; export default function Messenger() { const [to, setTo] = useState(contacts[0]); return ( div ContactList contacts={contacts} selectedContact={to} onSelect={contact = setTo(contact)} / Chat key={to.email} contact={to} / /div ) } const contacts = [ { name: 'Taylor', email: 'taylor@mail.com' }, { name: 'Alice', email: 'alice@mail.com' }, { name: 'Bob', email: 'bob@mail.com' } ]; Show more Ready to learn this topic?Read Preserving and Resetting State to learn the lifetime of state and how to control it.Read More Extracting state logic into a reducer Components with many state updates spread across many event handlers can get overwhelming. For these cases, you can consolidate all the state update logic outside your component in a single function, called reducer. Your event handlers become concise because they only specify the user actions. At the bottom of the file, the reducer function specifies how the state should update in response to each action! App.jsApp.js ResetForkimport { useReducer } from 'react'; import AddTask from './AddTask.js'; import TaskList from './TaskList.js'; export default function TaskApp() { const [tasks, dispatch] = useReducer( tasksReducer, initialTasks ); function handleAddTask(text) { dispatch({ type: 'added', id: nextId++, text: text, }); } function handleChangeTask(task) { dispatch({ type: 'changed', task: task }); } function handleDeleteTask(taskId) { dispatch({ type: 'deleted', id: taskId }); } return (  h1Prague itinerary/h1 AddTask onAddTask={handleAddTask} / TaskList tasks={tasks} onChangeTask={handleChangeTask} onDeleteTask={handleDeleteTask} / / ); } function tasksReducer(tasks, action) { switch (action.type) { case 'added': { return [...tasks, { id: action.id, text: action.text, done: false }]; } case 'changed': { return tasks.map(t = { if (t.id === action.task.id) { return action.task; } else { return t; } }); } case 'deleted': { return tasks.filter(t = t.id !== action.id); } default: { throw Error('Unknown action: ' + action.type); } } } let nextId = 3; const initialTasks = [ { id: 0, text: 'Visit Kafka Museum', done: true }, { id: 1, text: 'Watch a puppet show', done: false }, { id: 2, text: 'Lennon Wall pic', done: false } ]; Show more Ready to learn this topic?Read Extracting State Logic into a Reducer to learn how to consolidate logic in the reducer function.Read More Passing data deeply with context Usually, you will pass information from a parent component to a child component via props. But passing props can become inconvenient if you need to pass some prop through many components, or if many components need the same information. Context lets the parent component make some information available to any component in the tree below itno matter how deep it iswithout passing it explicitly through props. Here, the Heading component determines its heading level by asking the closest Section for its level. Each Section tracks its own level by asking the parent Section and adding one to it. Every Section provides information to all components below it without passing propsit does that through context. App.jsSection.jsHeading.jsLevelContext.jsApp.js ResetForkimport Heading from './Heading.js'; import Section from './Section.js'; export default function Page() { return ( Section HeadingTitle/Heading Section HeadingHeading/Heading HeadingHeading/Heading HeadingHeading/Heading Section HeadingSub-heading/Heading HeadingSub-heading/Heading HeadingSub-heading/Heading Section HeadingSub-sub-heading/Heading HeadingSub-sub-heading/Heading HeadingSub-sub-heading/Heading /Section /Section /Section /Section ); } Show more Ready to learn this topic?Read Passing Data Deeply with Context to learn about using context as an alternative to passing props.Read More Scaling up with reducer and context Reducers let you consolidate a components state update logic. Context lets you pass information deep down to other components. You can combine reducers and context together to manage state of a complex screen. With this approach, a parent component with complex state manages it with a reducer. Other components anywhere deep in the tree can read its state via context. They can also dispatch actions to update that state. App.jsTasksContext.jsAddTask.jsTaskList.jsApp.js ResetForkimport AddTask from './AddTask.js'; import TaskList from './TaskList.js'; import { TasksProvider } from './TasksContext.js'; export default function TaskApp() { return ( TasksProvider h1Day off in Kyoto/h1 AddTask / TaskList / /TasksProvider ); } Ready to learn this topic?Read Scaling Up with Reducer and Context to learn how state management scales in a growing app.Read More Whats next? Head over to Reacting to Input with State to start reading this chapter page by page! Or, if youre already familiar with these topics, why not read about Escape Hatches?PreviousUpdating Arrays in StateNextReacting to Input with State",
    "headings": [
      {
        "level": 1,
        "text": "Managing State",
        "id": ""
      },
      {
        "level": 2,
        "text": "Reacting to input with state",
        "id": "reacting-to-input-with-state"
      },
      {
        "level": 2,
        "text": "Ready to learn this topic?",
        "id": ""
      },
      {
        "level": 2,
        "text": "Choosing the state structure",
        "id": "choosing-the-state-structure"
      },
      {
        "level": 2,
        "text": "Ready to learn this topic?",
        "id": ""
      },
      {
        "level": 2,
        "text": "Sharing state between components",
        "id": "sharing-state-between-components"
      },
      {
        "level": 2,
        "text": "Ready to learn this topic?",
        "id": ""
      },
      {
        "level": 2,
        "text": "Preserving and resetting state",
        "id": "preserving-and-resetting-state"
      },
      {
        "level": 2,
        "text": "Ready to learn this topic?",
        "id": ""
      },
      {
        "level": 2,
        "text": "Extracting state logic into a reducer",
        "id": "extracting-state-logic-into-a-reducer"
      },
      {
        "level": 2,
        "text": "Ready to learn this topic?",
        "id": ""
      },
      {
        "level": 2,
        "text": "Passing data deeply with context",
        "id": "passing-data-deeply-with-context"
      },
      {
        "level": 2,
        "text": "Ready to learn this topic?",
        "id": ""
      },
      {
        "level": 2,
        "text": "Scaling up with reducer and context",
        "id": "scaling-up-with-reducer-and-context"
      },
      {
        "level": 2,
        "text": "Ready to learn this topic?",
        "id": ""
      },
      {
        "level": 2,
        "text": "What’s next?",
        "id": "whats-next"
      },
      {
        "level": 3,
        "text": "In this chapter",
        "id": ""
      }
    ],
    "codeBlocks": [
      {
        "language": "text",
        "code": "import { useState } from 'react';\n\nexport default function Form() {\n  const [answer, setAnswer] = useState('');\n  const [error, setError] = useState(null);\n  const [status, setStatus] = useState('typing');\n\n  if (status === 'success') {\n    return <h1>That's right!</h1>\n  }\n\n  async function handleSubmit(e) {\n    e.preventDefault();\n    setStatus('submitting');\n    try {\n      await submitForm(answer);\n      setStatus('success');\n    } catch (err) {\n      setStatus('typing');\n      setError(err);\n    }\n  }\n\n  function handleTextareaChange(e) {\n    setAnswer(e.target.value);\n  }\n\n  return (\n    <>\n      <h2>City quiz</h2>\n      <p>\n        In which city is there a billboard that turns air into drinkable water?\n      </p>\n      <form onSubmit={handleSubmit}>\n        <textarea\n          value={answer}\n          onChange={handleTextareaChange}\n          disabled={status === 'submitting'}\n        />\n        <br />\n        <button disabled={\n          answer.length === 0 ||\n          status === 'submitting'\n        }>\n          Submit\n        </button>\n        {error !== null &&\n          <p className=\"Error\">\n            {error.message}\n          </p>\n        }\n      </form>\n    </>\n  );\n}\n\nfunction submitForm(answer) {\n  // Pretend it's hitting the network.\n  return new Promise((resolve, reject) => {\n    setTimeout(() => {\n      let shouldError = answer.toLowerCase() !== 'lima'\n      if (shouldError) {\n        reject(new Error('Good guess but a wrong answer. Try again!'));\n      } else {\n        resolve();\n      }\n    }, 1500);\n  });\n}"
      },
      {
        "language": "text",
        "code": "import { useState } from 'react';\n\nexport default function Form() {\n  const [firstName, setFirstName] = useState('');\n  const [lastName, setLastName] = useState('');\n  const [fullName, setFullName] = useState('');\n\n  function handleFirstNameChange(e) {\n    setFirstName(e.target.value);\n    setFullName(e.target.value + ' ' + lastName);\n  }\n\n  function handleLastNameChange(e) {\n    setLastName(e.target.value);\n    setFullName(firstName + ' ' + e.target.value);\n  }\n\n  return (\n    <>\n      <h2>Let’s check you in</h2>\n      <label>\n        First name:{' '}\n        <input\n          value={firstName}\n          onChange={handleFirstNameChange}\n        />\n      </label>\n      <label>\n        Last name:{' '}\n        <input\n          value={lastName}\n          onChange={handleLastNameChange}\n        />\n      </label>\n      <p>\n        Your ticket will be issued to: <b>{fullName}</b>\n      </p>\n    </>\n  );\n}"
      },
      {
        "language": "text",
        "code": "import { useState } from 'react';\n\nexport default function Form() {\n  const [firstName, setFirstName] = useState('');\n  const [lastName, setLastName] = useState('');\n\n  const fullName = firstName + ' ' + lastName;\n\n  function handleFirstNameChange(e) {\n    setFirstName(e.target.value);\n  }\n\n  function handleLastNameChange(e) {\n    setLastName(e.target.value);\n  }\n\n  return (\n    <>\n      <h2>Let’s check you in</h2>\n      <label>\n        First name:{' '}\n        <input\n          value={firstName}\n          onChange={handleFirstNameChange}\n        />\n      </label>\n      <label>\n        Last name:{' '}\n        <input\n          value={lastName}\n          onChange={handleLastNameChange}\n        />\n      </label>\n      <p>\n        Your ticket will be issued to: <b>{fullName}</b>\n      </p>\n    </>\n  );\n}"
      },
      {
        "language": "text",
        "code": "import { useState } from 'react';\n\nexport default function Accordion() {\n  const [activeIndex, setActiveIndex] = useState(0);\n  return (\n    <>\n      <h2>Almaty, Kazakhstan</h2>\n      <Panel\n        title=\"About\"\n        isActive={activeIndex === 0}\n        onShow={() => setActiveIndex(0)}\n      >\n        With a population of about 2 million, Almaty is Kazakhstan's largest city. From 1929 to 1997, it was its capital city.\n      </Panel>\n      <Panel\n        title=\"Etymology\"\n        isActive={activeIndex === 1}\n        onShow={() => setActiveIndex(1)}\n      >\n        The name comes from <span lang=\"kk-KZ\">алма</span>, the Kazakh word for \"apple\" and is often translated as \"full of apples\". In fact, the region surrounding Almaty is thought to be the ancestral home of the apple, and the wild <i lang=\"la\">Malus sieversii</i> is considered a likely candidate for the ancestor of the modern domestic apple.\n      </Panel>\n    </>\n  );\n}\n\nfunction Panel({\n  title,\n  children,\n  isActive,\n  onShow\n}) {\n  return (\n    <section className=\"panel\">\n      <h3>{title}</h3>\n      {isActive ? (\n        <p>{children}</p>\n      ) : (\n        <button onClick={onShow}>\n          Show\n        </button>\n      )}\n    </section>\n  );\n}"
      },
      {
        "language": "text",
        "code": "import { useState } from 'react';\nimport Chat from './Chat.js';\nimport ContactList from './ContactList.js';\n\nexport default function Messenger() {\n  const [to, setTo] = useState(contacts[0]);\n  return (\n    <div>\n      <ContactList\n        contacts={contacts}\n        selectedContact={to}\n        onSelect={contact => setTo(contact)}\n      />\n      <Chat contact={to} />\n    </div>\n  )\n}\n\nconst contacts = [\n  { name: 'Taylor', email: 'taylor@mail.com' },\n  { name: 'Alice', email: 'alice@mail.com' },\n  { name: 'Bob', email: 'bob@mail.com' }\n];"
      },
      {
        "language": "text",
        "code": "<Chat key={email} />"
      },
      {
        "language": "text",
        "code": "import { useState } from 'react';\nimport Chat from './Chat.js';\nimport ContactList from './ContactList.js';\n\nexport default function Messenger() {\n  const [to, setTo] = useState(contacts[0]);\n  return (\n    <div>\n      <ContactList\n        contacts={contacts}\n        selectedContact={to}\n        onSelect={contact => setTo(contact)}\n      />\n      <Chat key={to.email} contact={to} />\n    </div>\n  )\n}\n\nconst contacts = [\n  { name: 'Taylor', email: 'taylor@mail.com' },\n  { name: 'Alice', email: 'alice@mail.com' },\n  { name: 'Bob', email: 'bob@mail.com' }\n];"
      },
      {
        "language": "text",
        "code": "import { useReducer } from 'react';\nimport AddTask from './AddTask.js';\nimport TaskList from './TaskList.js';\n\nexport default function TaskApp() {\n  const [tasks, dispatch] = useReducer(\n    tasksReducer,\n    initialTasks\n  );\n\n  function handleAddTask(text) {\n    dispatch({\n      type: 'added',\n      id: nextId++,\n      text: text,\n    });\n  }\n\n  function handleChangeTask(task) {\n    dispatch({\n      type: 'changed',\n      task: task\n    });\n  }\n\n  function handleDeleteTask(taskId) {\n    dispatch({\n      type: 'deleted',\n      id: taskId\n    });\n  }\n\n  return (\n    <>\n      <h1>Prague itinerary</h1>\n      <AddTask\n        onAddTask={handleAddTask}\n      />\n      <TaskList\n        tasks={tasks}\n        onChangeTask={handleChangeTask}\n        onDeleteTask={handleDeleteTask}\n      />\n    </>\n  );\n}\n\nfunction tasksReducer(tasks, action) {\n  switch (action.type) {\n    case 'added': {\n      return [...tasks, {\n        id: action.id,\n        text: action.text,\n        done: false\n      }];\n    }\n    case 'changed': {\n      return tasks.map(t => {\n        if (t.id === action.task.id) {\n          return action.task;\n        } else {\n          return t;\n        }\n      });\n    }\n    case 'deleted': {\n      return tasks.filter(t => t.id !== action.id);\n    }\n    default: {\n      throw Error('Unknown action: ' + action.type);\n    }\n  }\n}\n\nlet nextId = 3;\nconst initialTasks = [\n  { id: 0, text: 'Visit Kafka Museum', done: true },\n  { id: 1, text: 'Watch a puppet show', done: false },\n  { id: 2, text: 'Lennon Wall pic', done: false }\n];"
      },
      {
        "language": "text",
        "code": "import Heading from './Heading.js';\nimport Section from './Section.js';\n\nexport default function Page() {\n  return (\n    <Section>\n      <Heading>Title</Heading>\n      <Section>\n        <Heading>Heading</Heading>\n        <Heading>Heading</Heading>\n        <Heading>Heading</Heading>\n        <Section>\n          <Heading>Sub-heading</Heading>\n          <Heading>Sub-heading</Heading>\n          <Heading>Sub-heading</Heading>\n          <Section>\n            <Heading>Sub-sub-heading</Heading>\n            <Heading>Sub-sub-heading</Heading>\n            <Heading>Sub-sub-heading</Heading>\n          </Section>\n        </Section>\n      </Section>\n    </Section>\n  );\n}"
      },
      {
        "language": "text",
        "code": "import AddTask from './AddTask.js';\nimport TaskList from './TaskList.js';\nimport { TasksProvider } from './TasksContext.js';\n\nexport default function TaskApp() {\n  return (\n    <TasksProvider>\n      <h1>Day off in Kyoto</h1>\n      <AddTask />\n      <TaskList />\n    </TasksProvider>\n  );\n}"
      }
    ],
    "links": [
      {
        "text": "Learn React",
        "href": "/learn"
      },
      {
        "text": "How to think about UI changes as state changes",
        "href": "/learn/reacting-to-input-with-state"
      },
      {
        "text": "How to structure state well",
        "href": "/learn/choosing-the-state-structure"
      },
      {
        "text": "How to “lift state up” to share it between components",
        "href": "/learn/sharing-state-between-components"
      },
      {
        "text": "How to control whether the state gets preserved or reset",
        "href": "/learn/preserving-and-resetting-state"
      },
      {
        "text": "How to consolidate complex state logic in a function",
        "href": "/learn/extracting-state-logic-into-a-reducer"
      },
      {
        "text": "How to pass information without “prop drilling”",
        "href": "/learn/passing-data-deeply-with-context"
      },
      {
        "text": "How to scale state management as your app grows",
        "href": "/learn/scaling-up-with-reducer-and-context"
      },
      {
        "text": "Reacting to Input with State",
        "href": "/learn/reacting-to-input-with-state"
      },
      {
        "text": "Read More",
        "href": "/learn/reacting-to-input-with-state"
      },
      {
        "text": "Choosing the State Structure",
        "href": "/learn/choosing-the-state-structure"
      },
      {
        "text": "Read More",
        "href": "/learn/choosing-the-state-structure"
      },
      {
        "text": "Sharing State Between Components",
        "href": "/learn/sharing-state-between-components"
      },
      {
        "text": "Read More",
        "href": "/learn/sharing-state-between-components"
      },
      {
        "text": "Preserving and Resetting State",
        "href": "/learn/preserving-and-resetting-state"
      },
      {
        "text": "Read More",
        "href": "/learn/preserving-and-resetting-state"
      },
      {
        "text": "Extracting State Logic into a Reducer",
        "href": "/learn/extracting-state-logic-into-a-reducer"
      },
      {
        "text": "Read More",
        "href": "/learn/extracting-state-logic-into-a-reducer"
      },
      {
        "text": "Passing Data Deeply with Context",
        "href": "/learn/passing-data-deeply-with-context"
      },
      {
        "text": "Read More",
        "href": "/learn/passing-data-deeply-with-context"
      },
      {
        "text": "Scaling Up with Reducer and Context",
        "href": "/learn/scaling-up-with-reducer-and-context"
      },
      {
        "text": "Read More",
        "href": "/learn/scaling-up-with-reducer-and-context"
      },
      {
        "text": "Reacting to Input with State",
        "href": "/learn/reacting-to-input-with-state"
      },
      {
        "text": "Escape Hatches",
        "href": "/learn/escape-hatches"
      },
      {
        "text": "PreviousUpdating Arrays in State",
        "href": "/learn/updating-arrays-in-state"
      },
      {
        "text": "NextReacting to Input with State",
        "href": "/learn/reacting-to-input-with-state"
      }
    ],
    "meta": {
      "description": "",
      "keywords": ""
    },
    "summary": "Learn ReactManaging StateIntermediateAs your application grows, it helps to be more intentional about how your state is organized and how the data flows between your components",
    "tags": [
      "react",
      "angular",
      "javascript",
      "typescript",
      "html",
      "vite",
      "this",
      "state",
      "ready",
      "learn"
    ],
    "id": "managing-state-react-managingstate-part-1",
    "quality": 100
  },
  {
    "title": "memo – React",
    "url": "https://react.dev/reference/react/memo",
    "category": "react",
    "content": "API ReferenceAPIsmemomemo lets you skip re-rendering a component when its props are unchanged.const MemoizedComponent = memo(SomeComponent, arePropsEqual?) NoteReact Compiler automatically applies the equivalent of memo to all components, reducing the need for manual memoization. You can use the compiler to handle component memoization automatically. Reference memo(Component, arePropsEqual?) Usage Skipping re-rendering when props are unchanged Updating a memoized component using state Updating a memoized component using a context Minimizing props changes Specifying a custom comparison function Do I still need React.memo if I use React Compiler? Troubleshooting My component re-renders when a prop is an object, array, or function Reference memo(Component, arePropsEqual?) Wrap a component in memo to get a memoized version of that component. This memoized version of your component will usually not be re-rendered when its parent component is re-rendered as long as its props have not changed. But React may still re-render it: memoization is a performance optimization, not a guarantee. import { memo } from 'react';const SomeComponent = memo(function SomeComponent(props) { // ...}); See more examples below. Parameters Component: The component that you want to memoize. The memo does not modify this component, but returns a new, memoized component instead. Any valid React component, including functions and forwardRef components, is accepted. optional arePropsEqual: A function that accepts two arguments: the components previous props, and its new props. It should return true if the old and new props are equal: that is, if the component will render the same output and behave in the same way with the new props as with the old. Otherwise it should return false. Usually, you will not specify this function. By default, React will compare each prop with Object.is. Returns memo returns a new React component. It behaves the same as the component provided to memo except that React will not always re-render it when its parent is being re-rendered unless its props have changed. Usage Skipping re-rendering when props are unchanged React normally re-renders a component whenever its parent re-renders. With memo, you can create a component that React will not re-render when its parent re-renders so long as its new props are the same as the old props. Such a component is said to be memoized. To memoize a component, wrap it in memo and use the value that it returns in place of your original component: const Greeting = memo(function Greeting({ name }) { return h1Hello, {name}!/h1;});export default Greeting; A React component should always have pure rendering logic. This means that it must return the same output if its props, state, and context havent changed. By using memo, you are telling React that your component complies with this requirement, so React doesnt need to re-render as long as its props havent changed. Even with memo, your component will re-render if its own state changes or if a context that its using changes. In this example, notice that the Greeting component re-renders whenever name is changed (because thats one of its props), but not when address is changed (because its not passed to Greeting as a prop): App.jsApp.js Download ResetForkimport { memo, useState } from 'react'; export default function MyApp() { const [name, setName] = useState(''); const [address, setAddress] = useState(''); return (  label Name{': '} input value={name} onChange={e = setName(e.target.value)} / /label label Address{': '} input value={address} onChange={e = setAddress(e.target.value)} / /label Greeting name={name} / / ); } const Greeting = memo(function Greeting({ name }) { console.log(\"Greeting was rendered at\", new Date().toLocaleTimeString()); return h3Hello{name && ', '}{name}!/h3; }); Show more NoteYou should only rely on memo as a performance optimization. If your code doesnt work without it, find the underlying problem and fix it first. Then you may add memo to improve performance. Deep DiveShould you add memo everywhere? Show DetailsIf your app is like this site, and most interactions are coarse (like replacing a page or an entire section), memoization is usually unnecessary. On the other hand, if your app is more like a drawing editor, and most interactions are granular (like moving shapes), then you might find memoization very helpful.Optimizing with memo is only valuable when your component re-renders often with the same exact props, and its re-rendering logic is expensive. If there is no perceptible lag when your component re-renders, memo is unnecessary. Keep in mind that memo is completely useless if the props passed to your component are always different, such as if you pass an object or a plain function defined during rendering. This is why you will often need useMemo and useCallback together with memo.There is no benefit to wrapping a component in memo in other cases. There is no significant harm to doing that either, so some teams choose to not think about individual cases, and memoize as much as possible. The downside of this approach is that code becomes less readable. Also, not all memoization is effective: a single value thats always new is enough to break memoization for an entire component.In practice, you can make a lot of memoization unnecessary by following a few principles: When a component visually wraps other components, let it accept JSX as children. This way, when the wrapper component updates its own state, React knows that its children dont need to re-render. Prefer local state and dont lift state up any further than necessary. For example, dont keep transient state like forms and whether an item is hovered at the top of your tree or in a global state library. Keep your rendering logic pure. If re-rendering a component causes a problem or produces some noticeable visual artifact, its a bug in your component! Fix the bug instead of adding memoization. Avoid unnecessary Effects that update state. Most performance problems in React apps are caused by chains of updates originating from Effects that cause your components to render over and over. Try to remove unnecessary dependencies from your Effects. For example, instead of memoization, its often simpler to move some object or a function inside an Effect or outside the component. If a specific interaction still feels laggy, use the React Developer Tools profiler to see which components would benefit the most from memoization, and add memoization where needed. These principles make your components easier to debug and understand, so its good to follow them in any case. In the long term, were researching doing granular memoization automatically to solve this once and for all. Updating a memoized component using state Even when a component is memoized, it will still re-render when its own state changes. Memoization only has to do with props that are passed to the component from its parent. App.jsApp.js Download ResetForkimport { memo, useState } from 'react'; export default function MyApp() { const [name, setName] = useState(''); const [address, setAddress] = useState(''); return (  label Name{': '} input value={name} onChange={e = setName(e.target.value)} / /label label Address{': '} input value={address} onChange={e = setAddress(e.target.value)} / /label Greeting name={name} / / ); } const Greeting = memo(function Greeting({ name }) { console.log('Greeting was rendered at', new Date().toLocaleTimeString()); const [greeting, setGreeting] = useState('Hello'); return (  h3{greeting}{name && ', '}{name}!/h3 GreetingSelector value={greeting} onChange={setGreeting} / / ); }); function GreetingSelector({ value, onChange }) { return (  label input type=\"radio\" checked={value === 'Hello'} onChange={e = onChange('Hello')} / Regular greeting /label label input type=\"radio\" checked={value === 'Hello and welcome'} onChange={e = onChange('Hello and welcome')} / Enthusiastic greeting /label / ); } Show more If you set a state variable to its current value, React will skip re-rendering your component even without memo. You may still see your component function being called an extra time, but the result will be discarded. Updating a memoized component using a context Even when a component is memoized, it will still re-render when a context that its using changes. Memoization only has to do with props that are passed to the component from its parent. App.jsApp.js Download ResetForkimport { createContext, memo, useContext, useState } from 'react'; const ThemeContext = createContext(null); export default function MyApp() { const [theme, setTheme] = useState('dark'); function handleClick() { setTheme(theme === 'dark' ? 'light' : 'dark'); } return ( ThemeContext value={theme} button onClick={handleClick} Switch theme /button Greeting name=\"Taylor\" / /ThemeContext ); } const Greeting = memo(function Greeting({ name }) { console.log(\"Greeting was rendered at\", new Date().toLocaleTimeString()); const theme = useContext(ThemeContext); return ( h3 className={theme}Hello, {name}!/h3 ); }); Show more To make your component re-render only when a part of some context changes, split your component in two. Read what you need from the context in the outer component, and pass it down to a memoized child as a prop. Minimizing props changes When you use memo, your component re-renders whenever any prop is not shallowly equal to what it was previously. This means that React compares every prop in your component with its previous value using the Object.is comparison. Note that Object.is(3, 3) is true, but Object.is({}, {}) is false. To get the most out of memo, minimize the times that the props change. For example, if the prop is an object, prevent the parent component from re-creating that object every time by using useMemo: function Page() { const [name, setName] = useState('Taylor'); const [age, setAge] = useState(42); const person = useMemo( () = ({ name, age }), [name, age] ); return Profile person={person} /;}const Profile = memo(function Profile({ person }) { // ...}); A better way to minimize props changes is to make sure the component accepts the minimum necessary information in its props. For example, it could accept individual values instead of a whole object: function Page() { const [name, setName] = useState('Taylor'); const [age, setAge] = useState(42); return Profile name={name} age={age} /;}const Profile = memo(function Profile({ name, age }) { // ...}); Even individual values can sometimes be projected to ones that change less frequently. For example, here a component accepts a boolean indicating the presence of a value rather than the value itself: function GroupsLanding({ person }) { const hasGroups = person.groups !== null; return CallToAction hasGroups={hasGroups} /;}const CallToAction = memo(function CallToAction({ hasGroups }) { // ...}); When you need to pass a function to memoized component, either declare it outside your component so that it never changes, or useCallback to cache its definition between re-renders. Specifying a custom comparison function In rare cases it may be infeasible to minimize the props changes of a memoized component. In that case, you can provide a custom comparison function, which React will use to compare the old and new props instead of using shallow equality. This function is passed as a second argument to memo. It should return true only if the new props would result in the same output as the old props; otherwise it should return false. const Chart = memo(function Chart({ dataPoints }) { // ...}, arePropsEqual);function arePropsEqual(oldProps, newProps) { return ( oldProps.dataPoints.length === newProps.dataPoints.length && oldProps.dataPoints.every((oldPoint, index) = { const newPoint = newProps.dataPoints[index]; return oldPoint.x === newPoint.x && oldPoint.y === newPoint.y; }) );} If you do this, use the Performance panel in your browser developer tools to make sure that your comparison function is actually faster than re-rendering the component. You might be surprised. When you do performance measurements, make sure that React is running in the production mode. PitfallIf you provide a custom arePropsEqual implementation, you must compare every prop, including functions. Functions often close over the props and state of parent components. If you return true when oldProps.onClick !== newProps.onClick, your component will keep seeing the props and state from a previous render inside its onClick handler, leading to very confusing bugs.Avoid doing deep equality checks inside arePropsEqual unless you are 100% sure that the data structure youre working with has a known limited depth. Deep equality checks can become incredibly slow and can freeze your app for many seconds if someone changes the data structure later. Do I still need React.memo if I use React Compiler? When you enable React Compiler, you typically dont need React.memo anymore. The compiler automatically optimizes component re-rendering for you. Heres how it works: Without React Compiler, you need React.memo to prevent unnecessary re-renders: // Parent re-renders every secondfunction Parent() { const [seconds, setSeconds] = useState(0); useEffect(() = { const interval = setInterval(() = { setSeconds(s = s + 1); }, 1000); return () = clearInterval(interval); }, []); return (  h1Seconds: {seconds}/h1 ExpensiveChild name=\"John\" / / );}// Without memo, this re-renders every second even though props don't changeconst ExpensiveChild = memo(function ExpensiveChild({ name }) { console.log('ExpensiveChild rendered'); return divHello, {name}!/div;}); With React Compiler enabled, the same optimization happens automatically: // No memo needed - compiler prevents re-renders automaticallyfunction ExpensiveChild({ name }) { console.log('ExpensiveChild rendered'); return divHello, {name}!/div;} Heres the key part of what the React Compiler generates: function Parent() { const $ = _c(7); const [seconds, setSeconds] = useState(0); // ... other code ... let t3; if ($[4] === Symbol.for(\"react.memo_cache_sentinel\")) { t3 = ExpensiveChild name=\"John\" /; $[4] = t3; } else { t3 = $[4]; } // ... return statement ...} Notice the highlighted lines: The compiler wraps ExpensiveChild name=\"John\" / in a cache check. Since the name prop is always \"John\", this JSX is created once and reused on every parent re-render. This is exactly what React.memo does - it prevents the child from re-rendering when its props havent changed. The React Compiler automatically: Tracks that the name prop passed to ExpensiveChild hasnt changed Reuses the previously created JSX for ExpensiveChild name=\"John\" / Skips re-rendering ExpensiveChild entirely This means you can safely remove React.memo from your components when using React Compiler. The compiler provides the same optimization automatically, making your code cleaner and easier to maintain. NoteThe compilers optimization is actually more comprehensive than React.memo. It also memoizes intermediate values and expensive computations within your components, similar to combining React.memo with useMemo throughout your component tree. Troubleshooting My component re-renders when a prop is an object, array, or function React compares old and new props by shallow equality: that is, it considers whether each new prop is reference-equal to the old prop. If you create a new object or array each time the parent is re-rendered, even if the individual elements are each the same, React will still consider it to be changed. Similarly, if you create a new function when rendering the parent component, React will consider it to have changed even if the function has the same definition. To avoid this, simplify props or memoize props in the parent component.PreviouslazyNextstartTransition",
    "headings": [
      {
        "level": 1,
        "text": "memo",
        "id": ""
      },
      {
        "level": 2,
        "text": "Reference",
        "id": "reference"
      },
      {
        "level": 2,
        "text": "Usage",
        "id": "usage"
      },
      {
        "level": 2,
        "text": "Troubleshooting",
        "id": "troubleshooting"
      },
      {
        "level": 3,
        "text": "Note",
        "id": ""
      },
      {
        "level": 3,
        "text": "memo(Component, arePropsEqual?)",
        "id": "memo"
      },
      {
        "level": 3,
        "text": "Skipping re-rendering when props are unchanged",
        "id": "skipping-re-rendering-when-props-are-unchanged"
      },
      {
        "level": 3,
        "text": "Note",
        "id": ""
      },
      {
        "level": 3,
        "text": "Updating a memoized component using state",
        "id": "updating-a-memoized-component-using-state"
      },
      {
        "level": 3,
        "text": "Updating a memoized component using a context",
        "id": "updating-a-memoized-component-using-a-context"
      },
      {
        "level": 3,
        "text": "Minimizing props changes",
        "id": "minimizing-props-changes"
      },
      {
        "level": 3,
        "text": "Specifying a custom comparison function",
        "id": "specifying-a-custom-comparison-function"
      },
      {
        "level": 3,
        "text": "Pitfall",
        "id": ""
      },
      {
        "level": 3,
        "text": "Do I still need React.memo if I use React Compiler?",
        "id": "react-compiler-memo"
      },
      {
        "level": 3,
        "text": "Note",
        "id": ""
      },
      {
        "level": 3,
        "text": "My component re-renders when a prop is an object, array, or function",
        "id": "my-component-rerenders-when-a-prop-is-an-object-or-array"
      },
      {
        "level": 4,
        "text": "Parameters",
        "id": "parameters"
      },
      {
        "level": 4,
        "text": "Returns",
        "id": "returns"
      },
      {
        "level": 4,
        "text": "Should you add memo everywhere?",
        "id": "should-you-add-memo-everywhere"
      },
      {
        "level": 5,
        "text": "Deep Dive",
        "id": ""
      }
    ],
    "codeBlocks": [
      {
        "language": "text",
        "code": "const MemoizedComponent = memo(SomeComponent, arePropsEqual?)"
      },
      {
        "language": "text",
        "code": "const MemoizedComponent = memo(SomeComponent, arePropsEqual?)"
      },
      {
        "language": "text",
        "code": "memo(Component, arePropsEqual?)"
      },
      {
        "language": "text",
        "code": "memo(Component, arePropsEqual?)"
      },
      {
        "language": "text",
        "code": "import { memo } from 'react';const SomeComponent = memo(function SomeComponent(props) {  // ...});"
      },
      {
        "language": "text",
        "code": "import { memo } from 'react';const SomeComponent = memo(function SomeComponent(props) {  // ...});"
      },
      {
        "language": "text",
        "code": "arePropsEqual"
      },
      {
        "language": "text",
        "code": "const Greeting = memo(function Greeting({ name }) {  return <h1>Hello, {name}!</h1>;});export default Greeting;"
      },
      {
        "language": "text",
        "code": "const Greeting = memo(function Greeting({ name }) {  return <h1>Hello, {name}!</h1>;});export default Greeting;"
      },
      {
        "language": "text",
        "code": "import { memo, useState } from 'react';\n\nexport default function MyApp() {\n  const [name, setName] = useState('');\n  const [address, setAddress] = useState('');\n  return (\n    <>\n      <label>\n        Name{': '}\n        <input value={name} onChange={e => setName(e.target.value)} />\n      </label>\n      <label>\n        Address{': '}\n        <input value={address} onChange={e => setAddress(e.target.value)} />\n      </label>\n      <Greeting name={name} />\n    </>\n  );\n}\n\nconst Greeting = memo(function Greeting({ name }) {\n  console.log(\"Greeting was rendered at\", new Date().toLocaleTimeString());\n  return <h3>Hello{name && ', '}{name}!</h3>;\n});"
      },
      {
        "language": "text",
        "code": "useCallback"
      },
      {
        "language": "text",
        "code": "import { memo, useState } from 'react';\n\nexport default function MyApp() {\n  const [name, setName] = useState('');\n  const [address, setAddress] = useState('');\n  return (\n    <>\n      <label>\n        Name{': '}\n        <input value={name} onChange={e => setName(e.target.value)} />\n      </label>\n      <label>\n        Address{': '}\n        <input value={address} onChange={e => setAddress(e.target.value)} />\n      </label>\n      <Greeting name={name} />\n    </>\n  );\n}\n\nconst Greeting = memo(function Greeting({ name }) {\n  console.log('Greeting was rendered at', new Date().toLocaleTimeString());\n  const [greeting, setGreeting] = useState('Hello');\n  return (\n    <>\n      <h3>{greeting}{name && ', '}{name}!</h3>\n      <GreetingSelector value={greeting} onChange={setGreeting} />\n    </>\n  );\n});\n\nfunction GreetingSelector({ value, onChange }) {\n  return (\n    <>\n      <label>\n        <input\n          type=\"radio\"\n          checked={value === 'Hello'}\n          onChange={e => onChange('Hello')}\n        />\n        Regular greeting\n      </label>\n      <label>\n        <input\n          type=\"radio\"\n          checked={value === 'Hello and welcome'}\n          onChange={e => onChange('Hello and welcome')}\n        />\n        Enthusiastic greeting\n      </label>\n    </>\n  );\n}"
      },
      {
        "language": "text",
        "code": "import { createContext, memo, useContext, useState } from 'react';\n\nconst ThemeContext = createContext(null);\n\nexport default function MyApp() {\n  const [theme, setTheme] = useState('dark');\n\n  function handleClick() {\n    setTheme(theme === 'dark' ? 'light' : 'dark');\n  }\n\n  return (\n    <ThemeContext value={theme}>\n      <button onClick={handleClick}>\n        Switch theme\n      </button>\n      <Greeting name=\"Taylor\" />\n    </ThemeContext>\n  );\n}\n\nconst Greeting = memo(function Greeting({ name }) {\n  console.log(\"Greeting was rendered at\", new Date().toLocaleTimeString());\n  const theme = useContext(ThemeContext);\n  return (\n    <h3 className={theme}>Hello, {name}!</h3>\n  );\n});"
      },
      {
        "language": "text",
        "code": "Object.is(3, 3)"
      },
      {
        "language": "text",
        "code": "Object.is({}, {})"
      },
      {
        "language": "text",
        "code": "function Page() {  const [name, setName] = useState('Taylor');  const [age, setAge] = useState(42);  const person = useMemo(    () => ({ name, age }),    [name, age]  );  return <Profile person={person} />;}const Profile = memo(function Profile({ person }) {  // ...});"
      },
      {
        "language": "text",
        "code": "function Page() {  const [name, setName] = useState('Taylor');  const [age, setAge] = useState(42);  const person = useMemo(    () => ({ name, age }),    [name, age]  );  return <Profile person={person} />;}const Profile = memo(function Profile({ person }) {  // ...});"
      },
      {
        "language": "text",
        "code": "function Page() {  const [name, setName] = useState('Taylor');  const [age, setAge] = useState(42);  return <Profile name={name} age={age} />;}const Profile = memo(function Profile({ name, age }) {  // ...});"
      },
      {
        "language": "text",
        "code": "function Page() {  const [name, setName] = useState('Taylor');  const [age, setAge] = useState(42);  return <Profile name={name} age={age} />;}const Profile = memo(function Profile({ name, age }) {  // ...});"
      },
      {
        "language": "text",
        "code": "function GroupsLanding({ person }) {  const hasGroups = person.groups !== null;  return <CallToAction hasGroups={hasGroups} />;}const CallToAction = memo(function CallToAction({ hasGroups }) {  // ...});"
      },
      {
        "language": "text",
        "code": "function GroupsLanding({ person }) {  const hasGroups = person.groups !== null;  return <CallToAction hasGroups={hasGroups} />;}const CallToAction = memo(function CallToAction({ hasGroups }) {  // ...});"
      },
      {
        "language": "text",
        "code": "useCallback"
      },
      {
        "language": "text",
        "code": "const Chart = memo(function Chart({ dataPoints }) {  // ...}, arePropsEqual);function arePropsEqual(oldProps, newProps) {  return (    oldProps.dataPoints.length === newProps.dataPoints.length &&    oldProps.dataPoints.every((oldPoint, index) => {      const newPoint = newProps.dataPoints[index];      return oldPoint.x === newPoint.x && oldPoint.y === newPoint.y;    })  );}"
      },
      {
        "language": "text",
        "code": "const Chart = memo(function Chart({ dataPoints }) {  // ...}, arePropsEqual);function arePropsEqual(oldProps, newProps) {  return (    oldProps.dataPoints.length === newProps.dataPoints.length &&    oldProps.dataPoints.every((oldPoint, index) => {      const newPoint = newProps.dataPoints[index];      return oldPoint.x === newPoint.x && oldPoint.y === newPoint.y;    })  );}"
      },
      {
        "language": "text",
        "code": "arePropsEqual"
      },
      {
        "language": "text",
        "code": "oldProps.onClick !== newProps.onClick"
      },
      {
        "language": "text",
        "code": "arePropsEqual"
      },
      {
        "language": "text",
        "code": "// Parent re-renders every secondfunction Parent() {  const [seconds, setSeconds] = useState(0);  useEffect(() => {    const interval = setInterval(() => {      setSeconds(s => s + 1);    }, 1000);    return () => clearInterval(interval);  }, []);  return (    <>      <h1>Seconds: {seconds}</h1>      <ExpensiveChild name=\"John\" />    </>  );}// Without memo, this re-renders every second even though props don't changeconst ExpensiveChild = memo(function ExpensiveChild({ name }) {  console.log('ExpensiveChild rendered');  return <div>Hello, {name}!</div>;});"
      },
      {
        "language": "text",
        "code": "// Parent re-renders every secondfunction Parent() {  const [seconds, setSeconds] = useState(0);  useEffect(() => {    const interval = setInterval(() => {      setSeconds(s => s + 1);    }, 1000);    return () => clearInterval(interval);  }, []);  return (    <>      <h1>Seconds: {seconds}</h1>      <ExpensiveChild name=\"John\" />    </>  );}// Without memo, this re-renders every second even though props don't changeconst ExpensiveChild = memo(function ExpensiveChild({ name }) {  console.log('ExpensiveChild rendered');  return <div>Hello, {name}!</div>;});"
      },
      {
        "language": "text",
        "code": "// No memo needed - compiler prevents re-renders automaticallyfunction ExpensiveChild({ name }) {  console.log('ExpensiveChild rendered');  return <div>Hello, {name}!</div>;}"
      },
      {
        "language": "text",
        "code": "// No memo needed - compiler prevents re-renders automaticallyfunction ExpensiveChild({ name }) {  console.log('ExpensiveChild rendered');  return <div>Hello, {name}!</div>;}"
      },
      {
        "language": "text",
        "code": "function Parent() {  const $ = _c(7);  const [seconds, setSeconds] = useState(0);  // ... other code ...  let t3;  if ($[4] === Symbol.for(\"react.memo_cache_sentinel\")) {    t3 = <ExpensiveChild name=\"John\" />;    $[4] = t3;  } else {    t3 = $[4];  }  // ... return statement ...}"
      },
      {
        "language": "text",
        "code": "function Parent() {  const $ = _c(7);  const [seconds, setSeconds] = useState(0);  // ... other code ...  let t3;  if ($[4] === Symbol.for(\"react.memo_cache_sentinel\")) {    t3 = <ExpensiveChild name=\"John\" />;    $[4] = t3;  } else {    t3 = $[4];  }  // ... return statement ...}"
      },
      {
        "language": "text",
        "code": "<ExpensiveChild name=\"John\" />"
      },
      {
        "language": "text",
        "code": "ExpensiveChild"
      },
      {
        "language": "text",
        "code": "<ExpensiveChild name=\"John\" />"
      },
      {
        "language": "text",
        "code": "ExpensiveChild"
      }
    ],
    "links": [
      {
        "text": "API Reference",
        "href": "/reference/react"
      },
      {
        "text": "APIs",
        "href": "/reference/react/apis"
      },
      {
        "text": "React Compiler",
        "href": "/learn/react-compiler"
      },
      {
        "text": "forwardRef",
        "href": "/reference/react/forwardRef"
      },
      {
        "text": "Object.is.",
        "href": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/is"
      },
      {
        "text": "pure rendering logic.",
        "href": "/learn/keeping-components-pure"
      },
      {
        "text": "useMemo",
        "href": "/reference/react/useMemo#skipping-re-rendering-of-components"
      },
      {
        "text": "useCallback",
        "href": "/reference/react/useCallback#skipping-re-rendering-of-components"
      },
      {
        "text": "accept JSX as children.",
        "href": "/learn/passing-props-to-a-component#passing-jsx-as-children"
      },
      {
        "text": "lift state up",
        "href": "/learn/sharing-state-between-components"
      },
      {
        "text": "rendering logic pure.",
        "href": "/learn/keeping-components-pure"
      },
      {
        "text": "unnecessary Effects that update state.",
        "href": "/learn/you-might-not-need-an-effect"
      },
      {
        "text": "remove unnecessary dependencies from your Effects.",
        "href": "/learn/removing-effect-dependencies"
      },
      {
        "text": "use the React Developer Tools profiler",
        "href": "https://legacy.reactjs.org/blog/2018/09/10/introducing-the-react-profiler.html"
      },
      {
        "text": "doing granular memoization automatically",
        "href": "https://www.youtube.com/watch?v=lGEMwh32soc"
      },
      {
        "text": "Object.is",
        "href": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/is"
      },
      {
        "text": "useMemo:",
        "href": "/reference/react/useMemo"
      },
      {
        "text": "useCallback",
        "href": "/reference/react/useCallback#skipping-re-rendering-of-components"
      },
      {
        "text": "close over",
        "href": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Closures"
      },
      {
        "text": "React Compiler",
        "href": "/learn/react-compiler"
      },
      {
        "text": "Previouslazy",
        "href": "/reference/react/lazy"
      },
      {
        "text": "NextstartTransition",
        "href": "/reference/react/startTransition"
      }
    ],
    "meta": {
      "description": "",
      "keywords": ""
    },
    "summary": "API ReferenceAPIsmemomemo lets you skip re-rendering a component when its props are unchanged. const MemoizedComponent = memo(SomeComponent, arePropsEqual",
    "tags": [
      "react",
      "angular",
      "javascript",
      "typescript",
      "html",
      "vite",
      "memo",
      "component",
      "note",
      "when"
    ],
    "id": "memo-react-memo-part-1",
    "quality": 100
  },
  {
    "title": "lazy – React",
    "url": "https://react.dev/reference/react/lazy",
    "category": "react",
    "content": "API ReferenceAPIslazylazy lets you defer loading components code until it is rendered for the first time.const SomeComponent = lazy(load) Reference lazy(load) load function Usage Lazy-loading components with Suspense Troubleshooting My lazy components state gets reset unexpectedly Reference lazy(load) Call lazy outside your components to declare a lazy-loaded React component: import { lazy } from 'react';const MarkdownPreview = lazy(() = import('./MarkdownPreview.js')); See more examples below. Parameters load: A function that returns a Promise or another thenable (a Promise-like object with a then method). React will not call load until the first time you attempt to render the returned component. After React first calls load, it will wait for it to resolve, and then render the resolved values .default as a React component. Both the returned Promise and the Promises resolved value will be cached, so React will not call load more than once. If the Promise rejects, React will throw the rejection reason for the nearest Error Boundary to handle. Returns lazy returns a React component you can render in your tree. While the code for the lazy component is still loading, attempting to render it will suspend. Use Suspense to display a loading indicator while its loading. load function Parameters load receives no parameters. Returns You need to return a Promise or some other thenable (a Promise-like object with a then method). It needs to eventually resolve to an object whose .default property is a valid React component type, such as a function, memo, or a forwardRef component. Usage Lazy-loading components with Suspense Usually, you import components with the static import declaration: import MarkdownPreview from './MarkdownPreview.js'; To defer loading this components code until its rendered for the first time, replace this import with: import { lazy } from 'react';const MarkdownPreview = lazy(() = import('./MarkdownPreview.js')); This code relies on dynamic import(), which might require support from your bundler or framework. Using this pattern requires that the lazy component youre importing was exported as the default export. Now that your components code loads on demand, you also need to specify what should be displayed while it is loading. You can do this by wrapping the lazy component or any of its parents into a Suspense boundary: Suspense fallback={Loading /} h2Preview/h2 MarkdownPreview //Suspense In this example, the code for MarkdownPreview wont be loaded until you attempt to render it. If MarkdownPreview hasnt loaded yet, Loading will be shown in its place. Try ticking the checkbox: App.jsLoading.jsMarkdownPreview.jsApp.js ResetForkimport { useState, Suspense, lazy } from 'react'; import Loading from './Loading.js'; const MarkdownPreview = lazy(() = delayForDemo(import('./MarkdownPreview.js'))); export default function MarkdownEditor() { const [showPreview, setShowPreview] = useState(false); const [markdown, setMarkdown] = useState('Hello, **world**!'); return (  textarea value={markdown} onChange={e = setMarkdown(e.target.value)} / label input type=\"checkbox\" checked={showPreview} onChange={e = setShowPreview(e.target.checked)} / Show preview /label hr / {showPreview && ( Suspense fallback={Loading /} h2Preview/h2 MarkdownPreview markdown={markdown} / /Suspense )} / ); } // Add a fixed delay so you can see the loading state function delayForDemo(promise) { return new Promise(resolve = { setTimeout(resolve, 2000); }).then(() = promise); } Show more This demo loads with an artificial delay. The next time you untick and tick the checkbox, Preview will be cached, so there will be no loading state. To see the loading state again, click Reset on the sandbox. Learn more about managing loading states with Suspense. Troubleshooting My lazy components state gets reset unexpectedly Do not declare lazy components inside other components: import { lazy } from 'react';function Editor() { //  Bad: This will cause all state to be reset on re-renders const MarkdownPreview = lazy(() = import('./MarkdownPreview.js')); // ...} Instead, always declare them at the top level of your module: import { lazy } from 'react';//  Good: Declare lazy components outside of your componentsconst MarkdownPreview = lazy(() = import('./MarkdownPreview.js'));function Editor() { // ...}PreviouscreateContextNextmemo",
    "headings": [
      {
        "level": 1,
        "text": "lazy",
        "id": ""
      },
      {
        "level": 2,
        "text": "Reference",
        "id": "reference"
      },
      {
        "level": 2,
        "text": "Usage",
        "id": "usage"
      },
      {
        "level": 2,
        "text": "Troubleshooting",
        "id": "troubleshooting"
      },
      {
        "level": 3,
        "text": "lazy(load)",
        "id": "lazy"
      },
      {
        "level": 3,
        "text": "load function",
        "id": "load"
      },
      {
        "level": 3,
        "text": "Lazy-loading components with Suspense",
        "id": "suspense-for-code-splitting"
      },
      {
        "level": 3,
        "text": "My lazy component’s state gets reset unexpectedly",
        "id": "my-lazy-components-state-gets-reset-unexpectedly"
      },
      {
        "level": 4,
        "text": "Parameters",
        "id": "parameters"
      },
      {
        "level": 4,
        "text": "Returns",
        "id": "returns"
      },
      {
        "level": 4,
        "text": "Parameters",
        "id": "load-parameters"
      },
      {
        "level": 4,
        "text": "Returns",
        "id": "load-returns"
      }
    ],
    "codeBlocks": [
      {
        "language": "text",
        "code": "const SomeComponent = lazy(load)"
      },
      {
        "language": "text",
        "code": "const SomeComponent = lazy(load)"
      },
      {
        "language": "text",
        "code": "import { lazy } from 'react';const MarkdownPreview = lazy(() => import('./MarkdownPreview.js'));"
      },
      {
        "language": "text",
        "code": "import { lazy } from 'react';const MarkdownPreview = lazy(() => import('./MarkdownPreview.js'));"
      },
      {
        "language": "text",
        "code": "import MarkdownPreview from './MarkdownPreview.js';"
      },
      {
        "language": "text",
        "code": "import MarkdownPreview from './MarkdownPreview.js';"
      },
      {
        "language": "text",
        "code": "import { lazy } from 'react';const MarkdownPreview = lazy(() => import('./MarkdownPreview.js'));"
      },
      {
        "language": "text",
        "code": "import { lazy } from 'react';const MarkdownPreview = lazy(() => import('./MarkdownPreview.js'));"
      },
      {
        "language": "text",
        "code": "<Suspense fallback={<Loading />}>  <h2>Preview</h2>  <MarkdownPreview /></Suspense>"
      },
      {
        "language": "text",
        "code": "<Suspense fallback={<Loading />}>  <h2>Preview</h2>  <MarkdownPreview /></Suspense>"
      },
      {
        "language": "text",
        "code": "MarkdownPreview"
      },
      {
        "language": "text",
        "code": "MarkdownPreview"
      },
      {
        "language": "text",
        "code": "import { useState, Suspense, lazy } from 'react';\nimport Loading from './Loading.js';\n\nconst MarkdownPreview = lazy(() => delayForDemo(import('./MarkdownPreview.js')));\n\nexport default function MarkdownEditor() {\n  const [showPreview, setShowPreview] = useState(false);\n  const [markdown, setMarkdown] = useState('Hello, **world**!');\n  return (\n    <>\n      <textarea value={markdown} onChange={e => setMarkdown(e.target.value)} />\n      <label>\n        <input type=\"checkbox\" checked={showPreview} onChange={e => setShowPreview(e.target.checked)} />\n        Show preview\n      </label>\n      <hr />\n      {showPreview && (\n        <Suspense fallback={<Loading />}>\n          <h2>Preview</h2>\n          <MarkdownPreview markdown={markdown} />\n        </Suspense>\n      )}\n    </>\n  );\n}\n\n// Add a fixed delay so you can see the loading state\nfunction delayForDemo(promise) {\n  return new Promise(resolve => {\n    setTimeout(resolve, 2000);\n  }).then(() => promise);\n}"
      },
      {
        "language": "text",
        "code": "import { lazy } from 'react';function Editor() {  // 🔴 Bad: This will cause all state to be reset on re-renders  const MarkdownPreview = lazy(() => import('./MarkdownPreview.js'));  // ...}"
      },
      {
        "language": "text",
        "code": "import { lazy } from 'react';function Editor() {  // 🔴 Bad: This will cause all state to be reset on re-renders  const MarkdownPreview = lazy(() => import('./MarkdownPreview.js'));  // ...}"
      },
      {
        "language": "text",
        "code": "import { lazy } from 'react';// ✅ Good: Declare lazy components outside of your componentsconst MarkdownPreview = lazy(() => import('./MarkdownPreview.js'));function Editor() {  // ...}"
      },
      {
        "language": "text",
        "code": "import { lazy } from 'react';// ✅ Good: Declare lazy components outside of your componentsconst MarkdownPreview = lazy(() => import('./MarkdownPreview.js'));function Editor() {  // ...}"
      }
    ],
    "links": [
      {
        "text": "API Reference",
        "href": "/reference/react"
      },
      {
        "text": "APIs",
        "href": "/reference/react/apis"
      },
      {
        "text": "Promise",
        "href": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Promise"
      },
      {
        "text": "<Suspense>",
        "href": "/reference/react/Suspense"
      },
      {
        "text": "Promise",
        "href": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Promise"
      },
      {
        "text": "memo",
        "href": "/reference/react/memo"
      },
      {
        "text": "forwardRef",
        "href": "/reference/react/forwardRef"
      },
      {
        "text": "import",
        "href": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Statements/import"
      },
      {
        "text": "dynamic import(),",
        "href": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/import"
      },
      {
        "text": "<Suspense>",
        "href": "/reference/react/Suspense"
      },
      {
        "text": "Learn more about managing loading states with Suspense.",
        "href": "/reference/react/Suspense"
      },
      {
        "text": "PreviouscreateContext",
        "href": "/reference/react/createContext"
      },
      {
        "text": "Nextmemo",
        "href": "/reference/react/memo"
      }
    ],
    "meta": {
      "description": "",
      "keywords": ""
    },
    "summary": "API ReferenceAPIslazylazy lets you defer loading components code until it is rendered for the first time",
    "tags": [
      "react",
      "angular",
      "javascript",
      "typescript",
      "node",
      "webpack",
      "lazy",
      "load",
      "parameters",
      "returns"
    ],
    "id": "lazy-react-lazy-part-1",
    "quality": 100
  },
  {
    "title": "<Suspense> – React",
    "url": "https://react.dev/reference/react/Suspense",
    "category": "react",
    "content": "API ReferenceComponentsSuspenseSuspense lets you display a fallback until its children have finished loading.Suspense fallback={Loading /} SomeComponent //Suspense Reference Suspense Usage Displaying a fallback while content is loading Revealing content together at once Revealing nested content as it loads Showing stale content while fresh content is loading Preventing already revealed content from hiding Indicating that a Transition is happening Resetting Suspense boundaries on navigation Providing a fallback for server errors and client-only content Troubleshooting How do I prevent the UI from being replaced by a fallback during an update? Reference Suspense Props children: The actual UI you intend to render. If children suspends while rendering, the Suspense boundary will switch to rendering fallback. fallback: An alternate UI to render in place of the actual UI if it has not finished loading. Any valid React node is accepted, though in practice, a fallback is a lightweight placeholder view, such as a loading spinner or skeleton. Suspense will automatically switch to fallback when children suspends, and back to children when the data is ready. If fallback suspends while rendering, it will activate the closest parent Suspense boundary. Caveats React does not preserve any state for renders that got suspended before they were able to mount for the first time. When the component has loaded, React will retry rendering the suspended tree from scratch. If Suspense was displaying content for the tree, but then it suspended again, the fallback will be shown again unless the update causing it was caused by startTransition or useDeferredValue. If React needs to hide the already visible content because it suspended again, it will clean up layout Effects in the content tree. When the content is ready to be shown again, React will fire the layout Effects again. This ensures that Effects measuring the DOM layout dont try to do this while the content is hidden. React includes under-the-hood optimizations like Streaming Server Rendering and Selective Hydration that are integrated with Suspense. Read an architectural overview and watch a technical talk to learn more. Usage Displaying a fallback while content is loading You can wrap any part of your application with a Suspense boundary: Suspense fallback={Loading /} Albums //Suspense React will display your loading fallback until all the code and data needed by the children has been loaded. In the example below, the Albums component suspends while fetching the list of albums. Until its ready to render, React switches the closest Suspense boundary above to show the fallbackyour Loading component. Then, when the data loads, React hides the Loading fallback and renders the Albums component with data. ArtistPage.jsAlbums.jsArtistPage.js ResetForkimport { Suspense } from 'react'; import Albums from './Albums.js'; export default function ArtistPage({ artist }) { return (  h1{artist.name}/h1 Suspense fallback={Loading /} Albums artistId={artist.id} / /Suspense / ); } function Loading() { return h2 Loading.../h2; } Show more NoteOnly Suspense-enabled data sources will activate the Suspense component. They include: Data fetching with Suspense-enabled frameworks like Relay and Next.js Lazy-loading component code with lazy Reading the value of a cached Promise with use Suspense does not detect when data is fetched inside an Effect or event handler.The exact way you would load data in the Albums component above depends on your framework. If you use a Suspense-enabled framework, youll find the details in its data fetching documentation.Suspense-enabled data fetching without the use of an opinionated framework is not yet supported. The requirements for implementing a Suspense-enabled data source are unstable and undocumented. An official API for integrating data sources with Suspense will be released in a future version of React. Revealing content together at once By default, the whole tree inside Suspense is treated as a single unit. For example, even if only one of these components suspends waiting for some data, all of them together will be replaced by the loading indicator: Suspense fallback={Loading /} Biography / Panel Albums / /Panel/Suspense Then, after all of them are ready to be displayed, they will all appear together at once. In the example below, both Biography and Albums fetch some data. However, because they are grouped under a single Suspense boundary, these components always pop in together at the same time. ArtistPage.jsPanel.jsBiography.jsAlbums.jsArtistPage.js ResetForkimport { Suspense } from 'react'; import Albums from './Albums.js'; import Biography from './Biography.js'; import Panel from './Panel.js'; export default function ArtistPage({ artist }) { return (  h1{artist.name}/h1 Suspense fallback={Loading /} Biography artistId={artist.id} / Panel Albums artistId={artist.id} / /Panel /Suspense / ); } function Loading() { return h2 Loading.../h2; } Show more Components that load data dont have to be direct children of the Suspense boundary. For example, you can move Biography and Albums into a new Details component. This doesnt change the behavior. Biography and Albums share the same closest parent Suspense boundary, so their reveal is coordinated together. Suspense fallback={Loading /} Details artistId={artist.id} //Suspensefunction Details({ artistId }) { return (  Biography artistId={artistId} / Panel Albums artistId={artistId} / /Panel / );} Revealing nested content as it loads When a component suspends, the closest parent Suspense component shows the fallback. This lets you nest multiple Suspense components to create a loading sequence. Each Suspense boundarys fallback will be filled in as the next level of content becomes available. For example, you can give the album list its own fallback: Suspense fallback={BigSpinner /} Biography / Suspense fallback={AlbumsGlimmer /} Panel Albums / /Panel /Suspense/Suspense With this change, displaying the Biography doesnt need to wait for the Albums to load. The sequence will be: If Biography hasnt loaded yet, BigSpinner is shown in place of the entire content area. Once Biography finishes loading, BigSpinner is replaced by the content. If Albums hasnt loaded yet, AlbumsGlimmer is shown in place of Albums and its parent Panel. Finally, once Albums finishes loading, it replaces AlbumsGlimmer. ArtistPage.jsPanel.jsBiography.jsAlbums.jsArtistPage.js ResetForkimport { Suspense } from 'react'; import Albums from './Albums.js'; import Biography from './Biography.js'; import Panel from './Panel.js'; export default function ArtistPage({ artist }) { return (  h1{artist.name}/h1 Suspense fallback={BigSpinner /} Biography artistId={artist.id} / Suspense fallback={AlbumsGlimmer /} Panel Albums artistId={artist.id} / /Panel /Suspense /Suspense / ); } function BigSpinner() { return h2 Loading.../h2; } function AlbumsGlimmer() { return ( div className=\"glimmer-panel\" div className=\"glimmer-line\" / div className=\"glimmer-line\" / div className=\"glimmer-line\" / /div ); } Show more Suspense boundaries let you coordinate which parts of your UI should always pop in together at the same time, and which parts should progressively reveal more content in a sequence of loading states. You can add, move, or delete Suspense boundaries in any place in the tree without affecting the rest of your apps behavior. Dont put a Suspense boundary around every component. Suspense boundaries should not be more granular than the loading sequence that you want the user to experience. If you work with a designer, ask them where the loading states should be placedits likely that theyve already included them in their design wireframes. Showing stale content while fresh content is loading In this example, the SearchResults component suspends while fetching the search results. Type \"a\", wait for the results, and then edit it to \"ab\". The results for \"a\" will get replaced by the loading fallback. App.jsSearchResults.jsApp.js ResetForkimport { Suspense, useState } from 'react'; import SearchResults from './SearchResults.js'; export default function App() { const [query, setQuery] = useState(''); return (  label Search albums: input value={query} onChange={e = setQuery(e.target.value)} / /label Suspense fallback={h2Loading.../h2} SearchResults query={query} / /Suspense / ); } Show more A common alternative UI pattern is to defer updating the list and to keep showing the previous results until the new results are ready. The useDeferredValue Hook lets you pass a deferred version of the query down: export default function App() { const [query, setQuery] = useState(''); const deferredQuery = useDeferredValue(query); return (  label Search albums: input value={query} onChange={e = setQuery(e.target.value)} / /label Suspense fallback={h2Loading.../h2} SearchResults query={deferredQuery} / /Suspense / );} The query will update immediately, so the input will display the new value. However, the deferredQuery will keep its previous value until the data has loaded, so SearchResults will show the stale results for a bit. To make it more obvious to the user, you can add a visual indication when the stale result list is displayed: div style={{ opacity: query !== deferredQuery ? 0.5 : 1 }} SearchResults query={deferredQuery} //div Enter \"a\" in the example below, wait for the results to load, and then edit the input to \"ab\". Notice how instead of the Suspense fallback, you now see the dimmed stale result list until the new results have loaded: App.jsApp.js ResetForkimport { Suspense, useState, useDeferredValue } from 'react'; import SearchResults from './SearchResults.js'; export default function App() { const [query, setQuery] = useState(''); const deferredQuery = useDeferredValue(query); const isStale = query !== deferredQuery; return (  label Search albums: input value={query} onChange={e = setQuery(e.target.value)} / /label Suspense fallback={h2Loading.../h2} div style={{ opacity: isStale ? 0.5 : 1 }} SearchResults query={deferredQuery} / /div /Suspense / ); } Show more NoteBoth deferred values and Transitions let you avoid showing Suspense fallback in favor of inline indicators. Transitions mark the whole update as non-urgent so they are typically used by frameworks and router libraries for navigation. Deferred values, on the other hand, are mostly useful in application code where you want to mark a part of UI as non-urgent and let it lag behind the rest of the UI. Preventing already revealed content from hiding When a component suspends, the closest parent Suspense boundary switches to showing the fallback. This can lead to a jarring user experience if it was already displaying some content. Try pressing this button: App.jsLayout.jsIndexPage.jsArtistPage.jsAlbums.jsBiography.jsPanel.jsApp.js ResetForkimport { Suspense, useState } from 'react'; import IndexPage from './IndexPage.js'; import ArtistPage from './ArtistPage.js'; import Layout from './Layout.js'; export default function App() { return ( Suspense fallback={BigSpinner /} Router / /Suspense ); } function Router() { const [page, setPage] = useState('/'); function navigate(url) { setPage(url); } let content; if (page === '/') { content = ( IndexPage navigate={navigate} / ); } else if (page === '/the-beatles') { content = ( ArtistPage artist={{ id: 'the-beatles', name: 'The Beatles', }} / ); } return ( Layout {content} /Layout ); } function BigSpinner() { return h2 Loading.../h2; } Show more When you pressed the button, the Router component rendered ArtistPage instead of IndexPage. A component inside ArtistPage suspended, so the closest Suspense boundary started showing the fallback. The closest Suspense boundary was near the root, so the whole site layout got replaced by BigSpinner. To prevent this, you can mark the navigation state update as a Transition with startTransition: function Router() { const [page, setPage] = useState('/'); function navigate(url) { startTransition(() = { setPage(url); }); } // ... This tells React that the state transition is not urgent, and its better to keep showing the previous page instead of hiding any already revealed content. Now clicking the button waits for the Biography to load: App.jsLayout.jsIndexPage.jsArtistPage.jsAlbums.jsBiography.jsPanel.jsApp.js ResetForkimport { Suspense, startTransition, useState } from 'react'; import IndexPage from './IndexPage.js'; import ArtistPage from './ArtistPage.js'; import Layout from './Layout.js'; export default function App() { return ( Suspense fallback={BigSpinner /} Router / /Suspense ); } function Router() { const [page, setPage] = useState('/'); function navigate(url) { startTransition(() = { setPage(url); }); } let content; if (page === '/') { content = ( IndexPage navigate={navigate} / ); } else if (page === '/the-beatles') { content = ( ArtistPage artist={{ id: 'the-beatles', name: 'The Beatles', }} / ); } return ( Layout {content} /Layout ); } function BigSpinner() { return h2 Loading.../h2; } Show more A Transition doesnt wait for all content to load. It only waits long enough to avoid hiding already revealed content. For example, the website Layout was already revealed, so it would be bad to hide it behind a loading spinner. However, the nested Suspense boundary around Albums is new, so the Transition doesnt wait for it. NoteSuspense-enabled routers are expected to wrap the navigation updates into Transitions by default. Indicating that a Transition is happening In the above example, once you click the button, there is no visual indication that a navigation is in progress. To add an indicator, you can replace startTransition with useTransition which gives you a boolean isPending value. In the example below, its used to change the website header styling while a Transition is happening: App.jsLayout.jsIndexPage.jsArtistPage.jsAlbums.jsBiography.jsPanel.jsApp.js ResetForkimport { Suspense, useState, useTransition } from 'react'; import IndexPage from './IndexPage.js'; import ArtistPage from './ArtistPage.js'; import Layout from './Layout.js'; export default function App() { return ( Suspense fallback={BigSpinner /} Router / /Suspense ); } function Router() { const [page, setPage] = useState('/'); const [isPending, startTransition] = useTransition(); function navigate(url) { startTransition(() = { setPage(url); }); } let content; if (page === '/') { content = ( IndexPage navigate={navigate} / ); } else if (page === '/the-beatles') { content = ( ArtistPage artist={{ id: 'the-beatles', name: 'The Beatles', }} / ); } return ( Layout isPending={isPending} {content} /Layout ); } function BigSpinner() { return h2 Loading.../h2; } Show more Resetting Suspense boundaries on navigation During a Transition, React will avoid hiding already revealed content. However, if you navigate to a route with different parameters, you might want to tell React it is different content. You can express this with a key: ProfilePage key={queryParams.id} / Imagine youre navigating within a users profile page, and something suspends. If that update is wrapped in a Transition, it will not trigger the fallback for already visible content. Thats the expected behavior. However, now imagine youre navigating between two different user profiles. In that case, it makes sense to show the fallback. For example, one users timeline is different content from another users timeline. By specifying a key, you ensure that React treats different users profiles as different components, and resets the Suspense boundaries during navigation. Suspense-integrated routers should do this automatically. Providing a fallback for server errors and client-only content If you use one of the streaming server rendering APIs (or a framework that relies on them), React will also use your Suspense boundaries to handle errors on the server. If a component throws an error on the server, React will not abort the server render. Instead, it will find the closest Suspense component above it and include its fallback (such as a spinner) into the generated server HTML. The user will see a spinner at first. On the client, React will attempt to render the same component again. If it errors on the client too, React will throw the error and display the closest error boundary. However, if it does not error on the client, React will not display the error to the user since the content was eventually displayed successfully. You can use this to opt out some components from rendering on the server. To do this, throw an error in the server environment and then wrap them in a Suspense boundary to replace their HTML with fallbacks: Suspense fallback={Loading /} Chat //Suspensefunction Chat() { if (typeof window === 'undefined') { throw Error('Chat should only render on the client.'); } // ...} The server HTML will include the loading indicator. It will be replaced by the Chat component on the client. Troubleshooting How do I prevent the UI from being replaced by a fallback during an update? Replacing visible UI with a fallback creates a jarring user experience. This can happen when an update causes a component to suspend, and the nearest Suspense boundary is already showing content to the user. To prevent this from happening, mark the update as non-urgent using startTransition. During a Transition, React will wait until enough data has loaded to prevent an unwanted fallback from appearing: function handleNextPageClick() { // If this update suspends, don't hide the already displayed content startTransition(() = { setCurrentPage(currentPage + 1); });} This will avoid hiding existing content. However, any newly rendered Suspense boundaries will still immediately display fallbacks to avoid blocking the UI and let the user see the content as it becomes available. React will only prevent unwanted fallbacks during non-urgent updates. It will not delay a render if its the result of an urgent update. You must opt in with an API like startTransition or useDeferredValue. If your router is integrated with Suspense, it should wrap its updates into startTransition automatically.PreviousStrictModeNextActivity",
    "headings": [
      {
        "level": 1,
        "text": "<Suspense>",
        "id": ""
      },
      {
        "level": 2,
        "text": "Reference",
        "id": "reference"
      },
      {
        "level": 2,
        "text": "Usage",
        "id": "usage"
      },
      {
        "level": 2,
        "text": "Troubleshooting",
        "id": "troubleshooting"
      },
      {
        "level": 3,
        "text": "<Suspense>",
        "id": "suspense"
      },
      {
        "level": 3,
        "text": "Displaying a fallback while content is loading",
        "id": "displaying-a-fallback-while-content-is-loading"
      },
      {
        "level": 3,
        "text": "Note",
        "id": ""
      },
      {
        "level": 3,
        "text": "Revealing content together at once",
        "id": "revealing-content-together-at-once"
      },
      {
        "level": 3,
        "text": "Revealing nested content as it loads",
        "id": "revealing-nested-content-as-it-loads"
      },
      {
        "level": 3,
        "text": "Showing stale content while fresh content is loading",
        "id": "showing-stale-content-while-fresh-content-is-loading"
      },
      {
        "level": 3,
        "text": "Note",
        "id": ""
      },
      {
        "level": 3,
        "text": "Preventing already revealed content from hiding",
        "id": "preventing-already-revealed-content-from-hiding"
      },
      {
        "level": 3,
        "text": "Note",
        "id": ""
      },
      {
        "level": 3,
        "text": "Indicating that a Transition is happening",
        "id": "indicating-that-a-transition-is-happening"
      },
      {
        "level": 3,
        "text": "Resetting Suspense boundaries on navigation",
        "id": "resetting-suspense-boundaries-on-navigation"
      },
      {
        "level": 3,
        "text": "Providing a fallback for server errors and client-only content",
        "id": "providing-a-fallback-for-server-errors-and-client-only-content"
      },
      {
        "level": 3,
        "text": "How do I prevent the UI from being replaced by a fallback during an update?",
        "id": "preventing-unwanted-fallbacks"
      },
      {
        "level": 4,
        "text": "Props",
        "id": "props"
      },
      {
        "level": 4,
        "text": "Caveats",
        "id": "caveats"
      }
    ],
    "codeBlocks": [
      {
        "language": "text",
        "code": "<Suspense fallback={<Loading />}>  <SomeComponent /></Suspense>"
      },
      {
        "language": "text",
        "code": "<Suspense fallback={<Loading />}>  <SomeComponent /></Suspense>"
      },
      {
        "language": "text",
        "code": "startTransition"
      },
      {
        "language": "text",
        "code": "useDeferredValue"
      },
      {
        "language": "text",
        "code": "<Suspense fallback={<Loading />}>  <Albums /></Suspense>"
      },
      {
        "language": "text",
        "code": "<Suspense fallback={<Loading />}>  <Albums /></Suspense>"
      },
      {
        "language": "text",
        "code": "import { Suspense } from 'react';\nimport Albums from './Albums.js';\n\nexport default function ArtistPage({ artist }) {\n  return (\n    <>\n      <h1>{artist.name}</h1>\n      <Suspense fallback={<Loading />}>\n        <Albums artistId={artist.id} />\n      </Suspense>\n    </>\n  );\n}\n\nfunction Loading() {\n  return <h2>🌀 Loading...</h2>;\n}"
      },
      {
        "language": "text",
        "code": "<Suspense fallback={<Loading />}>  <Biography />  <Panel>    <Albums />  </Panel></Suspense>"
      },
      {
        "language": "text",
        "code": "<Suspense fallback={<Loading />}>  <Biography />  <Panel>    <Albums />  </Panel></Suspense>"
      },
      {
        "language": "text",
        "code": "import { Suspense } from 'react';\nimport Albums from './Albums.js';\nimport Biography from './Biography.js';\nimport Panel from './Panel.js';\n\nexport default function ArtistPage({ artist }) {\n  return (\n    <>\n      <h1>{artist.name}</h1>\n      <Suspense fallback={<Loading />}>\n        <Biography artistId={artist.id} />\n        <Panel>\n          <Albums artistId={artist.id} />\n        </Panel>\n      </Suspense>\n    </>\n  );\n}\n\nfunction Loading() {\n  return <h2>🌀 Loading...</h2>;\n}"
      },
      {
        "language": "text",
        "code": "<Suspense fallback={<Loading />}>  <Details artistId={artist.id} /></Suspense>function Details({ artistId }) {  return (    <>      <Biography artistId={artistId} />      <Panel>        <Albums artistId={artistId} />      </Panel>    </>  );}"
      },
      {
        "language": "text",
        "code": "<Suspense fallback={<Loading />}>  <Details artistId={artist.id} /></Suspense>function Details({ artistId }) {  return (    <>      <Biography artistId={artistId} />      <Panel>        <Albums artistId={artistId} />      </Panel>    </>  );}"
      },
      {
        "language": "text",
        "code": "<Suspense fallback={<BigSpinner />}>  <Biography />  <Suspense fallback={<AlbumsGlimmer />}>    <Panel>      <Albums />    </Panel>  </Suspense></Suspense>"
      },
      {
        "language": "text",
        "code": "<Suspense fallback={<BigSpinner />}>  <Biography />  <Suspense fallback={<AlbumsGlimmer />}>    <Panel>      <Albums />    </Panel>  </Suspense></Suspense>"
      },
      {
        "language": "text",
        "code": "AlbumsGlimmer"
      },
      {
        "language": "text",
        "code": "AlbumsGlimmer"
      },
      {
        "language": "text",
        "code": "import { Suspense } from 'react';\nimport Albums from './Albums.js';\nimport Biography from './Biography.js';\nimport Panel from './Panel.js';\n\nexport default function ArtistPage({ artist }) {\n  return (\n    <>\n      <h1>{artist.name}</h1>\n      <Suspense fallback={<BigSpinner />}>\n        <Biography artistId={artist.id} />\n        <Suspense fallback={<AlbumsGlimmer />}>\n          <Panel>\n            <Albums artistId={artist.id} />\n          </Panel>\n        </Suspense>\n      </Suspense>\n    </>\n  );\n}\n\nfunction BigSpinner() {\n  return <h2>🌀 Loading...</h2>;\n}\n\nfunction AlbumsGlimmer() {\n  return (\n    <div className=\"glimmer-panel\">\n      <div className=\"glimmer-line\" />\n      <div className=\"glimmer-line\" />\n      <div className=\"glimmer-line\" />\n    </div>\n  );\n}"
      },
      {
        "language": "text",
        "code": "SearchResults"
      },
      {
        "language": "text",
        "code": "import { Suspense, useState } from 'react';\nimport SearchResults from './SearchResults.js';\n\nexport default function App() {\n  const [query, setQuery] = useState('');\n  return (\n    <>\n      <label>\n        Search albums:\n        <input value={query} onChange={e => setQuery(e.target.value)} />\n      </label>\n      <Suspense fallback={<h2>Loading...</h2>}>\n        <SearchResults query={query} />\n      </Suspense>\n    </>\n  );\n}"
      },
      {
        "language": "text",
        "code": "useDeferredValue"
      },
      {
        "language": "text",
        "code": "export default function App() {  const [query, setQuery] = useState('');  const deferredQuery = useDeferredValue(query);  return (    <>      <label>        Search albums:        <input value={query} onChange={e => setQuery(e.target.value)} />      </label>      <Suspense fallback={<h2>Loading...</h2>}>        <SearchResults query={deferredQuery} />      </Suspense>    </>  );}"
      },
      {
        "language": "text",
        "code": "export default function App() {  const [query, setQuery] = useState('');  const deferredQuery = useDeferredValue(query);  return (    <>      <label>        Search albums:        <input value={query} onChange={e => setQuery(e.target.value)} />      </label>      <Suspense fallback={<h2>Loading...</h2>}>        <SearchResults query={deferredQuery} />      </Suspense>    </>  );}"
      },
      {
        "language": "text",
        "code": "deferredQuery"
      },
      {
        "language": "text",
        "code": "SearchResults"
      },
      {
        "language": "text",
        "code": "<div style={{  opacity: query !== deferredQuery ? 0.5 : 1 }}>  <SearchResults query={deferredQuery} /></div>"
      },
      {
        "language": "text",
        "code": "<div style={{  opacity: query !== deferredQuery ? 0.5 : 1 }}>  <SearchResults query={deferredQuery} /></div>"
      },
      {
        "language": "text",
        "code": "import { Suspense, useState, useDeferredValue } from 'react';\nimport SearchResults from './SearchResults.js';\n\nexport default function App() {\n  const [query, setQuery] = useState('');\n  const deferredQuery = useDeferredValue(query);\n  const isStale = query !== deferredQuery;\n  return (\n    <>\n      <label>\n        Search albums:\n        <input value={query} onChange={e => setQuery(e.target.value)} />\n      </label>\n      <Suspense fallback={<h2>Loading...</h2>}>\n        <div style={{ opacity: isStale ? 0.5 : 1 }}>\n          <SearchResults query={deferredQuery} />\n        </div>\n      </Suspense>\n    </>\n  );\n}"
      },
      {
        "language": "text",
        "code": "import { Suspense, useState } from 'react';\nimport IndexPage from './IndexPage.js';\nimport ArtistPage from './ArtistPage.js';\nimport Layout from './Layout.js';\n\nexport default function App() {\n  return (\n    <Suspense fallback={<BigSpinner />}>\n      <Router />\n    </Suspense>\n  );\n}\n\nfunction Router() {\n  const [page, setPage] = useState('/');\n\n  function navigate(url) {\n    setPage(url);\n  }\n\n  let content;\n  if (page === '/') {\n    content = (\n      <IndexPage navigate={navigate} />\n    );\n  } else if (page === '/the-beatles') {\n    content = (\n      <ArtistPage\n        artist={{\n          id: 'the-beatles',\n          name: 'The Beatles',\n        }}\n      />\n    );\n  }\n  return (\n    <Layout>\n      {content}\n    </Layout>\n  );\n}\n\nfunction BigSpinner() {\n  return <h2>🌀 Loading...</h2>;\n}"
      },
      {
        "language": "text",
        "code": "startTransition"
      },
      {
        "language": "text",
        "code": "function Router() {  const [page, setPage] = useState('/');  function navigate(url) {    startTransition(() => {      setPage(url);          });  }  // ..."
      },
      {
        "language": "text",
        "code": "function Router() {  const [page, setPage] = useState('/');  function navigate(url) {    startTransition(() => {      setPage(url);          });  }  // ..."
      },
      {
        "language": "text",
        "code": "import { Suspense, startTransition, useState } from 'react';\nimport IndexPage from './IndexPage.js';\nimport ArtistPage from './ArtistPage.js';\nimport Layout from './Layout.js';\n\nexport default function App() {\n  return (\n    <Suspense fallback={<BigSpinner />}>\n      <Router />\n    </Suspense>\n  );\n}\n\nfunction Router() {\n  const [page, setPage] = useState('/');\n\n  function navigate(url) {\n    startTransition(() => {\n      setPage(url);\n    });\n  }\n\n  let content;\n  if (page === '/') {\n    content = (\n      <IndexPage navigate={navigate} />\n    );\n  } else if (page === '/the-beatles') {\n    content = (\n      <ArtistPage\n        artist={{\n          id: 'the-beatles',\n          name: 'The Beatles',\n        }}\n      />\n    );\n  }\n  return (\n    <Layout>\n      {content}\n    </Layout>\n  );\n}\n\nfunction BigSpinner() {\n  return <h2>🌀 Loading...</h2>;\n}"
      },
      {
        "language": "text",
        "code": "startTransition"
      },
      {
        "language": "text",
        "code": "useTransition"
      },
      {
        "language": "text",
        "code": "import { Suspense, useState, useTransition } from 'react';\nimport IndexPage from './IndexPage.js';\nimport ArtistPage from './ArtistPage.js';\nimport Layout from './Layout.js';\n\nexport default function App() {\n  return (\n    <Suspense fallback={<BigSpinner />}>\n      <Router />\n    </Suspense>\n  );\n}\n\nfunction Router() {\n  const [page, setPage] = useState('/');\n  const [isPending, startTransition] = useTransition();\n\n  function navigate(url) {\n    startTransition(() => {\n      setPage(url);\n    });\n  }\n\n  let content;\n  if (page === '/') {\n    content = (\n      <IndexPage navigate={navigate} />\n    );\n  } else if (page === '/the-beatles') {\n    content = (\n      <ArtistPage\n        artist={{\n          id: 'the-beatles',\n          name: 'The Beatles',\n        }}\n      />\n    );\n  }\n  return (\n    <Layout isPending={isPending}>\n      {content}\n    </Layout>\n  );\n}\n\nfunction BigSpinner() {\n  return <h2>🌀 Loading...</h2>;\n}"
      },
      {
        "language": "text",
        "code": "<ProfilePage key={queryParams.id} />"
      },
      {
        "language": "text",
        "code": "<ProfilePage key={queryParams.id} />"
      },
      {
        "language": "text",
        "code": "<Suspense fallback={<Loading />}>  <Chat /></Suspense>function Chat() {  if (typeof window === 'undefined') {    throw Error('Chat should only render on the client.');  }  // ...}"
      },
      {
        "language": "text",
        "code": "<Suspense fallback={<Loading />}>  <Chat /></Suspense>function Chat() {  if (typeof window === 'undefined') {    throw Error('Chat should only render on the client.');  }  // ...}"
      },
      {
        "language": "text",
        "code": "startTransition"
      },
      {
        "language": "text",
        "code": "function handleNextPageClick() {  // If this update suspends, don't hide the already displayed content  startTransition(() => {    setCurrentPage(currentPage + 1);  });}"
      },
      {
        "language": "text",
        "code": "function handleNextPageClick() {  // If this update suspends, don't hide the already displayed content  startTransition(() => {    setCurrentPage(currentPage + 1);  });}"
      },
      {
        "language": "text",
        "code": "startTransition"
      },
      {
        "language": "text",
        "code": "useDeferredValue"
      },
      {
        "language": "text",
        "code": "startTransition"
      }
    ],
    "links": [
      {
        "text": "API Reference",
        "href": "/reference/react"
      },
      {
        "text": "Components",
        "href": "/reference/react/components"
      },
      {
        "text": "startTransition",
        "href": "/reference/react/startTransition"
      },
      {
        "text": "useDeferredValue",
        "href": "/reference/react/useDeferredValue"
      },
      {
        "text": "layout Effects",
        "href": "/reference/react/useLayoutEffect"
      },
      {
        "text": "an architectural overview",
        "href": "https://github.com/reactwg/react-18/discussions/37"
      },
      {
        "text": "a technical talk",
        "href": "https://www.youtube.com/watch?v=pj5N-Khihgc"
      },
      {
        "text": "Relay",
        "href": "https://relay.dev/docs/guided-tour/rendering/loading-states/"
      },
      {
        "text": "Next.js",
        "href": "https://nextjs.org/docs/app/building-your-application/routing/loading-ui-and-streaming#streaming-with-suspense"
      },
      {
        "text": "lazy",
        "href": "/reference/react/lazy"
      },
      {
        "text": "use",
        "href": "/reference/react/use"
      },
      {
        "text": "useDeferredValue",
        "href": "/reference/react/useDeferredValue"
      },
      {
        "text": "startTransition:",
        "href": "/reference/react/startTransition"
      },
      {
        "text": "startTransition",
        "href": "/reference/react/startTransition"
      },
      {
        "text": "useTransition",
        "href": "/reference/react/useTransition"
      },
      {
        "text": "streaming server rendering APIs",
        "href": "/reference/react-dom/server"
      },
      {
        "text": "error boundary.",
        "href": "/reference/react/Component#static-getderivedstatefromerror"
      },
      {
        "text": "startTransition",
        "href": "/reference/react/startTransition"
      },
      {
        "text": "useDeferredValue",
        "href": "/reference/react/useDeferredValue"
      },
      {
        "text": "startTransition",
        "href": "/reference/react/startTransition"
      },
      {
        "text": "Previous<StrictMode>",
        "href": "/reference/react/StrictMode"
      },
      {
        "text": "Next<Activity>",
        "href": "/reference/react/Activity"
      }
    ],
    "meta": {
      "description": "",
      "keywords": ""
    },
    "summary": "API ReferenceComponentsSuspenseSuspense lets you display a fallback until its children have finished loading",
    "tags": [
      "react",
      "angular",
      "javascript",
      "typescript",
      "css",
      "html",
      "node",
      "content",
      "suspense",
      "fallback"
    ],
    "id": "suspense-react-Suspense-part-1",
    "quality": 100
  }
]