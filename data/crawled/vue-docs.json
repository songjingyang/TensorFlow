[
  {
    "title": "Reactivity Fundamentals",
    "url": "https://vuejs.org/guide/essentials/reactivity-fundamentals.html",
    "category": "vue",
    "content": "Reactivity Fundamentals API PreferenceThis page and many other chapters later in the guide contain different content for the Options API and the Composition API. Your current preference is Options APIComposition API. You can toggle between the API styles using the \"API Preference\" switches at the top of the left sidebar.Declaring Reactive State With the Options API, we use the data option to declare reactive state of a component. The option value should be a function that returns an object. Vue will call the function when creating a new component instance, and wrap the returned object in its reactivity system. Any top-level properties of this object are proxied on the component instance (this in methods and lifecycle hooks):jsexport default { data() { return { count: 1 } }, // mounted is a lifecycle hook which we will explain later mounted() { // this refers to the component instance. console.log(this.count) // = 1 // data can be mutated as well this.count = 2 } }Try it in the PlaygroundThese instance properties are only added when the instance is first created, so you need to ensure they are all present in the object returned by the data function. Where necessary, use null, undefined or some other placeholder value for properties where the desired value isn't yet available.It is possible to add a new property directly to this without including it in data. However, properties added this way will not be able to trigger reactive updates.Vue uses a $ prefix when exposing its own built-in APIs via the component instance. It also reserves the prefix _ for internal properties. You should avoid using names for top-level data properties that start with either of these characters.Reactive Proxy vs. Original In Vue 3, data is made reactive by leveraging JavaScript Proxies. Users coming from Vue 2 should be aware of the following edge case:jsexport default { data() { return { someObject: {} } }, mounted() { const newObject = {} this.someObject = newObject console.log(newObject === this.someObject) // false } }When you access this.someObject after assigning it, the value is a reactive proxy of the original newObject. Unlike in Vue 2, the original newObject is left intact and will not be made reactive: make sure to always access reactive state as a property of this.Declaring Reactive State ref() In Composition API, the recommended way to declare reactive state is using the ref() function:jsimport { ref } from 'vue' const count = ref(0)ref() takes the argument and returns it wrapped within a ref object with a .value property:jsconst count = ref(0) console.log(count) // { value: 0 } console.log(count.value) // 0 count.value++ console.log(count.value) // 1See also: Typing Refs To access refs in a component's template, declare and return them from a component's setup() function:jsimport { ref } from 'vue' export default { // setup is a special hook dedicated for the Composition API. setup() { const count = ref(0) // expose the ref to the template return { count } } }templatediv{{ count }}/divNotice that we did not need to append .value when using the ref in the template. For convenience, refs are automatically unwrapped when used inside templates (with a few caveats).You can also mutate a ref directly in event handlers:templatebutton @click=\"count++\" {{ count }} /buttonFor more complex logic, we can declare functions that mutate refs in the same scope and expose them as methods alongside the state:jsimport { ref } from 'vue' export default { setup() { const count = ref(0) function increment() { // .value is needed in JavaScript count.value++ } // don't forget to expose the function as well. return { count, increment } } }Exposed methods can then be used as event handlers:templatebutton @click=\"increment\" {{ count }} /buttonHere's the example live on Codepen, without using any build tools.script setup Manually exposing state and methods via setup() can be verbose. Luckily, it can be avoided when using Single-File Components (SFCs). We can simplify the usage with script setup:vuescript setup import { ref } from 'vue' const count = ref(0) function increment() { count.value++ } /script template button @click=\"increment\" {{ count }} /button /templateTry it in the PlaygroundTop-level imports, variables and functions declared in script setup are automatically usable in the template of the same component. Think of the template as a JavaScript function declared in the same scope - it naturally has access to everything declared alongside it.TIPFor the rest of the guide, we will be primarily using SFC + script setup syntax for the Composition API code examples, as that is the most common usage for Vue developers.If you are not using SFC, you can still use Composition API with the setup() option.Why Refs? You might be wondering why we need refs with the .value instead of plain variables. To explain that, we will need to briefly discuss how Vue's reactivity system works.When you use a ref in a template, and change the ref's value later, Vue automatically detects the change and updates the DOM accordingly. This is made possible with a dependency-tracking based reactivity system. When a component is rendered for the first time, Vue tracks every ref that was used during the render. Later on, when a ref is mutated, it will trigger a re-render for components that are tracking it.In standard JavaScript, there is no way to detect the access or mutation of plain variables. However, we can intercept the get and set operations of an object's properties using getter and setter methods.The .value property gives Vue the opportunity to detect when a ref has been accessed or mutated. Under the hood, Vue performs the tracking in its getter, and performs triggering in its setter. Conceptually, you can think of a ref as an object that looks like this:js// pseudo code, not actual implementation const myRef = { _value: 0, get value() { track() return this._value }, set value(newValue) { this._value = newValue trigger() } }Another nice trait of refs is that unlike plain variables, you can pass refs into functions while retaining access to the latest value and the reactivity connection. This is particularly useful when refactoring complex logic into reusable code.The reactivity system is discussed in more details in the Reactivity in Depth section.Declaring Methods Watch a free video lesson on Vue SchoolTo add methods to a component instance we use the methods option. This should be an object containing the desired methods:jsexport default { data() { return { count: 0 } }, methods: { increment() { this.count++ } }, mounted() { // methods can be called in lifecycle hooks, or other methods! this.increment() } }Vue automatically binds the this value for methods so that it always refers to the component instance. This ensures that a method retains the correct this value if it's used as an event listener or callback. You should avoid using arrow functions when defining methods, as that prevents Vue from binding the appropriate this value:jsexport default { methods: { increment: () = { // BAD: no this access here! } } }Just like all other properties of the component instance, the methods are accessible from within the component's template. Inside a template they are most commonly used as event listeners:templatebutton @click=\"increment\"{{ count }}/buttonTry it in the PlaygroundIn the example above, the method increment will be called when the button is clicked.Deep Reactivity In Vue, state is deeply reactive by default. This means you can expect changes to be detected even when you mutate nested objects or arrays:jsexport default { data() { return { obj: { nested: { count: 0 }, arr: ['foo', 'bar'] } } }, methods: { mutateDeeply() { // these will work as expected. this.obj.nested.count++ this.obj.arr.push('baz') } } }Refs can hold any value type, including deeply nested objects, arrays, or JavaScript built-in data structures like Map.A ref will make its value deeply reactive. This means you can expect changes to be detected even when you mutate nested objects or arrays:jsimport { ref } from 'vue' const obj = ref({ nested: { count: 0 }, arr: ['foo', 'bar'] }) function mutateDeeply() { // these will work as expected. obj.value.nested.count++ obj.value.arr.push('baz') }Non-primitive values are turned into reactive proxies via reactive(), which is discussed below.It is also possible to opt-out of deep reactivity with shallow refs. For shallow refs, only .value access is tracked for reactivity. Shallow refs can be used for optimizing performance by avoiding the observation cost of large objects, or in cases where the inner state is managed by an external library.Further reading:Reduce Reactivity Overhead for Large Immutable StructuresIntegration with External State SystemsDOM Update Timing When you mutate reactive state, the DOM is updated automatically. However, it should be noted that the DOM updates are not applied synchronously. Instead, Vue buffers them until the \"next tick\" in the update cycle to ensure that each component updates only once no matter how many state changes you have made.To wait for the DOM update to complete after a state change, you can use the nextTick() global API:jsimport { nextTick } from 'vue' async function increment() { count.value++ await nextTick() // Now the DOM is updated }jsimport { nextTick } from 'vue' export default { methods: { async increment() { this.count++ await nextTick() // Now the DOM is updated } } }reactive() There is another way to declare reactive state, with the reactive() API. Unlike a ref which wraps the inner value in a special object, reactive() makes an object itself reactive:jsimport { reactive } from 'vue' const state = reactive({ count: 0 })See also: Typing Reactive Usage in template:templatebutton @click=\"state.count++\" {{ state.count }} /buttonReactive objects are JavaScript Proxies and behave just like normal objects. The difference is that Vue is able to intercept the access and mutation of all properties of a reactive object for reactivity tracking and triggering.reactive() converts the object deeply: nested objects are also wrapped with reactive() when accessed. It is also called by ref() internally when the ref value is an object. Similar to shallow refs, there is also the shallowReactive() API for opting-out of deep reactivity.Reactive Proxy vs. Original It is important to note that the returned value from reactive() is a Proxy of the original object, which is not equal to the original object:jsconst raw = {} const proxy = reactive(raw) // proxy is NOT equal to the original. console.log(proxy === raw) // falseOnly the proxy is reactive - mutating the original object will not trigger updates. Therefore, the best practice when working with Vue's reactivity system is to exclusively use the proxied versions of your state.To ensure consistent access to the proxy, calling reactive() on the same object always returns the same proxy, and calling reactive() on an existing proxy also returns that same proxy:js// calling reactive() on the same object returns the same proxy console.log(reactive(raw) === proxy) // true // calling reactive() on a proxy returns itself console.log(reactive(proxy) === proxy) // trueThis rule applies to nested objects as well. Due to deep reactivity, nested objects inside a reactive object are also proxies:jsconst proxy = reactive({}) const raw = {} proxy.nested = raw console.log(proxy.nested === raw) // falseLimitations of reactive() The reactive() API has a few limitations:Limited value types: it only works for object types (objects, arrays, and collection types such as Map and Set). It cannot hold primitive types such as string, number or boolean.Cannot replace entire object: since Vue's reactivity tracking works over property access, we must always keep the same reference to the reactive object. This means we can't easily \"replace\" a reactive object because the reactivity connection to the first reference is lost:jslet state = reactive({ count: 0 }) // the above reference ({ count: 0 }) is no longer being tracked // (reactivity connection is lost!) state = reactive({ count: 1 })Not destructure-friendly: when we destructure a reactive object's primitive type property into local variables, or when we pass that property into a function, we will lose the reactivity connection:jsconst state = reactive({ count: 0 }) // count is disconnected from state.count when destructured. let { count } = state // does not affect original state count++ // the function receives a plain number and // won't be able to track changes to state.count // we have to pass the entire object in to retain reactivity callSomeFunction(state.count)Due to these limitations, we recommend using ref() as the primary API for declaring reactive state.Additional Ref Unwrapping Details As Reactive Object Property A ref is automatically unwrapped when accessed or mutated as a property of a reactive object. In other words, it behaves like a normal property:jsconst count = ref(0) const state = reactive({ count }) console.log(state.count) // 0 state.count = 1 console.log(count.value) // 1If a new ref is assigned to a property linked to an existing ref, it will replace the old ref:jsconst otherCount = ref(2) state.count = otherCount console.log(state.count) // 2 // original ref is now disconnected from state.count console.log(count.value) // 1Ref unwrapping only happens when nested inside a deep reactive object. It does not apply when it is accessed as a property of a shallow reactive object.Caveat in Arrays and Collections Unlike reactive objects, there is no unwrapping performed when the ref is accessed as an element of a reactive array or a native collection type like Map:jsconst books = reactive([ref('Vue 3 Guide')]) // need .value here console.log(books[0].value) const map = reactive(new Map([['count', ref(0)]])) // need .value here console.log(map.get('count').value)Caveat when Unwrapping in Templates Ref unwrapping in templates only applies if the ref is a top-level property in the template render context.In the example below, count and object are top-level properties, but object.id is not:jsconst count = ref(0) const object = { id: ref(1) }Therefore, this expression works as expected:template{{ count + 1 }}...while this one does NOT:template{{ object.id + 1 }}The rendered result will be [object Object]1 because object.id is not unwrapped when evaluating the expression and remains a ref object. To fix this, we can destructure id into a top-level property:jsconst { id } = objecttemplate{{ id + 1 }}Now the render result will be 2.Another thing to note is that a ref does get unwrapped if it is the final evaluated value of a text interpolation (i.e. a {{ }} tag), so the following will render 1:template{{ object.id }}This is just a convenience feature of text interpolation and is equivalent to {{ object.id.value }}.Stateful Methods In some cases, we may need to dynamically create a method function, for example creating a debounced event handler:jsimport { debounce } from 'lodash-es' export default { methods: { // Debouncing with Lodash click: debounce(function () { // ... respond to click ... }, 500) } }However, this approach is problematic for components that are reused because a debounced function is stateful: it maintains some internal state on the elapsed time. If multiple component instances share the same debounced function, they will interfere with one another.To keep each component instance's debounced function independent of the others, we can create the debounced version in the created lifecycle hook:jsexport default { created() { // each instance now has its own copy of debounced handler this.debouncedClick = _.debounce(this.click, 500) }, unmounted() { // also a good idea to cancel the timer // when the component is removed this.debouncedClick.cancel() }, methods: { click() { // ... respond to click ... } } }Edit this page on GitHub",
    "headings": [
      {
        "level": 1,
        "text": "Reactivity Fundamentals ​",
        "id": "reactivity-fundamentals"
      },
      {
        "level": 2,
        "text": "Declaring Reactive State ​",
        "id": "declaring-reactive-state"
      },
      {
        "level": 2,
        "text": "Declaring Reactive State ​",
        "id": "declaring-reactive-state-1"
      },
      {
        "level": 2,
        "text": "Declaring Methods ​",
        "id": "declaring-methods"
      },
      {
        "level": 2,
        "text": "reactive() ​",
        "id": "reactive"
      },
      {
        "level": 2,
        "text": "Additional Ref Unwrapping Details ​",
        "id": "additional-ref-unwrapping-details"
      },
      {
        "level": 3,
        "text": "Reactive Proxy vs. Original ​",
        "id": "reactive-proxy-vs-original"
      },
      {
        "level": 3,
        "text": "ref() ​",
        "id": "ref"
      },
      {
        "level": 3,
        "text": "<script setup> ​",
        "id": "script-setup"
      },
      {
        "level": 3,
        "text": "Why Refs? ​",
        "id": "why-refs"
      },
      {
        "level": 3,
        "text": "Deep Reactivity ​",
        "id": "deep-reactivity"
      },
      {
        "level": 3,
        "text": "DOM Update Timing ​",
        "id": "dom-update-timing"
      },
      {
        "level": 3,
        "text": "Reactive Proxy vs. Original ​",
        "id": "reactive-proxy-vs-original-1"
      },
      {
        "level": 3,
        "text": "Limitations of reactive() ​",
        "id": "limitations-of-reactive"
      },
      {
        "level": 3,
        "text": "As Reactive Object Property ​",
        "id": "ref-unwrapping-as-reactive-object-property"
      },
      {
        "level": 3,
        "text": "Caveat in Arrays and Collections ​",
        "id": "caveat-in-arrays-and-collections"
      },
      {
        "level": 3,
        "text": "Caveat when Unwrapping in Templates ​",
        "id": "caveat-when-unwrapping-in-templates"
      },
      {
        "level": 3,
        "text": "Stateful Methods ​",
        "id": "stateful-methods"
      }
    ],
    "codeBlocks": [
      {
        "language": "text",
        "code": "export default {\n  data() {\n    return {\n      count: 1\n    }\n  },\n\n  // `mounted` is a lifecycle hook which we will explain later\n  mounted() {\n    // `this` refers to the component instance.\n    console.log(this.count) // => 1\n\n    // data can be mutated as well\n    this.count = 2\n  }\n}"
      },
      {
        "language": "text",
        "code": "export default {\n  data() {\n    return {\n      count: 1\n    }\n  },\n\n  // `mounted` is a lifecycle hook which we will explain later\n  mounted() {\n    // `this` refers to the component instance.\n    console.log(this.count) // => 1\n\n    // data can be mutated as well\n    this.count = 2\n  }\n}"
      },
      {
        "language": "text",
        "code": "export default {\n  data() {\n    return {\n      someObject: {}\n    }\n  },\n  mounted() {\n    const newObject = {}\n    this.someObject = newObject\n\n    console.log(newObject === this.someObject) // false\n  }\n}"
      },
      {
        "language": "text",
        "code": "export default {\n  data() {\n    return {\n      someObject: {}\n    }\n  },\n  mounted() {\n    const newObject = {}\n    this.someObject = newObject\n\n    console.log(newObject === this.someObject) // false\n  }\n}"
      },
      {
        "language": "text",
        "code": "this.someObject"
      },
      {
        "language": "text",
        "code": "import { ref } from 'vue'\n\nconst count = ref(0)"
      },
      {
        "language": "text",
        "code": "import { ref } from 'vue'\n\nconst count = ref(0)"
      },
      {
        "language": "text",
        "code": "const count = ref(0)\n\nconsole.log(count) // { value: 0 }\nconsole.log(count.value) // 0\n\ncount.value++\nconsole.log(count.value) // 1"
      },
      {
        "language": "text",
        "code": "const count = ref(0)\n\nconsole.log(count) // { value: 0 }\nconsole.log(count.value) // 0\n\ncount.value++\nconsole.log(count.value) // 1"
      },
      {
        "language": "text",
        "code": "import { ref } from 'vue'\n\nexport default {\n  // `setup` is a special hook dedicated for the Composition API.\n  setup() {\n    const count = ref(0)\n\n    // expose the ref to the template\n    return {\n      count\n    }\n  }\n}"
      },
      {
        "language": "text",
        "code": "import { ref } from 'vue'\n\nexport default {\n  // `setup` is a special hook dedicated for the Composition API.\n  setup() {\n    const count = ref(0)\n\n    // expose the ref to the template\n    return {\n      count\n    }\n  }\n}"
      },
      {
        "language": "text",
        "code": "<div>{{ count }}</div>"
      },
      {
        "language": "text",
        "code": "<div>{{ count }}</div>"
      },
      {
        "language": "text",
        "code": "<button @click=\"count++\">\n  {{ count }}\n</button>"
      },
      {
        "language": "text",
        "code": "<button @click=\"count++\">\n  {{ count }}\n</button>"
      },
      {
        "language": "text",
        "code": "import { ref } from 'vue'\n\nexport default {\n  setup() {\n    const count = ref(0)\n\n    function increment() {\n      // .value is needed in JavaScript\n      count.value++\n    }\n\n    // don't forget to expose the function as well.\n    return {\n      count,\n      increment\n    }\n  }\n}"
      },
      {
        "language": "text",
        "code": "import { ref } from 'vue'\n\nexport default {\n  setup() {\n    const count = ref(0)\n\n    function increment() {\n      // .value is needed in JavaScript\n      count.value++\n    }\n\n    // don't forget to expose the function as well.\n    return {\n      count,\n      increment\n    }\n  }\n}"
      },
      {
        "language": "text",
        "code": "<button @click=\"increment\">\n  {{ count }}\n</button>"
      },
      {
        "language": "text",
        "code": "<button @click=\"increment\">\n  {{ count }}\n</button>"
      },
      {
        "language": "text",
        "code": "<script setup>"
      },
      {
        "language": "text",
        "code": "<script setup>"
      },
      {
        "language": "text",
        "code": "<script setup>\nimport { ref } from 'vue'\n\nconst count = ref(0)\n\nfunction increment() {\n  count.value++\n}\n</script>\n\n<template>\n  <button @click=\"increment\">\n    {{ count }}\n  </button>\n</template>"
      },
      {
        "language": "text",
        "code": "<script setup>\nimport { ref } from 'vue'\n\nconst count = ref(0)\n\nfunction increment() {\n  count.value++\n}\n</script>\n\n<template>\n  <button @click=\"increment\">\n    {{ count }}\n  </button>\n</template>"
      },
      {
        "language": "text",
        "code": "<script setup>"
      },
      {
        "language": "text",
        "code": "<script setup>"
      },
      {
        "language": "text",
        "code": "// pseudo code, not actual implementation\nconst myRef = {\n  _value: 0,\n  get value() {\n    track()\n    return this._value\n  },\n  set value(newValue) {\n    this._value = newValue\n    trigger()\n  }\n}"
      },
      {
        "language": "text",
        "code": "// pseudo code, not actual implementation\nconst myRef = {\n  _value: 0,\n  get value() {\n    track()\n    return this._value\n  },\n  set value(newValue) {\n    this._value = newValue\n    trigger()\n  }\n}"
      },
      {
        "language": "text",
        "code": "export default {\n  data() {\n    return {\n      count: 0\n    }\n  },\n  methods: {\n    increment() {\n      this.count++\n    }\n  },\n  mounted() {\n    // methods can be called in lifecycle hooks, or other methods!\n    this.increment()\n  }\n}"
      },
      {
        "language": "text",
        "code": "export default {\n  data() {\n    return {\n      count: 0\n    }\n  },\n  methods: {\n    increment() {\n      this.count++\n    }\n  },\n  mounted() {\n    // methods can be called in lifecycle hooks, or other methods!\n    this.increment()\n  }\n}"
      },
      {
        "language": "text",
        "code": "export default {\n  methods: {\n    increment: () => {\n      // BAD: no `this` access here!\n    }\n  }\n}"
      },
      {
        "language": "text",
        "code": "export default {\n  methods: {\n    increment: () => {\n      // BAD: no `this` access here!\n    }\n  }\n}"
      },
      {
        "language": "text",
        "code": "<button @click=\"increment\">{{ count }}</button>"
      },
      {
        "language": "text",
        "code": "<button @click=\"increment\">{{ count }}</button>"
      },
      {
        "language": "text",
        "code": "export default {\n  data() {\n    return {\n      obj: {\n        nested: { count: 0 },\n        arr: ['foo', 'bar']\n      }\n    }\n  },\n  methods: {\n    mutateDeeply() {\n      // these will work as expected.\n      this.obj.nested.count++\n      this.obj.arr.push('baz')\n    }\n  }\n}"
      },
      {
        "language": "text",
        "code": "export default {\n  data() {\n    return {\n      obj: {\n        nested: { count: 0 },\n        arr: ['foo', 'bar']\n      }\n    }\n  },\n  methods: {\n    mutateDeeply() {\n      // these will work as expected.\n      this.obj.nested.count++\n      this.obj.arr.push('baz')\n    }\n  }\n}"
      },
      {
        "language": "text",
        "code": "import { ref } from 'vue'\n\nconst obj = ref({\n  nested: { count: 0 },\n  arr: ['foo', 'bar']\n})\n\nfunction mutateDeeply() {\n  // these will work as expected.\n  obj.value.nested.count++\n  obj.value.arr.push('baz')\n}"
      },
      {
        "language": "text",
        "code": "import { ref } from 'vue'\n\nconst obj = ref({\n  nested: { count: 0 },\n  arr: ['foo', 'bar']\n})\n\nfunction mutateDeeply() {\n  // these will work as expected.\n  obj.value.nested.count++\n  obj.value.arr.push('baz')\n}"
      },
      {
        "language": "text",
        "code": "import { nextTick } from 'vue'\n\nasync function increment() {\n  count.value++\n  await nextTick()\n  // Now the DOM is updated\n}"
      },
      {
        "language": "text",
        "code": "import { nextTick } from 'vue'\n\nasync function increment() {\n  count.value++\n  await nextTick()\n  // Now the DOM is updated\n}"
      },
      {
        "language": "text",
        "code": "import { nextTick } from 'vue'\n\nexport default {\n  methods: {\n    async increment() {\n      this.count++\n      await nextTick()\n      // Now the DOM is updated\n    }\n  }\n}"
      },
      {
        "language": "text",
        "code": "import { nextTick } from 'vue'\n\nexport default {\n  methods: {\n    async increment() {\n      this.count++\n      await nextTick()\n      // Now the DOM is updated\n    }\n  }\n}"
      },
      {
        "language": "text",
        "code": "import { reactive } from 'vue'\n\nconst state = reactive({ count: 0 })"
      },
      {
        "language": "text",
        "code": "import { reactive } from 'vue'\n\nconst state = reactive({ count: 0 })"
      },
      {
        "language": "text",
        "code": "<button @click=\"state.count++\">\n  {{ state.count }}\n</button>"
      },
      {
        "language": "text",
        "code": "<button @click=\"state.count++\">\n  {{ state.count }}\n</button>"
      },
      {
        "language": "text",
        "code": "shallowReactive()"
      },
      {
        "language": "text",
        "code": "const raw = {}\nconst proxy = reactive(raw)\n\n// proxy is NOT equal to the original.\nconsole.log(proxy === raw) // false"
      },
      {
        "language": "text",
        "code": "const raw = {}\nconst proxy = reactive(raw)\n\n// proxy is NOT equal to the original.\nconsole.log(proxy === raw) // false"
      },
      {
        "language": "text",
        "code": "// calling reactive() on the same object returns the same proxy\nconsole.log(reactive(raw) === proxy) // true\n\n// calling reactive() on a proxy returns itself\nconsole.log(reactive(proxy) === proxy) // true"
      },
      {
        "language": "text",
        "code": "// calling reactive() on the same object returns the same proxy\nconsole.log(reactive(raw) === proxy) // true\n\n// calling reactive() on a proxy returns itself\nconsole.log(reactive(proxy) === proxy) // true"
      },
      {
        "language": "text",
        "code": "const proxy = reactive({})\n\nconst raw = {}\nproxy.nested = raw\n\nconsole.log(proxy.nested === raw) // false"
      },
      {
        "language": "text",
        "code": "const proxy = reactive({})\n\nconst raw = {}\nproxy.nested = raw\n\nconsole.log(proxy.nested === raw) // false"
      },
      {
        "language": "text",
        "code": "let state = reactive({ count: 0 })\n\n// the above reference ({ count: 0 }) is no longer being tracked\n// (reactivity connection is lost!)\nstate = reactive({ count: 1 })"
      },
      {
        "language": "text",
        "code": "let state = reactive({ count: 0 })\n\n// the above reference ({ count: 0 }) is no longer being tracked\n// (reactivity connection is lost!)\nstate = reactive({ count: 1 })"
      },
      {
        "language": "text",
        "code": "const state = reactive({ count: 0 })\n\n// count is disconnected from state.count when destructured.\nlet { count } = state\n// does not affect original state\ncount++\n\n// the function receives a plain number and\n// won't be able to track changes to state.count\n// we have to pass the entire object in to retain reactivity\ncallSomeFunction(state.count)"
      },
      {
        "language": "text",
        "code": "const state = reactive({ count: 0 })\n\n// count is disconnected from state.count when destructured.\nlet { count } = state\n// does not affect original state\ncount++\n\n// the function receives a plain number and\n// won't be able to track changes to state.count\n// we have to pass the entire object in to retain reactivity\ncallSomeFunction(state.count)"
      },
      {
        "language": "text",
        "code": "const count = ref(0)\nconst state = reactive({\n  count\n})\n\nconsole.log(state.count) // 0\n\nstate.count = 1\nconsole.log(count.value) // 1"
      },
      {
        "language": "text",
        "code": "const count = ref(0)\nconst state = reactive({\n  count\n})\n\nconsole.log(state.count) // 0\n\nstate.count = 1\nconsole.log(count.value) // 1"
      },
      {
        "language": "text",
        "code": "const otherCount = ref(2)\n\nstate.count = otherCount\nconsole.log(state.count) // 2\n// original ref is now disconnected from state.count\nconsole.log(count.value) // 1"
      },
      {
        "language": "text",
        "code": "const otherCount = ref(2)\n\nstate.count = otherCount\nconsole.log(state.count) // 2\n// original ref is now disconnected from state.count\nconsole.log(count.value) // 1"
      },
      {
        "language": "text",
        "code": "const books = reactive([ref('Vue 3 Guide')])\n// need .value here\nconsole.log(books[0].value)\n\nconst map = reactive(new Map([['count', ref(0)]]))\n// need .value here\nconsole.log(map.get('count').value)"
      },
      {
        "language": "text",
        "code": "const books = reactive([ref('Vue 3 Guide')])\n// need .value here\nconsole.log(books[0].value)\n\nconst map = reactive(new Map([['count', ref(0)]]))\n// need .value here\nconsole.log(map.get('count').value)"
      },
      {
        "language": "text",
        "code": "const count = ref(0)\nconst object = { id: ref(1) }"
      },
      {
        "language": "text",
        "code": "const count = ref(0)\nconst object = { id: ref(1) }"
      },
      {
        "language": "text",
        "code": "{{ count + 1 }}"
      },
      {
        "language": "text",
        "code": "{{ count + 1 }}"
      },
      {
        "language": "text",
        "code": "{{ object.id + 1 }}"
      },
      {
        "language": "text",
        "code": "{{ object.id + 1 }}"
      },
      {
        "language": "text",
        "code": "[object Object]1"
      },
      {
        "language": "text",
        "code": "const { id } = object"
      },
      {
        "language": "text",
        "code": "const { id } = object"
      },
      {
        "language": "text",
        "code": "{{ id + 1 }}"
      },
      {
        "language": "text",
        "code": "{{ id + 1 }}"
      },
      {
        "language": "text",
        "code": "{{ object.id }}"
      },
      {
        "language": "text",
        "code": "{{ object.id }}"
      },
      {
        "language": "text",
        "code": "{{ object.id.value }}"
      },
      {
        "language": "text",
        "code": "import { debounce } from 'lodash-es'\n\nexport default {\n  methods: {\n    // Debouncing with Lodash\n    click: debounce(function () {\n      // ... respond to click ...\n    }, 500)\n  }\n}"
      },
      {
        "language": "text",
        "code": "import { debounce } from 'lodash-es'\n\nexport default {\n  methods: {\n    // Debouncing with Lodash\n    click: debounce(function () {\n      // ... respond to click ...\n    }, 500)\n  }\n}"
      },
      {
        "language": "text",
        "code": "export default {\n  created() {\n    // each instance now has its own copy of debounced handler\n    this.debouncedClick = _.debounce(this.click, 500)\n  },\n  unmounted() {\n    // also a good idea to cancel the timer\n    // when the component is removed\n    this.debouncedClick.cancel()\n  },\n  methods: {\n    click() {\n      // ... respond to click ...\n    }\n  }\n}"
      },
      {
        "language": "text",
        "code": "export default {\n  created() {\n    // each instance now has its own copy of debounced handler\n    this.debouncedClick = _.debounce(this.click, 500)\n  },\n  unmounted() {\n    // also a good idea to cancel the timer\n    // when the component is removed\n    this.debouncedClick.cancel()\n  },\n  methods: {\n    click() {\n      // ... respond to click ...\n    }\n  }\n}"
      }
    ],
    "links": [
      {
        "text": "Try it in the Playground",
        "href": "https://play.vuejs.org/#eNpFUNFqhDAQ/JXBpzsoHu2j3B2U/oYPpnGtoetGkrW2iP/eRFsPApthd2Zndilex7H8mqioimu0wY16r4W+Rx8ULXVmYsVSC9AaNafz/gcC6RTkHwHWT6IVnne85rI+1ZLr5YJmyG1qG7gIA3Yd2R/LhN77T8y9sz1mwuyYkXazcQI2SiHz/7iP3VlQexeb5KKjEKEe2lPyMIxeSBROohqxVO4E6yV6ppL9xykTy83tOQvd7tnzoZtDwhrBO2GYNFloYWLyxrzPPOi44WWLWUt618txvASUhhRCKSHgbZt2scKy7HfCujGOqWL9BVfOgyI="
      },
      {
        "text": "JavaScript Proxies",
        "href": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Proxy"
      },
      {
        "text": "ref()",
        "href": "/api/reactivity-core#ref"
      },
      {
        "text": "Typing Refs",
        "href": "/guide/typescript/composition-api#typing-ref"
      },
      {
        "text": "Codepen",
        "href": "https://codepen.io/vuejs-examples/pen/WNYbaqo"
      },
      {
        "text": "Single-File Components (SFCs)",
        "href": "/guide/scaling-up/sfc"
      },
      {
        "text": "Try it in the Playground",
        "href": "https://play.vuejs.org/#eNo9jUEKgzAQRa8yZKMiaNcllvYe2dgwQqiZhDhxE3L3jrW4/DPvv1/UK8Zhz6juSm82uciwIef4MOR8DImhQMIFKiwpeGgEbQwZsoE2BhsyMUwH0d66475ksuwCgSOb0CNx20ExBCc77POase8NVUN6PBdlSwKjj+vMKAlAvzOzWJ52dfYzGXXpjPoBAKX856uopDGeFfnq8XKp+gWq4FAi"
      },
      {
        "text": "setup()",
        "href": "/api/composition-api-setup"
      },
      {
        "text": "Reactivity in Depth",
        "href": "/guide/extras/reactivity-in-depth"
      },
      {
        "text": "Watch a free video lesson on Vue School",
        "href": "https://vueschool.io/lessons/methods-in-vue-3?friend=vuejs"
      },
      {
        "text": "Try it in the Playground",
        "href": "https://play.vuejs.org/#eNplj9EKwyAMRX8l+LSx0e65uLL9hy+dZlTWqtg4BuK/z1baDgZicsPJgUR2d656B2QN45P02lErDH6c9QQKn10YCKIwAKqj7nAsPYBHCt6sCUDaYKiBS8lpLuk8/yNSb9XUrKg20uOIhnYXAPV6qhbF6fRvmOeodn6hfzwLKkx+vN5OyIFwdENHmBMAfwQia+AmBy1fV8E2gWBtjOUASInXBcxLvN4MLH0BCe1i4Q=="
      },
      {
        "text": "shallow refs",
        "href": "/api/reactivity-advanced#shallowref"
      },
      {
        "text": "Reduce Reactivity Overhead for Large Immutable Structures",
        "href": "/guide/best-practices/performance#reduce-reactivity-overhead-for-large-immutable-structures"
      },
      {
        "text": "Integration with External State Systems",
        "href": "/guide/extras/reactivity-in-depth#integration-with-external-state-systems"
      },
      {
        "text": "nextTick()",
        "href": "/api/general#nexttick"
      },
      {
        "text": "Typing Reactive",
        "href": "/guide/typescript/composition-api#typing-reactive"
      },
      {
        "text": "JavaScript Proxies",
        "href": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Proxy"
      },
      {
        "text": "shallowReactive()",
        "href": "/api/reactivity-advanced#shallowreactive"
      },
      {
        "text": "Proxy",
        "href": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Proxy"
      },
      {
        "text": "collection types",
        "href": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects#keyed_collections"
      },
      {
        "text": "primitive types",
        "href": "https://developer.mozilla.org/en-US/docs/Glossary/Primitive"
      },
      {
        "text": "shallow reactive object",
        "href": "/api/reactivity-advanced#shallowreactive"
      },
      {
        "text": "Edit this page on GitHub",
        "href": "https://github.com/vuejs/docs/edit/main/src/guide/essentials/reactivity-fundamentals.md"
      }
    ],
    "meta": {
      "description": "Vue.js - The Progressive JavaScript Framework",
      "keywords": ""
    },
    "summary": "Reactivity Fundamentals API PreferenceThis page and many other chapters later in the guide contain different content for the Options API and the Composition API",
    "tags": [
      "react",
      "vue",
      "angular",
      "javascript",
      "typescript",
      "css",
      "html",
      "vite",
      "reactive",
      "reactivity"
    ],
    "id": "reactivity-fundamentals-reactivityfundamentalshtml-part-1",
    "quality": 100
  },
  {
    "title": "Computed Properties",
    "url": "https://vuejs.org/guide/essentials/computed.html",
    "category": "vue",
    "content": "Computed Properties Watch a free video lesson on Vue SchoolWatch a free video lesson on Vue SchoolBasic Example In-template expressions are very convenient, but they are meant for simple operations. Putting too much logic in your templates can make them bloated and hard to maintain. For example, if we have an object with a nested array:jsexport default { data() { return { author: { name: 'John Doe', books: [ 'Vue 2 - Advanced Guide', 'Vue 3 - Basic Guide', 'Vue 4 - The Mystery' ] } } } }jsconst author = reactive({ name: 'John Doe', books: [ 'Vue 2 - Advanced Guide', 'Vue 3 - Basic Guide', 'Vue 4 - The Mystery' ] })And we want to display different messages depending on if author already has some books or not:templatepHas published books:/p span{{ author.books.length  0 ? 'Yes' : 'No' }}/spanAt this point, the template is getting a bit cluttered. We have to look at it for a second before realizing that it performs a calculation depending on author.books. More importantly, we probably don't want to repeat ourselves if we need to include this calculation in the template more than once.That's why for complex logic that includes reactive data, it is recommended to use a computed property. Here's the same example, refactored:jsexport default { data() { return { author: { name: 'John Doe', books: [ 'Vue 2 - Advanced Guide', 'Vue 3 - Basic Guide', 'Vue 4 - The Mystery' ] } } }, computed: { // a computed getter publishedBooksMessage() { // this points to the component instance return this.author.books.length  0 ? 'Yes' : 'No' } } }templatepHas published books:/p span{{ publishedBooksMessage }}/spanTry it in the PlaygroundHere we have declared a computed property publishedBooksMessage.Try to change the value of the books array in the application data and you will see how publishedBooksMessage is changing accordingly.You can data-bind to computed properties in templates just like a normal property. Vue is aware that this.publishedBooksMessage depends on this.author.books, so it will update any bindings that depend on this.publishedBooksMessage when this.author.books changes.See also: Typing Computed Properties vuescript setup import { reactive, computed } from 'vue' const author = reactive({ name: 'John Doe', books: [ 'Vue 2 - Advanced Guide', 'Vue 3 - Basic Guide', 'Vue 4 - The Mystery' ] }) // a computed ref const publishedBooksMessage = computed(() = { return author.books.length  0 ? 'Yes' : 'No' }) /script template pHas published books:/p span{{ publishedBooksMessage }}/span /templateTry it in the PlaygroundHere we have declared a computed property publishedBooksMessage. The computed() function expects to be passed a getter function, and the returned value is a computed ref. Similar to normal refs, you can access the computed result as publishedBooksMessage.value. Computed refs are also auto-unwrapped in templates so you can reference them without .value in template expressions.A computed property automatically tracks its reactive dependencies. Vue is aware that the computation of publishedBooksMessage depends on author.books, so it will update any bindings that depend on publishedBooksMessage when author.books changes.See also: Typing Computed Computed Caching vs. Methods You may have noticed we can achieve the same result by invoking a method in the expression:templatep{{ calculateBooksMessage() }}/pjs// in component methods: { calculateBooksMessage() { return this.author.books.length  0 ? 'Yes' : 'No' } }js// in component function calculateBooksMessage() { return author.books.length  0 ? 'Yes' : 'No' }Instead of a computed property, we can define the same function as a method. For the end result, the two approaches are indeed exactly the same. However, the difference is that computed properties are cached based on their reactive dependencies. A computed property will only re-evaluate when some of its reactive dependencies have changed. This means as long as author.books has not changed, multiple access to publishedBooksMessage will immediately return the previously computed result without having to run the getter function again.This also means the following computed property will never update, because Date.now() is not a reactive dependency:jscomputed: { now() { return Date.now() } }jsconst now = computed(() = Date.now())In comparison, a method invocation will always run the function whenever a re-render happens.Why do we need caching? Imagine we have an expensive computed property list, which requires looping through a huge array and doing a lot of computations. Then we may have other computed properties that in turn depend on list. Without caching, we would be executing lists getter many more times than necessary! In cases where you do not want caching, use a method call instead.Writable Computed Computed properties are by default getter-only. If you attempt to assign a new value to a computed property, you will receive a runtime warning. In the rare cases where you need a \"writable\" computed property, you can create one by providing both a getter and a setter:jsexport default { data() { return { firstName: 'John', lastName: 'Doe' } }, computed: { fullName: { // getter get() { return this.firstName + ' ' + this.lastName }, // setter set(newValue) { // Note: we are using destructuring assignment syntax here. [this.firstName, this.lastName] = newValue.split(' ') } } } }Now when you run this.fullName = 'John Doe', the setter will be invoked and this.firstName and this.lastName will be updated accordingly.vuescript setup import { ref, computed } from 'vue' const firstName = ref('John') const lastName = ref('Doe') const fullName = computed({ // getter get() { return firstName.value + ' ' + lastName.value }, // setter set(newValue) { // Note: we are using destructuring assignment syntax here. [firstName.value, lastName.value] = newValue.split(' ') } }) /scriptNow when you run fullName.value = 'John Doe', the setter will be invoked and firstName and lastName will be updated accordingly.Getting the Previous Value Only supported in 3.4+ In case you need it, you can get the previous value returned by the computed property accessing the second argument of the getter: In case you need it, you can get the previous value returned by the computed property accessing the first argument of the getter: jsexport default { data() { return { count: 2 } }, computed: { // This computed will return the value of count when it's less or equal to 3. // When count is =4, the last value that fulfilled our condition will be returned // instead until count is less or equal to 3 alwaysSmall(_, previous) { if (this.count = 3) { return this.count } return previous } } }vuescript setup import { ref, computed } from 'vue' const count = ref(2) // This computed will return the value of count when it's less or equal to 3. // When count is =4, the last value that fulfilled our condition will be returned // instead until count is less or equal to 3 const alwaysSmall = computed((previous) = { if (count.value = 3) { return count.value } return previous }) /scriptIn case you're using a writable computed:jsexport default { data() { return { count: 2 } }, computed: { alwaysSmall: { get(_, previous) { if (this.count = 3) { return this.count } return previous; }, set(newValue) { this.count = newValue * 2 } } } }vuescript setup import { ref, computed } from 'vue' const count = ref(2) const alwaysSmall = computed({ get(previous) { if (count.value = 3) { return count.value } return previous }, set(newValue) { count.value = newValue * 2 } }) /scriptBest Practices Getters should be side-effect free It is important to remember that computed getter functions should only perform pure computation and be free of side effects. For example, don't mutate other state, make async requests, or mutate the DOM inside a computed getter! Think of a computed property as declaratively describing how to derive a value based on other values - its only responsibility should be computing and returning that value. Later in the guide we will discuss how we can perform side effects in reaction to state changes with watchers.Avoid mutating computed value The returned value from a computed property is derived state. Think of it as a temporary snapshot - every time the source state changes, a new snapshot is created. It does not make sense to mutate a snapshot, so a computed return value should be treated as read-only and never be mutated - instead, update the source state it depends on to trigger new computations.Edit this page on GitHub",
    "headings": [
      {
        "level": 1,
        "text": "Computed Properties ​",
        "id": "computed-properties"
      },
      {
        "level": 2,
        "text": "Basic Example ​",
        "id": "basic-example"
      },
      {
        "level": 2,
        "text": "Computed Caching vs. Methods ​",
        "id": "computed-caching-vs-methods"
      },
      {
        "level": 2,
        "text": "Writable Computed ​",
        "id": "writable-computed"
      },
      {
        "level": 2,
        "text": "Getting the Previous Value ​",
        "id": "previous"
      },
      {
        "level": 2,
        "text": "Best Practices ​",
        "id": "best-practices"
      },
      {
        "level": 3,
        "text": "Getters should be side-effect free ​",
        "id": "getters-should-be-side-effect-free"
      },
      {
        "level": 3,
        "text": "Avoid mutating computed value ​",
        "id": "avoid-mutating-computed-value"
      }
    ],
    "codeBlocks": [
      {
        "language": "text",
        "code": "export default {\n  data() {\n    return {\n      author: {\n        name: 'John Doe',\n        books: [\n          'Vue 2 - Advanced Guide',\n          'Vue 3 - Basic Guide',\n          'Vue 4 - The Mystery'\n        ]\n      }\n    }\n  }\n}"
      },
      {
        "language": "text",
        "code": "export default {\n  data() {\n    return {\n      author: {\n        name: 'John Doe',\n        books: [\n          'Vue 2 - Advanced Guide',\n          'Vue 3 - Basic Guide',\n          'Vue 4 - The Mystery'\n        ]\n      }\n    }\n  }\n}"
      },
      {
        "language": "text",
        "code": "const author = reactive({\n  name: 'John Doe',\n  books: [\n    'Vue 2 - Advanced Guide',\n    'Vue 3 - Basic Guide',\n    'Vue 4 - The Mystery'\n  ]\n})"
      },
      {
        "language": "text",
        "code": "const author = reactive({\n  name: 'John Doe',\n  books: [\n    'Vue 2 - Advanced Guide',\n    'Vue 3 - Basic Guide',\n    'Vue 4 - The Mystery'\n  ]\n})"
      },
      {
        "language": "text",
        "code": "<p>Has published books:</p>\n<span>{{ author.books.length > 0 ? 'Yes' : 'No' }}</span>"
      },
      {
        "language": "text",
        "code": "<p>Has published books:</p>\n<span>{{ author.books.length > 0 ? 'Yes' : 'No' }}</span>"
      },
      {
        "language": "text",
        "code": "author.books"
      },
      {
        "language": "text",
        "code": "export default {\n  data() {\n    return {\n      author: {\n        name: 'John Doe',\n        books: [\n          'Vue 2 - Advanced Guide',\n          'Vue 3 - Basic Guide',\n          'Vue 4 - The Mystery'\n        ]\n      }\n    }\n  },\n  computed: {\n    // a computed getter\n    publishedBooksMessage() {\n      // `this` points to the component instance\n      return this.author.books.length > 0 ? 'Yes' : 'No'\n    }\n  }\n}"
      },
      {
        "language": "text",
        "code": "export default {\n  data() {\n    return {\n      author: {\n        name: 'John Doe',\n        books: [\n          'Vue 2 - Advanced Guide',\n          'Vue 3 - Basic Guide',\n          'Vue 4 - The Mystery'\n        ]\n      }\n    }\n  },\n  computed: {\n    // a computed getter\n    publishedBooksMessage() {\n      // `this` points to the component instance\n      return this.author.books.length > 0 ? 'Yes' : 'No'\n    }\n  }\n}"
      },
      {
        "language": "text",
        "code": "<p>Has published books:</p>\n<span>{{ publishedBooksMessage }}</span>"
      },
      {
        "language": "text",
        "code": "<p>Has published books:</p>\n<span>{{ publishedBooksMessage }}</span>"
      },
      {
        "language": "text",
        "code": "publishedBooksMessage"
      },
      {
        "language": "text",
        "code": "publishedBooksMessage"
      },
      {
        "language": "text",
        "code": "this.publishedBooksMessage"
      },
      {
        "language": "text",
        "code": "this.author.books"
      },
      {
        "language": "text",
        "code": "this.publishedBooksMessage"
      },
      {
        "language": "text",
        "code": "this.author.books"
      },
      {
        "language": "text",
        "code": "<script setup>\nimport { reactive, computed } from 'vue'\n\nconst author = reactive({\n  name: 'John Doe',\n  books: [\n    'Vue 2 - Advanced Guide',\n    'Vue 3 - Basic Guide',\n    'Vue 4 - The Mystery'\n  ]\n})\n\n// a computed ref\nconst publishedBooksMessage = computed(() => {\n  return author.books.length > 0 ? 'Yes' : 'No'\n})\n</script>\n\n<template>\n  <p>Has published books:</p>\n  <span>{{ publishedBooksMessage }}</span>\n</template>"
      },
      {
        "language": "text",
        "code": "<script setup>\nimport { reactive, computed } from 'vue'\n\nconst author = reactive({\n  name: 'John Doe',\n  books: [\n    'Vue 2 - Advanced Guide',\n    'Vue 3 - Basic Guide',\n    'Vue 4 - The Mystery'\n  ]\n})\n\n// a computed ref\nconst publishedBooksMessage = computed(() => {\n  return author.books.length > 0 ? 'Yes' : 'No'\n})\n</script>\n\n<template>\n  <p>Has published books:</p>\n  <span>{{ publishedBooksMessage }}</span>\n</template>"
      },
      {
        "language": "text",
        "code": "publishedBooksMessage"
      },
      {
        "language": "text",
        "code": "publishedBooksMessage.value"
      },
      {
        "language": "text",
        "code": "publishedBooksMessage"
      },
      {
        "language": "text",
        "code": "author.books"
      },
      {
        "language": "text",
        "code": "publishedBooksMessage"
      },
      {
        "language": "text",
        "code": "author.books"
      },
      {
        "language": "text",
        "code": "<p>{{ calculateBooksMessage() }}</p>"
      },
      {
        "language": "text",
        "code": "<p>{{ calculateBooksMessage() }}</p>"
      },
      {
        "language": "text",
        "code": "// in component\nmethods: {\n  calculateBooksMessage() {\n    return this.author.books.length > 0 ? 'Yes' : 'No'\n  }\n}"
      },
      {
        "language": "text",
        "code": "// in component\nmethods: {\n  calculateBooksMessage() {\n    return this.author.books.length > 0 ? 'Yes' : 'No'\n  }\n}"
      },
      {
        "language": "text",
        "code": "// in component\nfunction calculateBooksMessage() {\n  return author.books.length > 0 ? 'Yes' : 'No'\n}"
      },
      {
        "language": "text",
        "code": "// in component\nfunction calculateBooksMessage() {\n  return author.books.length > 0 ? 'Yes' : 'No'\n}"
      },
      {
        "language": "text",
        "code": "author.books"
      },
      {
        "language": "text",
        "code": "publishedBooksMessage"
      },
      {
        "language": "text",
        "code": "computed: {\n  now() {\n    return Date.now()\n  }\n}"
      },
      {
        "language": "text",
        "code": "computed: {\n  now() {\n    return Date.now()\n  }\n}"
      },
      {
        "language": "text",
        "code": "const now = computed(() => Date.now())"
      },
      {
        "language": "text",
        "code": "const now = computed(() => Date.now())"
      },
      {
        "language": "text",
        "code": "export default {\n  data() {\n    return {\n      firstName: 'John',\n      lastName: 'Doe'\n    }\n  },\n  computed: {\n    fullName: {\n      // getter\n      get() {\n        return this.firstName + ' ' + this.lastName\n      },\n      // setter\n      set(newValue) {\n        // Note: we are using destructuring assignment syntax here.\n        [this.firstName, this.lastName] = newValue.split(' ')\n      }\n    }\n  }\n}"
      },
      {
        "language": "text",
        "code": "export default {\n  data() {\n    return {\n      firstName: 'John',\n      lastName: 'Doe'\n    }\n  },\n  computed: {\n    fullName: {\n      // getter\n      get() {\n        return this.firstName + ' ' + this.lastName\n      },\n      // setter\n      set(newValue) {\n        // Note: we are using destructuring assignment syntax here.\n        [this.firstName, this.lastName] = newValue.split(' ')\n      }\n    }\n  }\n}"
      },
      {
        "language": "text",
        "code": "this.fullName = 'John Doe'"
      },
      {
        "language": "text",
        "code": "this.firstName"
      },
      {
        "language": "text",
        "code": "this.lastName"
      },
      {
        "language": "text",
        "code": "<script setup>\nimport { ref, computed } from 'vue'\n\nconst firstName = ref('John')\nconst lastName = ref('Doe')\n\nconst fullName = computed({\n  // getter\n  get() {\n    return firstName.value + ' ' + lastName.value\n  },\n  // setter\n  set(newValue) {\n    // Note: we are using destructuring assignment syntax here.\n    [firstName.value, lastName.value] = newValue.split(' ')\n  }\n})\n</script>"
      },
      {
        "language": "text",
        "code": "<script setup>\nimport { ref, computed } from 'vue'\n\nconst firstName = ref('John')\nconst lastName = ref('Doe')\n\nconst fullName = computed({\n  // getter\n  get() {\n    return firstName.value + ' ' + lastName.value\n  },\n  // setter\n  set(newValue) {\n    // Note: we are using destructuring assignment syntax here.\n    [firstName.value, lastName.value] = newValue.split(' ')\n  }\n})\n</script>"
      },
      {
        "language": "text",
        "code": "fullName.value = 'John Doe'"
      },
      {
        "language": "text",
        "code": "export default {\n  data() {\n    return {\n      count: 2\n    }\n  },\n  computed: {\n    // This computed will return the value of count when it's less or equal to 3.\n    // When count is >=4, the last value that fulfilled our condition will be returned\n    // instead until count is less or equal to 3\n    alwaysSmall(_, previous) {\n      if (this.count <= 3) {\n        return this.count\n      }\n\n      return previous\n    }\n  }\n}"
      },
      {
        "language": "text",
        "code": "export default {\n  data() {\n    return {\n      count: 2\n    }\n  },\n  computed: {\n    // This computed will return the value of count when it's less or equal to 3.\n    // When count is >=4, the last value that fulfilled our condition will be returned\n    // instead until count is less or equal to 3\n    alwaysSmall(_, previous) {\n      if (this.count <= 3) {\n        return this.count\n      }\n\n      return previous\n    }\n  }\n}"
      },
      {
        "language": "text",
        "code": "<script setup>\nimport { ref, computed } from 'vue'\n\nconst count = ref(2)\n\n// This computed will return the value of count when it's less or equal to 3.\n// When count is >=4, the last value that fulfilled our condition will be returned\n// instead until count is less or equal to 3\nconst alwaysSmall = computed((previous) => {\n  if (count.value <= 3) {\n    return count.value\n  }\n\n  return previous\n})\n</script>"
      },
      {
        "language": "text",
        "code": "<script setup>\nimport { ref, computed } from 'vue'\n\nconst count = ref(2)\n\n// This computed will return the value of count when it's less or equal to 3.\n// When count is >=4, the last value that fulfilled our condition will be returned\n// instead until count is less or equal to 3\nconst alwaysSmall = computed((previous) => {\n  if (count.value <= 3) {\n    return count.value\n  }\n\n  return previous\n})\n</script>"
      },
      {
        "language": "text",
        "code": "export default {\n  data() {\n    return {\n      count: 2\n    }\n  },\n  computed: {\n    alwaysSmall: {\n      get(_, previous) {\n        if (this.count <= 3) {\n          return this.count\n        }\n\n        return previous;\n      },\n      set(newValue) {\n        this.count = newValue * 2\n      }\n    }\n  }\n}"
      },
      {
        "language": "text",
        "code": "export default {\n  data() {\n    return {\n      count: 2\n    }\n  },\n  computed: {\n    alwaysSmall: {\n      get(_, previous) {\n        if (this.count <= 3) {\n          return this.count\n        }\n\n        return previous;\n      },\n      set(newValue) {\n        this.count = newValue * 2\n      }\n    }\n  }\n}"
      },
      {
        "language": "text",
        "code": "<script setup>\nimport { ref, computed } from 'vue'\n\nconst count = ref(2)\n\nconst alwaysSmall = computed({\n  get(previous) {\n    if (count.value <= 3) {\n      return count.value\n    }\n\n    return previous\n  },\n  set(newValue) {\n    count.value = newValue * 2\n  }\n})\n</script>"
      },
      {
        "language": "text",
        "code": "<script setup>\nimport { ref, computed } from 'vue'\n\nconst count = ref(2)\n\nconst alwaysSmall = computed({\n  get(previous) {\n    if (count.value <= 3) {\n      return count.value\n    }\n\n    return previous\n  },\n  set(newValue) {\n    count.value = newValue * 2\n  }\n})\n</script>"
      }
    ],
    "links": [
      {
        "text": "Watch a free video lesson on Vue School",
        "href": "https://vueschool.io/lessons/computed-properties-in-vue-3?friend=vuejs"
      },
      {
        "text": "Watch a free video lesson on Vue School",
        "href": "https://vueschool.io/lessons/vue-fundamentals-capi-computed-properties-in-vue-with-the-composition-api?friend=vuejs"
      },
      {
        "text": "Try it in the Playground",
        "href": "https://play.vuejs.org/#eNqFkN1KxDAQhV/l0JsqaFfUq1IquwiKsF6JINaLbDNui20S8rO4lL676c82eCFCIDOZMzkzXxetlUoOjqI0ykypa2XzQtC3ktqC0ydzjUVXCIAzy87OpxjQZJ0WpwxgzlZSp+EBEKylFPGTrATuJcUXobST8sukeA8vQPzqCNe4xJofmCiJ48HV/FfbLLrxog0zdfmn4tYrXirC9mgs6WMcBB+nsJ+C8erHH0rZKmeJL0sot2tqUxHfDONuyRi2p4BggWCr2iQTgGTcLGlI7G2FHFe4Q/xGJoYn8SznQSbTQviTrRboPrHUqoZZ8hmQqfyRmTDFTC1bqalsFBN5183o/3NG33uvoWUwXYyi/gdTEpwK"
      },
      {
        "text": "Typing Computed Properties",
        "href": "/guide/typescript/options-api#typing-computed-properties"
      },
      {
        "text": "Try it in the Playground",
        "href": "https://play.vuejs.org/#eNp1kE9Lw0AQxb/KI5dtoTainkoaaREUoZ5EEONhm0ybYLO77J9CCfnuzta0vdjbzr6Zeb95XbIwZroPlMySzJW2MR6OfDB5oZrWaOvRwZIsfbOnCUrdmuCpQo+N1S0ET4pCFarUynnI4GttMT9PjLpCAUq2NIN41bXCkyYxiZ9rrX/cDF/xDYiPQLjDDRbVXqqSHZ5DUw2tg3zP8lK6pvxHe2DtvSasDs6TPTAT8F2ofhzh0hTygm5pc+I1Yb1rXE3VMsKsyDm5JcY/9Y5GY8xzHI+wnIpVw4nTI/10R2rra+S4xSPEJzkBvvNNs310ztK/RDlLLjy1Zic9cQVkJn+R7gIwxJGlMXiWnZEq77orhH3Pq2NH9DjvTfpfSBSbmA=="
      },
      {
        "text": "getter function",
        "href": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Functions/get#description"
      },
      {
        "text": "Typing Computed",
        "href": "/guide/typescript/composition-api#typing-computed"
      },
      {
        "text": "watchers",
        "href": "/guide/essentials/watchers"
      },
      {
        "text": "Edit this page on GitHub",
        "href": "https://github.com/vuejs/docs/edit/main/src/guide/essentials/computed.md"
      }
    ],
    "meta": {
      "description": "Vue.js - The Progressive JavaScript Framework",
      "keywords": ""
    },
    "summary": "Computed Properties Watch a free video lesson on Vue SchoolWatch a free video lesson on Vue SchoolBasic Example In-template expressions are very convenient, but they are meant for simple operations",
    "tags": [
      "react",
      "vue",
      "angular",
      "javascript",
      "typescript",
      "html",
      "computed",
      "properties",
      "value",
      "basic"
    ],
    "id": "computed-properties-computedhtml-part-1",
    "quality": 100
  },
  {
    "title": "Watchers",
    "url": "https://vuejs.org/guide/essentials/watchers.html",
    "category": "vue",
    "content": "Watchers Basic Example Computed properties allow us to declaratively compute derived values. However, there are cases where we need to perform \"side effects\" in reaction to state changes - for example, mutating the DOM, or changing another piece of state based on the result of an async operation.With the Options API, we can use the watch option to trigger a function whenever a reactive property changes:jsexport default { data() { return { question: '', answer: 'Questions usually contain a question mark. ;-)', loading: false } }, watch: { // whenever question changes, this function will run question(newQuestion, oldQuestion) { if (newQuestion.includes('?')) { this.getAnswer() } } }, methods: { async getAnswer() { this.loading = true this.answer = 'Thinking...' try { const res = await fetch('https://yesno.wtf/api') this.answer = (await res.json()).answer } catch (error) { this.answer = 'Error! Could not reach the API. ' + error } finally { this.loading = false } } } }templatep Ask a yes/no question: input v-model=\"question\" :disabled=\"loading\" / /p p{{ answer }}/pTry it in the PlaygroundThe watch option also supports a dot-delimited path as the key:jsexport default { watch: { // Note: only simple paths. Expressions are not supported. 'some.nested.key'(newValue) { // ... } } }With Composition API, we can use the watch function to trigger a callback whenever a piece of reactive state changes:vuescript setup import { ref, watch } from 'vue' const question = ref('') const answer = ref('Questions usually contain a question mark. ;-)') const loading = ref(false) // watch works directly on a ref watch(question, async (newQuestion, oldQuestion) = { if (newQuestion.includes('?')) { loading.value = true answer.value = 'Thinking...' try { const res = await fetch('https://yesno.wtf/api') answer.value = (await res.json()).answer } catch (error) { answer.value = 'Error! Could not reach the API. ' + error } finally { loading.value = false } } }) /script template p Ask a yes/no question: input v-model=\"question\" :disabled=\"loading\" / /p p{{ answer }}/p /templateTry it in the PlaygroundWatch Source Types watch's first argument can be different types of reactive \"sources\": it can be a ref (including computed refs), a reactive object, a getter function, or an array of multiple sources:jsconst x = ref(0) const y = ref(0) // single ref watch(x, (newX) = { console.log(x is ${newX}) }) // getter watch( () = x.value + y.value, (sum) = { console.log(sum of x + y is: ${sum}) } ) // array of multiple sources watch([x, () = y.value], ([newX, newY]) = { console.log(x is ${newX} and y is ${newY}) })Do note that you can't watch a property of a reactive object like this:jsconst obj = reactive({ count: 0 }) // this won't work because we are passing a number to watch() watch(obj.count, (count) = { console.log(Count is: ${count}) })Instead, use a getter:js// instead, use a getter: watch( () = obj.count, (count) = { console.log(Count is: ${count}) } )Deep Watchers watch is shallow by default: the callback will only trigger when the watched property has been assigned a new value - it won't trigger on nested property changes. If you want the callback to fire on all nested mutations, you need to use a deep watcher:jsexport default { watch: { someObject: { handler(newValue, oldValue) { // Note: newValue will be equal to oldValue here // on nested mutations as long as the object itself // hasn't been replaced. }, deep: true } } }When you call watch() directly on a reactive object, it will implicitly create a deep watcher - the callback will be triggered on all nested mutations:jsconst obj = reactive({ count: 0 }) watch(obj, (newValue, oldValue) = { // fires on nested property mutations // Note: newValue will be equal to oldValue here // because they both point to the same object! }) obj.count++This should be differentiated with a getter that returns a reactive object - in the latter case, the callback will only fire if the getter returns a different object:jswatch( () = state.someObject, () = { // fires only when state.someObject is replaced } )You can, however, force the second case into a deep watcher by explicitly using the deep option:jswatch( () = state.someObject, (newValue, oldValue) = { // Note: newValue will be equal to oldValue here // *unless* state.someObject has been replaced }, { deep: true } )In Vue 3.5+, the deep option can also be a number indicating the max traversal depth - i.e. how many levels should Vue traverse an object's nested properties.Use with CautionDeep watch requires traversing all nested properties in the watched object, and can be expensive when used on large data structures. Use it only when necessary and beware of the performance implications.Eager Watchers watch is lazy by default: the callback won't be called until the watched source has changed. But in some cases we may want the same callback logic to be run eagerly - for example, we may want to fetch some initial data, and then re-fetch the data whenever relevant state changes.We can force a watcher's callback to be executed immediately by declaring it using an object with a handler function and the immediate: true option:jsexport default { // ... watch: { question: { handler(newQuestion) { // this will be run immediately on component creation. }, // force eager callback execution immediate: true } } // ... }The initial execution of the handler function will happen just before the created hook. Vue will have already processed the data, computed, and methods options, so those properties will be available on the first invocation.We can force a watcher's callback to be executed immediately by passing the immediate: true option:jswatch( source, (newValue, oldValue) = { // executed immediately, then again when source changes }, { immediate: true } )Once Watchers Only supported in 3.4+Watcher's callback will execute whenever the watched source changes. If you want the callback to trigger only once when the source changes, use the once: true option.jsexport default { watch: { source: { handler(newValue, oldValue) { // when source changes, triggers only once }, once: true } } }jswatch( source, (newValue, oldValue) = { // when source changes, triggers only once }, { once: true } )watchEffect() It is common for the watcher callback to use exactly the same reactive state as the source. For example, consider the following code, which uses a watcher to load a remote resource whenever the todoId ref changes:jsconst todoId = ref(1) const data = ref(null) watch( todoId, async () = { const response = await fetch( https://jsonplaceholder.typicode.com/todos/${todoId.value} ) data.value = await response.json() }, { immediate: true } )In particular, notice how the watcher uses todoId twice, once as the source and then again inside the callback.This can be simplified with watchEffect(). watchEffect() allows us to track the callback's reactive dependencies automatically. The watcher above can be rewritten as:jswatchEffect(async () = { const response = await fetch( https://jsonplaceholder.typicode.com/todos/${todoId.value} ) data.value = await response.json() })Here, the callback will run immediately, there's no need to specify immediate: true. During its execution, it will automatically track todoId.value as a dependency (similar to computed properties). Whenever todoId.value changes, the callback will be run again. With watchEffect(), we no longer need to pass todoId explicitly as the source value.You can check out this example of watchEffect() and reactive data-fetching in action.For examples like these, with only one dependency, the benefit of watchEffect() is relatively small. But for watchers that have multiple dependencies, using watchEffect() removes the burden of having to maintain the list of dependencies manually. In addition, if you need to watch several properties in a nested data structure, watchEffect() may prove more efficient than a deep watcher, as it will only track the properties that are used in the callback, rather than recursively tracking all of them.TIPwatchEffect only tracks dependencies during its synchronous execution. When using it with an async callback, only properties accessed before the first await tick will be tracked.watch vs. watchEffect watch and watchEffect both allow us to reactively perform side effects. Their main difference is the way they track their reactive dependencies:watch only tracks the explicitly watched source. It won't track anything accessed inside the callback. In addition, the callback only triggers when the source has actually changed. watch separates dependency tracking from the side effect, giving us more precise control over when the callback should fire.watchEffect, on the other hand, combines dependency tracking and side effect into one phase. It automatically tracks every reactive property accessed during its synchronous execution. This is more convenient and typically results in terser code, but makes its reactive dependencies less explicit.Side Effect Cleanup Sometimes we may perform side effects, e.g. asynchronous requests, in a watcher:jswatch(id, (newId) = { fetch(/api/${newId}).then(() = { // callback logic }) })jsexport default { watch: { id(newId) { fetch(/api/${newId}).then(() = { // callback logic }) } } }But what if id changes before the request completes? When the previous request completes, it will still fire the callback with an ID value that is already stale. Ideally, we want to be able to cancel the stale request when id changes to a new value.We can use the onWatcherCleanup() API to register a cleanup function that will be called when the watcher is invalidated and is about to re-run:jsimport { watch, onWatcherCleanup } from 'vue' watch(id, (newId) = { const controller = new AbortController() fetch(/api/${newId}, { signal: controller.signal }).then(() = { // callback logic }) onWatcherCleanup(() = { // abort stale request controller.abort() }) })jsimport { onWatcherCleanup } from 'vue' export default { watch: { id(newId) { const controller = new AbortController() fetch(/api/${newId}, { signal: controller.signal }).then(() = { // callback logic }) onWatcherCleanup(() = { // abort stale request controller.abort() }) } } }Note that onWatcherCleanup is only supported in Vue 3.5+ and must be called during the synchronous execution of a watchEffect effect function or watch callback function: you cannot call it after an await statement in an async function.Alternatively, an onCleanup function is also passed to watcher callbacks as the 3rd argument, and to the watchEffect effect function as the first argument:jswatch(id, (newId, oldId, onCleanup) = { // ... onCleanup(() = { // cleanup logic }) }) watchEffect((onCleanup) = { // ... onCleanup(() = { // cleanup logic }) })jsexport default { watch: { id(newId, oldId, onCleanup) { // ... onCleanup(() = { // cleanup logic }) } } }This works in versions before 3.5. In addition, onCleanup passed via function argument is bound to the watcher instance so it is not subject to the synchronously constraint of onWatcherCleanup.Callback Flush Timing When you mutate reactive state, it may trigger both Vue component updates and watcher callbacks created by you.Similar to component updates, user-created watcher callbacks are batched to avoid duplicate invocations. For example, we probably don't want a watcher to fire a thousand times if we synchronously push a thousand items into an array being watched.By default, a watcher's callback is called after parent component updates (if any), and before the owner component's DOM updates. This means if you attempt to access the owner component's own DOM inside a watcher callback, the DOM will be in a pre-update state.Post Watchers If you want to access the owner component's DOM in a watcher callback after Vue has updated it, you need to specify the flush: 'post' option:jsexport default { // ... watch: { key: { handler() {}, flush: 'post' } } }jswatch(source, callback, { flush: 'post' }) watchEffect(callback, { flush: 'post' })Post-flush watchEffect() also has a convenience alias, watchPostEffect():jsimport { watchPostEffect } from 'vue' watchPostEffect(() = { /* executed after Vue updates */ })Sync Watchers It's also possible to create a watcher that fires synchronously, before any Vue-managed updates:jsexport default { // ... watch: { key: { handler() {}, flush: 'sync' } } }jswatch(source, callback, { flush: 'sync' }) watchEffect(callback, { flush: 'sync' })Sync watchEffect() also has a convenience alias, watchSyncEffect():jsimport { watchSyncEffect } from 'vue' watchSyncEffect(() = { /* executed synchronously upon reactive data change */ })Use with CautionSync watchers do not have batching and triggers every time a reactive mutation is detected. It's ok to use them to watch simple boolean values, but avoid using them on data sources that might be synchronously mutated many times, e.g. arrays.this.$watch() It's also possible to imperatively create watchers using the $watch() instance method:jsexport default { created() { this.$watch('question', (newQuestion) = { // ... }) } }This is useful when you need to conditionally set up a watcher, or only watch something in response to user interaction. It also allows you to stop the watcher early.Stopping a Watcher Watchers declared using the watch option or the $watch() instance method are automatically stopped when the owner component is unmounted, so in most cases you don't need to worry about stopping the watcher yourself.In the rare case where you need to stop a watcher before the owner component unmounts, the $watch() API returns a function for that:jsconst unwatch = this.$watch('foo', callback) // ...when the watcher is no longer needed: unwatch()Watchers declared synchronously inside setup() or script setup are bound to the owner component instance, and will be automatically stopped when the owner component is unmounted. In most cases, you don't need to worry about stopping the watcher yourself.The key here is that the watcher must be created synchronously: if the watcher is created in an async callback, it won't be bound to the owner component and must be stopped manually to avoid memory leaks. Here's an example:vuescript setup import { watchEffect } from 'vue' // this one will be automatically stopped watchEffect(() = {}) // ...this one will not! setTimeout(() = { watchEffect(() = {}) }, 100) /scriptTo manually stop a watcher, use the returned handle function. This works for both watch and watchEffect:jsconst unwatch = watchEffect(() = {}) // ...later, when no longer needed unwatch()Note that there should be very few cases where you need to create watchers asynchronously, and synchronous creation should be preferred whenever possible. If you need to wait for some async data, you can make your watch logic conditional instead:js// data to be loaded asynchronously const data = ref(null) watchEffect(() = { if (data.value) { // do something when data is loaded } })Edit this page on GitHub",
    "headings": [
      {
        "level": 1,
        "text": "Watchers ​",
        "id": "watchers"
      },
      {
        "level": 2,
        "text": "Basic Example ​",
        "id": "basic-example"
      },
      {
        "level": 2,
        "text": "Deep Watchers ​",
        "id": "deep-watchers"
      },
      {
        "level": 2,
        "text": "Eager Watchers ​",
        "id": "eager-watchers"
      },
      {
        "level": 2,
        "text": "Once Watchers ​",
        "id": "once-watchers"
      },
      {
        "level": 2,
        "text": "watchEffect() ​",
        "id": "watcheffect"
      },
      {
        "level": 2,
        "text": "Side Effect Cleanup ​",
        "id": "side-effect-cleanup"
      },
      {
        "level": 2,
        "text": "Callback Flush Timing ​",
        "id": "callback-flush-timing"
      },
      {
        "level": 2,
        "text": "this.$watch() ​",
        "id": "this-watch"
      },
      {
        "level": 2,
        "text": "Stopping a Watcher ​",
        "id": "stopping-a-watcher"
      },
      {
        "level": 3,
        "text": "Watch Source Types ​",
        "id": "watch-source-types"
      },
      {
        "level": 3,
        "text": "watch vs. watchEffect ​",
        "id": "watch-vs-watcheffect"
      },
      {
        "level": 3,
        "text": "Post Watchers ​",
        "id": "post-watchers"
      },
      {
        "level": 3,
        "text": "Sync Watchers ​",
        "id": "sync-watchers"
      }
    ],
    "codeBlocks": [
      {
        "language": "text",
        "code": "export default {\n  data() {\n    return {\n      question: '',\n      answer: 'Questions usually contain a question mark. ;-)',\n      loading: false\n    }\n  },\n  watch: {\n    // whenever question changes, this function will run\n    question(newQuestion, oldQuestion) {\n      if (newQuestion.includes('?')) {\n        this.getAnswer()\n      }\n    }\n  },\n  methods: {\n    async getAnswer() {\n      this.loading = true\n      this.answer = 'Thinking...'\n      try {\n        const res = await fetch('https://yesno.wtf/api')\n        this.answer = (await res.json()).answer\n      } catch (error) {\n        this.answer = 'Error! Could not reach the API. ' + error\n      } finally {\n        this.loading = false\n      }\n    }\n  }\n}"
      },
      {
        "language": "text",
        "code": "export default {\n  data() {\n    return {\n      question: '',\n      answer: 'Questions usually contain a question mark. ;-)',\n      loading: false\n    }\n  },\n  watch: {\n    // whenever question changes, this function will run\n    question(newQuestion, oldQuestion) {\n      if (newQuestion.includes('?')) {\n        this.getAnswer()\n      }\n    }\n  },\n  methods: {\n    async getAnswer() {\n      this.loading = true\n      this.answer = 'Thinking...'\n      try {\n        const res = await fetch('https://yesno.wtf/api')\n        this.answer = (await res.json()).answer\n      } catch (error) {\n        this.answer = 'Error! Could not reach the API. ' + error\n      } finally {\n        this.loading = false\n      }\n    }\n  }\n}"
      },
      {
        "language": "text",
        "code": "<p>\n  Ask a yes/no question:\n  <input v-model=\"question\" :disabled=\"loading\" />\n</p>\n<p>{{ answer }}</p>"
      },
      {
        "language": "text",
        "code": "<p>\n  Ask a yes/no question:\n  <input v-model=\"question\" :disabled=\"loading\" />\n</p>\n<p>{{ answer }}</p>"
      },
      {
        "language": "text",
        "code": "export default {\n  watch: {\n    // Note: only simple paths. Expressions are not supported.\n    'some.nested.key'(newValue) {\n      // ...\n    }\n  }\n}"
      },
      {
        "language": "text",
        "code": "export default {\n  watch: {\n    // Note: only simple paths. Expressions are not supported.\n    'some.nested.key'(newValue) {\n      // ...\n    }\n  }\n}"
      },
      {
        "language": "text",
        "code": "<script setup>\nimport { ref, watch } from 'vue'\n\nconst question = ref('')\nconst answer = ref('Questions usually contain a question mark. ;-)')\nconst loading = ref(false)\n\n// watch works directly on a ref\nwatch(question, async (newQuestion, oldQuestion) => {\n  if (newQuestion.includes('?')) {\n    loading.value = true\n    answer.value = 'Thinking...'\n    try {\n      const res = await fetch('https://yesno.wtf/api')\n      answer.value = (await res.json()).answer\n    } catch (error) {\n      answer.value = 'Error! Could not reach the API. ' + error\n    } finally {\n      loading.value = false\n    }\n  }\n})\n</script>\n\n<template>\n  <p>\n    Ask a yes/no question:\n    <input v-model=\"question\" :disabled=\"loading\" />\n  </p>\n  <p>{{ answer }}</p>\n</template>"
      },
      {
        "language": "text",
        "code": "<script setup>\nimport { ref, watch } from 'vue'\n\nconst question = ref('')\nconst answer = ref('Questions usually contain a question mark. ;-)')\nconst loading = ref(false)\n\n// watch works directly on a ref\nwatch(question, async (newQuestion, oldQuestion) => {\n  if (newQuestion.includes('?')) {\n    loading.value = true\n    answer.value = 'Thinking...'\n    try {\n      const res = await fetch('https://yesno.wtf/api')\n      answer.value = (await res.json()).answer\n    } catch (error) {\n      answer.value = 'Error! Could not reach the API. ' + error\n    } finally {\n      loading.value = false\n    }\n  }\n})\n</script>\n\n<template>\n  <p>\n    Ask a yes/no question:\n    <input v-model=\"question\" :disabled=\"loading\" />\n  </p>\n  <p>{{ answer }}</p>\n</template>"
      },
      {
        "language": "text",
        "code": "const x = ref(0)\nconst y = ref(0)\n\n// single ref\nwatch(x, (newX) => {\n  console.log(`x is ${newX}`)\n})\n\n// getter\nwatch(\n  () => x.value + y.value,\n  (sum) => {\n    console.log(`sum of x + y is: ${sum}`)\n  }\n)\n\n// array of multiple sources\nwatch([x, () => y.value], ([newX, newY]) => {\n  console.log(`x is ${newX} and y is ${newY}`)\n})"
      },
      {
        "language": "text",
        "code": "const x = ref(0)\nconst y = ref(0)\n\n// single ref\nwatch(x, (newX) => {\n  console.log(`x is ${newX}`)\n})\n\n// getter\nwatch(\n  () => x.value + y.value,\n  (sum) => {\n    console.log(`sum of x + y is: ${sum}`)\n  }\n)\n\n// array of multiple sources\nwatch([x, () => y.value], ([newX, newY]) => {\n  console.log(`x is ${newX} and y is ${newY}`)\n})"
      },
      {
        "language": "text",
        "code": "const obj = reactive({ count: 0 })\n\n// this won't work because we are passing a number to watch()\nwatch(obj.count, (count) => {\n  console.log(`Count is: ${count}`)\n})"
      },
      {
        "language": "text",
        "code": "const obj = reactive({ count: 0 })\n\n// this won't work because we are passing a number to watch()\nwatch(obj.count, (count) => {\n  console.log(`Count is: ${count}`)\n})"
      },
      {
        "language": "text",
        "code": "// instead, use a getter:\nwatch(\n  () => obj.count,\n  (count) => {\n    console.log(`Count is: ${count}`)\n  }\n)"
      },
      {
        "language": "text",
        "code": "// instead, use a getter:\nwatch(\n  () => obj.count,\n  (count) => {\n    console.log(`Count is: ${count}`)\n  }\n)"
      },
      {
        "language": "text",
        "code": "export default {\n  watch: {\n    someObject: {\n      handler(newValue, oldValue) {\n        // Note: `newValue` will be equal to `oldValue` here\n        // on nested mutations as long as the object itself\n        // hasn't been replaced.\n      },\n      deep: true\n    }\n  }\n}"
      },
      {
        "language": "text",
        "code": "export default {\n  watch: {\n    someObject: {\n      handler(newValue, oldValue) {\n        // Note: `newValue` will be equal to `oldValue` here\n        // on nested mutations as long as the object itself\n        // hasn't been replaced.\n      },\n      deep: true\n    }\n  }\n}"
      },
      {
        "language": "text",
        "code": "const obj = reactive({ count: 0 })\n\nwatch(obj, (newValue, oldValue) => {\n  // fires on nested property mutations\n  // Note: `newValue` will be equal to `oldValue` here\n  // because they both point to the same object!\n})\n\nobj.count++"
      },
      {
        "language": "text",
        "code": "const obj = reactive({ count: 0 })\n\nwatch(obj, (newValue, oldValue) => {\n  // fires on nested property mutations\n  // Note: `newValue` will be equal to `oldValue` here\n  // because they both point to the same object!\n})\n\nobj.count++"
      },
      {
        "language": "text",
        "code": "watch(\n  () => state.someObject,\n  () => {\n    // fires only when state.someObject is replaced\n  }\n)"
      },
      {
        "language": "text",
        "code": "watch(\n  () => state.someObject,\n  () => {\n    // fires only when state.someObject is replaced\n  }\n)"
      },
      {
        "language": "text",
        "code": "watch(\n  () => state.someObject,\n  (newValue, oldValue) => {\n    // Note: `newValue` will be equal to `oldValue` here\n    // *unless* state.someObject has been replaced\n  },\n  { deep: true }\n)"
      },
      {
        "language": "text",
        "code": "watch(\n  () => state.someObject,\n  (newValue, oldValue) => {\n    // Note: `newValue` will be equal to `oldValue` here\n    // *unless* state.someObject has been replaced\n  },\n  { deep: true }\n)"
      },
      {
        "language": "text",
        "code": "immediate: true"
      },
      {
        "language": "text",
        "code": "export default {\n  // ...\n  watch: {\n    question: {\n      handler(newQuestion) {\n        // this will be run immediately on component creation.\n      },\n      // force eager callback execution\n      immediate: true\n    }\n  }\n  // ...\n}"
      },
      {
        "language": "text",
        "code": "export default {\n  // ...\n  watch: {\n    question: {\n      handler(newQuestion) {\n        // this will be run immediately on component creation.\n      },\n      // force eager callback execution\n      immediate: true\n    }\n  }\n  // ...\n}"
      },
      {
        "language": "text",
        "code": "immediate: true"
      },
      {
        "language": "text",
        "code": "watch(\n  source,\n  (newValue, oldValue) => {\n    // executed immediately, then again when `source` changes\n  },\n  { immediate: true }\n)"
      },
      {
        "language": "text",
        "code": "watch(\n  source,\n  (newValue, oldValue) => {\n    // executed immediately, then again when `source` changes\n  },\n  { immediate: true }\n)"
      },
      {
        "language": "text",
        "code": "export default {\n  watch: {\n    source: {\n      handler(newValue, oldValue) {\n        // when `source` changes, triggers only once\n      },\n      once: true\n    }\n  }\n}"
      },
      {
        "language": "text",
        "code": "export default {\n  watch: {\n    source: {\n      handler(newValue, oldValue) {\n        // when `source` changes, triggers only once\n      },\n      once: true\n    }\n  }\n}"
      },
      {
        "language": "text",
        "code": "watch(\n  source,\n  (newValue, oldValue) => {\n    // when `source` changes, triggers only once\n  },\n  { once: true }\n)"
      },
      {
        "language": "text",
        "code": "watch(\n  source,\n  (newValue, oldValue) => {\n    // when `source` changes, triggers only once\n  },\n  { once: true }\n)"
      },
      {
        "language": "text",
        "code": "watchEffect()"
      },
      {
        "language": "text",
        "code": "const todoId = ref(1)\nconst data = ref(null)\n\nwatch(\n  todoId,\n  async () => {\n    const response = await fetch(\n      `https://jsonplaceholder.typicode.com/todos/${todoId.value}`\n    )\n    data.value = await response.json()\n  },\n  { immediate: true }\n)"
      },
      {
        "language": "text",
        "code": "const todoId = ref(1)\nconst data = ref(null)\n\nwatch(\n  todoId,\n  async () => {\n    const response = await fetch(\n      `https://jsonplaceholder.typicode.com/todos/${todoId.value}`\n    )\n    data.value = await response.json()\n  },\n  { immediate: true }\n)"
      },
      {
        "language": "text",
        "code": "watchEffect()"
      },
      {
        "language": "text",
        "code": "watchEffect()"
      },
      {
        "language": "text",
        "code": "watchEffect(async () => {\n  const response = await fetch(\n    `https://jsonplaceholder.typicode.com/todos/${todoId.value}`\n  )\n  data.value = await response.json()\n})"
      },
      {
        "language": "text",
        "code": "watchEffect(async () => {\n  const response = await fetch(\n    `https://jsonplaceholder.typicode.com/todos/${todoId.value}`\n  )\n  data.value = await response.json()\n})"
      },
      {
        "language": "text",
        "code": "immediate: true"
      },
      {
        "language": "text",
        "code": "todoId.value"
      },
      {
        "language": "text",
        "code": "todoId.value"
      },
      {
        "language": "text",
        "code": "watchEffect()"
      },
      {
        "language": "text",
        "code": "watchEffect()"
      },
      {
        "language": "text",
        "code": "watchEffect()"
      },
      {
        "language": "text",
        "code": "watchEffect()"
      },
      {
        "language": "text",
        "code": "watchEffect()"
      },
      {
        "language": "text",
        "code": "watchEffect"
      },
      {
        "language": "text",
        "code": "watchEffect"
      },
      {
        "language": "text",
        "code": "watchEffect"
      },
      {
        "language": "text",
        "code": "watchEffect"
      },
      {
        "language": "text",
        "code": "watch(id, (newId) => {\n  fetch(`/api/${newId}`).then(() => {\n    // callback logic\n  })\n})"
      },
      {
        "language": "text",
        "code": "watch(id, (newId) => {\n  fetch(`/api/${newId}`).then(() => {\n    // callback logic\n  })\n})"
      },
      {
        "language": "text",
        "code": "export default {\n  watch: {\n    id(newId) {\n      fetch(`/api/${newId}`).then(() => {\n        // callback logic\n      })\n    }\n  }\n}"
      },
      {
        "language": "text",
        "code": "export default {\n  watch: {\n    id(newId) {\n      fetch(`/api/${newId}`).then(() => {\n        // callback logic\n      })\n    }\n  }\n}"
      },
      {
        "language": "text",
        "code": "onWatcherCleanup()"
      },
      {
        "language": "text",
        "code": "import { watch, onWatcherCleanup } from 'vue'\n\nwatch(id, (newId) => {\n  const controller = new AbortController()\n\n  fetch(`/api/${newId}`, { signal: controller.signal }).then(() => {\n    // callback logic\n  })\n\n  onWatcherCleanup(() => {\n    // abort stale request\n    controller.abort()\n  })\n})"
      },
      {
        "language": "text",
        "code": "import { watch, onWatcherCleanup } from 'vue'\n\nwatch(id, (newId) => {\n  const controller = new AbortController()\n\n  fetch(`/api/${newId}`, { signal: controller.signal }).then(() => {\n    // callback logic\n  })\n\n  onWatcherCleanup(() => {\n    // abort stale request\n    controller.abort()\n  })\n})"
      },
      {
        "language": "text",
        "code": "import { onWatcherCleanup } from 'vue'\n\nexport default {\n  watch: {\n    id(newId) {\n      const controller = new AbortController()\n\n      fetch(`/api/${newId}`, { signal: controller.signal }).then(() => {\n        // callback logic\n      })\n\n      onWatcherCleanup(() => {\n        // abort stale request\n        controller.abort()\n      })\n    }\n  }\n}"
      },
      {
        "language": "text",
        "code": "import { onWatcherCleanup } from 'vue'\n\nexport default {\n  watch: {\n    id(newId) {\n      const controller = new AbortController()\n\n      fetch(`/api/${newId}`, { signal: controller.signal }).then(() => {\n        // callback logic\n      })\n\n      onWatcherCleanup(() => {\n        // abort stale request\n        controller.abort()\n      })\n    }\n  }\n}"
      },
      {
        "language": "text",
        "code": "onWatcherCleanup"
      },
      {
        "language": "text",
        "code": "watchEffect"
      },
      {
        "language": "text",
        "code": "watchEffect"
      },
      {
        "language": "text",
        "code": "watch(id, (newId, oldId, onCleanup) => {\n  // ...\n  onCleanup(() => {\n    // cleanup logic\n  })\n})\n\nwatchEffect((onCleanup) => {\n  // ...\n  onCleanup(() => {\n    // cleanup logic\n  })\n})"
      },
      {
        "language": "text",
        "code": "watch(id, (newId, oldId, onCleanup) => {\n  // ...\n  onCleanup(() => {\n    // cleanup logic\n  })\n})\n\nwatchEffect((onCleanup) => {\n  // ...\n  onCleanup(() => {\n    // cleanup logic\n  })\n})"
      },
      {
        "language": "text",
        "code": "export default {\n  watch: {\n    id(newId, oldId, onCleanup) {\n      // ...\n      onCleanup(() => {\n        // cleanup logic\n      })\n    }\n  }\n}"
      },
      {
        "language": "text",
        "code": "export default {\n  watch: {\n    id(newId, oldId, onCleanup) {\n      // ...\n      onCleanup(() => {\n        // cleanup logic\n      })\n    }\n  }\n}"
      },
      {
        "language": "text",
        "code": "onWatcherCleanup"
      },
      {
        "language": "text",
        "code": "flush: 'post'"
      },
      {
        "language": "text",
        "code": "export default {\n  // ...\n  watch: {\n    key: {\n      handler() {},\n      flush: 'post'\n    }\n  }\n}"
      },
      {
        "language": "text",
        "code": "export default {\n  // ...\n  watch: {\n    key: {\n      handler() {},\n      flush: 'post'\n    }\n  }\n}"
      },
      {
        "language": "text",
        "code": "watch(source, callback, {\n  flush: 'post'\n})\n\nwatchEffect(callback, {\n  flush: 'post'\n})"
      },
      {
        "language": "text",
        "code": "watch(source, callback, {\n  flush: 'post'\n})\n\nwatchEffect(callback, {\n  flush: 'post'\n})"
      },
      {
        "language": "text",
        "code": "watchEffect()"
      },
      {
        "language": "text",
        "code": "watchPostEffect()"
      },
      {
        "language": "text",
        "code": "import { watchPostEffect } from 'vue'\n\nwatchPostEffect(() => {\n  /* executed after Vue updates */\n})"
      },
      {
        "language": "text",
        "code": "import { watchPostEffect } from 'vue'\n\nwatchPostEffect(() => {\n  /* executed after Vue updates */\n})"
      },
      {
        "language": "text",
        "code": "export default {\n  // ...\n  watch: {\n    key: {\n      handler() {},\n      flush: 'sync'\n    }\n  }\n}"
      },
      {
        "language": "text",
        "code": "export default {\n  // ...\n  watch: {\n    key: {\n      handler() {},\n      flush: 'sync'\n    }\n  }\n}"
      },
      {
        "language": "text",
        "code": "watch(source, callback, {\n  flush: 'sync'\n})\n\nwatchEffect(callback, {\n  flush: 'sync'\n})"
      },
      {
        "language": "text",
        "code": "watch(source, callback, {\n  flush: 'sync'\n})\n\nwatchEffect(callback, {\n  flush: 'sync'\n})"
      },
      {
        "language": "text",
        "code": "watchEffect()"
      },
      {
        "language": "text",
        "code": "watchSyncEffect()"
      },
      {
        "language": "text",
        "code": "import { watchSyncEffect } from 'vue'\n\nwatchSyncEffect(() => {\n  /* executed synchronously upon reactive data change */\n})"
      },
      {
        "language": "text",
        "code": "import { watchSyncEffect } from 'vue'\n\nwatchSyncEffect(() => {\n  /* executed synchronously upon reactive data change */\n})"
      },
      {
        "language": "text",
        "code": "this.$watch()"
      },
      {
        "language": "text",
        "code": "export default {\n  created() {\n    this.$watch('question', (newQuestion) => {\n      // ...\n    })\n  }\n}"
      },
      {
        "language": "text",
        "code": "export default {\n  created() {\n    this.$watch('question', (newQuestion) => {\n      // ...\n    })\n  }\n}"
      },
      {
        "language": "text",
        "code": "const unwatch = this.$watch('foo', callback)\n\n// ...when the watcher is no longer needed:\nunwatch()"
      },
      {
        "language": "text",
        "code": "const unwatch = this.$watch('foo', callback)\n\n// ...when the watcher is no longer needed:\nunwatch()"
      },
      {
        "language": "text",
        "code": "<script setup>"
      },
      {
        "language": "text",
        "code": "<script setup>\nimport { watchEffect } from 'vue'\n\n// this one will be automatically stopped\nwatchEffect(() => {})\n\n// ...this one will not!\nsetTimeout(() => {\n  watchEffect(() => {})\n}, 100)\n</script>"
      },
      {
        "language": "text",
        "code": "<script setup>\nimport { watchEffect } from 'vue'\n\n// this one will be automatically stopped\nwatchEffect(() => {})\n\n// ...this one will not!\nsetTimeout(() => {\n  watchEffect(() => {})\n}, 100)\n</script>"
      },
      {
        "language": "text",
        "code": "watchEffect"
      },
      {
        "language": "text",
        "code": "const unwatch = watchEffect(() => {})\n\n// ...later, when no longer needed\nunwatch()"
      },
      {
        "language": "text",
        "code": "const unwatch = watchEffect(() => {})\n\n// ...later, when no longer needed\nunwatch()"
      },
      {
        "language": "text",
        "code": "// data to be loaded asynchronously\nconst data = ref(null)\n\nwatchEffect(() => {\n  if (data.value) {\n    // do something when data is loaded\n  }\n})"
      },
      {
        "language": "text",
        "code": "// data to be loaded asynchronously\nconst data = ref(null)\n\nwatchEffect(() => {\n  if (data.value) {\n    // do something when data is loaded\n  }\n})"
      }
    ],
    "links": [
      {
        "text": "watch option",
        "href": "/api/options-state#watch"
      },
      {
        "text": "Try it in the Playground",
        "href": "https://play.vuejs.org/#eNp9VE1v2zAM/SucLnaw1D70lqUbsiKH7rB1W4++aDYdq5ElTx9xgiD/fbT8lXZFAQO2+Mgn8pH0mW2aJjl4ZCu2trkRjfucKTw22jgosOReOjhnCqDgjseL/hvAoPNGjSeAvx6tE1qtIIqWo5Er26Ih088BteCt51KeINfKcaGAT5FQc7NP4NPNYiaQmhdC7VZQcmlxMF+61yUcWu7yajVmkabQVqjwgGZmzSuudmiX4CphofQqD+ZWSAnGqz5y9I4VtmOuS9CyGA9T3QCihGu3RKhc+gJtHH2JFld+EG5Mdug2QYZ4MSKhgBd11OgqXdipEm5PKoer0Jk2kA66wB044/EF1GtOSPRUCbUnryRJosnFnK4zpC5YR7205M9bLhyUSIrGUeVcY1dpekKrdNK6MuWNiKYKXt8V98FElDxbknGxGLCpZMi7VkGMxmjzv0pz1tvO4QPcay8LULoj5RToKoTN40MCEXyEQDJTl0KFmXpNOqsUxudN+TNFzzqdJp8ODutGcod0Alg34QWwsXsaVtIjVXqe9h5bC9V4B4ebWhco7zI24hmDVSEs/yOxIPOQEFnTnjzt2emS83nYFrhcevM6nRJhS+Ys9aoUu6Av7WqoNWO5rhsh0fxownplbBqhjJEmuv0WbN2UDNtDMRXm+zfsz/bY2TL2SH1Ec8CMTZjjhqaxh7e/v+ORvieQqvaSvN8Bf6HV0veSdG5fvSoo7Su/kO1D3f13SKInuz06VHYsahzzfl0yRj+s+3dKn9O9TW7HPrPLP624lFU="
      },
      {
        "text": "watch function",
        "href": "/api/reactivity-core#watch"
      },
      {
        "text": "Try it in the Playground",
        "href": "https://play.vuejs.org/#eNp9U8Fy0zAQ/ZVFF9tDah96C2mZ0umhHKBAj7oIe52oUSQjyXEyGf87KytyoDC9JPa+p+e3b1cndtd15b5HtmQrV1vZeXDo++6Wa7nrjPVwAovtAgbh6w2M0Fqzg4xOZFxzXRvtPPzq0XlpNNwEbp5lRUKEdgPaVP925jnoXS+UOgKxvJAaxEVjJ+y2hA9XxUVFGdFIvT7LtEI5JIzrqjrbGozdOmikxdqTKqmIQOV6gvOkvQDhjrqGXOOQvCzAqCa9FHBzCyeuAWT7F6uUulZ9gy7PPmZFETmQjJV7oXoke972GJHY+Axkzxupt4FalhRcYHh7TDIQcqA+LTriikFIDy0G59nG+84tq+qITpty8G0lOhmSiedefSaPZ0mnfHFG50VRRkbkj1BPceVorbFzF/+6fQj4O7g3vWpAm6Ao6JzfINw9PZaQwXuYNJJuK/U0z1nxdTLT0M7s8Ec/I3WxquLS0brRi8ddp4RHegNYhR0M/Du3pXFSAJU285osI7aSuus97K92pkF1w1nCOYNlI534qbCh8tkOVasoXkV1+sjplLZ0HGN5Vc1G2IJ5R8Np5XpKlK7J1CJntdl1UqH92k0bzdkyNc8ZRWGGz1MtbMQi1esN1tv/1F/cIdQ4e6LJod0jZzPmhV2jj/DDjy94oOcZpK57Rew3wO/ojOpjJIH2qdcN2f6DN7l9nC47RfTsHg4etUtNpZUeJz5ndPPv32j9Yve6vE6DZuNvu1R2Tg=="
      },
      {
        "text": "getter function",
        "href": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Functions/get#description"
      },
      {
        "text": "watchEffect()",
        "href": "/api/reactivity-core#watcheffect"
      },
      {
        "text": "this example",
        "href": "/examples/#fetching-data"
      },
      {
        "text": "onWatcherCleanup()",
        "href": "/api/reactivity-core#onwatchercleanup"
      },
      {
        "text": "$watch() instance method",
        "href": "/api/component-instance#watch"
      },
      {
        "text": "Edit this page on GitHub",
        "href": "https://github.com/vuejs/docs/edit/main/src/guide/essentials/watchers.md"
      }
    ],
    "meta": {
      "description": "Vue.js - The Progressive JavaScript Framework",
      "keywords": ""
    },
    "summary": "Watchers Basic Example Computed properties allow us to declaratively compute derived values",
    "tags": [
      "react",
      "vue",
      "angular",
      "javascript",
      "typescript",
      "html",
      "watchers",
      "watch",
      "watcheffect",
      "basic"
    ],
    "id": "watchers-watchershtml-part-1",
    "quality": 90
  },
  {
    "title": "Lifecycle Hooks",
    "url": "https://vuejs.org/guide/essentials/lifecycle.html",
    "category": "vue",
    "content": "Lifecycle Hooks Each Vue component instance goes through a series of initialization steps when it's created - for example, it needs to set up data observation, compile the template, mount the instance to the DOM, and update the DOM when data changes. Along the way, it also runs functions called lifecycle hooks, giving users the opportunity to add their own code at specific stages.Registering Lifecycle Hooks For example, the onMountedmounted hook can be used to run code after the component has finished the initial rendering and created the DOM nodes:vuescript setup import { onMounted } from 'vue' onMounted(() = { console.log(the component is now mounted.) }) /scriptjsexport default { mounted() { console.log(the component is now mounted.) } }There are also other hooks which will be called at different stages of the instance's lifecycle, with the most commonly used being onMounted, onUpdated, and onUnmounted.mounted, updated, and unmounted.All lifecycle hooks are called with their this context pointing to the current active instance invoking it. Note this means you should avoid using arrow functions when declaring lifecycle hooks, as you won't be able to access the component instance via this if you do so.When calling onMounted, Vue automatically associates the registered callback function with the current active component instance. This requires these hooks to be registered synchronously during component setup. For example, do not do this:jssetTimeout(() = { onMounted(() = { // this won't work. }) }, 100)Do note this doesn't mean that the call must be placed lexically inside setup() or script setup. onMounted() can be called in an external function as long as the call stack is synchronous and originates from within setup().Lifecycle Diagram Below is a diagram for the instance lifecycle. You don't need to fully understand everything going on right now, but as you learn and build more, it will be a useful reference.Consult the Lifecycle Hooks API referenceLifecycle Hooks API reference for details on all lifecycle hooks and their respective use cases.Edit this page on GitHub",
    "headings": [
      {
        "level": 1,
        "text": "Lifecycle Hooks ​",
        "id": "lifecycle-hooks"
      },
      {
        "level": 2,
        "text": "Registering Lifecycle Hooks ​",
        "id": "registering-lifecycle-hooks"
      },
      {
        "level": 2,
        "text": "Lifecycle Diagram ​",
        "id": "lifecycle-diagram"
      }
    ],
    "codeBlocks": [
      {
        "language": "text",
        "code": "<script setup>\nimport { onMounted } from 'vue'\n\nonMounted(() => {\n  console.log(`the component is now mounted.`)\n})\n</script>"
      },
      {
        "language": "text",
        "code": "<script setup>\nimport { onMounted } from 'vue'\n\nonMounted(() => {\n  console.log(`the component is now mounted.`)\n})\n</script>"
      },
      {
        "language": "text",
        "code": "export default {\n  mounted() {\n    console.log(`the component is now mounted.`)\n  }\n}"
      },
      {
        "language": "text",
        "code": "export default {\n  mounted() {\n    console.log(`the component is now mounted.`)\n  }\n}"
      },
      {
        "language": "text",
        "code": "onUnmounted"
      },
      {
        "language": "text",
        "code": "setTimeout(() => {\n  onMounted(() => {\n    // this won't work.\n  })\n}, 100)"
      },
      {
        "language": "text",
        "code": "setTimeout(() => {\n  onMounted(() => {\n    // this won't work.\n  })\n}, 100)"
      },
      {
        "language": "text",
        "code": "<script setup>"
      },
      {
        "language": "text",
        "code": "onMounted()"
      }
    ],
    "links": [
      {
        "text": "onMounted",
        "href": "/api/composition-api-lifecycle#onmounted"
      },
      {
        "text": "onUpdated",
        "href": "/api/composition-api-lifecycle#onupdated"
      },
      {
        "text": "onUnmounted",
        "href": "/api/composition-api-lifecycle#onunmounted"
      },
      {
        "text": "mounted",
        "href": "/api/options-lifecycle#mounted"
      },
      {
        "text": "updated",
        "href": "/api/options-lifecycle#updated"
      },
      {
        "text": "unmounted",
        "href": "/api/options-lifecycle#unmounted"
      },
      {
        "text": "Lifecycle Hooks API reference",
        "href": "/api/composition-api-lifecycle"
      },
      {
        "text": "Lifecycle Hooks API reference",
        "href": "/api/options-lifecycle"
      },
      {
        "text": "Edit this page on GitHub",
        "href": "https://github.com/vuejs/docs/edit/main/src/guide/essentials/lifecycle.md"
      }
    ],
    "meta": {
      "description": "Vue.js - The Progressive JavaScript Framework",
      "keywords": ""
    },
    "summary": "Lifecycle Hooks Each Vue component instance goes through a series of initialization steps when it's created - for example, it needs to set up data observation, compile the template, mount the instance...",
    "tags": [
      "react",
      "vue",
      "angular",
      "javascript",
      "node",
      "vite",
      "lifecycle",
      "hooks",
      "registering",
      "diagram"
    ],
    "id": "lifecycle-hooks-lifecyclehtml-part-1",
    "quality": 100
  },
  {
    "title": "Template Syntax",
    "url": "https://vuejs.org/guide/essentials/template-syntax.html",
    "category": "vue",
    "content": "Template Syntax  Watch an interactive video lesson on Scrimba Vue uses an HTML-based template syntax that allows you to declaratively bind the rendered DOM to the underlying component instance's data. All Vue templates are syntactically valid HTML that can be parsed by spec-compliant browsers and HTML parsers.Under the hood, Vue compiles the templates into highly-optimized JavaScript code. Combined with the reactivity system, Vue can intelligently figure out the minimal number of components to re-render and apply the minimal amount of DOM manipulations when the app state changes.If you are familiar with Virtual DOM concepts and prefer the raw power of JavaScript, you can also directly write render functions instead of templates, with optional JSX support. However, do note that they do not enjoy the same level of compile-time optimizations as templates.Text Interpolation The most basic form of data binding is text interpolation using the \"Mustache\" syntax (double curly braces):templatespanMessage: {{ msg }}/spanThe mustache tag will be replaced with the value of the msg property from the corresponding component instance. It will also be updated whenever the msg property changes.Raw HTML The double mustaches interpret the data as plain text, not HTML. In order to output real HTML, you will need to use the v-html directive:templatepUsing text interpolation: {{ rawHtml }}/p pUsing v-html directive: span v-html=\"rawHtml\"/span/pUsing text interpolation: span style=\"color: red\"This should be red./spanUsing v-html directive: This should be red.Here we're encountering something new. The v-html attribute you're seeing is called a directive. Directives are prefixed with v- to indicate that they are special attributes provided by Vue, and as you may have guessed, they apply special reactive behavior to the rendered DOM. Here, we're basically saying \"keep this element's inner HTML up-to-date with the rawHtml property on the current active instance.\"The contents of the span will be replaced with the value of the rawHtml property, interpreted as plain HTML - data bindings are ignored. Note that you cannot use v-html to compose template partials, because Vue is not a string-based templating engine. Instead, components are preferred as the fundamental unit for UI reuse and composition.Security WarningDynamically rendering arbitrary HTML on your website can be very dangerous because it can easily lead to XSS vulnerabilities. Only use v-html on trusted content and never on user-provided content.Attribute Bindings Mustaches cannot be used inside HTML attributes. Instead, use a v-bind directive:templatediv v-bind:id=\"dynamicId\"/divThe v-bind directive instructs Vue to keep the element's id attribute in sync with the component's dynamicId property. If the bound value is null or undefined, then the attribute will be removed from the rendered element.Shorthand Because v-bind is so commonly used, it has a dedicated shorthand syntax:templatediv :id=\"dynamicId\"/divAttributes that start with : may look a bit different from normal HTML, but it is in fact a valid character for attribute names and all Vue-supported browsers can parse it correctly. In addition, they do not appear in the final rendered markup. The shorthand syntax is optional, but you will likely appreciate it when you learn more about its usage later.For the rest of the guide, we will be using the shorthand syntax in code examples, as that's the most common usage for Vue developers.Same-name Shorthand Only supported in 3.4+If the attribute has the same name as the variable name of the JavaScript value being bound, the syntax can be further shortened to omit the attribute value:template!-- same as :id=\"id\" -- div :id/div !-- this also works -- div v-bind:id/divThis is similar to the property shorthand syntax when declaring objects in JavaScript. Note this is a feature that is only available in Vue 3.4 and above.Boolean Attributes Boolean attributes are attributes that can indicate true / false values by their presence on an element. For example, disabled is one of the most commonly used boolean attributes.v-bind works a bit differently in this case:templatebutton :disabled=\"isButtonDisabled\"Button/buttonThe disabled attribute will be included if isButtonDisabled has a truthy value. It will also be included if the value is an empty string, maintaining consistency with button disabled=\"\". For other falsy values the attribute will be omitted.Dynamically Binding Multiple Attributes If you have a JavaScript object representing multiple attributes that looks like this:jsconst objectOfAttrs = { id: 'container', class: 'wrapper', style: 'background-color:green' }jsdata() { return { objectOfAttrs: { id: 'container', class: 'wrapper' } } }You can bind them to a single element by using v-bind without an argument:templatediv v-bind=\"objectOfAttrs\"/divUsing JavaScript Expressions So far we've only been binding to simple property keys in our templates. But Vue actually supports the full power of JavaScript expressions inside all data bindings:template{{ number + 1 }} {{ ok ? 'YES' : 'NO' }} {{ message.split('').reverse().join('') }} div :id=\"list-${id}\"/divThese expressions will be evaluated as JavaScript in the data scope of the current component instance.In Vue templates, JavaScript expressions can be used in the following positions:Inside text interpolations (mustaches)In the attribute value of any Vue directives (special attributes that start with v-)Expressions Only Each binding can only contain one single expression. An expression is a piece of code that can be evaluated to a value. A simple check is whether it can be used after return.Therefore, the following will NOT work:template!-- this is a statement, not an expression: -- {{ var a = 1 }} !-- flow control won't work either, use ternary expressions -- {{ if (ok) { return message } }}Calling Functions It is possible to call a component-exposed method inside a binding expression:templatetime :title=\"toTitleDate(date)\" :datetime=\"date\" {{ formatDate(date) }} /timeTIPFunctions called inside binding expressions will be called every time the component updates, so they should not have any side effects, such as changing data or triggering asynchronous operations.Restricted Globals Access Template expressions are sandboxed and only have access to a restricted list of globals. The list exposes commonly used built-in globals such as Math and Date.Globals not explicitly included in the list, for example user-attached properties on window, will not be accessible in template expressions. You can, however, explicitly define additional globals for all Vue expressions by adding them to app.config.globalProperties.Directives Directives are special attributes with the v- prefix. Vue provides a number of built-in directives, including v-html and v-bind which we have introduced above.Directive attribute values are expected to be single JavaScript expressions (with the exception of v-for, v-on and v-slot, which will be discussed in their respective sections later). A directive's job is to reactively apply updates to the DOM when the value of its expression changes. Take v-if as an example:templatep v-if=\"seen\"Now you see me/pHere, the v-if directive would remove or insert the p element based on the truthiness of the value of the expression seen.Arguments Some directives can take an \"argument\", denoted by a colon after the directive name. For example, the v-bind directive is used to reactively update an HTML attribute:templatea v-bind:href=\"url\" ... /a !-- shorthand -- a :href=\"url\" ... /aHere, href is the argument, which tells the v-bind directive to bind the element's href attribute to the value of the expression url. In the shorthand, everything before the argument (i.e., v-bind:) is condensed into a single character, :.Another example is the v-on directive, which listens to DOM events:templatea v-on:click=\"doSomething\" ... /a !-- shorthand -- a @click=\"doSomething\" ... /aHere, the argument is the event name to listen to: click. v-on has a corresponding shorthand, namely the @ character. We will talk about event handling in more detail too.Dynamic Arguments It is also possible to use a JavaScript expression in a directive argument by wrapping it with square brackets:template!-- Note that there are some constraints to the argument expression, as explained in the \"Dynamic Argument Value Constraints\" and \"Dynamic Argument Syntax Constraints\" sections below. -- a v-bind:[attributeName]=\"url\" ... /a !-- shorthand -- a :[attributeName]=\"url\" ... /aHere, attributeName will be dynamically evaluated as a JavaScript expression, and its evaluated value will be used as the final value for the argument. For example, if your component instance has a data property, attributeName, whose value is \"href\", then this binding will be equivalent to v-bind:href.Similarly, you can use dynamic arguments to bind a handler to a dynamic event name:templatea v-on:[eventName]=\"doSomething\" ... /a !-- shorthand -- a @[eventName]=\"doSomething\" ... /aIn this example, when eventName's value is \"focus\", v-on:[eventName] will be equivalent to v-on:focus.Dynamic Argument Value Constraints Dynamic arguments are expected to evaluate to a string, with the exception of null. The special value null can be used to explicitly remove the binding. Any other non-string value will trigger a warning.Dynamic Argument Syntax Constraints Dynamic argument expressions have some syntax constraints because certain characters, such as spaces and quotes, are invalid inside HTML attribute names. For example, the following is invalid:template!-- This will trigger a compiler warning. -- a :['foo' + bar]=\"value\" ... /aIf you need to pass a complex dynamic argument, it's probably better to use a computed property, which we will cover shortly.When using in-DOM templates (templates directly written in an HTML file), you should also avoid naming keys with uppercase characters, as browsers will coerce attribute names into lowercase:templatea :[someAttr]=\"value\" ... /aThe above will be converted to :[someattr] in in-DOM templates. If your component has a someAttr property instead of someattr, your code won't work. Templates inside Single-File Components are not subject to this constraint.Modifiers Modifiers are special postfixes denoted by a dot, which indicate that a directive should be bound in some special way. For example, the .prevent modifier tells the v-on directive to call event.preventDefault() on the triggered event:templateform @submit.prevent=\"onSubmit\".../formYou'll see other examples of modifiers later, for v-on and for v-model, when we explore those features.And finally, here's the full directive syntax visualized:Edit this page on GitHub",
    "headings": [
      {
        "level": 1,
        "text": "Template Syntax ​",
        "id": "template-syntax"
      },
      {
        "level": 2,
        "text": "Text Interpolation ​",
        "id": "text-interpolation"
      },
      {
        "level": 2,
        "text": "Raw HTML ​",
        "id": "raw-html"
      },
      {
        "level": 2,
        "text": "Attribute Bindings ​",
        "id": "attribute-bindings"
      },
      {
        "level": 2,
        "text": "Using JavaScript Expressions ​",
        "id": "using-javascript-expressions"
      },
      {
        "level": 2,
        "text": "Directives ​",
        "id": "directives"
      },
      {
        "level": 3,
        "text": "Shorthand ​",
        "id": "shorthand"
      },
      {
        "level": 3,
        "text": "Same-name Shorthand ​",
        "id": "same-name-shorthand"
      },
      {
        "level": 3,
        "text": "Boolean Attributes ​",
        "id": "boolean-attributes"
      },
      {
        "level": 3,
        "text": "Dynamically Binding Multiple Attributes ​",
        "id": "dynamically-binding-multiple-attributes"
      },
      {
        "level": 3,
        "text": "Expressions Only ​",
        "id": "expressions-only"
      },
      {
        "level": 3,
        "text": "Calling Functions ​",
        "id": "calling-functions"
      },
      {
        "level": 3,
        "text": "Restricted Globals Access ​",
        "id": "restricted-globals-access"
      },
      {
        "level": 3,
        "text": "Arguments ​",
        "id": "arguments"
      },
      {
        "level": 3,
        "text": "Dynamic Arguments ​",
        "id": "dynamic-arguments"
      },
      {
        "level": 3,
        "text": "Modifiers ​",
        "id": "modifiers"
      },
      {
        "level": 4,
        "text": "Dynamic Argument Value Constraints ​",
        "id": "dynamic-argument-value-constraints"
      },
      {
        "level": 4,
        "text": "Dynamic Argument Syntax Constraints ​",
        "id": "dynamic-argument-syntax-constraints"
      }
    ],
    "codeBlocks": [
      {
        "language": "text",
        "code": "<span>Message: {{ msg }}</span>"
      },
      {
        "language": "text",
        "code": "<span>Message: {{ msg }}</span>"
      },
      {
        "language": "text",
        "code": "<p>Using text interpolation: {{ rawHtml }}</p>\n<p>Using v-html directive: <span v-html=\"rawHtml\"></span></p>"
      },
      {
        "language": "text",
        "code": "<p>Using text interpolation: {{ rawHtml }}</p>\n<p>Using v-html directive: <span v-html=\"rawHtml\"></span></p>"
      },
      {
        "language": "text",
        "code": "<div v-bind:id=\"dynamicId\"></div>"
      },
      {
        "language": "text",
        "code": "<div v-bind:id=\"dynamicId\"></div>"
      },
      {
        "language": "text",
        "code": "<div :id=\"dynamicId\"></div>"
      },
      {
        "language": "text",
        "code": "<div :id=\"dynamicId\"></div>"
      },
      {
        "language": "text",
        "code": "<!-- same as :id=\"id\" -->\n<div :id></div>\n\n<!-- this also works -->\n<div v-bind:id></div>"
      },
      {
        "language": "text",
        "code": "<!-- same as :id=\"id\" -->\n<div :id></div>\n\n<!-- this also works -->\n<div v-bind:id></div>"
      },
      {
        "language": "text",
        "code": "<button :disabled=\"isButtonDisabled\">Button</button>"
      },
      {
        "language": "text",
        "code": "<button :disabled=\"isButtonDisabled\">Button</button>"
      },
      {
        "language": "text",
        "code": "isButtonDisabled"
      },
      {
        "language": "text",
        "code": "<button disabled=\"\">"
      },
      {
        "language": "text",
        "code": "const objectOfAttrs = {\n  id: 'container',\n  class: 'wrapper',\n  style: 'background-color:green'\n}"
      },
      {
        "language": "text",
        "code": "const objectOfAttrs = {\n  id: 'container',\n  class: 'wrapper',\n  style: 'background-color:green'\n}"
      },
      {
        "language": "text",
        "code": "data() {\n  return {\n    objectOfAttrs: {\n      id: 'container',\n      class: 'wrapper'\n    }\n  }\n}"
      },
      {
        "language": "text",
        "code": "data() {\n  return {\n    objectOfAttrs: {\n      id: 'container',\n      class: 'wrapper'\n    }\n  }\n}"
      },
      {
        "language": "text",
        "code": "<div v-bind=\"objectOfAttrs\"></div>"
      },
      {
        "language": "text",
        "code": "<div v-bind=\"objectOfAttrs\"></div>"
      },
      {
        "language": "text",
        "code": "{{ number + 1 }}\n\n{{ ok ? 'YES' : 'NO' }}\n\n{{ message.split('').reverse().join('') }}\n\n<div :id=\"`list-${id}`\"></div>"
      },
      {
        "language": "text",
        "code": "{{ number + 1 }}\n\n{{ ok ? 'YES' : 'NO' }}\n\n{{ message.split('').reverse().join('') }}\n\n<div :id=\"`list-${id}`\"></div>"
      },
      {
        "language": "text",
        "code": "<!-- this is a statement, not an expression: -->\n{{ var a = 1 }}\n\n<!-- flow control won't work either, use ternary expressions -->\n{{ if (ok) { return message } }}"
      },
      {
        "language": "text",
        "code": "<!-- this is a statement, not an expression: -->\n{{ var a = 1 }}\n\n<!-- flow control won't work either, use ternary expressions -->\n{{ if (ok) { return message } }}"
      },
      {
        "language": "text",
        "code": "<time :title=\"toTitleDate(date)\" :datetime=\"date\">\n  {{ formatDate(date) }}\n</time>"
      },
      {
        "language": "text",
        "code": "<time :title=\"toTitleDate(date)\" :datetime=\"date\">\n  {{ formatDate(date) }}\n</time>"
      },
      {
        "language": "text",
        "code": "app.config.globalProperties"
      },
      {
        "language": "text",
        "code": "<p v-if=\"seen\">Now you see me</p>"
      },
      {
        "language": "text",
        "code": "<p v-if=\"seen\">Now you see me</p>"
      },
      {
        "language": "text",
        "code": "<a v-bind:href=\"url\"> ... </a>\n\n<!-- shorthand -->\n<a :href=\"url\"> ... </a>"
      },
      {
        "language": "text",
        "code": "<a v-bind:href=\"url\"> ... </a>\n\n<!-- shorthand -->\n<a :href=\"url\"> ... </a>"
      },
      {
        "language": "text",
        "code": "<a v-on:click=\"doSomething\"> ... </a>\n\n<!-- shorthand -->\n<a @click=\"doSomething\"> ... </a>"
      },
      {
        "language": "text",
        "code": "<a v-on:click=\"doSomething\"> ... </a>\n\n<!-- shorthand -->\n<a @click=\"doSomething\"> ... </a>"
      },
      {
        "language": "text",
        "code": "<!--\nNote that there are some constraints to the argument expression,\nas explained in the \"Dynamic Argument Value Constraints\" and \"Dynamic Argument Syntax Constraints\" sections below.\n-->\n<a v-bind:[attributeName]=\"url\"> ... </a>\n\n<!-- shorthand -->\n<a :[attributeName]=\"url\"> ... </a>"
      },
      {
        "language": "text",
        "code": "<!--\nNote that there are some constraints to the argument expression,\nas explained in the \"Dynamic Argument Value Constraints\" and \"Dynamic Argument Syntax Constraints\" sections below.\n-->\n<a v-bind:[attributeName]=\"url\"> ... </a>\n\n<!-- shorthand -->\n<a :[attributeName]=\"url\"> ... </a>"
      },
      {
        "language": "text",
        "code": "attributeName"
      },
      {
        "language": "text",
        "code": "attributeName"
      },
      {
        "language": "text",
        "code": "v-bind:href"
      },
      {
        "language": "text",
        "code": "<a v-on:[eventName]=\"doSomething\"> ... </a>\n\n<!-- shorthand -->\n<a @[eventName]=\"doSomething\"> ... </a>"
      },
      {
        "language": "text",
        "code": "<a v-on:[eventName]=\"doSomething\"> ... </a>\n\n<!-- shorthand -->\n<a @[eventName]=\"doSomething\"> ... </a>"
      },
      {
        "language": "text",
        "code": "v-on:[eventName]"
      },
      {
        "language": "text",
        "code": "<!-- This will trigger a compiler warning. -->\n<a :['foo' + bar]=\"value\"> ... </a>"
      },
      {
        "language": "text",
        "code": "<!-- This will trigger a compiler warning. -->\n<a :['foo' + bar]=\"value\"> ... </a>"
      },
      {
        "language": "text",
        "code": "<a :[someAttr]=\"value\"> ... </a>"
      },
      {
        "language": "text",
        "code": "<a :[someAttr]=\"value\"> ... </a>"
      },
      {
        "language": "text",
        "code": ":[someattr]"
      },
      {
        "language": "text",
        "code": "event.preventDefault()"
      },
      {
        "language": "text",
        "code": "<form @submit.prevent=\"onSubmit\">...</form>"
      },
      {
        "language": "text",
        "code": "<form @submit.prevent=\"onSubmit\">...</form>"
      }
    ],
    "links": [
      {
        "text": "Watch an interactive video lesson on Scrimba",
        "href": "https://scrimba.com/links/vue-template-syntax"
      },
      {
        "text": "directly write render functions",
        "href": "/guide/extras/render-function"
      },
      {
        "text": "from the corresponding component instance",
        "href": "/guide/essentials/reactivity-fundamentals#declaring-reactive-state"
      },
      {
        "text": "v-html directive",
        "href": "/api/built-in-directives#v-html"
      },
      {
        "text": "XSS vulnerabilities",
        "href": "https://en.wikipedia.org/wiki/Cross-site_scripting"
      },
      {
        "text": "v-bind directive",
        "href": "/api/built-in-directives#v-bind"
      },
      {
        "text": "Boolean attributes",
        "href": "https://html.spec.whatwg.org/multipage/common-microsyntaxes.html#boolean-attributes"
      },
      {
        "text": "disabled",
        "href": "https://developer.mozilla.org/en-US/docs/Web/HTML/Attributes/disabled"
      },
      {
        "text": "truthy value",
        "href": "https://developer.mozilla.org/en-US/docs/Glossary/Truthy"
      },
      {
        "text": "falsy values",
        "href": "https://developer.mozilla.org/en-US/docs/Glossary/Falsy"
      },
      {
        "text": "restricted list of globals",
        "href": "https://github.com/vuejs/core/blob/main/packages/shared/src/globalsAllowList.ts#L3"
      },
      {
        "text": "app.config.globalProperties",
        "href": "/api/application#app-config-globalproperties"
      },
      {
        "text": "built-in directives",
        "href": "/api/built-in-directives"
      },
      {
        "text": "v-if",
        "href": "/api/built-in-directives#v-if"
      },
      {
        "text": "computed property",
        "href": "/guide/essentials/computed"
      },
      {
        "text": "for v-on",
        "href": "/guide/essentials/event-handling#event-modifiers"
      },
      {
        "text": "for v-model",
        "href": "/guide/essentials/forms#modifiers"
      },
      {
        "text": "Edit this page on GitHub",
        "href": "https://github.com/vuejs/docs/edit/main/src/guide/essentials/template-syntax.md"
      }
    ],
    "meta": {
      "description": "Vue.js - The Progressive JavaScript Framework",
      "keywords": ""
    },
    "summary": "Template Syntax  Watch an interactive video lesson on Scrimba Vue uses an HTML-based template syntax that allows you to declaratively bind the rendered DOM to the underlying component instance's data",
    "tags": [
      "react",
      "vue",
      "angular",
      "javascript",
      "typescript",
      "css",
      "html",
      "vite",
      "syntax",
      "dynamic"
    ],
    "id": "template-syntax-templatesyntaxhtml-part-1",
    "quality": 100
  },
  {
    "title": "Event Handling",
    "url": "https://vuejs.org/guide/essentials/event-handling.html",
    "category": "vue",
    "content": "Event Handling Watch a free video lesson on Vue SchoolWatch a free video lesson on Vue SchoolListening to Events We can use the v-on directive, which we typically shorten to the @ symbol, to listen to DOM events and run some JavaScript when they're triggered. The usage would be v-on:click=\"handler\" or with the shortcut, @click=\"handler\".The handler value can be one of the following:Inline handlers: Inline JavaScript to be executed when the event is triggered (similar to the native onclick attribute).Method handlers: A property name or path that points to a method defined on the component.Inline Handlers Inline handlers are typically used in simple cases, for example:jsconst count = ref(0)jsdata() { return { count: 0 } }templatebutton @click=\"count++\"Add 1/button pCount is: {{ count }}/pTry it in the PlaygroundTry it in the PlaygroundMethod Handlers The logic for many event handlers will be more complex though, and likely isn't feasible with inline handlers. That's why v-on can also accept the name or path of a component method you'd like to call.For example:jsconst name = ref('Vue.js') function greet(event) { alert(Hello ${name.value}!) // event is the native DOM event if (event) { alert(event.target.tagName) } }jsdata() { return { name: 'Vue.js' } }, methods: { greet(event) { // this inside methods points to the current active instance alert(Hello ${this.name}!) // event is the native DOM event if (event) { alert(event.target.tagName) } } }template!-- greet is the name of the method defined above -- button @click=\"greet\"Greet/buttonTry it in the PlaygroundTry it in the PlaygroundA method handler automatically receives the native DOM Event object that triggers it - in the example above, we are able to access the element dispatching the event via event.target.See also: Typing Event Handlers See also: Typing Event Handlers Method vs. Inline Detection The template compiler detects method handlers by checking whether the v-on value string is a valid JavaScript identifier or property access path. For example, foo, foo.bar and foo['bar'] are treated as method handlers, while foo() and count++ are treated as inline handlers.Calling Methods in Inline Handlers Instead of binding directly to a method name, we can also call methods in an inline handler. This allows us to pass the method custom arguments instead of the native event:jsfunction say(message) { alert(message) }jsmethods: { say(message) { alert(message) } }templatebutton @click=\"say('hello')\"Say hello/button button @click=\"say('bye')\"Say bye/buttonTry it in the PlaygroundTry it in the PlaygroundAccessing Event Argument in Inline Handlers Sometimes we also need to access the original DOM event in an inline handler. You can pass it into a method using the special $event variable, or use an inline arrow function:template!-- using $event special variable -- button @click=\"warn('Form cannot be submitted yet.', $event)\" Submit /button !-- using inline arrow function -- button @click=\"(event) = warn('Form cannot be submitted yet.', event)\" Submit /buttonjsfunction warn(message, event) { // now we have access to the native event if (event) { event.preventDefault() } alert(message) }jsmethods: { warn(message, event) { // now we have access to the native event if (event) { event.preventDefault() } alert(message) } }Event Modifiers It is a very common need to call event.preventDefault() or event.stopPropagation() inside event handlers. Although we can do this easily inside methods, it would be better if the methods can be purely about data logic rather than having to deal with DOM event details.To address this problem, Vue provides event modifiers for v-on. Recall that modifiers are directive postfixes denoted by a dot..stop.prevent.self.capture.once.passivetemplate!-- the click event's propagation will be stopped -- a @click.stop=\"doThis\"/a !-- the submit event will no longer reload the page -- form @submit.prevent=\"onSubmit\"/form !-- modifiers can be chained -- a @click.stop.prevent=\"doThat\"/a !-- just the modifier -- form @submit.prevent/form !-- only trigger handler if event.target is the element itself -- !-- i.e. not from a child element -- div @click.self=\"doThat\".../divTIPOrder matters when using modifiers because the relevant code is generated in the same order. Therefore using @click.prevent.self will prevent click's default action on the element itself and its children, while @click.self.prevent will only prevent click's default action on the element itself.The .capture, .once, and .passive modifiers mirror the options of the native addEventListener method:template!-- use capture mode when adding the event listener -- !-- i.e. an event targeting an inner element is handled -- !-- here before being handled by that element -- div @click.capture=\"doThis\".../div !-- the click event will be triggered at most once -- a @click.once=\"doThis\"/a !-- the scroll event's default behavior (scrolling) will happen -- !-- immediately, instead of waiting for onScroll to complete -- !-- in case it contains event.preventDefault() -- div @scroll.passive=\"onScroll\".../divThe .passive modifier is typically used with touch event listeners for improving performance on mobile devices.TIPDo not use .passive and .prevent together, because .passive already indicates to the browser that you do not intend to prevent the event's default behavior, and you will likely see a warning from the browser if you do so.Key Modifiers When listening for keyboard events, we often need to check for specific keys. Vue allows adding key modifiers for v-on or @ when listening for key events:template!-- only call submit when the key is Enter -- input @keyup.enter=\"submit\" /You can directly use any valid key names exposed via KeyboardEvent.key as modifiers by converting them to kebab-case.templateinput @keyup.page-down=\"onPageDown\" /In the above example, the handler will only be called if $event.key is equal to 'PageDown'.Key Aliases Vue provides aliases for the most commonly used keys:.enter.tab.delete (captures both \"Delete\" and \"Backspace\" keys).esc.space.up.down.left.rightSystem Modifier Keys You can use the following modifiers to trigger mouse or keyboard event listeners only when the corresponding modifier key is pressed:.ctrl.alt.shift.metaNoteOn Macintosh keyboards, meta is the command key (). On Windows keyboards, meta is the Windows key (). On Sun Microsystems keyboards, meta is marked as a solid diamond (). On certain keyboards, specifically MIT and Lisp machine keyboards and successors, such as the Knight keyboard, space-cadet keyboard, meta is labeled META. On Symbolics keyboards, meta is labeled META or Meta.For example:template!-- Alt + Enter -- input @keyup.alt.enter=\"clear\" / !-- Ctrl + Click -- div @click.ctrl=\"doSomething\"Do something/divTIPNote that modifier keys are different from regular keys and when used with keyup events, they have to be pressed when the event is emitted. In other words, keyup.ctrl will only trigger if you release a key while holding down ctrl. It won't trigger if you release the ctrl key alone..exact Modifier The .exact modifier allows control of the exact combination of system modifiers needed to trigger an event.template!-- this will fire even if Alt or Shift is also pressed -- button @click.ctrl=\"onClick\"A/button !-- this will only fire when Ctrl and no other keys are pressed -- button @click.ctrl.exact=\"onCtrlClick\"A/button !-- this will only fire when no system modifiers are pressed -- button @click.exact=\"onClick\"A/buttonMouse Button Modifiers .left.right.middleThese modifiers restrict the handler to events triggered by a specific mouse button.Note, however, that .left, .right, and .middle modifier names are based on the typical right-handed mouse layout, but in fact represent \"main\", \"secondary\", and \"auxiliary\" pointing device event triggers, respectively, and not the actual physical buttons. So that for a left-handed mouse layout the \"main\" button might physically be the right one but would trigger the .left modifier handler. Or a trackpad might trigger the .left handler with a one-finger tap, the .right handler with a two-finger tap, and the .middle handler with a three-finger tap. Similarly, other devices and event sources generating \"mouse\" events might have trigger modes that are not related to \"left\" and \"right\" whatsoever.Edit this page on GitHub",
    "headings": [
      {
        "level": 1,
        "text": "Event Handling ​",
        "id": "event-handling"
      },
      {
        "level": 2,
        "text": "Listening to Events ​",
        "id": "listening-to-events"
      },
      {
        "level": 2,
        "text": "Inline Handlers ​",
        "id": "inline-handlers"
      },
      {
        "level": 2,
        "text": "Method Handlers ​",
        "id": "method-handlers"
      },
      {
        "level": 2,
        "text": "Calling Methods in Inline Handlers ​",
        "id": "calling-methods-in-inline-handlers"
      },
      {
        "level": 2,
        "text": "Accessing Event Argument in Inline Handlers ​",
        "id": "accessing-event-argument-in-inline-handlers"
      },
      {
        "level": 2,
        "text": "Event Modifiers ​",
        "id": "event-modifiers"
      },
      {
        "level": 2,
        "text": "Key Modifiers ​",
        "id": "key-modifiers"
      },
      {
        "level": 2,
        "text": "Mouse Button Modifiers ​",
        "id": "mouse-button-modifiers"
      },
      {
        "level": 3,
        "text": "Method vs. Inline Detection ​",
        "id": "method-vs-inline-detection"
      },
      {
        "level": 3,
        "text": "Key Aliases ​",
        "id": "key-aliases"
      },
      {
        "level": 3,
        "text": "System Modifier Keys ​",
        "id": "system-modifier-keys"
      },
      {
        "level": 3,
        "text": ".exact Modifier ​",
        "id": "exact-modifier"
      }
    ],
    "codeBlocks": [
      {
        "language": "text",
        "code": "v-on:click=\"handler\""
      },
      {
        "language": "text",
        "code": "@click=\"handler\""
      },
      {
        "language": "text",
        "code": "const count = ref(0)"
      },
      {
        "language": "text",
        "code": "const count = ref(0)"
      },
      {
        "language": "text",
        "code": "data() {\n  return {\n    count: 0\n  }\n}"
      },
      {
        "language": "text",
        "code": "data() {\n  return {\n    count: 0\n  }\n}"
      },
      {
        "language": "text",
        "code": "<button @click=\"count++\">Add 1</button>\n<p>Count is: {{ count }}</p>"
      },
      {
        "language": "text",
        "code": "<button @click=\"count++\">Add 1</button>\n<p>Count is: {{ count }}</p>"
      },
      {
        "language": "text",
        "code": "const name = ref('Vue.js')\n\nfunction greet(event) {\n  alert(`Hello ${name.value}!`)\n  // `event` is the native DOM event\n  if (event) {\n    alert(event.target.tagName)\n  }\n}"
      },
      {
        "language": "text",
        "code": "const name = ref('Vue.js')\n\nfunction greet(event) {\n  alert(`Hello ${name.value}!`)\n  // `event` is the native DOM event\n  if (event) {\n    alert(event.target.tagName)\n  }\n}"
      },
      {
        "language": "text",
        "code": "data() {\n  return {\n    name: 'Vue.js'\n  }\n},\nmethods: {\n  greet(event) {\n    // `this` inside methods points to the current active instance\n    alert(`Hello ${this.name}!`)\n    // `event` is the native DOM event\n    if (event) {\n      alert(event.target.tagName)\n    }\n  }\n}"
      },
      {
        "language": "text",
        "code": "data() {\n  return {\n    name: 'Vue.js'\n  }\n},\nmethods: {\n  greet(event) {\n    // `this` inside methods points to the current active instance\n    alert(`Hello ${this.name}!`)\n    // `event` is the native DOM event\n    if (event) {\n      alert(event.target.tagName)\n    }\n  }\n}"
      },
      {
        "language": "text",
        "code": "<!-- `greet` is the name of the method defined above -->\n<button @click=\"greet\">Greet</button>"
      },
      {
        "language": "text",
        "code": "<!-- `greet` is the name of the method defined above -->\n<button @click=\"greet\">Greet</button>"
      },
      {
        "language": "text",
        "code": "event.target"
      },
      {
        "language": "text",
        "code": "function say(message) {\n  alert(message)\n}"
      },
      {
        "language": "text",
        "code": "function say(message) {\n  alert(message)\n}"
      },
      {
        "language": "text",
        "code": "methods: {\n  say(message) {\n    alert(message)\n  }\n}"
      },
      {
        "language": "text",
        "code": "methods: {\n  say(message) {\n    alert(message)\n  }\n}"
      },
      {
        "language": "text",
        "code": "<button @click=\"say('hello')\">Say hello</button>\n<button @click=\"say('bye')\">Say bye</button>"
      },
      {
        "language": "text",
        "code": "<button @click=\"say('hello')\">Say hello</button>\n<button @click=\"say('bye')\">Say bye</button>"
      },
      {
        "language": "text",
        "code": "<!-- using $event special variable -->\n<button @click=\"warn('Form cannot be submitted yet.', $event)\">\n  Submit\n</button>\n\n<!-- using inline arrow function -->\n<button @click=\"(event) => warn('Form cannot be submitted yet.', event)\">\n  Submit\n</button>"
      },
      {
        "language": "text",
        "code": "<!-- using $event special variable -->\n<button @click=\"warn('Form cannot be submitted yet.', $event)\">\n  Submit\n</button>\n\n<!-- using inline arrow function -->\n<button @click=\"(event) => warn('Form cannot be submitted yet.', event)\">\n  Submit\n</button>"
      },
      {
        "language": "text",
        "code": "function warn(message, event) {\n  // now we have access to the native event\n  if (event) {\n    event.preventDefault()\n  }\n  alert(message)\n}"
      },
      {
        "language": "text",
        "code": "function warn(message, event) {\n  // now we have access to the native event\n  if (event) {\n    event.preventDefault()\n  }\n  alert(message)\n}"
      },
      {
        "language": "text",
        "code": "methods: {\n  warn(message, event) {\n    // now we have access to the native event\n    if (event) {\n      event.preventDefault()\n    }\n    alert(message)\n  }\n}"
      },
      {
        "language": "text",
        "code": "methods: {\n  warn(message, event) {\n    // now we have access to the native event\n    if (event) {\n      event.preventDefault()\n    }\n    alert(message)\n  }\n}"
      },
      {
        "language": "text",
        "code": "event.preventDefault()"
      },
      {
        "language": "text",
        "code": "event.stopPropagation()"
      },
      {
        "language": "text",
        "code": "<!-- the click event's propagation will be stopped -->\n<a @click.stop=\"doThis\"></a>\n\n<!-- the submit event will no longer reload the page -->\n<form @submit.prevent=\"onSubmit\"></form>\n\n<!-- modifiers can be chained -->\n<a @click.stop.prevent=\"doThat\"></a>\n\n<!-- just the modifier -->\n<form @submit.prevent></form>\n\n<!-- only trigger handler if event.target is the element itself -->\n<!-- i.e. not from a child element -->\n<div @click.self=\"doThat\">...</div>"
      },
      {
        "language": "text",
        "code": "<!-- the click event's propagation will be stopped -->\n<a @click.stop=\"doThis\"></a>\n\n<!-- the submit event will no longer reload the page -->\n<form @submit.prevent=\"onSubmit\"></form>\n\n<!-- modifiers can be chained -->\n<a @click.stop.prevent=\"doThat\"></a>\n\n<!-- just the modifier -->\n<form @submit.prevent></form>\n\n<!-- only trigger handler if event.target is the element itself -->\n<!-- i.e. not from a child element -->\n<div @click.self=\"doThat\">...</div>"
      },
      {
        "language": "text",
        "code": "@click.prevent.self"
      },
      {
        "language": "text",
        "code": "@click.self.prevent"
      },
      {
        "language": "text",
        "code": "addEventListener"
      },
      {
        "language": "text",
        "code": "<!-- use capture mode when adding the event listener     -->\n<!-- i.e. an event targeting an inner element is handled -->\n<!-- here before being handled by that element           -->\n<div @click.capture=\"doThis\">...</div>\n\n<!-- the click event will be triggered at most once -->\n<a @click.once=\"doThis\"></a>\n\n<!-- the scroll event's default behavior (scrolling) will happen -->\n<!-- immediately, instead of waiting for `onScroll` to complete  -->\n<!-- in case it contains `event.preventDefault()`                -->\n<div @scroll.passive=\"onScroll\">...</div>"
      },
      {
        "language": "text",
        "code": "<!-- use capture mode when adding the event listener     -->\n<!-- i.e. an event targeting an inner element is handled -->\n<!-- here before being handled by that element           -->\n<div @click.capture=\"doThis\">...</div>\n\n<!-- the click event will be triggered at most once -->\n<a @click.once=\"doThis\"></a>\n\n<!-- the scroll event's default behavior (scrolling) will happen -->\n<!-- immediately, instead of waiting for `onScroll` to complete  -->\n<!-- in case it contains `event.preventDefault()`                -->\n<div @scroll.passive=\"onScroll\">...</div>"
      },
      {
        "language": "text",
        "code": "<!-- only call `submit` when the `key` is `Enter` -->\n<input @keyup.enter=\"submit\" />"
      },
      {
        "language": "text",
        "code": "<!-- only call `submit` when the `key` is `Enter` -->\n<input @keyup.enter=\"submit\" />"
      },
      {
        "language": "text",
        "code": "KeyboardEvent.key"
      },
      {
        "language": "text",
        "code": "<input @keyup.page-down=\"onPageDown\" />"
      },
      {
        "language": "text",
        "code": "<input @keyup.page-down=\"onPageDown\" />"
      },
      {
        "language": "text",
        "code": "<!-- Alt + Enter -->\n<input @keyup.alt.enter=\"clear\" />\n\n<!-- Ctrl + Click -->\n<div @click.ctrl=\"doSomething\">Do something</div>"
      },
      {
        "language": "text",
        "code": "<!-- Alt + Enter -->\n<input @keyup.alt.enter=\"clear\" />\n\n<!-- Ctrl + Click -->\n<div @click.ctrl=\"doSomething\">Do something</div>"
      },
      {
        "language": "text",
        "code": "<!-- this will fire even if Alt or Shift is also pressed -->\n<button @click.ctrl=\"onClick\">A</button>\n\n<!-- this will only fire when Ctrl and no other keys are pressed -->\n<button @click.ctrl.exact=\"onCtrlClick\">A</button>\n\n<!-- this will only fire when no system modifiers are pressed -->\n<button @click.exact=\"onClick\">A</button>"
      },
      {
        "language": "text",
        "code": "<!-- this will fire even if Alt or Shift is also pressed -->\n<button @click.ctrl=\"onClick\">A</button>\n\n<!-- this will only fire when Ctrl and no other keys are pressed -->\n<button @click.ctrl.exact=\"onCtrlClick\">A</button>\n\n<!-- this will only fire when no system modifiers are pressed -->\n<button @click.exact=\"onClick\">A</button>"
      }
    ],
    "links": [
      {
        "text": "Watch a free video lesson on Vue School",
        "href": "https://vueschool.io/lessons/user-events-in-vue-3?friend=vuejs"
      },
      {
        "text": "Watch a free video lesson on Vue School",
        "href": "https://vueschool.io/lessons/vue-fundamentals-capi-user-events-in-vue-3?friend=vuejs"
      },
      {
        "text": "Try it in the Playground",
        "href": "https://play.vuejs.org/#eNo9jssKgzAURH/lko0tgrbbEqX+Q5fZaLxiqHmQ3LgJ+fdqFZcD58xMYp1z1RqRvRgP0itHEJCia4VR2llPkMDjBBkmbzUUG1oII4y0JhBIGw2hh2Znbo+7MLw+WjZ/C4TaLT3hnogPkcgaeMtFyW8j2GmXpWBtN47w5PWBHLhrPzPCKfWDXRHmPsCAaOBfgSOkdH3IGUhpDBWv9/e8vsZZ/gFFhFJN"
      },
      {
        "text": "Try it in the Playground",
        "href": "https://play.vuejs.org/#eNo9jcEKgzAQRH9lyKlF0PYqqdR/6DGXaLYo1RjiRgrivzepIizLzu7sm1XUzuVLIFEKObe+d1wpS183eYahtw4DY1UWMJr15ZpmxYAnDt7uF0BxOwXL5Evc0kbxlmyxxZLFyY2CaXSDZkqKZROYJ4tnO/Tt56HEgckyJaraGNxlsVt2u6teHeF40s20EDo9oyGy+CPIYF1xULBt4H6kOZeFiwBZnOFi+wH0B1hk"
      },
      {
        "text": "Try it in the Playground",
        "href": "https://play.vuejs.org/#eNpVj0FLxDAQhf/KMwjtXtq7dBcFQS/qzVMOrWFao2kSkkkvpf/dJIuCEBgm771vZnbx4H23JRJ3YogqaM+IxMlfpNWrd4GxI9CMA3NwK5psbaSVVjkbGXZaCediaJv3RN1XbE5FnZNVrJ3FEoi4pY0sn7BLC0yGArfjMxnjcLsXQrdNJtFxM+Ys0PcYa2CEjuBPylNYb4THtxdUobj0jH/YX3D963gKC5WyvGZ+xR7S5jf01yPzeblhWr2ZmErHw0dizivfK6PV91mKursUl6dSh/4qZ+vQ/+XE8QODonDi"
      },
      {
        "text": "Try it in the Playground",
        "href": "https://play.vuejs.org/#eNplUE1LxDAQ/StjEbYL0t5LXRQEvag3Tz00prNtNE1CMilC6X83SUkRhJDJfLz3Jm8tHo2pFo9FU7SOW2Ho0in8MdoSDHhlXhKsnQIYGLHyvL8BLJK3KmcAis3YwOnDY/XlTnt1i2G7i/eMNOnBNRkwWkQqcUFFByVAXUNPk3A9COXEgBkGRgtFDkgDTQjcWxuAwDiJBeMsMcUxszCJlsr+BaXUcLtGwiqut930579KST1IBd5Aqlgie3p/hdTIk+IK//bMGqleEbMjxjC+BZVDIv0+m9CpcNr6MDgkhLORjDBm1H56Iq3ggUvBv++7IhnUFZfnGNt6b4fRtj5wxfYL9p+Sjw=="
      },
      {
        "text": "Typing Event Handlers",
        "href": "/guide/typescript/composition-api#typing-event-handlers"
      },
      {
        "text": "Typing Event Handlers",
        "href": "/guide/typescript/options-api#typing-event-handlers"
      },
      {
        "text": "Try it in the Playground",
        "href": "https://play.vuejs.org/#eNp9jTEOwjAMRa8SeSld6I5CBWdg9ZJGBiJSN2ocpKjq3UmpFDGx+Vn//b/ANYTjOxGcQEc7uyAqkqTQI98TW3ETq2jyYaQYzYNatSArZTzNUn/IK7Ludr2IBYTG4I3QRqKHJFJ6LtY7+zojbIXNk7yfmhahv5msvqS7PfnHGjJVp9w/hu7qKKwfEd1NSg=="
      },
      {
        "text": "Try it in the Playground",
        "href": "https://play.vuejs.org/#eNptjUEKwjAQRa8yZFO7sfsSi57B7WzGdjTBtA3NVC2ldzehEFwIw8D7vM9f1cX742tmVSsd2sl6aXDgjx8ngY7vNDuBFQeAnsWMXagToQAEWg49h0APLncDAIUcT5LzlKJsqRBfPF3ljQjCvXcknEj0bRYZBzi3zrbPE6o0UBhblKiaKy1grK52J/oA//23IcmNBD8dXeVBtX0BF0pXsg=="
      },
      {
        "text": "options of the native addEventListener method",
        "href": "https://developer.mozilla.org/en-US/docs/Web/API/EventTarget/addEventListener#options"
      },
      {
        "text": "improving performance on mobile devices",
        "href": "https://developer.mozilla.org/en-US/docs/Web/API/EventTarget/addEventListener#improving_scroll_performance_using_passive_listeners"
      },
      {
        "text": "KeyboardEvent.key",
        "href": "https://developer.mozilla.org/en-US/docs/Web/API/UI_Events/Keyboard_event_key_values"
      },
      {
        "text": "Edit this page on GitHub",
        "href": "https://github.com/vuejs/docs/edit/main/src/guide/essentials/event-handling.md"
      }
    ],
    "meta": {
      "description": "Vue.js - The Progressive JavaScript Framework",
      "keywords": ""
    },
    "summary": "Event Handling Watch a free video lesson on Vue SchoolWatch a free video lesson on Vue SchoolListening to Events We can use the v-on directive, which we typically shorten to the @ symbol, to listen to...",
    "tags": [
      "react",
      "vue",
      "angular",
      "javascript",
      "typescript",
      "html",
      "vite",
      "event",
      "inline",
      "handlers"
    ],
    "id": "event-handling-eventhandlinghtml-part-1",
    "quality": 100
  },
  {
    "title": "Form Input Bindings",
    "url": "https://vuejs.org/guide/essentials/forms.html",
    "category": "vue",
    "content": "Form Input Bindings Watch a free video lesson on Vue SchoolWatch a free video lesson on Vue SchoolWhen dealing with forms on the frontend, we often need to sync the state of form input elements with corresponding state in JavaScript. It can be cumbersome to manually wire up value bindings and change event listeners:templateinput :value=\"text\" @input=\"event = text = event.target.value\"The v-model directive helps us simplify the above to:templateinput v-model=\"text\"In addition, v-model can be used on inputs of different types, textarea, and select elements. It automatically expands to different DOM property and event pairs based on the element it is used on:input with text types and textarea elements use value property and input event;input type=\"checkbox\" and input type=\"radio\" use checked property and change event;select uses value as a prop and change as an event.Notev-model will ignore the initial value, checked or selected attributes found on any form elements. It will always treat the current bound JavaScript state as the source of truth. You should declare the initial value on the JavaScript side, using the data optionreactivity APIs.Basic Usage Text templatepMessage is: {{ message }}/p input v-model=\"message\" placeholder=\"edit me\" /Message is: Try it in the PlaygroundTry it in the PlaygroundNoteFor languages that require an IME (Chinese, Japanese, Korean, etc.), you'll notice that v-model doesn't get updated during IME composition. If you want to respond to these updates as well, use your own input event listener and value binding instead of using v-model.Multiline Text templatespanMultiline message is:/span p style=\"white-space: pre-line;\"{{ message }}/p textarea v-model=\"message\" placeholder=\"add multiple lines\"/textareaMultiline message is:Try it in the PlaygroundTry it in the PlaygroundNote that interpolation inside textarea won't work. Use v-model instead.template!-- bad -- textarea{{ text }}/textarea !-- good -- textarea v-model=\"text\"/textareaCheckbox Single checkbox, boolean value:templateinput type=\"checkbox\" id=\"checkbox\" v-model=\"checked\" / label for=\"checkbox\"{{ checked }}/labelfalseTry it in the PlaygroundTry it in the PlaygroundWe can also bind multiple checkboxes to the same array or Set value:jsconst checkedNames = ref([])jsexport default { data() { return { checkedNames: [] } } }templatedivChecked names: {{ checkedNames }}/div input type=\"checkbox\" id=\"jack\" value=\"Jack\" v-model=\"checkedNames\" / label for=\"jack\"Jack/label input type=\"checkbox\" id=\"john\" value=\"John\" v-model=\"checkedNames\" / label for=\"john\"John/label input type=\"checkbox\" id=\"mike\" value=\"Mike\" v-model=\"checkedNames\" / label for=\"mike\"Mike/labelChecked names: []JackJohnMikeIn this case, the checkedNames array will always contain the values from the currently checked boxes.Try it in the PlaygroundTry it in the PlaygroundRadio templatedivPicked: {{ picked }}/div input type=\"radio\" id=\"one\" value=\"One\" v-model=\"picked\" / label for=\"one\"One/label input type=\"radio\" id=\"two\" value=\"Two\" v-model=\"picked\" / label for=\"two\"Two/labelPicked: OneTwoTry it in the PlaygroundTry it in the PlaygroundSelect Single select:templatedivSelected: {{ selected }}/div select v-model=\"selected\" option disabled value=\"\"Please select one/option optionA/option optionB/option optionC/option /selectSelected: Please select oneABCTry it in the PlaygroundTry it in the PlaygroundNoteIf the initial value of your v-model expression does not match any of the options, the select element will render in an \"unselected\" state. On iOS this will cause the user not being able to select the first item because iOS does not fire a change event in this case. It is therefore recommended to provide a disabled option with an empty value, as demonstrated in the example above.Multiple select (bound to array):templatedivSelected: {{ selected }}/div select v-model=\"selected\" multiple optionA/option optionB/option optionC/option /selectSelected: []ABCTry it in the PlaygroundTry it in the PlaygroundSelect options can be dynamically rendered with v-for:jsconst selected = ref('A') const options = ref([ { text: 'One', value: 'A' }, { text: 'Two', value: 'B' }, { text: 'Three', value: 'C' } ])jsexport default { data() { return { selected: 'A', options: [ { text: 'One', value: 'A' }, { text: 'Two', value: 'B' }, { text: 'Three', value: 'C' } ] } } }templatedivSelected: {{ selected }}/div select v-model=\"selected\" option v-for=\"option in options\" :value=\"option.value\" {{ option.text }} /option /selectSelected: AOneTwoThreeTry it in the PlaygroundTry it in the PlaygroundValue Bindings For radio, checkbox and select options, the v-model binding values are usually static strings (or booleans for checkbox):template!-- picked is a string \"a\" when checked -- input type=\"radio\" v-model=\"picked\" value=\"a\" / !-- toggle is either true or false -- input type=\"checkbox\" v-model=\"toggle\" / !-- selected is a string \"abc\" when the first option is selected -- select v-model=\"selected\" option value=\"abc\"ABC/option /selectBut sometimes we may want to bind the value to a dynamic property on the current active instance. We can use v-bind to achieve that. In addition, using v-bind allows us to bind the input value to non-string values.Checkbox templateinput type=\"checkbox\" v-model=\"toggle\" true-value=\"yes\" false-value=\"no\" /true-value and false-value are Vue-specific attributes that only work with v-model. Here the toggle property's value will be set to 'yes' when the box is checked, and set to 'no' when unchecked. You can also bind them to dynamic values using v-bind:templateinput type=\"checkbox\" v-model=\"toggle\" :true-value=\"dynamicTrueValue\" :false-value=\"dynamicFalseValue\" /TipThe true-value and false-value attributes don't affect the input's value attribute, because browsers don't include unchecked boxes in form submissions. To guarantee that one of two values is submitted in a form (e.g. \"yes\" or \"no\"), use radio inputs instead.Radio templateinput type=\"radio\" v-model=\"pick\" :value=\"first\" / input type=\"radio\" v-model=\"pick\" :value=\"second\" /pick will be set to the value of first when the first radio input is checked, and set to the value of second when the second one is checked.Select Options templateselect v-model=\"selected\" !-- inline object literal -- option :value=\"{ number: 123 }\"123/option /selectv-model supports value bindings of non-string values as well! In the above example, when the option is selected, selected will be set to the object literal value of { number: 123 }.Modifiers .lazy By default, v-model syncs the input with the data after each input event (with the exception of IME composition as stated above). You can add the lazy modifier to instead sync after change events:template!-- synced after \"change\" instead of \"input\" -- input v-model.lazy=\"msg\" /.number If you want user input to be automatically typecast as a number, you can add the number modifier to your v-model managed inputs:templateinput v-model.number=\"age\" /If the value cannot be parsed with parseFloat(), then the original (string) value is used instead. In particular, if the input is empty (for instance after the user clearing the input field), an empty string is returned. This behavior differs from the DOM property valueAsNumber.The number modifier is applied automatically if the input has type=\"number\"..trim If you want whitespace from user input to be trimmed automatically, you can add the trim modifier to your v-model-managed inputs:templateinput v-model.trim=\"msg\" /v-model with Components If you're not yet familiar with Vue's components, you can skip this for now.HTML's built-in input types won't always meet your needs. Fortunately, Vue components allow you to build reusable inputs with completely customized behavior. These inputs even work with v-model! To learn more, read about Usage with v-model in the Components guide.Edit this page on GitHub",
    "headings": [
      {
        "level": 1,
        "text": "Form Input Bindings ​",
        "id": "form-input-bindings"
      },
      {
        "level": 2,
        "text": "Basic Usage ​",
        "id": "basic-usage"
      },
      {
        "level": 2,
        "text": "Value Bindings ​",
        "id": "value-bindings"
      },
      {
        "level": 2,
        "text": "Modifiers ​",
        "id": "modifiers"
      },
      {
        "level": 2,
        "text": "v-model with Components ​",
        "id": "v-model-with-components"
      },
      {
        "level": 3,
        "text": "Text ​",
        "id": "text"
      },
      {
        "level": 3,
        "text": "Multiline Text ​",
        "id": "multiline-text"
      },
      {
        "level": 3,
        "text": "Checkbox ​",
        "id": "checkbox"
      },
      {
        "level": 3,
        "text": "Radio ​",
        "id": "radio"
      },
      {
        "level": 3,
        "text": "Select ​",
        "id": "select"
      },
      {
        "level": 3,
        "text": "Checkbox ​",
        "id": "checkbox-1"
      },
      {
        "level": 3,
        "text": "Radio ​",
        "id": "radio-1"
      },
      {
        "level": 3,
        "text": "Select Options ​",
        "id": "select-options"
      },
      {
        "level": 3,
        "text": ".lazy ​",
        "id": "lazy"
      },
      {
        "level": 3,
        "text": ".number ​",
        "id": "number"
      },
      {
        "level": 3,
        "text": ".trim ​",
        "id": "trim"
      }
    ],
    "codeBlocks": [
      {
        "language": "text",
        "code": "<input\n  :value=\"text\"\n  @input=\"event => text = event.target.value\">"
      },
      {
        "language": "text",
        "code": "<input\n  :value=\"text\"\n  @input=\"event => text = event.target.value\">"
      },
      {
        "language": "text",
        "code": "<input v-model=\"text\">"
      },
      {
        "language": "text",
        "code": "<input v-model=\"text\">"
      },
      {
        "language": "text",
        "code": "<input type=\"checkbox\">"
      },
      {
        "language": "text",
        "code": "<input type=\"radio\">"
      },
      {
        "language": "text",
        "code": "<p>Message is: {{ message }}</p>\n<input v-model=\"message\" placeholder=\"edit me\" />"
      },
      {
        "language": "text",
        "code": "<p>Message is: {{ message }}</p>\n<input v-model=\"message\" placeholder=\"edit me\" />"
      },
      {
        "language": "text",
        "code": "<span>Multiline message is:</span>\n<p style=\"white-space: pre-line;\">{{ message }}</p>\n<textarea v-model=\"message\" placeholder=\"add multiple lines\"></textarea>"
      },
      {
        "language": "text",
        "code": "<span>Multiline message is:</span>\n<p style=\"white-space: pre-line;\">{{ message }}</p>\n<textarea v-model=\"message\" placeholder=\"add multiple lines\"></textarea>"
      },
      {
        "language": "text",
        "code": "<!-- bad -->\n<textarea>{{ text }}</textarea>\n\n<!-- good -->\n<textarea v-model=\"text\"></textarea>"
      },
      {
        "language": "text",
        "code": "<!-- bad -->\n<textarea>{{ text }}</textarea>\n\n<!-- good -->\n<textarea v-model=\"text\"></textarea>"
      },
      {
        "language": "text",
        "code": "<input type=\"checkbox\" id=\"checkbox\" v-model=\"checked\" />\n<label for=\"checkbox\">{{ checked }}</label>"
      },
      {
        "language": "text",
        "code": "<input type=\"checkbox\" id=\"checkbox\" v-model=\"checked\" />\n<label for=\"checkbox\">{{ checked }}</label>"
      },
      {
        "language": "text",
        "code": "const checkedNames = ref([])"
      },
      {
        "language": "text",
        "code": "const checkedNames = ref([])"
      },
      {
        "language": "text",
        "code": "export default {\n  data() {\n    return {\n      checkedNames: []\n    }\n  }\n}"
      },
      {
        "language": "text",
        "code": "export default {\n  data() {\n    return {\n      checkedNames: []\n    }\n  }\n}"
      },
      {
        "language": "text",
        "code": "<div>Checked names: {{ checkedNames }}</div>\n\n<input type=\"checkbox\" id=\"jack\" value=\"Jack\" v-model=\"checkedNames\" />\n<label for=\"jack\">Jack</label>\n\n<input type=\"checkbox\" id=\"john\" value=\"John\" v-model=\"checkedNames\" />\n<label for=\"john\">John</label>\n\n<input type=\"checkbox\" id=\"mike\" value=\"Mike\" v-model=\"checkedNames\" />\n<label for=\"mike\">Mike</label>"
      },
      {
        "language": "text",
        "code": "<div>Checked names: {{ checkedNames }}</div>\n\n<input type=\"checkbox\" id=\"jack\" value=\"Jack\" v-model=\"checkedNames\" />\n<label for=\"jack\">Jack</label>\n\n<input type=\"checkbox\" id=\"john\" value=\"John\" v-model=\"checkedNames\" />\n<label for=\"john\">John</label>\n\n<input type=\"checkbox\" id=\"mike\" value=\"Mike\" v-model=\"checkedNames\" />\n<label for=\"mike\">Mike</label>"
      },
      {
        "language": "text",
        "code": "checkedNames"
      },
      {
        "language": "text",
        "code": "<div>Picked: {{ picked }}</div>\n\n<input type=\"radio\" id=\"one\" value=\"One\" v-model=\"picked\" />\n<label for=\"one\">One</label>\n\n<input type=\"radio\" id=\"two\" value=\"Two\" v-model=\"picked\" />\n<label for=\"two\">Two</label>"
      },
      {
        "language": "text",
        "code": "<div>Picked: {{ picked }}</div>\n\n<input type=\"radio\" id=\"one\" value=\"One\" v-model=\"picked\" />\n<label for=\"one\">One</label>\n\n<input type=\"radio\" id=\"two\" value=\"Two\" v-model=\"picked\" />\n<label for=\"two\">Two</label>"
      },
      {
        "language": "text",
        "code": "<div>Selected: {{ selected }}</div>\n\n<select v-model=\"selected\">\n  <option disabled value=\"\">Please select one</option>\n  <option>A</option>\n  <option>B</option>\n  <option>C</option>\n</select>"
      },
      {
        "language": "text",
        "code": "<div>Selected: {{ selected }}</div>\n\n<select v-model=\"selected\">\n  <option disabled value=\"\">Please select one</option>\n  <option>A</option>\n  <option>B</option>\n  <option>C</option>\n</select>"
      },
      {
        "language": "text",
        "code": "<div>Selected: {{ selected }}</div>\n\n<select v-model=\"selected\" multiple>\n  <option>A</option>\n  <option>B</option>\n  <option>C</option>\n</select>"
      },
      {
        "language": "text",
        "code": "<div>Selected: {{ selected }}</div>\n\n<select v-model=\"selected\" multiple>\n  <option>A</option>\n  <option>B</option>\n  <option>C</option>\n</select>"
      },
      {
        "language": "text",
        "code": "const selected = ref('A')\n\nconst options = ref([\n  { text: 'One', value: 'A' },\n  { text: 'Two', value: 'B' },\n  { text: 'Three', value: 'C' }\n])"
      },
      {
        "language": "text",
        "code": "const selected = ref('A')\n\nconst options = ref([\n  { text: 'One', value: 'A' },\n  { text: 'Two', value: 'B' },\n  { text: 'Three', value: 'C' }\n])"
      },
      {
        "language": "text",
        "code": "export default {\n  data() {\n    return {\n      selected: 'A',\n      options: [\n        { text: 'One', value: 'A' },\n        { text: 'Two', value: 'B' },\n        { text: 'Three', value: 'C' }\n      ]\n    }\n  }\n}"
      },
      {
        "language": "text",
        "code": "export default {\n  data() {\n    return {\n      selected: 'A',\n      options: [\n        { text: 'One', value: 'A' },\n        { text: 'Two', value: 'B' },\n        { text: 'Three', value: 'C' }\n      ]\n    }\n  }\n}"
      },
      {
        "language": "text",
        "code": "<div>Selected: {{ selected }}</div>\n\n<select v-model=\"selected\">\n  <option v-for=\"option in options\" :value=\"option.value\">\n    {{ option.text }}\n  </option>\n</select>"
      },
      {
        "language": "text",
        "code": "<div>Selected: {{ selected }}</div>\n\n<select v-model=\"selected\">\n  <option v-for=\"option in options\" :value=\"option.value\">\n    {{ option.text }}\n  </option>\n</select>"
      },
      {
        "language": "text",
        "code": "<!-- `picked` is a string \"a\" when checked -->\n<input type=\"radio\" v-model=\"picked\" value=\"a\" />\n\n<!-- `toggle` is either true or false -->\n<input type=\"checkbox\" v-model=\"toggle\" />\n\n<!-- `selected` is a string \"abc\" when the first option is selected -->\n<select v-model=\"selected\">\n  <option value=\"abc\">ABC</option>\n</select>"
      },
      {
        "language": "text",
        "code": "<!-- `picked` is a string \"a\" when checked -->\n<input type=\"radio\" v-model=\"picked\" value=\"a\" />\n\n<!-- `toggle` is either true or false -->\n<input type=\"checkbox\" v-model=\"toggle\" />\n\n<!-- `selected` is a string \"abc\" when the first option is selected -->\n<select v-model=\"selected\">\n  <option value=\"abc\">ABC</option>\n</select>"
      },
      {
        "language": "text",
        "code": "<input\n  type=\"checkbox\"\n  v-model=\"toggle\"\n  true-value=\"yes\"\n  false-value=\"no\" />"
      },
      {
        "language": "text",
        "code": "<input\n  type=\"checkbox\"\n  v-model=\"toggle\"\n  true-value=\"yes\"\n  false-value=\"no\" />"
      },
      {
        "language": "text",
        "code": "false-value"
      },
      {
        "language": "text",
        "code": "<input\n  type=\"checkbox\"\n  v-model=\"toggle\"\n  :true-value=\"dynamicTrueValue\"\n  :false-value=\"dynamicFalseValue\" />"
      },
      {
        "language": "text",
        "code": "<input\n  type=\"checkbox\"\n  v-model=\"toggle\"\n  :true-value=\"dynamicTrueValue\"\n  :false-value=\"dynamicFalseValue\" />"
      },
      {
        "language": "text",
        "code": "false-value"
      },
      {
        "language": "text",
        "code": "<input type=\"radio\" v-model=\"pick\" :value=\"first\" />\n<input type=\"radio\" v-model=\"pick\" :value=\"second\" />"
      },
      {
        "language": "text",
        "code": "<input type=\"radio\" v-model=\"pick\" :value=\"first\" />\n<input type=\"radio\" v-model=\"pick\" :value=\"second\" />"
      },
      {
        "language": "text",
        "code": "<select v-model=\"selected\">\n  <!-- inline object literal -->\n  <option :value=\"{ number: 123 }\">123</option>\n</select>"
      },
      {
        "language": "text",
        "code": "<select v-model=\"selected\">\n  <!-- inline object literal -->\n  <option :value=\"{ number: 123 }\">123</option>\n</select>"
      },
      {
        "language": "text",
        "code": "{ number: 123 }"
      },
      {
        "language": "text",
        "code": "<!-- synced after \"change\" instead of \"input\" -->\n<input v-model.lazy=\"msg\" />"
      },
      {
        "language": "text",
        "code": "<!-- synced after \"change\" instead of \"input\" -->\n<input v-model.lazy=\"msg\" />"
      },
      {
        "language": "text",
        "code": "<input v-model.number=\"age\" />"
      },
      {
        "language": "text",
        "code": "<input v-model.number=\"age\" />"
      },
      {
        "language": "text",
        "code": "parseFloat()"
      },
      {
        "language": "text",
        "code": "valueAsNumber"
      },
      {
        "language": "text",
        "code": "type=\"number\""
      },
      {
        "language": "text",
        "code": "<input v-model.trim=\"msg\" />"
      },
      {
        "language": "text",
        "code": "<input v-model.trim=\"msg\" />"
      }
    ],
    "links": [
      {
        "text": "Watch a free video lesson on Vue School",
        "href": "https://vueschool.io/lessons/user-inputs-vue-devtools-in-vue-3?friend=vuejs"
      },
      {
        "text": "Watch a free video lesson on Vue School",
        "href": "https://vueschool.io/lessons/vue-fundamentals-capi-user-inputs-in-vue?friend=vuejs"
      },
      {
        "text": "data",
        "href": "/api/options-state#data"
      },
      {
        "text": "reactivity APIs",
        "href": "/api/reactivity-core#reactivity-api-core"
      },
      {
        "text": "Try it in the Playground",
        "href": "https://play.vuejs.org/#eNo9jUEOgyAQRa8yYUO7aNkbNOkBegM2RseWRGACoxvC3TumxuX/+f+9ql5Ez31D1SlbpuyJoSBvNLjoA6XMUCHjAg2WnAJomWoXXZxSLAwBSxk/CP2xuWl9d9GaP0YAEhgDrSOjJABLw/s8+NJBrde/NWsOpWPrI20M+yOkGdfeqXPiFAhowm9aZ8zS4+wPv/RGjtZcJtV+YpNK1g=="
      },
      {
        "text": "Try it in the Playground",
        "href": "https://play.vuejs.org/#eNo9jdEKwjAMRX8l9EV90L2POvAD/IO+lDVqoetCmw6h9N/NmBuEJPeSc1PVg+i2FFS90nlMnngwEb80JwaHL1sCQzURwFm258u2AyTkkuKuACbM2b6xh9Nps9o6pEnp7ggWwThRsIyiADQNz40En3uodQ+C1nRHK8HaRyoMy3WaHYa7Uf8To0CCRvzMwWESH51n4cXvBNTd8Um1H0FuTq0="
      },
      {
        "text": "IME",
        "href": "https://en.wikipedia.org/wiki/Input_method"
      },
      {
        "text": "Try it in the Playground",
        "href": "https://play.vuejs.org/#eNo9jktuwzAMRK9CaON24XrvKgZ6gN5AG8FmGgH6ECKdJjB891D5LYec9zCb+SH6Oq9oRmN5roEEGGWlyeWQqFSBDSoeYYdjLQk6rXYuuzyXzAIJmf0fwqF1Prru02U7PDQq0CCYKHrBlsQy+Tz9rlFCDBnfdOBRqfa7twhYrhEPzvyfgmCvnxlHoIp9w76dmbbtDe+7HdpaBQUv4it6OPepLBjV8Gw5AzpjxlOJC1a9+2WB1IZQRGhWVqsdXgb1tfDcbvYbJDRqLQ=="
      },
      {
        "text": "Try it in the Playground",
        "href": "https://play.vuejs.org/#eNo9jk2OwyAMha9isenMIpN9hok0B+gN2FjBbZEIscDpj6LcvaZpKiHg2X6f32L+mX+uM5nO2DLkwNK7RHeesoCnE85RYHEJwKPg1/f2B8gkc067AhipFDxTB4fDVlrro5ce237AKoRGjihUldjCmPqjLgkxJNoxEEqnrtp7TTEUeUT6c+Z2CUKNdgbdxZmaavt1pl+Wj3ldbcubUegumAnh2oyTp6iE95QzoDEGukzRU9Y6eg9jDcKRoFKLUm27E5RXxTu7WZ89/G4E"
      },
      {
        "text": "Try it in the Playground",
        "href": "https://play.vuejs.org/#eNpVjssKgzAURH/lko3tonVfotD/yEaTKw3Ni3gjLSH/3qhUcDnDnMNk9gzhviRkD8ZnGXUgmJFS6IXTNvhIkCHiBAWm6C00ddoIJ5z0biaQL5RvVNCtmwvFhFfheLuLqqIGQhvMQLgm4tqFREDfgJ1gGz36j2Cg1TkvN+sVmn+JqnbtrjDDiAYmH09En/PxphTebqsK8PY4wMoPslBUxQ=="
      },
      {
        "text": "Try it in the Playground",
        "href": "https://play.vuejs.org/#eNpVjtEKgzAMRX8l9Gl72Po+OmH/0ZdqI5PVNnSpOEr/fVVREEKSc0kuN4sX0X1KKB5Cfbs4EDfa40whMljsTXIMWXsAa9hcrtsOEJFT9DsBdG/sPmgfwDHhJpZl1FZLycO6AuNIzjAuxGrwlBj4R/jUYrVpw6wFDPbM020MFt0uoq2a3CycadFBH+Lpo8l5jwWlKLle1QcljwCi/AH7gFic"
      },
      {
        "text": "Set",
        "href": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Set"
      },
      {
        "text": "Try it in the Playground",
        "href": "https://play.vuejs.org/#eNqVkUtqwzAURbfy0CTtoNU8KILSWaHdQNWBIj8T1fohyybBeO+RbOc3i2e+vHvuMWggHyG89x2SLWGtijokaDF1gQunbfAxwQARaxihjt7CJlc3wgmnvGsTqAOqBqsfabGFXSm+/P69CsfovJVXckhog5EJcwJgle7558yBK+AWhuFxaRwZLbVCZ0K70CVIp4A7Qabi3h8FAV3l/C9Vk797abpy/lrim/UVmkt/Gc4HOv+EkXs0UPt4XeCFZHQ6lM4TZn9w9+YlrjFPCC/kKrPVDd6Zv5e4wjwv8ELezIxeX4qMZwHduAs="
      },
      {
        "text": "Try it in the Playground",
        "href": "https://play.vuejs.org/#eNqVUc1qxCAQfpXBU3tovS9WKL0V2hdoenDjLGtjVNwxbAl592rMpru3DYjO5/cnOLLXEJ6HhGzHxKmNJpBsHJ6DjwQaDypZgrFxAFqRenisM0BEStFdEEB7xLZD/al6PO3g67veT+XIW16Cr+kZEPbBKsKMAIQ2g3yrAeBqwjjeRMI0CV5kxZ0dxoVEQL8BXxo2C/f+3DAwOuMf1XZ5HpRNhX5f4FPvNdqLfgnOBK+PsGqPFg4+rgmyOAWfiaK5o9kf3XXzArc0zxZZnJuae9PhVfPHAjc01wRZnP/Ngq8/xaY/yMW74g=="
      },
      {
        "text": "Try it in the Playground",
        "href": "https://play.vuejs.org/#eNqFkDFuwzAMRa9CaHE7tNoDxUBP0A4dtTgWDQiRJUKmHQSG7x7KhpMMAbLxk3z/g5zVD9H3NKI6KDO02RPDgDxSbaPvKWWGGTJ2sECXUw+VrFY22timODCQb8/o4FhWPqrfiNWnjUZvRmIhgrGn0DCKAjDOT/XfCh1gnnd+WYwukwJYNj7SyMBXwqNVuXE+WQXeiUgRpZyaMJaR5BX11SeHQfTmJi1dnNiE5oQBupR3shbC6LX9Posvpdyz/jf1OksOe85ayVqIR5bR9z+o5Qbc6oCk"
      },
      {
        "text": "Try it in the Playground",
        "href": "https://play.vuejs.org/#eNqNkEEOAiEMRa/SsFEXyt7gJJ5AFy5ng1ITIgLBMmomc3eLOONSEwJ9Lf//pL3YxrjqMoq1ULdTspGa1uMjhkRg8KyzI+hbD2A06fmi1gAJKSc/EkC0pwuaNcx2Hme1OZSHLz5KTtYMhNfoNGEhUsZ2zf6j7vuPEQyDkmVSBPzJ+pgJ6Blx04qkjQ2tAGsYgkcuO+1yGXF6oeU1GHTM1Y1bsoY5fUQH55BGZcMKJd/t31l0L+WYdaj0V9Zb2bDim6XktAcxvADR+YWb"
      },
      {
        "text": "Try it in the Playground",
        "href": "https://play.vuejs.org/#eNp1j7EOgyAQhl/lwmI7tO4Nmti+QJOuLFTPxASBALoQ3r2H2jYOjvff939wkTXWXucJ2Y1x37rBBvAYJlsLPYzWuAARHPaQoHdmhILQQmihW6N9RhW2ATuoMnQqirPQvFw9ZKAh4GiVDEgTAPdW6hpeW+sGMf4VKVEz73Mvs8sC5stoOlSVYF9SsEVGiLFhMBq6wcu3IsUs1YREEvFUKD1udjAaebnS+27dHOT3g/yxy+nHywM08PJ3KksfXwJ2dA=="
      },
      {
        "text": "Try it in the Playground",
        "href": "https://play.vuejs.org/#eNp1j1ELgyAUhf/KxZe2h633cEHbHxjstReXdxCYSt5iEP333XIJPQSinuN3jjqJyvvrOKAohAxN33oqa4tf73oCjR81GIKptgBakTqd4x6gRxp6uymAgAYbQl1AlkVvXhaeeMg8NbMg7LxRhKwAZPDKlvBK8WlKXTDPnFzOI7naMF46p9HcarFxtVgBRpyn1lnQbVBvwwWjMgMyycTToAr47wZnUeaR3mfL6sC/H/iPnc/vXS9gIfP0UTH/ACgWeYE="
      },
      {
        "text": "Try it in the Playground",
        "href": "https://play.vuejs.org/#eNp1kL2OwjAQhF9l5Ya74i7QBhMJeARKTIESIyz5Z5VsAsjyu7NOQEBB5xl/M7vaKNaI/0OvRSlkV7cGCTpNPVbKG4ehJYjQ6hMkOLXBwYzRmfLK18F3GbW6Jt3AKkM/+8Ov8rKYeriBBWmH9kiaFYBszFDtHpkSYnwVpCSL/JtDDE4+DH8uNNqulHiCSoDrLRm0UyWzAckEX61l8Xh9+psv/vbD563HCSxk8bY0y45u47AJ2D/HHyDm4MU0dC5hMZ/jdal8Gg8wJkS6A3nRew4="
      },
      {
        "text": "Try it in the Playground",
        "href": "https://play.vuejs.org/#eNp1UEEOgjAQ/MqmJz0oeMVKgj7BI3AgdI1NCjSwIIbwdxcqRA4mTbsznd2Z7CAia49diyIQsslrbSlMSuxtVRMofGStIRiSEkBllO32rgaokdq6XBBAgwZzQhVAnDpunB6++EhvncyAsLAmI2QEIJXuwvvaPAzrJBhH6U2/UxMLHQ/doagUmksiFmEioOCU2ho3krWVJV2VYSS9b7Xlr3/424bn1LMDA+n9hGbY0Hs2c4J4sU/dPl5a0TOAk+/b/rwsYO4Q4wdtRX7l"
      },
      {
        "text": "Try it in the Playground",
        "href": "https://play.vuejs.org/#eNp9kj9vwjAQxb/KyUtaiYahGwpIgBjaoVSFre6AkguEOnZkOwEpynfv2flDqlZkyt37+fye7ZotiyKsSmQzFplYZ4UFg7YsFlxmeaG0hRo0ptBAqlUOAaEBl1zGShqHCowtJjB30EOwDB5voipsRj+d9skl0CyLVzuDYCsxmEB1ECVStQygmfzS9xc10ld/9ZPG8YQ1EVx+0e7RtI1BAaiwmBfiYNFVNkqyarHrLM+grm/+myaaOtUtAojaPlRPuUpQzDnrQc4IAfqiNh0hqdIEdGUm+9icwcy7G8TQl8MESlN3cOhSkYdu9LTteo7i+K2piKZDGjZh1tApp9kxPBsl6fZqR3MWq7zIBOpt74JytmM5OwihLq++Z3WJ/kT9mhPG3//0z+bqepy9azSoK/I+aPagj2hbebN7I/8jkU6tFETfET/QKFE6jy22KmVCtkecd/vi32Amj3uzuVqUpg/ljDqyfRec0btc34l+s/scPvt1XDas+QENov3B"
      },
      {
        "text": "Try it in the Playground",
        "href": "https://play.vuejs.org/#eNp9ksFuwjAMhl/FyoVNYuWwG+omAeKwHcY0uC07VK2BspBUiVuQKt59Tkq6Hjakqortz87/J2nFrKqSpkYxFanLbVnRs9R4rowlKHCb1YqglRqgyCi7u+/WABaptjpGAA4V5oTFFEaz0ThmTUWl0W4KnzED0ALhmZhbaRyNoclUjaELLn3fgNqczICa/0ftLQ6nLZiL2Fe3CDH/+EsnvVMOCI+Vygh9RGlRNs/r3kzb9s7gckknvuqbANIuD83D0RSonqSIoBSM+B3Tzj4jW2MZuIaljuciBUyD4r6YhLCfwA7bK5x4p6zhOnrSZQPHdsLWHKST3o0YC3K50dtylxyc0XzB4bakyM2xKhXaVVTBPruxUmRKmdNryJGt8XrW3LPH/PuP/MGdfU6Kd4sObcPa+xpldofUlZfrN9Y/KPKp1YrpG8UPdEbVXmOHzWtdsOwBF9S+HP1jLfVu45ZnQu2iKS80XHrgpeBXvrhh/VfuY/IYH4u4/AD+8ADR"
      },
      {
        "text": "DOM property valueAsNumber",
        "href": "https://developer.mozilla.org/en-US/docs/Web/API/HTMLInputElement#valueasnumber"
      },
      {
        "text": "Usage with v-model",
        "href": "/guide/components/v-model"
      },
      {
        "text": "Edit this page on GitHub",
        "href": "https://github.com/vuejs/docs/edit/main/src/guide/essentials/forms.md"
      }
    ],
    "meta": {
      "description": "Vue.js - The Progressive JavaScript Framework",
      "keywords": ""
    },
    "summary": "Form Input Bindings Watch a free video lesson on Vue SchoolWatch a free video lesson on Vue SchoolWhen dealing with forms on the frontend, we often need to sync the state of form input elements with c...",
    "tags": [
      "react",
      "vue",
      "angular",
      "javascript",
      "typescript",
      "css",
      "html",
      "vite",
      "bindings",
      "form"
    ],
    "id": "form-input-bindings-formshtml-part-1",
    "quality": 100
  },
  {
    "title": "Composition API FAQ",
    "url": "https://vuejs.org/guide/extras/composition-api-faq.html",
    "category": "vue",
    "content": "Composition API FAQ TIPThis FAQ assumes prior experience with Vue - in particular, experience with Vue 2 while primarily using Options API.What is Composition API? Watch a free video lesson on Vue SchoolComposition API is a set of APIs that allows us to author Vue components using imported functions instead of declaring options. It is an umbrella term that covers the following APIs:Reactivity API, e.g. ref() and reactive(), that allows us to directly create reactive state, computed state, and watchers.Lifecycle Hooks, e.g. onMounted() and onUnmounted(), that allow us to programmatically hook into the component lifecycle.Dependency Injection, i.e. provide() and inject(), that allow us to leverage Vue's dependency injection system while using Reactivity APIs.Composition API is a built-in feature of Vue 3 and Vue 2.7. For older Vue 2 versions, use the officially maintained @vue/composition-api plugin. In Vue 3, it is also primarily used together with the script setup syntax in Single-File Components. Here's a basic example of a component using Composition API:vuescript setup import { ref, onMounted } from 'vue' // reactive state const count = ref(0) // functions that mutate state and trigger updates function increment() { count.value++ } // lifecycle hooks onMounted(() = { console.log(The initial count is ${count.value}.) }) /script template button @click=\"increment\"Count is: {{ count }}/button /templateDespite an API style based on function composition, Composition API is NOT functional programming. Composition API is based on Vue's mutable, fine-grained reactivity paradigm, whereas functional programming emphasizes immutability.If you are interested in learning how to use Vue with Composition API, you can set the site-wide API preference to Composition API using the toggle at the top of the left sidebar, and then go through the guide from the beginning.Why Composition API? Better Logic Reuse The primary advantage of Composition API is that it enables clean, efficient logic reuse in the form of Composable functions. It solves all the drawbacks of mixins, the primary logic reuse mechanism for Options API.Composition API's logic reuse capability has given rise to impressive community projects such as VueUse, an ever-growing collection of composable utilities. It also serves as a clean mechanism for easily integrating stateful third-party services or libraries into Vue's reactivity system, for example immutable data, state machines, and RxJS.More Flexible Code Organization Many users love that we write organized code by default with Options API: everything has its place based on the option it falls under. However, Options API poses serious limitations when a single component's logic grows beyond a certain complexity threshold. This limitation is particularly prominent in components that need to deal with multiple logical concerns, which we have witnessed first hand in many production Vue 2 apps.Take the folder explorer component from Vue CLI's GUI as an example: this component is responsible for the following logical concerns:Tracking current folder state and displaying its contentHandling folder navigation (opening, closing, refreshing...)Handling new folder creationToggling show favorite folders onlyToggling show hidden foldersHandling current working directory changesThe original version of the component was written in Options API. If we give each line of code a color based on the logical concern it is dealing with, this is how it looks:Notice how code dealing with the same logical concern is forced to be split under different options, located in different parts of the file. In a component that is several hundred lines long, understanding and navigating a single logical concern requires constantly scrolling up and down the file, making it much more difficult than it should be. In addition, if we ever intend to extract a logical concern into a reusable utility, it takes quite a bit of work to find and extract the right pieces of code from different parts of the file.Here's the same component, before and after the refactor into Composition API:Notice how the code related to the same logical concern can now be grouped together: we no longer need to jump between different options blocks while working on a specific logical concern. Moreover, we can now move a group of code into an external file with minimal effort, since we no longer need to shuffle the code around in order to extract them. This reduced friction for refactoring is key to the long-term maintainability in large codebases.Better Type Inference In recent years, more and more frontend developers are adopting TypeScript as it helps us write more robust code, make changes with more confidence, and provides a great development experience with IDE support. However, the Options API, originally conceived in 2013, was designed without type inference in mind. We had to implement some absurdly complex type gymnastics to make type inference work with the Options API. Even with all this effort, type inference for Options API can still break down for mixins and dependency injection.This had led many developers who wanted to use Vue with TS to lean towards Class API powered by vue-class-component. However, a class-based API heavily relies on ES decorators, a language feature that was only a stage 2 proposal when Vue 3 was being developed in 2019. We felt it was too risky to base an official API on an unstable proposal. Since then, the decorators proposal has gone through yet another complete overhaul, and finally reached stage 3 in 2022. In addition, class-based API suffers from logic reuse and organization limitations similar to Options API.In comparison, Composition API utilizes mostly plain variables and functions, which are naturally type friendly. Code written in Composition API can enjoy full type inference with little need for manual type hints. Most of the time, Composition API code will look largely identical in TypeScript and plain JavaScript. This also makes it possible for plain JavaScript users to benefit from partial type inference.Smaller Production Bundle and Less Overhead Code written in Composition API and script setup is also more efficient and minification-friendly than Options API equivalent. This is because the template in a script setup component is compiled as a function inlined in the same scope of the script setup code. Unlike property access from this, the compiled template code can directly access variables declared inside script setup, without an instance proxy in between. This also leads to better minification because all the variable names can be safely shortened.Relationship with Options API Trade-offs Some users moving from Options API found their Composition API code less organized, and concluded that Composition API is \"worse\" in terms of code organization. We recommend users with such opinions to look at that problem from a different perspective.It is true that Composition API no longer provides the \"guard rails\" that guide you to put your code into respective buckets. In return, you get to author component code like how you would write normal JavaScript. This means you can and should apply any code organization best practices to your Composition API code as you would when writing normal JavaScript. If you can write well-organized JavaScript, you should also be able to write well-organized Composition API code.Options API does allow you to \"think less\" when writing component code, which is why many users love it. However, in reducing the mental overhead, it also locks you into the prescribed code organization pattern with no escape hatch, which can make it difficult to refactor or improve code quality in larger scale projects. In this regard, Composition API provides better long term scalability.Does Composition API cover all use cases? Yes in terms of stateful logic. When using Composition API, there are only a few options that may still be needed: props, emits, name, and inheritAttrs.TIPSince 3.3 you can directly use defineOptions in script setup to set the component name or inheritAttrs propertyIf you intend to exclusively use Composition API (along with the options listed above), you can shave a few kbs off your production bundle via a compile-time flag that drops Options API related code from Vue. Note this also affects Vue components in your dependencies.Can I use both APIs in the same component? Yes. You can use Composition API via the setup() option in an Options API component.However, we only recommend doing so if you have an existing Options API codebase that needs to integrate with new features / external libraries written with Composition API.Will Options API be deprecated? No, we do not have any plan to do so. Options API is an integral part of Vue and the reason many developers love it. We also realize that many of the benefits of Composition API only manifest in larger-scale projects, and Options API remains a solid choice for many low-to-medium-complexity scenarios.Relationship with Class API We no longer recommend using Class API with Vue 3, given that Composition API provides great TypeScript integration with additional logic reuse and code organization benefits.Comparison with React Hooks Composition API provides the same level of logic composition capabilities as React Hooks, but with some important differences.React Hooks are invoked repeatedly every time a component updates. This creates a number of caveats that can confuse even seasoned React developers. It also leads to performance optimization issues that can severely affect development experience. Here are some examples:Hooks are call-order sensitive and cannot be conditional.Variables declared in a React component can be captured by a hook closure and become \"stale\" if the developer fails to pass in the correct dependencies array. This leads to React developers relying on ESLint rules to ensure correct dependencies are passed. However, the rule is often not smart enough and over-compensates for correctness, which leads to unnecessary invalidation and headaches when edge cases are encountered.Expensive computations require the use of useMemo, which again requires manually passing in the correct dependencies array.Event handlers passed to child components cause unnecessary child updates by default, and require explicit useCallback as an optimization. This is almost always needed, and again requires a correct dependencies array. Neglecting this leads to over-rendering apps by default and can cause performance issues without realizing it.The stale closure problem, combined with Concurrent features, makes it difficult to reason about when a piece of hooks code is run, and makes working with mutable state that should persist across renders (via useRef) cumbersome.Note: some of the above issues that are related to memoization can be resolved by the upcoming React Compiler.In comparison, Vue Composition API:Invokes setup() or script setup code only once. This makes the code align better with the intuitions of idiomatic JavaScript usage as there are no stale closures to worry about. Composition API calls are also not sensitive to call order and can be conditional.Vue's runtime reactivity system automatically collects reactive dependencies used in computed properties and watchers, so there's no need to manually declare dependencies.No need to manually cache callback functions to avoid unnecessary child updates. In general, Vue's fine-grained reactivity system ensures child components only update when they need to. Manual child-update optimizations are rarely a concern for Vue developers.We acknowledge the creativity of React Hooks, and it is a major source of inspiration for Composition API. However, the issues mentioned above do exist in its design and we noticed Vue's reactivity model happens to provide a way around them.Edit this page on GitHub",
    "headings": [
      {
        "level": 1,
        "text": "Composition API FAQ ​",
        "id": "composition-api-faq"
      },
      {
        "level": 2,
        "text": "What is Composition API? ​",
        "id": "what-is-composition-api"
      },
      {
        "level": 2,
        "text": "Why Composition API? ​",
        "id": "why-composition-api"
      },
      {
        "level": 2,
        "text": "Relationship with Options API ​",
        "id": "relationship-with-options-api"
      },
      {
        "level": 2,
        "text": "Relationship with Class API ​",
        "id": "relationship-with-class-api"
      },
      {
        "level": 2,
        "text": "Comparison with React Hooks ​",
        "id": "comparison-with-react-hooks"
      },
      {
        "level": 3,
        "text": "Better Logic Reuse ​",
        "id": "better-logic-reuse"
      },
      {
        "level": 3,
        "text": "More Flexible Code Organization ​",
        "id": "more-flexible-code-organization"
      },
      {
        "level": 3,
        "text": "Better Type Inference ​",
        "id": "better-type-inference"
      },
      {
        "level": 3,
        "text": "Smaller Production Bundle and Less Overhead ​",
        "id": "smaller-production-bundle-and-less-overhead"
      },
      {
        "level": 3,
        "text": "Trade-offs ​",
        "id": "trade-offs"
      },
      {
        "level": 3,
        "text": "Does Composition API cover all use cases? ​",
        "id": "does-composition-api-cover-all-use-cases"
      },
      {
        "level": 3,
        "text": "Can I use both APIs in the same component? ​",
        "id": "can-i-use-both-apis-in-the-same-component"
      },
      {
        "level": 3,
        "text": "Will Options API be deprecated? ​",
        "id": "will-options-api-be-deprecated"
      }
    ],
    "codeBlocks": [
      {
        "language": "text",
        "code": "onMounted()"
      },
      {
        "language": "text",
        "code": "onUnmounted()"
      },
      {
        "language": "text",
        "code": "@vue/composition-api"
      },
      {
        "language": "text",
        "code": "<script setup>"
      },
      {
        "language": "text",
        "code": "<script setup>\nimport { ref, onMounted } from 'vue'\n\n// reactive state\nconst count = ref(0)\n\n// functions that mutate state and trigger updates\nfunction increment() {\n  count.value++\n}\n\n// lifecycle hooks\nonMounted(() => {\n  console.log(`The initial count is ${count.value}.`)\n})\n</script>\n\n<template>\n  <button @click=\"increment\">Count is: {{ count }}</button>\n</template>"
      },
      {
        "language": "text",
        "code": "<script setup>\nimport { ref, onMounted } from 'vue'\n\n// reactive state\nconst count = ref(0)\n\n// functions that mutate state and trigger updates\nfunction increment() {\n  count.value++\n}\n\n// lifecycle hooks\nonMounted(() => {\n  console.log(`The initial count is ${count.value}.`)\n})\n</script>\n\n<template>\n  <button @click=\"increment\">Count is: {{ count }}</button>\n</template>"
      },
      {
        "language": "text",
        "code": "vue-class-component"
      },
      {
        "language": "text",
        "code": "<script setup>"
      },
      {
        "language": "text",
        "code": "<script setup>"
      },
      {
        "language": "text",
        "code": "<script setup>"
      },
      {
        "language": "text",
        "code": "<script setup>"
      },
      {
        "language": "text",
        "code": "inheritAttrs"
      },
      {
        "language": "text",
        "code": "defineOptions"
      },
      {
        "language": "text",
        "code": "<script setup>"
      },
      {
        "language": "text",
        "code": "inheritAttrs"
      },
      {
        "language": "text",
        "code": "useCallback"
      },
      {
        "language": "text",
        "code": "<script setup>"
      }
    ],
    "links": [
      {
        "text": "Watch a free video lesson on Vue School",
        "href": "https://vueschool.io/lessons/introduction-to-the-vue-js-3-composition-api?friend=vuejs"
      },
      {
        "text": "Reactivity API",
        "href": "/api/reactivity-core"
      },
      {
        "text": "Lifecycle Hooks",
        "href": "/api/composition-api-lifecycle"
      },
      {
        "text": "Dependency Injection",
        "href": "/api/composition-api-dependency-injection"
      },
      {
        "text": "Vue 2.7",
        "href": "https://blog.vuejs.org/posts/vue-2-7-naruto.html"
      },
      {
        "text": "@vue/composition-api",
        "href": "https://github.com/vuejs/composition-api"
      },
      {
        "text": "<script setup>",
        "href": "/api/sfc-script-setup"
      },
      {
        "text": "Composable functions",
        "href": "/guide/reusability/composables"
      },
      {
        "text": "all the drawbacks of mixins",
        "href": "/guide/reusability/composables#vs-mixins"
      },
      {
        "text": "VueUse",
        "href": "https://vueuse.org/"
      },
      {
        "text": "immutable data",
        "href": "/guide/extras/reactivity-in-depth#immutable-data"
      },
      {
        "text": "state machines",
        "href": "/guide/extras/reactivity-in-depth#state-machines"
      },
      {
        "text": "RxJS",
        "href": "/guide/extras/reactivity-in-depth#rxjs"
      },
      {
        "text": "original version",
        "href": "https://github.com/vuejs/vue-cli/blob/a09407dd5b9f18ace7501ddb603b95e31d6d93c0/packages/@vue/cli-ui/src/components/folder/FolderExplorer.vue#L198-L404"
      },
      {
        "text": "refactor into Composition API",
        "href": "https://gist.github.com/yyx990803/8854f8f6a97631576c14b63c8acd8f2e"
      },
      {
        "text": "TypeScript",
        "href": "https://www.typescriptlang.org/"
      },
      {
        "text": "absurdly complex type gymnastics",
        "href": "https://github.com/vuejs/core/blob/44b95276f5c086e1d88fa3c686a5f39eb5bb7821/packages/runtime-core/src/componentPublicInstance.ts#L132-L165"
      },
      {
        "text": "compile-time flag",
        "href": "/api/compile-time-flags"
      },
      {
        "text": "setup()",
        "href": "/api/composition-api-setup"
      },
      {
        "text": "React Compiler",
        "href": "https://react.dev/learn/react-compiler"
      },
      {
        "text": "Edit this page on GitHub",
        "href": "https://github.com/vuejs/docs/edit/main/src/guide/extras/composition-api-faq.md"
      }
    ],
    "meta": {
      "description": "Vue.js - The Progressive JavaScript Framework",
      "keywords": ""
    },
    "summary": "Composition API FAQ TIPThis FAQ assumes prior experience with Vue - in particular, experience with Vue 2 while primarily using Options API. What is Composition API",
    "tags": [
      "react",
      "vue",
      "angular",
      "javascript",
      "typescript",
      "css",
      "html",
      "webpack",
      "vite",
      "api"
    ],
    "id": "composition-api-faq-compositionapifaqhtml-part-1",
    "quality": 100
  },
  {
    "title": "Composition API: setup()",
    "url": "https://vuejs.org/api/composition-api-setup.html",
    "category": "vue",
    "content": "Composition API: setup() Basic Usage The setup() hook serves as the entry point for Composition API usage in components in the following cases:Using Composition API without a build step;Integrating with Composition-API-based code in an Options API component.NoteIf you are using Composition API with Single-File Components, script setup is strongly recommended for a more succinct and ergonomic syntax.We can declare reactive state using Reactivity APIs and expose them to the template by returning an object from setup(). The properties on the returned object will also be made available on the component instance (if other options are used):vuescript import { ref } from 'vue' export default { setup() { const count = ref(0) // expose to template and other options API hooks return { count } }, mounted() { console.log(this.count) // 0 } } /script template button @click=\"count++\"{{ count }}/button /templaterefs returned from setup are automatically shallow unwrapped when accessed in the template so you do not need to use .value when accessing them. They are also unwrapped in the same way when accessed on this.setup() itself does not have access to the component instance - this will have a value of undefined inside setup(). You can access Composition-API-exposed values from Options API, but not the other way around.setup() should return an object synchronously. The only case when async setup() can be used is when the component is a descendant of a Suspense component.Accessing Props The first argument in the setup function is the props argument. Just as you would expect in a standard component, props inside of a setup function are reactive and will be updated when new props are passed in.jsexport default { props: { title: String }, setup(props) { console.log(props.title) } }Note that if you destructure the props object, the destructured variables will lose reactivity. It is therefore recommended to always access props in the form of props.xxx.If you really need to destructure the props, or need to pass a prop into an external function while retaining reactivity, you can do so with the toRefs() and toRef() utility APIs:jsimport { toRefs, toRef } from 'vue' export default { setup(props) { // turn props into an object of refs, then destructure const { title } = toRefs(props) // title is a ref that tracks props.title console.log(title.value) // OR, turn a single property on props into a ref const title = toRef(props, 'title') } }Setup Context The second argument passed to the setup function is a Setup Context object. The context object exposes other values that may be useful inside setup:jsexport default { setup(props, context) { // Attributes (Non-reactive object, equivalent to $attrs) console.log(context.attrs) // Slots (Non-reactive object, equivalent to $slots) console.log(context.slots) // Emit events (Function, equivalent to $emit) console.log(context.emit) // Expose public properties (Function) console.log(context.expose) } }The context object is not reactive and can be safely destructured:jsexport default { setup(props, { attrs, slots, emit, expose }) { ... } }attrs and slots are stateful objects that are always updated when the component itself is updated. This means you should avoid destructuring them and always reference properties as attrs.x or slots.x. Also note that, unlike props, the properties of attrs and slots are not reactive. If you intend to apply side effects based on changes to attrs or slots, you should do so inside an onBeforeUpdate lifecycle hook.Exposing Public Properties expose is a function that can be used to explicitly limit the properties exposed when the component instance is accessed by a parent component via template refs:jsexport default { setup(props, { expose }) { // make the instance \"closed\" - // i.e. do not expose anything to the parent expose() const publicCount = ref(0) const privateCount = ref(0) // selectively expose local state expose({ count: publicCount }) } }Usage with Render Functions setup can also return a render function which can directly make use of the reactive state declared in the same scope:jsimport { h, ref } from 'vue' export default { setup() { const count = ref(0) return () = h('div', count.value) } }Returning a render function prevents us from returning anything else. Internally that shouldn't be a problem, but it can be problematic if we want to expose methods of this component to the parent component via template refs.We can solve this problem by calling expose():jsimport { h, ref } from 'vue' export default { setup(props, { expose }) { const count = ref(0) const increment = () = ++count.value expose({ increment }) return () = h('div', count.value) } }The increment method would then be available in the parent component via a template ref.Edit this page on GitHub",
    "headings": [
      {
        "level": 1,
        "text": "Composition API: setup() ​",
        "id": "composition-api-setup"
      },
      {
        "level": 2,
        "text": "Basic Usage ​",
        "id": "basic-usage"
      },
      {
        "level": 2,
        "text": "Accessing Props ​",
        "id": "accessing-props"
      },
      {
        "level": 2,
        "text": "Setup Context ​",
        "id": "setup-context"
      },
      {
        "level": 2,
        "text": "Usage with Render Functions ​",
        "id": "usage-with-render-functions"
      },
      {
        "level": 3,
        "text": "Exposing Public Properties ​",
        "id": "exposing-public-properties"
      }
    ],
    "codeBlocks": [
      {
        "language": "text",
        "code": "<script setup>"
      },
      {
        "language": "text",
        "code": "<script>\nimport { ref } from 'vue'\n\nexport default {\n  setup() {\n    const count = ref(0)\n\n    // expose to template and other options API hooks\n    return {\n      count\n    }\n  },\n\n  mounted() {\n    console.log(this.count) // 0\n  }\n}\n</script>\n\n<template>\n  <button @click=\"count++\">{{ count }}</button>\n</template>"
      },
      {
        "language": "text",
        "code": "<script>\nimport { ref } from 'vue'\n\nexport default {\n  setup() {\n    const count = ref(0)\n\n    // expose to template and other options API hooks\n    return {\n      count\n    }\n  },\n\n  mounted() {\n    console.log(this.count) // 0\n  }\n}\n</script>\n\n<template>\n  <button @click=\"count++\">{{ count }}</button>\n</template>"
      },
      {
        "language": "text",
        "code": "async setup()"
      },
      {
        "language": "text",
        "code": "export default {\n  props: {\n    title: String\n  },\n  setup(props) {\n    console.log(props.title)\n  }\n}"
      },
      {
        "language": "text",
        "code": "export default {\n  props: {\n    title: String\n  },\n  setup(props) {\n    console.log(props.title)\n  }\n}"
      },
      {
        "language": "text",
        "code": "import { toRefs, toRef } from 'vue'\n\nexport default {\n  setup(props) {\n    // turn `props` into an object of refs, then destructure\n    const { title } = toRefs(props)\n    // `title` is a ref that tracks `props.title`\n    console.log(title.value)\n\n    // OR, turn a single property on `props` into a ref\n    const title = toRef(props, 'title')\n  }\n}"
      },
      {
        "language": "text",
        "code": "import { toRefs, toRef } from 'vue'\n\nexport default {\n  setup(props) {\n    // turn `props` into an object of refs, then destructure\n    const { title } = toRefs(props)\n    // `title` is a ref that tracks `props.title`\n    console.log(title.value)\n\n    // OR, turn a single property on `props` into a ref\n    const title = toRef(props, 'title')\n  }\n}"
      },
      {
        "language": "text",
        "code": "export default {\n  setup(props, context) {\n    // Attributes (Non-reactive object, equivalent to $attrs)\n    console.log(context.attrs)\n\n    // Slots (Non-reactive object, equivalent to $slots)\n    console.log(context.slots)\n\n    // Emit events (Function, equivalent to $emit)\n    console.log(context.emit)\n\n    // Expose public properties (Function)\n    console.log(context.expose)\n  }\n}"
      },
      {
        "language": "text",
        "code": "export default {\n  setup(props, context) {\n    // Attributes (Non-reactive object, equivalent to $attrs)\n    console.log(context.attrs)\n\n    // Slots (Non-reactive object, equivalent to $slots)\n    console.log(context.slots)\n\n    // Emit events (Function, equivalent to $emit)\n    console.log(context.emit)\n\n    // Expose public properties (Function)\n    console.log(context.expose)\n  }\n}"
      },
      {
        "language": "text",
        "code": "export default {\n  setup(props, { attrs, slots, emit, expose }) {\n    ...\n  }\n}"
      },
      {
        "language": "text",
        "code": "export default {\n  setup(props, { attrs, slots, emit, expose }) {\n    ...\n  }\n}"
      },
      {
        "language": "text",
        "code": "onBeforeUpdate"
      },
      {
        "language": "text",
        "code": "export default {\n  setup(props, { expose }) {\n    // make the instance \"closed\" -\n    // i.e. do not expose anything to the parent\n    expose()\n\n    const publicCount = ref(0)\n    const privateCount = ref(0)\n    // selectively expose local state\n    expose({ count: publicCount })\n  }\n}"
      },
      {
        "language": "text",
        "code": "export default {\n  setup(props, { expose }) {\n    // make the instance \"closed\" -\n    // i.e. do not expose anything to the parent\n    expose()\n\n    const publicCount = ref(0)\n    const privateCount = ref(0)\n    // selectively expose local state\n    expose({ count: publicCount })\n  }\n}"
      },
      {
        "language": "text",
        "code": "import { h, ref } from 'vue'\n\nexport default {\n  setup() {\n    const count = ref(0)\n    return () => h('div', count.value)\n  }\n}"
      },
      {
        "language": "text",
        "code": "import { h, ref } from 'vue'\n\nexport default {\n  setup() {\n    const count = ref(0)\n    return () => h('div', count.value)\n  }\n}"
      },
      {
        "language": "text",
        "code": "import { h, ref } from 'vue'\n\nexport default {\n  setup(props, { expose }) {\n    const count = ref(0)\n    const increment = () => ++count.value\n\n    expose({\n      increment\n    })\n\n    return () => h('div', count.value)\n  }\n}"
      },
      {
        "language": "text",
        "code": "import { h, ref } from 'vue'\n\nexport default {\n  setup(props, { expose }) {\n    const count = ref(0)\n    const increment = () => ++count.value\n\n    expose({\n      increment\n    })\n\n    return () => h('div', count.value)\n  }\n}"
      }
    ],
    "links": [
      {
        "text": "<script setup>",
        "href": "/api/sfc-script-setup"
      },
      {
        "text": "Reactivity APIs",
        "href": "/api/reactivity-core"
      },
      {
        "text": "refs",
        "href": "/api/reactivity-core#ref"
      },
      {
        "text": "automatically shallow unwrapped",
        "href": "/guide/essentials/reactivity-fundamentals#deep-reactivity"
      },
      {
        "text": "Suspense",
        "href": "/guide/built-ins/suspense"
      },
      {
        "text": "toRefs()",
        "href": "/api/reactivity-utilities#torefs"
      },
      {
        "text": "toRef()",
        "href": "/api/reactivity-utilities#toref"
      },
      {
        "text": "template refs",
        "href": "/guide/essentials/template-refs#ref-on-component"
      },
      {
        "text": "render function",
        "href": "/guide/extras/render-function"
      },
      {
        "text": "Edit this page on GitHub",
        "href": "https://github.com/vuejs/docs/edit/main/src/api/composition-api-setup.md"
      }
    ],
    "meta": {
      "description": "Vue.js - The Progressive JavaScript Framework",
      "keywords": ""
    },
    "summary": "Composition API: setup() Basic Usage The setup() hook serves as the entry point for Composition API usage in components in the following cases:Using Composition API without a build step;Integrating wi...",
    "tags": [
      "react",
      "vue",
      "angular",
      "javascript",
      "typescript",
      "html",
      "vite",
      "setup",
      "composition",
      "api"
    ],
    "id": "composition-api-setup-compositionapisetuphtml-part-1",
    "quality": 100
  },
  {
    "title": "Reactivity API: Core",
    "url": "https://vuejs.org/api/reactivity-core.html",
    "category": "vue",
    "content": "Reactivity API: Core See alsoTo better understand the Reactivity APIs, it is recommended to read the following chapters in the guide:Reactivity Fundamentals (with the API preference set to Composition API)Reactivity in Depthref() Takes an inner value and returns a reactive and mutable ref object, which has a single property .value that points to the inner value.Typetsfunction refT(value: T): RefUnwrapRefT interface RefT { value: T }DetailsThe ref object is mutable - i.e. you can assign new values to .value. It is also reactive - i.e. any read operations to .value are tracked, and write operations will trigger associated effects.If an object is assigned as a ref's value, the object is made deeply reactive with reactive(). This also means if the object contains nested refs, they will be deeply unwrapped.To avoid the deep conversion, use shallowRef() instead.Examplejsconst count = ref(0) console.log(count.value) // 0 count.value = 1 console.log(count.value) // 1See alsoGuide - Reactivity Fundamentals with ref()Guide - Typing ref() computed() Takes a getter function and returns a readonly reactive ref object for the returned value from the getter. It can also take an object with get and set functions to create a writable ref object.Typets// read-only function computedT( getter: (oldValue: T  undefined) = T, // see \"Computed Debugging\" link below debuggerOptions?: DebuggerOptions ): ReadonlyRefReadonlyT // writable function computedT( options: { get: (oldValue: T  undefined) = T set: (value: T) = void }, debuggerOptions?: DebuggerOptions ): RefTExampleCreating a readonly computed ref:jsconst count = ref(1) const plusOne = computed(() = count.value + 1) console.log(plusOne.value) // 2 plusOne.value++ // errorCreating a writable computed ref:jsconst count = ref(1) const plusOne = computed({ get: () = count.value + 1, set: (val) = { count.value = val - 1 } }) plusOne.value = 1 console.log(count.value) // 0Debugging:jsconst plusOne = computed(() = count.value + 1, { onTrack(e) { debugger }, onTrigger(e) { debugger } })See alsoGuide - Computed PropertiesGuide - Computed DebuggingGuide - Typing computed() Guide - Performance - Computed Stabilityreactive() Returns a reactive proxy of the object.Typetsfunction reactiveT extends object(target: T): UnwrapNestedRefsTDetailsThe reactive conversion is \"deep\": it affects all nested properties. A reactive object also deeply unwraps any properties that are refs while maintaining reactivity.It should also be noted that there is no ref unwrapping performed when the ref is accessed as an element of a reactive array or a native collection type like Map.To avoid the deep conversion and only retain reactivity at the root level, use shallowReactive() instead.The returned object and its nested objects are wrapped with ES Proxy and not equal to the original objects. It is recommended to work exclusively with the reactive proxy and avoid relying on the original object.ExampleCreating a reactive object:jsconst obj = reactive({ count: 0 }) obj.count++Ref unwrapping:tsconst count = ref(1) const obj = reactive({ count }) // ref will be unwrapped console.log(obj.count === count.value) // true // it will update obj.count count.value++ console.log(count.value) // 2 console.log(obj.count) // 2 // it will also update count ref obj.count++ console.log(obj.count) // 3 console.log(count.value) // 3Note that refs are not unwrapped when accessed as array or collection elements:jsconst books = reactive([ref('Vue 3 Guide')]) // need .value here console.log(books[0].value) const map = reactive(new Map([['count', ref(0)]])) // need .value here console.log(map.get('count').value)When assigning a ref to a reactive property, that ref will also be automatically unwrapped:tsconst count = ref(1) const obj = reactive({}) obj.count = count console.log(obj.count) // 1 console.log(obj.count === count.value) // trueSee alsoGuide - Reactivity FundamentalsGuide - Typing reactive() readonly() Takes an object (reactive or plain) or a ref and returns a readonly proxy to the original.Typetsfunction readonlyT extends object( target: T ): DeepReadonlyUnwrapNestedRefsTDetailsA readonly proxy is deep: any nested property accessed will be readonly as well. It also has the same ref-unwrapping behavior as reactive(), except the unwrapped values will also be made readonly.To avoid the deep conversion, use shallowReadonly() instead.Examplejsconst original = reactive({ count: 0 }) const copy = readonly(original) watchEffect(() = { // works for reactivity tracking console.log(copy.count) }) // mutating original will trigger watchers relying on the copy original.count++ // mutating the copy will fail and result in a warning copy.count++ // warning!watchEffect() Runs a function immediately while reactively tracking its dependencies and re-runs it whenever the dependencies are changed.Typetsfunction watchEffect( effect: (onCleanup: OnCleanup) = void, options?: WatchEffectOptions ): WatchHandle type OnCleanup = (cleanupFn: () = void) = void interface WatchEffectOptions { flush?: 'pre'  'post'  'sync' // default: 'pre' onTrack?: (event: DebuggerEvent) = void onTrigger?: (event: DebuggerEvent) = void } interface WatchHandle { (): void // callable, same as stop pause: () = void resume: () = void stop: () = void }DetailsThe first argument is the effect function to be run. The effect function receives a function that can be used to register a cleanup callback. The cleanup callback will be called right before the next time the effect is re-run, and can be used to clean up invalidated side effects, e.g. a pending async request (see example below).The second argument is an optional options object that can be used to adjust the effect's flush timing or to debug the effect's dependencies.By default, watchers will run just prior to component rendering. Setting flush: 'post' will defer the watcher until after component rendering. See Callback Flush Timing for more information. In rare cases, it might be necessary to trigger a watcher immediately when a reactive dependency changes, e.g. to invalidate a cache. This can be achieved using flush: 'sync'. However, this setting should be used with caution, as it can lead to problems with performance and data consistency if multiple properties are being updated at the same time.The return value is a handle function that can be called to stop the effect from running again.Examplejsconst count = ref(0) watchEffect(() = console.log(count.value)) // - logs 0 count.value++ // - logs 1Stopping the watcher:jsconst stop = watchEffect(() = {}) // when the watcher is no longer needed: stop()Pausing / resuming the watcher: jsconst { stop, pause, resume } = watchEffect(() = {}) // temporarily pause the watcher pause() // resume later resume() // stop stop()Side effect cleanup:jswatchEffect(async (onCleanup) = { const { response, cancel } = doAsyncWork(newId) // cancel will be called if id changes, cancelling // the previous request if it hasn't completed yet onCleanup(cancel) data.value = await response })Side effect cleanup in 3.5+:jsimport { onWatcherCleanup } from 'vue' watchEffect(async () = { const { response, cancel } = doAsyncWork(newId) // cancel will be called if id changes, cancelling // the previous request if it hasn't completed yet onWatcherCleanup(cancel) data.value = await response })Options:jswatchEffect(() = {}, { flush: 'post', onTrack(e) { debugger }, onTrigger(e) { debugger } })See alsoGuide - WatchersGuide - Watcher DebuggingwatchPostEffect() Alias of watchEffect() with flush: 'post' option.watchSyncEffect() Alias of watchEffect() with flush: 'sync' option.watch() Watches one or more reactive data sources and invokes a callback function when the sources change.Typets// watching single source function watchT( source: WatchSourceT, callback: WatchCallbackT, options?: WatchOptions ): WatchHandle // watching multiple sources function watchT( sources: WatchSourceT[], callback: WatchCallbackT[], options?: WatchOptions ): WatchHandle type WatchCallbackT = ( value: T, oldValue: T, onCleanup: (cleanupFn: () = void) = void ) = void type WatchSourceT =  RefT // ref  (() = T) // getter  (T extends object ? T : never) // reactive object interface WatchOptions extends WatchEffectOptions { immediate?: boolean // default: false deep?: boolean  number // default: false flush?: 'pre'  'post'  'sync' // default: 'pre' onTrack?: (event: DebuggerEvent) = void onTrigger?: (event: DebuggerEvent) = void once?: boolean // default: false (3.4+) } interface WatchHandle { (): void // callable, same as stop pause: () = void resume: () = void stop: () = void }Types are simplified for readability.Detailswatch() is lazy by default - i.e. the callback is only called when the watched source has changed.The first argument is the watcher's source. The source can be one of the following:A getter function that returns a valueA refA reactive object...or an array of the above.The second argument is the callback that will be called when the source changes. The callback receives three arguments: the new value, the old value, and a function for registering a side effect cleanup callback. The cleanup callback will be called right before the next time the effect is re-run, and can be used to clean up invalidated side effects, e.g. a pending async request.When watching multiple sources, the callback receives two arrays containing new / old values corresponding to the source array.The third optional argument is an options object that supports the following options:immediate: trigger the callback immediately on watcher creation. Old value will be undefined on the first call.deep: force deep traversal of the source if it is an object, so that the callback fires on deep mutations. In 3.5+, this can also be a number indicating the max traversal depth. See Deep Watchers.flush: adjust the callback's flush timing. See Callback Flush Timing and watchEffect().onTrack / onTrigger: debug the watcher's dependencies. See Watcher Debugging.once: (3.4+) run the callback only once. The watcher is automatically stopped after the first callback run.Compared to watchEffect(), watch() allows us to:Perform the side effect lazily;Be more specific about what state should trigger the watcher to re-run;Access both the previous and current value of the watched state.ExampleWatching a getter:jsconst state = reactive({ count: 0 }) watch( () = state.count, (count, prevCount) = { /* ... */ } )Watching a ref:jsconst count = ref(0) watch(count, (count, prevCount) = { /* ... */ })When watching multiple sources, the callback receives arrays containing new / old values corresponding to the source array:jswatch([fooRef, barRef], ([foo, bar], [prevFoo, prevBar]) = { /* ... */ })When using a getter source, the watcher only fires if the getter's return value has changed. If you want the callback to fire even on deep mutations, you need to explicitly force the watcher into deep mode with { deep: true }. Note in deep mode, the new value and the old will be the same object if the callback was triggered by a deep mutation:jsconst state = reactive({ count: 0 }) watch( () = state, (newValue, oldValue) = { // newValue === oldValue }, { deep: true } )When directly watching a reactive object, the watcher is automatically in deep mode:jsconst state = reactive({ count: 0 }) watch(state, () = { /* triggers on deep mutation to state */ })watch() shares the same flush timing and debugging options with watchEffect():jswatch(source, callback, { flush: 'post', onTrack(e) { debugger }, onTrigger(e) { debugger } })Stopping the watcher:jsconst stop = watch(source, callback) // when the watcher is no longer needed: stop()Pausing / resuming the watcher: jsconst { stop, pause, resume } = watch(() = {}) // temporarily pause the watcher pause() // resume later resume() // stop stop()Side effect cleanup:jswatch(id, async (newId, oldId, onCleanup) = { const { response, cancel } = doAsyncWork(newId) // cancel will be called if id changes, cancelling // the previous request if it hasn't completed yet onCleanup(cancel) data.value = await response })Side effect cleanup in 3.5+:jsimport { onWatcherCleanup } from 'vue' watch(id, async (newId) = { const { response, cancel } = doAsyncWork(newId) onWatcherCleanup(cancel) data.value = await response })See alsoGuide - WatchersGuide - Watcher DebuggingonWatcherCleanup() Register a cleanup function to be executed when the current watcher is about to re-run. Can only be called during the synchronous execution of a watchEffect effect function or watch callback function (i.e. it cannot be called after an await statement in an async function.)Typetsfunction onWatcherCleanup( cleanupFn: () = void, failSilently?: boolean ): voidExampletsimport { watch, onWatcherCleanup } from 'vue' watch(id, (newId) = { const { response, cancel } = doAsyncWork(newId) // cancel will be called if id changes, cancelling // the previous request if it hasn't completed yet onWatcherCleanup(cancel) })Edit this page on GitHub",
    "headings": [
      {
        "level": 1,
        "text": "Reactivity API: Core ​",
        "id": "reactivity-api-core"
      },
      {
        "level": 2,
        "text": "ref() ​",
        "id": "ref"
      },
      {
        "level": 2,
        "text": "computed() ​",
        "id": "computed"
      },
      {
        "level": 2,
        "text": "reactive() ​",
        "id": "reactive"
      },
      {
        "level": 2,
        "text": "readonly() ​",
        "id": "readonly"
      },
      {
        "level": 2,
        "text": "watchEffect() ​",
        "id": "watcheffect"
      },
      {
        "level": 2,
        "text": "watchPostEffect() ​",
        "id": "watchposteffect"
      },
      {
        "level": 2,
        "text": "watchSyncEffect() ​",
        "id": "watchsynceffect"
      },
      {
        "level": 2,
        "text": "watch() ​",
        "id": "watch"
      },
      {
        "level": 2,
        "text": "onWatcherCleanup()  ​",
        "id": "onwatchercleanup"
      }
    ],
    "codeBlocks": [
      {
        "language": "text",
        "code": "function ref<T>(value: T): Ref<UnwrapRef<T>>\n\ninterface Ref<T> {\n  value: T\n}"
      },
      {
        "language": "text",
        "code": "function ref<T>(value: T): Ref<UnwrapRef<T>>\n\ninterface Ref<T> {\n  value: T\n}"
      },
      {
        "language": "text",
        "code": "shallowRef()"
      },
      {
        "language": "text",
        "code": "const count = ref(0)\nconsole.log(count.value) // 0\n\ncount.value = 1\nconsole.log(count.value) // 1"
      },
      {
        "language": "text",
        "code": "const count = ref(0)\nconsole.log(count.value) // 0\n\ncount.value = 1\nconsole.log(count.value) // 1"
      },
      {
        "language": "text",
        "code": "// read-only\nfunction computed<T>(\n  getter: (oldValue: T | undefined) => T,\n  // see \"Computed Debugging\" link below\n  debuggerOptions?: DebuggerOptions\n): Readonly<Ref<Readonly<T>>>\n\n// writable\nfunction computed<T>(\n  options: {\n    get: (oldValue: T | undefined) => T\n    set: (value: T) => void\n  },\n  debuggerOptions?: DebuggerOptions\n): Ref<T>"
      },
      {
        "language": "text",
        "code": "// read-only\nfunction computed<T>(\n  getter: (oldValue: T | undefined) => T,\n  // see \"Computed Debugging\" link below\n  debuggerOptions?: DebuggerOptions\n): Readonly<Ref<Readonly<T>>>\n\n// writable\nfunction computed<T>(\n  options: {\n    get: (oldValue: T | undefined) => T\n    set: (value: T) => void\n  },\n  debuggerOptions?: DebuggerOptions\n): Ref<T>"
      },
      {
        "language": "text",
        "code": "const count = ref(1)\nconst plusOne = computed(() => count.value + 1)\n\nconsole.log(plusOne.value) // 2\n\nplusOne.value++ // error"
      },
      {
        "language": "text",
        "code": "const count = ref(1)\nconst plusOne = computed(() => count.value + 1)\n\nconsole.log(plusOne.value) // 2\n\nplusOne.value++ // error"
      },
      {
        "language": "text",
        "code": "const count = ref(1)\nconst plusOne = computed({\n  get: () => count.value + 1,\n  set: (val) => {\n    count.value = val - 1\n  }\n})\n\nplusOne.value = 1\nconsole.log(count.value) // 0"
      },
      {
        "language": "text",
        "code": "const count = ref(1)\nconst plusOne = computed({\n  get: () => count.value + 1,\n  set: (val) => {\n    count.value = val - 1\n  }\n})\n\nplusOne.value = 1\nconsole.log(count.value) // 0"
      },
      {
        "language": "text",
        "code": "const plusOne = computed(() => count.value + 1, {\n  onTrack(e) {\n    debugger\n  },\n  onTrigger(e) {\n    debugger\n  }\n})"
      },
      {
        "language": "text",
        "code": "const plusOne = computed(() => count.value + 1, {\n  onTrack(e) {\n    debugger\n  },\n  onTrigger(e) {\n    debugger\n  }\n})"
      },
      {
        "language": "text",
        "code": "function reactive<T extends object>(target: T): UnwrapNestedRefs<T>"
      },
      {
        "language": "text",
        "code": "function reactive<T extends object>(target: T): UnwrapNestedRefs<T>"
      },
      {
        "language": "text",
        "code": "const obj = reactive({ count: 0 })\nobj.count++"
      },
      {
        "language": "text",
        "code": "const obj = reactive({ count: 0 })\nobj.count++"
      },
      {
        "language": "text",
        "code": "const count = ref(1)\nconst obj = reactive({ count })\n\n// ref will be unwrapped\nconsole.log(obj.count === count.value) // true\n\n// it will update `obj.count`\ncount.value++\nconsole.log(count.value) // 2\nconsole.log(obj.count) // 2\n\n// it will also update `count` ref\nobj.count++\nconsole.log(obj.count) // 3\nconsole.log(count.value) // 3"
      },
      {
        "language": "text",
        "code": "const count = ref(1)\nconst obj = reactive({ count })\n\n// ref will be unwrapped\nconsole.log(obj.count === count.value) // true\n\n// it will update `obj.count`\ncount.value++\nconsole.log(count.value) // 2\nconsole.log(obj.count) // 2\n\n// it will also update `count` ref\nobj.count++\nconsole.log(obj.count) // 3\nconsole.log(count.value) // 3"
      },
      {
        "language": "text",
        "code": "const books = reactive([ref('Vue 3 Guide')])\n// need .value here\nconsole.log(books[0].value)\n\nconst map = reactive(new Map([['count', ref(0)]]))\n// need .value here\nconsole.log(map.get('count').value)"
      },
      {
        "language": "text",
        "code": "const books = reactive([ref('Vue 3 Guide')])\n// need .value here\nconsole.log(books[0].value)\n\nconst map = reactive(new Map([['count', ref(0)]]))\n// need .value here\nconsole.log(map.get('count').value)"
      },
      {
        "language": "text",
        "code": "const count = ref(1)\nconst obj = reactive({})\n\nobj.count = count\n\nconsole.log(obj.count) // 1\nconsole.log(obj.count === count.value) // true"
      },
      {
        "language": "text",
        "code": "const count = ref(1)\nconst obj = reactive({})\n\nobj.count = count\n\nconsole.log(obj.count) // 1\nconsole.log(obj.count === count.value) // true"
      },
      {
        "language": "text",
        "code": "function readonly<T extends object>(\n  target: T\n): DeepReadonly<UnwrapNestedRefs<T>>"
      },
      {
        "language": "text",
        "code": "function readonly<T extends object>(\n  target: T\n): DeepReadonly<UnwrapNestedRefs<T>>"
      },
      {
        "language": "text",
        "code": "const original = reactive({ count: 0 })\n\nconst copy = readonly(original)\n\nwatchEffect(() => {\n  // works for reactivity tracking\n  console.log(copy.count)\n})\n\n// mutating original will trigger watchers relying on the copy\noriginal.count++\n\n// mutating the copy will fail and result in a warning\ncopy.count++ // warning!"
      },
      {
        "language": "text",
        "code": "const original = reactive({ count: 0 })\n\nconst copy = readonly(original)\n\nwatchEffect(() => {\n  // works for reactivity tracking\n  console.log(copy.count)\n})\n\n// mutating original will trigger watchers relying on the copy\noriginal.count++\n\n// mutating the copy will fail and result in a warning\ncopy.count++ // warning!"
      },
      {
        "language": "text",
        "code": "function watchEffect(\n  effect: (onCleanup: OnCleanup) => void,\n  options?: WatchEffectOptions\n): WatchHandle\n\ntype OnCleanup = (cleanupFn: () => void) => void\n\ninterface WatchEffectOptions {\n  flush?: 'pre' | 'post' | 'sync' // default: 'pre'\n  onTrack?: (event: DebuggerEvent) => void\n  onTrigger?: (event: DebuggerEvent) => void\n}\n\ninterface WatchHandle {\n  (): void // callable, same as `stop`\n  pause: () => void\n  resume: () => void\n  stop: () => void\n}"
      },
      {
        "language": "text",
        "code": "function watchEffect(\n  effect: (onCleanup: OnCleanup) => void,\n  options?: WatchEffectOptions\n): WatchHandle\n\ntype OnCleanup = (cleanupFn: () => void) => void\n\ninterface WatchEffectOptions {\n  flush?: 'pre' | 'post' | 'sync' // default: 'pre'\n  onTrack?: (event: DebuggerEvent) => void\n  onTrigger?: (event: DebuggerEvent) => void\n}\n\ninterface WatchHandle {\n  (): void // callable, same as `stop`\n  pause: () => void\n  resume: () => void\n  stop: () => void\n}"
      },
      {
        "language": "text",
        "code": "flush: 'post'"
      },
      {
        "language": "text",
        "code": "flush: 'sync'"
      },
      {
        "language": "text",
        "code": "const count = ref(0)\n\nwatchEffect(() => console.log(count.value))\n// -> logs 0\n\ncount.value++\n// -> logs 1"
      },
      {
        "language": "text",
        "code": "const count = ref(0)\n\nwatchEffect(() => console.log(count.value))\n// -> logs 0\n\ncount.value++\n// -> logs 1"
      },
      {
        "language": "text",
        "code": "const stop = watchEffect(() => {})\n\n// when the watcher is no longer needed:\nstop()"
      },
      {
        "language": "text",
        "code": "const stop = watchEffect(() => {})\n\n// when the watcher is no longer needed:\nstop()"
      },
      {
        "language": "text",
        "code": "const { stop, pause, resume } = watchEffect(() => {})\n\n// temporarily pause the watcher\npause()\n\n// resume later\nresume()\n\n// stop\nstop()"
      },
      {
        "language": "text",
        "code": "const { stop, pause, resume } = watchEffect(() => {})\n\n// temporarily pause the watcher\npause()\n\n// resume later\nresume()\n\n// stop\nstop()"
      },
      {
        "language": "text",
        "code": "watchEffect(async (onCleanup) => {\n  const { response, cancel } = doAsyncWork(newId)\n  // `cancel` will be called if `id` changes, cancelling\n  // the previous request if it hasn't completed yet\n  onCleanup(cancel)\n  data.value = await response\n})"
      },
      {
        "language": "text",
        "code": "watchEffect(async (onCleanup) => {\n  const { response, cancel } = doAsyncWork(newId)\n  // `cancel` will be called if `id` changes, cancelling\n  // the previous request if it hasn't completed yet\n  onCleanup(cancel)\n  data.value = await response\n})"
      },
      {
        "language": "text",
        "code": "import { onWatcherCleanup } from 'vue'\n\nwatchEffect(async () => {\n  const { response, cancel } = doAsyncWork(newId)\n  // `cancel` will be called if `id` changes, cancelling\n  // the previous request if it hasn't completed yet\n  onWatcherCleanup(cancel)\n  data.value = await response\n})"
      },
      {
        "language": "text",
        "code": "import { onWatcherCleanup } from 'vue'\n\nwatchEffect(async () => {\n  const { response, cancel } = doAsyncWork(newId)\n  // `cancel` will be called if `id` changes, cancelling\n  // the previous request if it hasn't completed yet\n  onWatcherCleanup(cancel)\n  data.value = await response\n})"
      },
      {
        "language": "text",
        "code": "watchEffect(() => {}, {\n  flush: 'post',\n  onTrack(e) {\n    debugger\n  },\n  onTrigger(e) {\n    debugger\n  }\n})"
      },
      {
        "language": "text",
        "code": "watchEffect(() => {}, {\n  flush: 'post',\n  onTrack(e) {\n    debugger\n  },\n  onTrigger(e) {\n    debugger\n  }\n})"
      },
      {
        "language": "text",
        "code": "watchEffect()"
      },
      {
        "language": "text",
        "code": "flush: 'post'"
      },
      {
        "language": "text",
        "code": "watchEffect()"
      },
      {
        "language": "text",
        "code": "flush: 'sync'"
      },
      {
        "language": "text",
        "code": "// watching single source\nfunction watch<T>(\n  source: WatchSource<T>,\n  callback: WatchCallback<T>,\n  options?: WatchOptions\n): WatchHandle\n\n// watching multiple sources\nfunction watch<T>(\n  sources: WatchSource<T>[],\n  callback: WatchCallback<T[]>,\n  options?: WatchOptions\n): WatchHandle\n\ntype WatchCallback<T> = (\n  value: T,\n  oldValue: T,\n  onCleanup: (cleanupFn: () => void) => void\n) => void\n\ntype WatchSource<T> =\n  | Ref<T> // ref\n  | (() => T) // getter\n  | (T extends object ? T : never) // reactive object\n\ninterface WatchOptions extends WatchEffectOptions {\n  immediate?: boolean // default: false\n  deep?: boolean | number // default: false\n  flush?: 'pre' | 'post' | 'sync' // default: 'pre'\n  onTrack?: (event: DebuggerEvent) => void\n  onTrigger?: (event: DebuggerEvent) => void\n  once?: boolean // default: false (3.4+)\n}\n\ninterface WatchHandle {\n  (): void // callable, same as `stop`\n  pause: () => void\n  resume: () => void\n  stop: () => void\n}"
      },
      {
        "language": "text",
        "code": "// watching single source\nfunction watch<T>(\n  source: WatchSource<T>,\n  callback: WatchCallback<T>,\n  options?: WatchOptions\n): WatchHandle\n\n// watching multiple sources\nfunction watch<T>(\n  sources: WatchSource<T>[],\n  callback: WatchCallback<T[]>,\n  options?: WatchOptions\n): WatchHandle\n\ntype WatchCallback<T> = (\n  value: T,\n  oldValue: T,\n  onCleanup: (cleanupFn: () => void) => void\n) => void\n\ntype WatchSource<T> =\n  | Ref<T> // ref\n  | (() => T) // getter\n  | (T extends object ? T : never) // reactive object\n\ninterface WatchOptions extends WatchEffectOptions {\n  immediate?: boolean // default: false\n  deep?: boolean | number // default: false\n  flush?: 'pre' | 'post' | 'sync' // default: 'pre'\n  onTrack?: (event: DebuggerEvent) => void\n  onTrigger?: (event: DebuggerEvent) => void\n  once?: boolean // default: false (3.4+)\n}\n\ninterface WatchHandle {\n  (): void // callable, same as `stop`\n  pause: () => void\n  resume: () => void\n  stop: () => void\n}"
      },
      {
        "language": "text",
        "code": "watchEffect()"
      },
      {
        "language": "text",
        "code": "onTrack / onTrigger"
      },
      {
        "language": "text",
        "code": "watchEffect()"
      },
      {
        "language": "text",
        "code": "const state = reactive({ count: 0 })\nwatch(\n  () => state.count,\n  (count, prevCount) => {\n    /* ... */\n  }\n)"
      },
      {
        "language": "text",
        "code": "const state = reactive({ count: 0 })\nwatch(\n  () => state.count,\n  (count, prevCount) => {\n    /* ... */\n  }\n)"
      },
      {
        "language": "text",
        "code": "const count = ref(0)\nwatch(count, (count, prevCount) => {\n  /* ... */\n})"
      },
      {
        "language": "text",
        "code": "const count = ref(0)\nwatch(count, (count, prevCount) => {\n  /* ... */\n})"
      },
      {
        "language": "text",
        "code": "watch([fooRef, barRef], ([foo, bar], [prevFoo, prevBar]) => {\n  /* ... */\n})"
      },
      {
        "language": "text",
        "code": "watch([fooRef, barRef], ([foo, bar], [prevFoo, prevBar]) => {\n  /* ... */\n})"
      },
      {
        "language": "text",
        "code": "{ deep: true }"
      },
      {
        "language": "text",
        "code": "const state = reactive({ count: 0 })\nwatch(\n  () => state,\n  (newValue, oldValue) => {\n    // newValue === oldValue\n  },\n  { deep: true }\n)"
      },
      {
        "language": "text",
        "code": "const state = reactive({ count: 0 })\nwatch(\n  () => state,\n  (newValue, oldValue) => {\n    // newValue === oldValue\n  },\n  { deep: true }\n)"
      },
      {
        "language": "text",
        "code": "const state = reactive({ count: 0 })\nwatch(state, () => {\n  /* triggers on deep mutation to state */\n})"
      },
      {
        "language": "text",
        "code": "const state = reactive({ count: 0 })\nwatch(state, () => {\n  /* triggers on deep mutation to state */\n})"
      },
      {
        "language": "text",
        "code": "watchEffect()"
      },
      {
        "language": "text",
        "code": "watch(source, callback, {\n  flush: 'post',\n  onTrack(e) {\n    debugger\n  },\n  onTrigger(e) {\n    debugger\n  }\n})"
      },
      {
        "language": "text",
        "code": "watch(source, callback, {\n  flush: 'post',\n  onTrack(e) {\n    debugger\n  },\n  onTrigger(e) {\n    debugger\n  }\n})"
      },
      {
        "language": "text",
        "code": "const stop = watch(source, callback)\n\n// when the watcher is no longer needed:\nstop()"
      },
      {
        "language": "text",
        "code": "const stop = watch(source, callback)\n\n// when the watcher is no longer needed:\nstop()"
      },
      {
        "language": "text",
        "code": "const { stop, pause, resume } = watch(() => {})\n\n// temporarily pause the watcher\npause()\n\n// resume later\nresume()\n\n// stop\nstop()"
      },
      {
        "language": "text",
        "code": "const { stop, pause, resume } = watch(() => {})\n\n// temporarily pause the watcher\npause()\n\n// resume later\nresume()\n\n// stop\nstop()"
      },
      {
        "language": "text",
        "code": "watch(id, async (newId, oldId, onCleanup) => {\n  const { response, cancel } = doAsyncWork(newId)\n  // `cancel` will be called if `id` changes, cancelling\n  // the previous request if it hasn't completed yet\n  onCleanup(cancel)\n  data.value = await response\n})"
      },
      {
        "language": "text",
        "code": "watch(id, async (newId, oldId, onCleanup) => {\n  const { response, cancel } = doAsyncWork(newId)\n  // `cancel` will be called if `id` changes, cancelling\n  // the previous request if it hasn't completed yet\n  onCleanup(cancel)\n  data.value = await response\n})"
      },
      {
        "language": "text",
        "code": "import { onWatcherCleanup } from 'vue'\n\nwatch(id, async (newId) => {\n  const { response, cancel } = doAsyncWork(newId)\n  onWatcherCleanup(cancel)\n  data.value = await response\n})"
      },
      {
        "language": "text",
        "code": "import { onWatcherCleanup } from 'vue'\n\nwatch(id, async (newId) => {\n  const { response, cancel } = doAsyncWork(newId)\n  onWatcherCleanup(cancel)\n  data.value = await response\n})"
      },
      {
        "language": "text",
        "code": "watchEffect"
      },
      {
        "language": "text",
        "code": "function onWatcherCleanup(\n  cleanupFn: () => void,\n  failSilently?: boolean\n): void"
      },
      {
        "language": "text",
        "code": "function onWatcherCleanup(\n  cleanupFn: () => void,\n  failSilently?: boolean\n): void"
      },
      {
        "language": "text",
        "code": "import { watch, onWatcherCleanup } from 'vue'\n\nwatch(id, (newId) => {\n  const { response, cancel } = doAsyncWork(newId)\n  // `cancel` will be called if `id` changes, cancelling\n  // the previous request if it hasn't completed yet\n  onWatcherCleanup(cancel)\n})"
      },
      {
        "language": "text",
        "code": "import { watch, onWatcherCleanup } from 'vue'\n\nwatch(id, (newId) => {\n  const { response, cancel } = doAsyncWork(newId)\n  // `cancel` will be called if `id` changes, cancelling\n  // the previous request if it hasn't completed yet\n  onWatcherCleanup(cancel)\n})"
      }
    ],
    "links": [
      {
        "text": "Reactivity Fundamentals",
        "href": "/guide/essentials/reactivity-fundamentals"
      },
      {
        "text": "Reactivity in Depth",
        "href": "/guide/extras/reactivity-in-depth"
      },
      {
        "text": "shallowRef()",
        "href": "/api/reactivity-advanced#shallowref"
      },
      {
        "text": "Guide - Reactivity Fundamentals with ref()",
        "href": "/guide/essentials/reactivity-fundamentals#ref"
      },
      {
        "text": "Guide - Typing ref()",
        "href": "/guide/typescript/composition-api#typing-ref"
      },
      {
        "text": "getter function",
        "href": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Functions/get#description"
      },
      {
        "text": "Guide - Computed Properties",
        "href": "/guide/essentials/computed"
      },
      {
        "text": "Guide - Computed Debugging",
        "href": "/guide/extras/reactivity-in-depth#computed-debugging"
      },
      {
        "text": "Guide - Typing computed()",
        "href": "/guide/typescript/composition-api#typing-computed"
      },
      {
        "text": "Guide - Performance - Computed Stability",
        "href": "/guide/best-practices/performance#computed-stability"
      },
      {
        "text": "shallowReactive()",
        "href": "/api/reactivity-advanced#shallowreactive"
      },
      {
        "text": "ES Proxy",
        "href": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Proxy"
      },
      {
        "text": "Guide - Reactivity Fundamentals",
        "href": "/guide/essentials/reactivity-fundamentals"
      },
      {
        "text": "Guide - Typing reactive()",
        "href": "/guide/typescript/composition-api#typing-reactive"
      },
      {
        "text": "shallowReadonly()",
        "href": "/api/reactivity-advanced#shallowreadonly"
      },
      {
        "text": "Callback Flush Timing",
        "href": "/guide/essentials/watchers#callback-flush-timing"
      },
      {
        "text": "Guide - Watchers",
        "href": "/guide/essentials/watchers#watcheffect"
      },
      {
        "text": "Guide - Watcher Debugging",
        "href": "/guide/extras/reactivity-in-depth#watcher-debugging"
      },
      {
        "text": "Deep Watchers",
        "href": "/guide/essentials/watchers#deep-watchers"
      },
      {
        "text": "Callback Flush Timing",
        "href": "/guide/essentials/watchers#callback-flush-timing"
      },
      {
        "text": "watchEffect()",
        "href": "/api/reactivity-core#watcheffect"
      },
      {
        "text": "Watcher Debugging",
        "href": "/guide/extras/reactivity-in-depth#watcher-debugging"
      },
      {
        "text": "Guide - Watchers",
        "href": "/guide/essentials/watchers"
      },
      {
        "text": "Guide - Watcher Debugging",
        "href": "/guide/extras/reactivity-in-depth#watcher-debugging"
      },
      {
        "text": "Edit this page on GitHub",
        "href": "https://github.com/vuejs/docs/edit/main/src/api/reactivity-core.md"
      }
    ],
    "meta": {
      "description": "Vue.js - The Progressive JavaScript Framework",
      "keywords": ""
    },
    "summary": "Reactivity API: Core See alsoTo better understand the Reactivity APIs, it is recommended to read the following chapters in the guide:Reactivity Fundamentals (with the API preference set to Composition...",
    "tags": [
      "react",
      "vue",
      "angular",
      "javascript",
      "typescript",
      "html",
      "reactivity",
      "api",
      "core",
      "ref"
    ],
    "id": "reactivity-api-core-reactivitycorehtml-part-1",
    "quality": 100
  },
  {
    "title": "Components Basics",
    "url": "https://vuejs.org/guide/essentials/component-basics.html",
    "category": "vue",
    "content": "Components Basics  Watch an interactive video lesson on Scrimba Components allow us to split the UI into independent and reusable pieces, and think about each piece in isolation. It's common for an app to be organized into a tree of nested components:This is very similar to how we nest native HTML elements, but Vue implements its own component model that allows us to encapsulate custom content and logic in each component. Vue also plays nicely with native Web Components. If you are curious about the relationship between Vue Components and native Web Components, read more here.Defining a Component When using a build step, we typically define each Vue component in a dedicated file using the .vue extension - known as a Single-File Component (SFC for short):vuescript export default { data() { return { count: 0 } } } /script template button @click=\"count++\"You clicked me {{ count }} times./button /templatevuescript setup import { ref } from 'vue' const count = ref(0) /script template button @click=\"count++\"You clicked me {{ count }} times./button /templateWhen not using a build step, a Vue component can be defined as a plain JavaScript object containing Vue-specific options:jsexport default { data() { return { count: 0 } }, template:  button @click=\"count++\" You clicked me {{ count }} times. /button }jsimport { ref } from 'vue' export default { setup() { const count = ref(0) return { count } }, template:  button @click=\"count++\" You clicked me {{ count }} times. /button // Can also target an in-DOM template: // template: '#my-template-element' }The template is inlined as a JavaScript string here, which Vue will compile on the fly. You can also use an ID selector pointing to an element (usually native template elements) - Vue will use its content as the template source.The example above defines a single component and exports it as the default export of a .js file, but you can use named exports to export multiple components from the same file.Using a Component TIPWe will be using SFC syntax for the rest of this guide - the concepts around components are the same regardless of whether you are using a build step or not. The Examples section shows component usage in both scenarios.To use a child component, we need to import it in the parent component. Assuming we placed our counter component inside a file called ButtonCounter.vue, the component will be exposed as the file's default export:vuescript import ButtonCounter from './ButtonCounter.vue' export default { components: { ButtonCounter } } /script template h1Here is a child component!/h1 ButtonCounter / /templateTo expose the imported component to our template, we need to register it with the components option. The component will then be available as a tag using the key it is registered under.vuescript setup import ButtonCounter from './ButtonCounter.vue' /script template h1Here is a child component!/h1 ButtonCounter / /templateWith script setup, imported components are automatically made available to the template.It's also possible to globally register a component, making it available to all components in a given app without having to import it. The pros and cons of global vs. local registration is discussed in the dedicated Component Registration section.Components can be reused as many times as you want:templateh1Here are many child components!/h1 ButtonCounter / ButtonCounter / ButtonCounter /Try it in the PlaygroundTry it in the PlaygroundNotice that when clicking on the buttons, each one maintains its own, separate count. That's because each time you use a component, a new instance of it is created.In SFCs, it's recommended to use PascalCase tag names for child components to differentiate from native HTML elements. Although native HTML tag names are case-insensitive, Vue SFC is a compiled format so we are able to use case-sensitive tag names in it. We are also able to use / to close a tag.If you are authoring your templates directly in a DOM (e.g. as the content of a native template element), the template will be subject to the browser's native HTML parsing behavior. In such cases, you will need to use kebab-case and explicit closing tags for components:template!-- if this template is written in the DOM -- button-counter/button-counter button-counter/button-counter button-counter/button-counterSee in-DOM template parsing caveats for more details.Passing Props If we are building a blog, we will likely need a component representing a blog post. We want all the blog posts to share the same visual layout, but with different content. Such a component won't be useful unless you can pass data to it, such as the title and content of the specific post we want to display. That's where props come in.Props are custom attributes you can register on a component. To pass a title to our blog post component, we must declare it in the list of props this component accepts, using the props optiondefineProps macro:BlogPost.vuevuescript export default { props: ['title'] } /script template h4{{ title }}/h4 /templateWhen a value is passed to a prop attribute, it becomes a property on that component instance. The value of that property is accessible within the template and on the component's this context, just like any other component property.BlogPost.vuevuescript setup defineProps(['title']) /script template h4{{ title }}/h4 /templatedefineProps is a compile-time macro that is only available inside script setup and does not need to be explicitly imported. Declared props are automatically exposed to the template. defineProps also returns an object that contains all the props passed to the component, so that we can access them in JavaScript if needed:jsconst props = defineProps(['title']) console.log(props.title)See also: Typing Component Props If you are not using script setup, props should be declared using the props option, and the props object will be passed to setup() as the first argument:jsexport default { props: ['title'], setup(props) { console.log(props.title) } }A component can have as many props as you like and, by default, any value can be passed to any prop.Once a prop is registered, you can pass data to it as a custom attribute, like this:templateBlogPost title=\"My journey with Vue\" / BlogPost title=\"Blogging with Vue\" / BlogPost title=\"Why Vue is so fun\" /In a typical app, however, you'll likely have an array of posts in your parent component:jsexport default { // ... data() { return { posts: [ { id: 1, title: 'My journey with Vue' }, { id: 2, title: 'Blogging with Vue' }, { id: 3, title: 'Why Vue is so fun' } ] } } }jsconst posts = ref([ { id: 1, title: 'My journey with Vue' }, { id: 2, title: 'Blogging with Vue' }, { id: 3, title: 'Why Vue is so fun' } ])Then want to render a component for each one, using v-for:templateBlogPost v-for=\"post in posts\" :key=\"post.id\" :title=\"post.title\" /Try it in the PlaygroundTry it in the PlaygroundNotice how v-bind syntax (:title=\"post.title\") is used to pass dynamic prop values. This is especially useful when you don't know the exact content you're going to render ahead of time.That's all you need to know about props for now, but once you've finished reading this page and feel comfortable with its content, we recommend coming back later to read the full guide on Props.Listening to Events As we develop our BlogPost component, some features may require communicating back up to the parent. For example, we may decide to include an accessibility feature to enlarge the text of blog posts, while leaving the rest of the page at its default size.In the parent, we can support this feature by adding a postFontSize data propertyref:jsdata() { return { posts: [ /* ... */ ], postFontSize: 1 } }jsconst posts = ref([ /* ... */ ]) const postFontSize = ref(1)Which can be used in the template to control the font size of all blog posts:templatediv :style=\"{ fontSize: postFontSize + 'em' }\" BlogPost v-for=\"post in posts\" :key=\"post.id\" :title=\"post.title\" / /divNow let's add a button to the BlogPost component's template:BlogPost.vuevue!-- omitting script -- template div class=\"blog-post\" h4{{ title }}/h4 buttonEnlarge text/button /div /templateThe button doesn't do anything yet - we want clicking the button to communicate to the parent that it should enlarge the text of all posts. To solve this problem, components provide a custom events system. The parent can choose to listen to any event on the child component instance with v-on or @, just as we would with a native DOM event:templateBlogPost ... @enlarge-text=\"postFontSize += 0.1\" /Then the child component can emit an event on itself by calling the built-in $emit method, passing the name of the event:BlogPost.vuevue!-- omitting script -- template div class=\"blog-post\" h4{{ title }}/h4 button @click=\"$emit('enlarge-text')\"Enlarge text/button /div /templateThanks to the @enlarge-text=\"postFontSize += 0.1\" listener, the parent will receive the event and update the value of postFontSize.Try it in the PlaygroundTry it in the PlaygroundWe can optionally declare emitted events using the emits optiondefineEmits macro:BlogPost.vuevuescript export default { props: ['title'], emits: ['enlarge-text'] } /scriptBlogPost.vuevuescript setup defineProps(['title']) defineEmits(['enlarge-text']) /scriptThis documents all the events that a component emits and optionally validates them. It also allows Vue to avoid implicitly applying them as native listeners to the child component's root element.Similar to defineProps, defineEmits is only usable in script setup and doesn't need to be imported. It returns an emit function that is equivalent to the $emit method. It can be used to emit events in the script setup section of a component, where $emit isn't directly accessible:vuescript setup const emit = defineEmits(['enlarge-text']) emit('enlarge-text') /scriptSee also: Typing Component Emits If you are not using script setup, you can declare emitted events using the emits option. You can access the emit function as a property of the setup context (passed to setup() as the second argument):jsexport default { emits: ['enlarge-text'], setup(props, ctx) { ctx.emit('enlarge-text') } }That's all you need to know about custom component events for now, but once you've finished reading this page and feel comfortable with its content, we recommend coming back later to read the full guide on Custom Events.Content Distribution with Slots Just like with HTML elements, it's often useful to be able to pass content to a component, like this:templateAlertBox Something bad happened. /AlertBoxWhich might render something like:This is an Error for Demo PurposesSomething bad happened.This can be achieved using Vue's custom slot element:AlertBox.vuevuetemplate div class=\"alert-box\" strongThis is an Error for Demo Purposes/strong slot / /div /template style scoped .alert-box { /* ... */ } /styleAs you'll see above, we use the slot as a placeholder where we want the content to go  and that's it. We're done!Try it in the PlaygroundTry it in the PlaygroundThat's all you need to know about slots for now, but once you've finished reading this page and feel comfortable with its content, we recommend coming back later to read the full guide on Slots.Dynamic Components Sometimes, it's useful to dynamically switch between components, like in a tabbed interface:Open example in the PlaygroundOpen example in the PlaygroundThe above is made possible by Vue's component element with the special is attribute:template!-- Component changes when currentTab changes -- component :is=\"currentTab\"/componenttemplate!-- Component changes when currentTab changes -- component :is=\"tabs[currentTab]\"/componentIn the example above, the value passed to :is can contain either:the name string of a registered component, ORthe actual imported component objectYou can also use the is attribute to create regular HTML elements.When switching between multiple components with component :is=\"...\", a component will be unmounted when it is switched away from. We can force the inactive components to stay \"alive\" with the built-in KeepAlive component.in-DOM Template Parsing Caveats If you are writing your Vue templates directly in the DOM, Vue will have to retrieve the template string from the DOM. This leads to some caveats due to browsers' native HTML parsing behavior.TIPIt should be noted that the limitations discussed below only apply if you are writing your templates directly in the DOM. They do NOT apply if you are using string templates from the following sources:Single-File ComponentsInlined template strings (e.g. template: '...')script type=\"text/x-template\"Case Insensitivity HTML tags and attribute names are case-insensitive, so browsers will interpret any uppercase characters as lowercase. That means when youre using in-DOM templates, PascalCase component names and camelCased prop names or v-on event names all need to use their kebab-cased (hyphen-delimited) equivalents:js// camelCase in JavaScript const BlogPost = { props: ['postTitle'], emits: ['updatePost'], template:  h3{{ postTitle }}/h3  }template!-- kebab-case in HTML -- blog-post post-title=\"hello!\" @update-post=\"onUpdatePost\"/blog-postSelf Closing Tags We have been using self-closing tags for components in previous code samples:templateMyComponent /This is because Vue's template parser respects / as an indication to end any tag, regardless of its type.In in-DOM templates, however, we must always include explicit closing tags:templatemy-component/my-componentThis is because the HTML spec only allows a few specific elements to omit closing tags, the most common being input and img. For all other elements, if you omit the closing tag, the native HTML parser will think you never terminated the opening tag. For example, the following snippet:templatemy-component / !-- we intend to close the tag here... -- spanhello/spanwill be parsed as:templatemy-component spanhello/span /my-component !-- but the browser will close it here. --Element Placement Restrictions Some HTML elements, such as ul, ol, table and select have restrictions on what elements can appear inside them, and some elements such as li, tr, and option can only appear inside certain other elements.This will lead to issues when using components with elements that have such restrictions. For example:templatetable blog-post-row/blog-post-row /tableThe custom component blog-post-row will be hoisted out as invalid content, causing errors in the eventual rendered output. We can use the special is attribute as a workaround:templatetable tr is=\"vue:blog-post-row\"/tr /tableTIPWhen used on native HTML elements, the value of is must be prefixed with vue: in order to be interpreted as a Vue component. This is required to avoid confusion with native customized built-in elements.That's all you need to know about in-DOM template parsing caveats for now - and actually, the end of Vue's Essentials. Congratulations! There's still more to learn, but first, we recommend taking a break to play with Vue yourself - build something fun, or check out some of the Examples if you haven't already.Once you feel comfortable with the knowledge you've just digested, move on with the guide to learn more about components in depth.Edit this page on GitHub",
    "headings": [
      {
        "level": 1,
        "text": "Components Basics ​",
        "id": "components-basics"
      },
      {
        "level": 2,
        "text": "Defining a Component ​",
        "id": "defining-a-component"
      },
      {
        "level": 2,
        "text": "Using a Component ​",
        "id": "using-a-component"
      },
      {
        "level": 2,
        "text": "Passing Props ​",
        "id": "passing-props"
      },
      {
        "level": 2,
        "text": "Listening to Events ​",
        "id": "listening-to-events"
      },
      {
        "level": 2,
        "text": "Content Distribution with Slots ​",
        "id": "content-distribution-with-slots"
      },
      {
        "level": 2,
        "text": "Dynamic Components ​",
        "id": "dynamic-components"
      },
      {
        "level": 2,
        "text": "in-DOM Template Parsing Caveats ​",
        "id": "in-dom-template-parsing-caveats"
      },
      {
        "level": 3,
        "text": "Case Insensitivity ​",
        "id": "case-insensitivity"
      },
      {
        "level": 3,
        "text": "Self Closing Tags ​",
        "id": "self-closing-tags"
      },
      {
        "level": 3,
        "text": "Element Placement Restrictions ​",
        "id": "element-placement-restrictions"
      }
    ],
    "codeBlocks": [
      {
        "language": "text",
        "code": "<script>\nexport default {\n  data() {\n    return {\n      count: 0\n    }\n  }\n}\n</script>\n\n<template>\n  <button @click=\"count++\">You clicked me {{ count }} times.</button>\n</template>"
      },
      {
        "language": "text",
        "code": "<script>\nexport default {\n  data() {\n    return {\n      count: 0\n    }\n  }\n}\n</script>\n\n<template>\n  <button @click=\"count++\">You clicked me {{ count }} times.</button>\n</template>"
      },
      {
        "language": "text",
        "code": "<script setup>\nimport { ref } from 'vue'\n\nconst count = ref(0)\n</script>\n\n<template>\n  <button @click=\"count++\">You clicked me {{ count }} times.</button>\n</template>"
      },
      {
        "language": "text",
        "code": "<script setup>\nimport { ref } from 'vue'\n\nconst count = ref(0)\n</script>\n\n<template>\n  <button @click=\"count++\">You clicked me {{ count }} times.</button>\n</template>"
      },
      {
        "language": "text",
        "code": "export default {\n  data() {\n    return {\n      count: 0\n    }\n  },\n  template: `\n    <button @click=\"count++\">\n      You clicked me {{ count }} times.\n    </button>`\n}"
      },
      {
        "language": "text",
        "code": "export default {\n  data() {\n    return {\n      count: 0\n    }\n  },\n  template: `\n    <button @click=\"count++\">\n      You clicked me {{ count }} times.\n    </button>`\n}"
      },
      {
        "language": "text",
        "code": "import { ref } from 'vue'\n\nexport default {\n  setup() {\n    const count = ref(0)\n    return { count }\n  },\n  template: `\n    <button @click=\"count++\">\n      You clicked me {{ count }} times.\n    </button>`\n  // Can also target an in-DOM template:\n  // template: '#my-template-element'\n}"
      },
      {
        "language": "text",
        "code": "import { ref } from 'vue'\n\nexport default {\n  setup() {\n    const count = ref(0)\n    return { count }\n  },\n  template: `\n    <button @click=\"count++\">\n      You clicked me {{ count }} times.\n    </button>`\n  // Can also target an in-DOM template:\n  // template: '#my-template-element'\n}"
      },
      {
        "language": "text",
        "code": "ButtonCounter.vue"
      },
      {
        "language": "text",
        "code": "<script>\nimport ButtonCounter from './ButtonCounter.vue'\n\nexport default {\n  components: {\n    ButtonCounter\n  }\n}\n</script>\n\n<template>\n  <h1>Here is a child component!</h1>\n  <ButtonCounter />\n</template>"
      },
      {
        "language": "text",
        "code": "<script>\nimport ButtonCounter from './ButtonCounter.vue'\n\nexport default {\n  components: {\n    ButtonCounter\n  }\n}\n</script>\n\n<template>\n  <h1>Here is a child component!</h1>\n  <ButtonCounter />\n</template>"
      },
      {
        "language": "text",
        "code": "<script setup>\nimport ButtonCounter from './ButtonCounter.vue'\n</script>\n\n<template>\n  <h1>Here is a child component!</h1>\n  <ButtonCounter />\n</template>"
      },
      {
        "language": "text",
        "code": "<script setup>\nimport ButtonCounter from './ButtonCounter.vue'\n</script>\n\n<template>\n  <h1>Here is a child component!</h1>\n  <ButtonCounter />\n</template>"
      },
      {
        "language": "text",
        "code": "<script setup>"
      },
      {
        "language": "text",
        "code": "<h1>Here are many child components!</h1>\n<ButtonCounter />\n<ButtonCounter />\n<ButtonCounter />"
      },
      {
        "language": "text",
        "code": "<h1>Here are many child components!</h1>\n<ButtonCounter />\n<ButtonCounter />\n<ButtonCounter />"
      },
      {
        "language": "text",
        "code": "<!-- if this template is written in the DOM -->\n<button-counter></button-counter>\n<button-counter></button-counter>\n<button-counter></button-counter>"
      },
      {
        "language": "text",
        "code": "<!-- if this template is written in the DOM -->\n<button-counter></button-counter>\n<button-counter></button-counter>\n<button-counter></button-counter>"
      },
      {
        "language": "text",
        "code": "defineProps"
      },
      {
        "language": "text",
        "code": "<script>\nexport default {\n  props: ['title']\n}\n</script>\n\n<template>\n  <h4>{{ title }}</h4>\n</template>"
      },
      {
        "language": "text",
        "code": "<script>\nexport default {\n  props: ['title']\n}\n</script>\n\n<template>\n  <h4>{{ title }}</h4>\n</template>"
      },
      {
        "language": "text",
        "code": "<script setup>\ndefineProps(['title'])\n</script>\n\n<template>\n  <h4>{{ title }}</h4>\n</template>"
      },
      {
        "language": "text",
        "code": "<script setup>\ndefineProps(['title'])\n</script>\n\n<template>\n  <h4>{{ title }}</h4>\n</template>"
      },
      {
        "language": "text",
        "code": "defineProps"
      },
      {
        "language": "text",
        "code": "<script setup>"
      },
      {
        "language": "text",
        "code": "defineProps"
      },
      {
        "language": "text",
        "code": "const props = defineProps(['title'])\nconsole.log(props.title)"
      },
      {
        "language": "text",
        "code": "const props = defineProps(['title'])\nconsole.log(props.title)"
      },
      {
        "language": "text",
        "code": "<script setup>"
      },
      {
        "language": "text",
        "code": "export default {\n  props: ['title'],\n  setup(props) {\n    console.log(props.title)\n  }\n}"
      },
      {
        "language": "text",
        "code": "export default {\n  props: ['title'],\n  setup(props) {\n    console.log(props.title)\n  }\n}"
      },
      {
        "language": "text",
        "code": "<BlogPost title=\"My journey with Vue\" />\n<BlogPost title=\"Blogging with Vue\" />\n<BlogPost title=\"Why Vue is so fun\" />"
      },
      {
        "language": "text",
        "code": "<BlogPost title=\"My journey with Vue\" />\n<BlogPost title=\"Blogging with Vue\" />\n<BlogPost title=\"Why Vue is so fun\" />"
      },
      {
        "language": "text",
        "code": "export default {\n  // ...\n  data() {\n    return {\n      posts: [\n        { id: 1, title: 'My journey with Vue' },\n        { id: 2, title: 'Blogging with Vue' },\n        { id: 3, title: 'Why Vue is so fun' }\n      ]\n    }\n  }\n}"
      },
      {
        "language": "text",
        "code": "export default {\n  // ...\n  data() {\n    return {\n      posts: [\n        { id: 1, title: 'My journey with Vue' },\n        { id: 2, title: 'Blogging with Vue' },\n        { id: 3, title: 'Why Vue is so fun' }\n      ]\n    }\n  }\n}"
      },
      {
        "language": "text",
        "code": "const posts = ref([\n  { id: 1, title: 'My journey with Vue' },\n  { id: 2, title: 'Blogging with Vue' },\n  { id: 3, title: 'Why Vue is so fun' }\n])"
      },
      {
        "language": "text",
        "code": "const posts = ref([\n  { id: 1, title: 'My journey with Vue' },\n  { id: 2, title: 'Blogging with Vue' },\n  { id: 3, title: 'Why Vue is so fun' }\n])"
      },
      {
        "language": "text",
        "code": "<BlogPost\n  v-for=\"post in posts\"\n  :key=\"post.id\"\n  :title=\"post.title\"\n />"
      },
      {
        "language": "text",
        "code": "<BlogPost\n  v-for=\"post in posts\"\n  :key=\"post.id\"\n  :title=\"post.title\"\n />"
      },
      {
        "language": "text",
        "code": ":title=\"post.title\""
      },
      {
        "language": "text",
        "code": "postFontSize"
      },
      {
        "language": "text",
        "code": "data() {\n  return {\n    posts: [\n      /* ... */\n    ],\n    postFontSize: 1\n  }\n}"
      },
      {
        "language": "text",
        "code": "data() {\n  return {\n    posts: [\n      /* ... */\n    ],\n    postFontSize: 1\n  }\n}"
      },
      {
        "language": "text",
        "code": "const posts = ref([\n  /* ... */\n])\n\nconst postFontSize = ref(1)"
      },
      {
        "language": "text",
        "code": "const posts = ref([\n  /* ... */\n])\n\nconst postFontSize = ref(1)"
      },
      {
        "language": "text",
        "code": "<div :style=\"{ fontSize: postFontSize + 'em' }\">\n  <BlogPost\n    v-for=\"post in posts\"\n    :key=\"post.id\"\n    :title=\"post.title\"\n   />\n</div>"
      },
      {
        "language": "text",
        "code": "<div :style=\"{ fontSize: postFontSize + 'em' }\">\n  <BlogPost\n    v-for=\"post in posts\"\n    :key=\"post.id\"\n    :title=\"post.title\"\n   />\n</div>"
      },
      {
        "language": "text",
        "code": "<!-- omitting <script> -->\n<template>\n  <div class=\"blog-post\">\n    <h4>{{ title }}</h4>\n    <button>Enlarge text</button>\n  </div>\n</template>"
      },
      {
        "language": "text",
        "code": "<!-- omitting <script> -->\n<template>\n  <div class=\"blog-post\">\n    <h4>{{ title }}</h4>\n    <button>Enlarge text</button>\n  </div>\n</template>"
      },
      {
        "language": "text",
        "code": "<BlogPost\n  ...\n  @enlarge-text=\"postFontSize += 0.1\"\n />"
      },
      {
        "language": "text",
        "code": "<BlogPost\n  ...\n  @enlarge-text=\"postFontSize += 0.1\"\n />"
      },
      {
        "language": "text",
        "code": "<!-- omitting <script> -->\n<template>\n  <div class=\"blog-post\">\n    <h4>{{ title }}</h4>\n    <button @click=\"$emit('enlarge-text')\">Enlarge text</button>\n  </div>\n</template>"
      },
      {
        "language": "text",
        "code": "<!-- omitting <script> -->\n<template>\n  <div class=\"blog-post\">\n    <h4>{{ title }}</h4>\n    <button @click=\"$emit('enlarge-text')\">Enlarge text</button>\n  </div>\n</template>"
      },
      {
        "language": "text",
        "code": "@enlarge-text=\"postFontSize += 0.1\""
      },
      {
        "language": "text",
        "code": "postFontSize"
      },
      {
        "language": "text",
        "code": "defineEmits"
      },
      {
        "language": "text",
        "code": "<script>\nexport default {\n  props: ['title'],\n  emits: ['enlarge-text']\n}\n</script>"
      },
      {
        "language": "text",
        "code": "<script>\nexport default {\n  props: ['title'],\n  emits: ['enlarge-text']\n}\n</script>"
      },
      {
        "language": "text",
        "code": "<script setup>\ndefineProps(['title'])\ndefineEmits(['enlarge-text'])\n</script>"
      },
      {
        "language": "text",
        "code": "<script setup>\ndefineProps(['title'])\ndefineEmits(['enlarge-text'])\n</script>"
      },
      {
        "language": "text",
        "code": "defineProps"
      },
      {
        "language": "text",
        "code": "defineEmits"
      },
      {
        "language": "text",
        "code": "<script setup>"
      },
      {
        "language": "text",
        "code": "<script setup>"
      },
      {
        "language": "text",
        "code": "<script setup>\nconst emit = defineEmits(['enlarge-text'])\n\nemit('enlarge-text')\n</script>"
      },
      {
        "language": "text",
        "code": "<script setup>\nconst emit = defineEmits(['enlarge-text'])\n\nemit('enlarge-text')\n</script>"
      },
      {
        "language": "text",
        "code": "<script setup>"
      },
      {
        "language": "text",
        "code": "export default {\n  emits: ['enlarge-text'],\n  setup(props, ctx) {\n    ctx.emit('enlarge-text')\n  }\n}"
      },
      {
        "language": "text",
        "code": "export default {\n  emits: ['enlarge-text'],\n  setup(props, ctx) {\n    ctx.emit('enlarge-text')\n  }\n}"
      },
      {
        "language": "text",
        "code": "<AlertBox>\n  Something bad happened.\n</AlertBox>"
      },
      {
        "language": "text",
        "code": "<AlertBox>\n  Something bad happened.\n</AlertBox>"
      },
      {
        "language": "text",
        "code": "<template>\n  <div class=\"alert-box\">\n    <strong>This is an Error for Demo Purposes</strong>\n    <slot />\n  </div>\n</template>\n\n<style scoped>\n.alert-box {\n  /* ... */\n}\n</style>"
      },
      {
        "language": "text",
        "code": "<template>\n  <div class=\"alert-box\">\n    <strong>This is an Error for Demo Purposes</strong>\n    <slot />\n  </div>\n</template>\n\n<style scoped>\n.alert-box {\n  /* ... */\n}\n</style>"
      },
      {
        "language": "text",
        "code": "<component>"
      },
      {
        "language": "text",
        "code": "<!-- Component changes when currentTab changes -->\n<component :is=\"currentTab\"></component>"
      },
      {
        "language": "text",
        "code": "<!-- Component changes when currentTab changes -->\n<component :is=\"currentTab\"></component>"
      },
      {
        "language": "text",
        "code": "<!-- Component changes when currentTab changes -->\n<component :is=\"tabs[currentTab]\"></component>"
      },
      {
        "language": "text",
        "code": "<!-- Component changes when currentTab changes -->\n<component :is=\"tabs[currentTab]\"></component>"
      },
      {
        "language": "text",
        "code": "<component :is=\"...\">"
      },
      {
        "language": "text",
        "code": "<KeepAlive>"
      },
      {
        "language": "text",
        "code": "template: '...'"
      },
      {
        "language": "text",
        "code": "<script type=\"text/x-template\">"
      },
      {
        "language": "text",
        "code": "// camelCase in JavaScript\nconst BlogPost = {\n  props: ['postTitle'],\n  emits: ['updatePost'],\n  template: `\n    <h3>{{ postTitle }}</h3>\n  `\n}"
      },
      {
        "language": "text",
        "code": "// camelCase in JavaScript\nconst BlogPost = {\n  props: ['postTitle'],\n  emits: ['updatePost'],\n  template: `\n    <h3>{{ postTitle }}</h3>\n  `\n}"
      },
      {
        "language": "text",
        "code": "<!-- kebab-case in HTML -->\n<blog-post post-title=\"hello!\" @update-post=\"onUpdatePost\"></blog-post>"
      },
      {
        "language": "text",
        "code": "<!-- kebab-case in HTML -->\n<blog-post post-title=\"hello!\" @update-post=\"onUpdatePost\"></blog-post>"
      },
      {
        "language": "text",
        "code": "<MyComponent />"
      },
      {
        "language": "text",
        "code": "<MyComponent />"
      },
      {
        "language": "text",
        "code": "<my-component></my-component>"
      },
      {
        "language": "text",
        "code": "<my-component></my-component>"
      },
      {
        "language": "text",
        "code": "<my-component /> <!-- we intend to close the tag here... -->\n<span>hello</span>"
      },
      {
        "language": "text",
        "code": "<my-component /> <!-- we intend to close the tag here... -->\n<span>hello</span>"
      },
      {
        "language": "text",
        "code": "<my-component>\n  <span>hello</span>\n</my-component> <!-- but the browser will close it here. -->"
      },
      {
        "language": "text",
        "code": "<my-component>\n  <span>hello</span>\n</my-component> <!-- but the browser will close it here. -->"
      },
      {
        "language": "text",
        "code": "<table>\n  <blog-post-row></blog-post-row>\n</table>"
      },
      {
        "language": "text",
        "code": "<table>\n  <blog-post-row></blog-post-row>\n</table>"
      },
      {
        "language": "text",
        "code": "<blog-post-row>"
      },
      {
        "language": "text",
        "code": "<table>\n  <tr is=\"vue:blog-post-row\"></tr>\n</table>"
      },
      {
        "language": "text",
        "code": "<table>\n  <tr is=\"vue:blog-post-row\"></tr>\n</table>"
      }
    ],
    "links": [
      {
        "text": "Watch an interactive video lesson on Scrimba",
        "href": "https://scrimba.com/links/vue-component-basics"
      },
      {
        "text": "read more here",
        "href": "/guide/extras/web-components"
      },
      {
        "text": "Single-File Component",
        "href": "/guide/scaling-up/sfc"
      },
      {
        "text": "Examples",
        "href": "/examples/"
      },
      {
        "text": "register",
        "href": "/guide/components/registration"
      },
      {
        "text": "Component Registration",
        "href": "/guide/components/registration"
      },
      {
        "text": "Try it in the Playground",
        "href": "https://play.vuejs.org/#eNqVUE1LxDAQ/StjLqusNHotcfHj4l8QcontLBtsJiGdiFL6301SdrEqyEJyeG9m3ps3k3gIoXlPKFqhxi7awDtN1gUfGR4Ts6cnn4gxwj56B5tGrtgyutEEoAk/6lCPe5MGhqmwnc9KhMRjuxCwFi3UrCk/JU/uGTC6MBjGglgdbnfPGBFM/s7QJ3QHO/TfxC+UzD21d72zPItU8uQrrsWvnKsT/ZW2N2wur45BI3KKdETlFlmphZsF58j/RgdQr3UJuO8G273daVFFtlstahngxSeoNezBIUzTYgPzDGwdjk1VkYvMj4jzF0nwsyQ="
      },
      {
        "text": "Try it in the Playground",
        "href": "https://play.vuejs.org/#eNqVj91KAzEQhV/lmJsqlY3eSlr8ufEVhNys6ZQGNz8kE0GWfXez2SJUsdCLuZiZM9+ZM4qnGLvPQuJBqGySjYxMXOJWe+tiSIznwhz8SyieKWGfgsOqkyfTGbDSXsmFUG9rw+Ti0DPNHavD/faVEqGv5Xr/BXOwww4mVBNPnvOVklXTtKeO8qKhkj++4lb8+fL/mCMS7TEdAy6BtDfBZ65fVgA2s+L67uZMUEC9N0s8msGaj40W7Xa91qKtgbdQ0Ha0gyOM45E+TWDrKHeNIhfMr0DTN4U0me8="
      },
      {
        "text": "props",
        "href": "/api/options-state#props"
      },
      {
        "text": "defineProps",
        "href": "/api/sfc-script-setup#defineprops-defineemits"
      },
      {
        "text": "Typing Component Props",
        "href": "/guide/typescript/composition-api#typing-component-props"
      },
      {
        "text": "Try it in the Playground",
        "href": "https://play.vuejs.org/#eNp9UU1rhDAU/CtDLrawVfpxklRo74We2kPtQdaoaTUJ8bmtiP+9ia6uC2VBgjOZeXnz3sCejAkPnWAx4+3eSkNJqmRjtCU817p81S2hsLpBEEYL4Q1BqoBUid9Jmosi62rC4Nm9dn4lFLXxTGAt5dG482eeUXZ1vdxbQZ1VCwKM0zr3x4KBATKPcbsDSapFjOClx5d2JtHjR1KFN9fTsfbWcXdy+CZKqcqL+vuT/r3qvQqyRatRdMrpF/nn/DNhd7iPR+v8HCDRmDoj4RHxbfyUDjeFto8p8yEh1Rw2ZV4JxN+iP96FMvest8RTTws/gdmQ8HUr7ikere+yHduu62y//y3NWG38xIOpeODyXcoE8OohGYZ5VhhHHjl83sD4B3XgyGI="
      },
      {
        "text": "Try it in the Playground",
        "href": "https://play.vuejs.org/#eNp9kU9PhDAUxL/KpBfWBCH+OZEuid5N9qSHrQezFKhC27RlDSF8d1tYQBP1+N78OpN5HciD1sm54yQj1J6M0A6Wu07nTIpWK+MwwPASI0qjWkQejVbpsVHVQVl30ZJ0WQRHjwFMnpT0gPZLi32w2h2DMEAUGW5iOOEaniF66vGuOiN5j0/hajx7B4zxxt5ubIiphKz+IO828qXugw5hYRXKTnqSydcrJmk61/VF/eB4q5s3x8Pk6FJjauDO16Uye0ZCBwg5d2EkkED2wfuLlogibMOTbMpf9tMwP8jpeiMfRdM1l8Tk+/F++Y6Cl0Lyg1Ha7o7R5Bn9WwSg9X0+DPMxMI409fPP1PELlVmwdQ=="
      },
      {
        "text": "v-bind syntax",
        "href": "/api/built-in-directives#v-bind"
      },
      {
        "text": "Props",
        "href": "/guide/components/props"
      },
      {
        "text": "$emit method",
        "href": "/api/component-instance#emit"
      },
      {
        "text": "Try it in the Playground",
        "href": "https://play.vuejs.org/#eNqNUsFOg0AQ/ZUJMaGNbbHqidCmmujNxMRED9IDhYWuhV0CQy0S/t1ZYIEmaiRkw8y8N/vmMZVxl6aLY8EM23ByP+Mprl3Bk1RmCPexjJ5ljhBmMgFzYemEIpiuAHAFOzXQgIVeESNUKutL4gsmMLfbBPStVFTP1Bl46E2mup4xLDKhI4CUsMR+1zFABTywYTkD5BgzG8ynEj4kkVgJnxz38Eqaut5jxvXAUCIiLqI/8TcD/m1fKhTwHHIJYSEIr+HbnqikPkqBL/yLSMs23eDooNexel8pQJaksYeMIgAn4EewcyxjtnKNCsK+zbgpXILJEnW30bCIN7ZTPcd5KDNqoWjARWufa+iyfWBlV13wYJRvJtWVJhiKGyZiL4vYHNkJO8wgaQVXi6UGr51+Ndq5LBqMvhyrH9eYGePtOVu3n3YozWSqFsBsVJmt3SzhzVaYY2nm9l82+7GX5zTGjlTM1SyNmy5SeX+7rqr2r0NdOxbFXWVXIEoBGz/m/oHIF0rB5Pz6KTV6aBOgEo7Vsn51ov4GgAAf2A=="
      },
      {
        "text": "Try it in the Playground",
        "href": "https://play.vuejs.org/#eNp1Uk1PwkAQ/SuTxqQYgYp6ahaiJngzITHRA/UAZQor7W7TnaK16X93th8UEuHEvPdm5s3bls5Tmo4POTq+I0yYyZTAIOXpLFAySXVGUEKGEVQQZToBl6XukXqO9XahDbXc2OsAO5FlAIEKtWJByqCBqR01WFqiBLnxYTIEkhSjD+5rAV86zxQW8C1pB+88Aaphr73rtXbNVqrtBeV9r/zYFZYHacBoiHLFykB9Xgfq1NmLVvQmf7E1OGFaeE0anAMXhEkarwhtRWIjD+AbKmKcBk4JUdvtn8+6ARcTu87hLuCf6NJpSoDDKNIZj7BtIFUTUuB0tL/HomXHcnOC18d1TF305COqeJVtcUT4Q62mtzSF2/GkE8/E8b1qh8Ljw/if8I7nOkPn9En/+Ug2GEmFi0ynZrB0azOujbfB54kki5+aqumL8bING28Yr4xh+2vePrI39CnuHmZl2TwwVJXwuG6ZdU6kFTyGsQz33HyFvH5wvvyaB80bACwgvKbrYgLVH979DQc="
      },
      {
        "text": "emits",
        "href": "/api/options-state#emits"
      },
      {
        "text": "defineEmits",
        "href": "/api/sfc-script-setup#defineprops-defineemits"
      },
      {
        "text": "validates them",
        "href": "/guide/components/events#events-validation"
      },
      {
        "text": "Typing Component Emits",
        "href": "/guide/typescript/composition-api#typing-component-emits"
      },
      {
        "text": "Custom Events",
        "href": "/guide/components/events"
      },
      {
        "text": "Try it in the Playground",
        "href": "https://play.vuejs.org/#eNpVUcFOwzAM/RUTDruwFhCaUCmThsQXcO0lbbKtIo0jx52Kpv07TreWouTynl+en52z2oWQnXqrClXGhtrA28q3XUBi2DlL/IED7Ak7WGX5RKQHq8oDVN4Oo9TYve4dwzmxDcp7bz3HAs5/LpfKyy3zuY0Atl1wmm1CXE5SQeLNX9hZPrb+ALU2cNQhWG9NNkrnLKIt89lGPahlyDTVogVAadoTNE7H+F4pnZTrGodKjUUpRyb0h+0nEdKdRL3CW7GmfNY5ZLiiMhfP/ynG0SL/OAuxwWCNMNncbVqSQyrgfrPZvCVcIxkrxFMYIKJrDZA1i8qatGl72ehLGEY6aGNkNwU8P96YWjffB8Lem/Xkvn9NR6qy+fRd14FSgopvmtQmzTT9Toq9VZdfIpa5jQ=="
      },
      {
        "text": "Try it in the Playground",
        "href": "https://play.vuejs.org/#eNpVUEtOwzAQvcpgFt3QBBCqUAiRisQJ2GbjxG4a4Xis8aQKqnp37PyUyqv3mZn3fBVH55JLr0Umcl9T6xi85t4VpW07h8RwNJr4Cwc4EXawS9KFiGO70ubpNBcmAmDdOSNZR8T5Yg0IoOQf7DSfW9tAJRWcpXPaapWM1nVt8ObpukY8ie29GHNzAiBX7QVqI73/LIWMzn2FQylGMcieCW1TfBMhPYSoE5zFitLVZ5BhQnkadt6nGKt5/jMafI1Oq8Ak6zW4xrEaDVIGj4fD4SPiCknpQLy4ATyaVgFptVH2JFXb+wze3DDSTioV/iaD1+eZqWT92xD2Vu2X7af3+IJ6G7/UToVigpJnTzwTO42eWDnELsTtH/wUqH4="
      },
      {
        "text": "Slots",
        "href": "/guide/components/slots"
      },
      {
        "text": "Open example in the Playground",
        "href": "https://play.vuejs.org/#eNqNVE2PmzAQ/Ssj9kArLSHbrXpwk1X31mMPvS17cIxJrICNbJMmivLfO/7AEG2jRiDkefP85sNmztlr3y8OA89ItjJMi96+VFJ0vdIWfqqOQ6NVB/midIYj5sn9Sxlrkt9b14RXzXbiMElEO5IAKsmPnljzhg6thbNDmcLdkktrSADAJ/IYlj5MXEc9Z1w8VFNLP30ed2luBy1HC4UHrVH2N90QyJ1kHnUALN1gtLeIQu6juEUMkb8H5sXHqiS+qzK1Cw3Lu76llqMFsKrFAVhLjVlXWc07VWUeR89msFbhhhAWDkWjNJIwPgjp06iy5CV7fgrOOTgKv+XoKIIgpnoGyiymSmZ1wnq9dqJweZ8p/GCtYHtUmBMdLXFitgDnc9ju68b0yxDO1WzRTEcFRLiUJsEqSw3wwi+rMpFDj0psEq5W5ax1aBp7at1y4foWzq5R0hYN7UR7ImCoNIXhWjTfnW+jdM01gaf+CEa1ooYHzvnMVWhaiwEP90t/9HBP61rILQJL3POMHw93VG+FLKzqUYx3c2yjsOaOwNeRO2B8zKHlzBKQWJNH1YHrplV/iiMBOliFILYNK5mOKdSTMviGCTyNojFdTKBoeWNT3s8f/Vpsd7cIV61gjHkXnotR6OqVkJbrQKdsv9VqkDWBh2bpnn8VXaDcHPexE4wFzsojO9eDUOSVPF+65wN/EW7sHRsi5XaFqaexn+EH9Xcpe8zG2eWG3O0/NVzUaeJMk+jGhUXlNPXulw5j8w7t2bi8X32cuf/Vv/wF/SL98A=="
      },
      {
        "text": "Open example in the Playground",
        "href": "https://play.vuejs.org/#eNqNVMGOmzAQ/ZURe2BXCiHbrXpwk1X31mMPvS1V5RiTWAEb2SZNhPLvHdvggLZRE6TIM/P8/N5gpk/e2nZ57HhCkrVhWrQWDLdd+1pI0bRKW/iuGg6VVg2ky9wFDp7G8g9lrIl1H80Bb5rtxfFKMcRzUA+aV3AZQKEEhWRKGgus05pL+5NuYeNwj6mTkT4VckRYujVY63GT17twC6/Fr4YjC3kp5DoPNtEgBpY3bU0txwhgXYojsJoasymSkjeqSHweK9vOWoUbXIC/Y1YpjaDH3wt39hMI6TUUSYSQAz8jArPT5Mj+nmIhC6zpAu1TZlEhmXndbBwpXH5NGL6xWrADMsyaMj1lkAzQ92E7mvYe8nCcM24xZApbL5ECiHCSnP73KyseGnvh6V/XedwS2pVjv3C1ziddxNDYc+2WS9fC8E4qJW1W0UbUZwKGSpMZrkX11dW2SpdcE3huT2BULUp44JxPSpmmpegMgU/tyadbWpZC7jCxwj0v+OfTDdU7ITOrWiTjzTS3Vei8IfB5xHZ4PmqoObMEJHryWXXkuqrVn+xEgHZWYRKbh06uLyv4iQq+oIDnkXSQiwKymlc26n75WNdit78FmLWCMeZL+GKMwlKrhLRcBzhlh51WnSwJPFQr9/zLdIZ007w/O6bR4MQe2bseBJMzer5yzwf8MtzbOzYMkNsOY0+HfoZv1d+lZJGMg8fNqdsfbbio4b77uRVv7I0Li8xxZN1PHWbeHdyTWXc/+zgw/8t/+QsROe9h"
      },
      {
        "text": "<KeepAlive> component",
        "href": "/guide/built-ins/keep-alive"
      },
      {
        "text": "a few specific elements",
        "href": "https://html.spec.whatwg.org/multipage/syntax.html#void-elements"
      },
      {
        "text": "is attribute",
        "href": "/api/built-in-special-attributes#is"
      },
      {
        "text": "customized built-in elements",
        "href": "https://html.spec.whatwg.org/multipage/custom-elements.html#custom-elements-customized-builtin-example"
      },
      {
        "text": "Examples",
        "href": "/examples/"
      },
      {
        "text": "Edit this page on GitHub",
        "href": "https://github.com/vuejs/docs/edit/main/src/guide/essentials/component-basics.md"
      }
    ],
    "meta": {
      "description": "Vue.js - The Progressive JavaScript Framework",
      "keywords": ""
    },
    "summary": "Components Basics  Watch an interactive video lesson on Scrimba Components allow us to split the UI into independent and reusable pieces, and think about each piece in isolation",
    "tags": [
      "react",
      "vue",
      "angular",
      "javascript",
      "typescript",
      "css",
      "html",
      "vite",
      "components",
      "basics"
    ],
    "id": "components-basics-componentbasicshtml-part-1",
    "quality": 100
  },
  {
    "title": "Props",
    "url": "https://vuejs.org/guide/components/props.html",
    "category": "vue",
    "content": "Props This page assumes you've already read the Components Basics. Read that first if you are new to components.Watch a free video lesson on Vue SchoolProps Declaration Vue components require explicit props declaration so that Vue knows what external props passed to the component should be treated as fallthrough attributes (which will be discussed in its dedicated section).In SFCs using script setup, props can be declared using the defineProps() macro:vuescript setup const props = defineProps(['foo']) console.log(props.foo) /scriptIn non-script setup components, props are declared using the props option:jsexport default { props: ['foo'], setup(props) { // setup() receives props as the first argument. console.log(props.foo) } }Notice the argument passed to defineProps() is the same as the value provided to the props options: the same props options API is shared between the two declaration styles.Props are declared using the props option:jsexport default { props: ['foo'], created() { // props are exposed on this console.log(this.foo) } }In addition to declaring props using an array of strings, we can also use the object syntax:jsexport default { props: { title: String, likes: Number } }js// in script setup defineProps({ title: String, likes: Number })js// in non-script setup export default { props: { title: String, likes: Number } }For each property in the object declaration syntax, the key is the name of the prop, while the value should be the constructor function of the expected type.This not only documents your component, but will also warn other developers using your component in the browser console if they pass the wrong type. We will discuss more details about prop validation further down this page.See also: Typing Component Props If you are using TypeScript with script setup, it's also possible to declare props using pure type annotations:vuescript setup lang=\"ts\" defineProps{ title?: string likes?: number }() /scriptMore details: Typing Component Props Reactive Props Destructure Vue's reactivity system tracks state usage based on property access. E.g. when you access props.foo in a computed getter or a watcher, the foo prop gets tracked as a dependency.So, given the following code:jsconst { foo } = defineProps(['foo']) watchEffect(() = { // runs only once before 3.5 // re-runs when the \"foo\" prop changes in 3.5+ console.log(foo) })In version 3.4 and below, foo is an actual constant and will never change. In version 3.5 and above, Vue's compiler automatically prepends props. when code in the same script setup block accesses variables destructured from defineProps. Therefore the code above becomes equivalent to the following:jsconst props = defineProps(['foo']) watchEffect(() = { // foo transformed to props.foo by the compiler console.log(props.foo) })In addition, you can use JavaScript's native default value syntax to declare default values for the props. This is particularly useful when using the type-based props declaration:tsconst { foo = 'hello' } = defineProps{ foo?: string }()If you prefer to have more visual distinction between destructured props and normal variables in your IDE, Vue's VSCode extension provides a setting to enable inlay-hints for destructured props.Passing Destructured Props into Functions When we pass a destructured prop into a function, e.g.:jsconst { foo } = defineProps(['foo']) watch(foo, /* ... */)This will not work as expected because it is equivalent to watch(props.foo, ...) - we are passing a value instead of a reactive data source to watch. In fact, Vue's compiler will catch such cases and throw a warning.Similar to how we can watch a normal prop with watch(() = props.foo, ...), we can watch a destructured prop also by wrapping it in a getter:jswatch(() = foo, /* ... */)In addition, this is the recommended approach when we need to pass a destructured prop into an external function while retaining reactivity:jsuseComposable(() = foo)The external function can call the getter (or normalize it with toValue) when it needs to track changes of the provided prop, e.g. in a computed or watcher getter.Prop Passing Details Prop Name Casing We declare long prop names using camelCase because this avoids having to use quotes when using them as property keys, and allows us to reference them directly in template expressions because they are valid JavaScript identifiers:jsdefineProps({ greetingMessage: String })jsexport default { props: { greetingMessage: String } }templatespan{{ greetingMessage }}/spanTechnically, you can also use camelCase when passing props to a child component (except in in-DOM templates). However, the convention is using kebab-case in all cases to align with HTML attributes:templateMyComponent greeting-message=\"hello\" /We use PascalCase for component tags when possible because it improves template readability by differentiating Vue components from native elements. However, there isn't as much practical benefit in using camelCase when passing props, so we choose to follow each language's conventions.Static vs. Dynamic Props So far, you've seen props passed as static values, like in:templateBlogPost title=\"My journey with Vue\" /You've also seen props assigned dynamically with v-bind or its : shortcut, such as in:template!-- Dynamically assign the value of a variable -- BlogPost :title=\"post.title\" / !-- Dynamically assign the value of a complex expression -- BlogPost :title=\"post.title + ' by ' + post.author.name\" /Passing Different Value Types In the two examples above, we happen to pass string values, but any type of value can be passed to a prop.Number template!-- Even though 42 is static, we need v-bind to tell Vue that -- !-- this is a JavaScript expression rather than a string. -- BlogPost :likes=\"42\" / !-- Dynamically assign to the value of a variable. -- BlogPost :likes=\"post.likes\" /Boolean template!-- Including the prop with no value will imply true. -- BlogPost is-published / !-- Even though false is static, we need v-bind to tell Vue that -- !-- this is a JavaScript expression rather than a string. -- BlogPost :is-published=\"false\" / !-- Dynamically assign to the value of a variable. -- BlogPost :is-published=\"post.isPublished\" /Array template!-- Even though the array is static, we need v-bind to tell Vue that -- !-- this is a JavaScript expression rather than a string. -- BlogPost :comment-ids=\"[234, 266, 273]\" / !-- Dynamically assign to the value of a variable. -- BlogPost :comment-ids=\"post.commentIds\" /Object template!-- Even though the object is static, we need v-bind to tell Vue that -- !-- this is a JavaScript expression rather than a string. -- BlogPost :author=\"{ name: 'Veronica', company: 'Veridian Dynamics' }\" / !-- Dynamically assign to the value of a variable. -- BlogPost :author=\"post.author\" /Binding Multiple Properties Using an Object If you want to pass all the properties of an object as props, you can use v-bind without an argument (v-bind instead of :prop-name). For example, given a post object:jsexport default { data() { return { post: { id: 1, title: 'My Journey with Vue' } } } }jsconst post = { id: 1, title: 'My Journey with Vue' }The following template:templateBlogPost v-bind=\"post\" /Will be equivalent to:templateBlogPost :id=\"post.id\" :title=\"post.title\" /One-Way Data Flow All props form a one-way-down binding between the child property and the parent one: when the parent property updates, it will flow down to the child, but not the other way around. This prevents child components from accidentally mutating the parent's state, which can make your app's data flow harder to understand.In addition, every time the parent component is updated, all props in the child component will be refreshed with the latest value. This means you should not attempt to mutate a prop inside a child component. If you do, Vue will warn you in the console:jsconst props = defineProps(['foo']) //  warning, props are readonly! props.foo = 'bar'jsexport default { props: ['foo'], created() { //  warning, props are readonly! this.foo = 'bar' } }There are usually two cases where it's tempting to mutate a prop:The prop is used to pass in an initial value; the child component wants to use it as a local data property afterwards. In this case, it's best to define a local data property that uses the prop as its initial value:jsconst props = defineProps(['initialCounter']) // counter only uses props.initialCounter as the initial value; // it is disconnected from future prop updates. const counter = ref(props.initialCounter)jsexport default { props: ['initialCounter'], data() { return { // counter only uses this.initialCounter as the initial value; // it is disconnected from future prop updates. counter: this.initialCounter } } }The prop is passed in as a raw value that needs to be transformed. In this case, it's best to define a computed property using the prop's value:jsconst props = defineProps(['size']) // computed property that auto-updates when the prop changes const normalizedSize = computed(() = props.size.trim().toLowerCase())jsexport default { props: ['size'], computed: { // computed property that auto-updates when the prop changes normalizedSize() { return this.size.trim().toLowerCase() } } }Mutating Object / Array Props When objects and arrays are passed as props, while the child component cannot mutate the prop binding, it will be able to mutate the object or array's nested properties. This is because in JavaScript objects and arrays are passed by reference, and it is unreasonably expensive for Vue to prevent such mutations.The main drawback of such mutations is that it allows the child component to affect parent state in a way that isn't obvious to the parent component, potentially making it more difficult to reason about the data flow in the future. As a best practice, you should avoid such mutations unless the parent and child are tightly coupled by design. In most cases, the child should emit an event to let the parent perform the mutation.Prop Validation Components can specify requirements for their props, such as the types you've already seen. If a requirement is not met, Vue will warn you in the browser's JavaScript console. This is especially useful when developing a component that is intended to be used by others.To specify prop validations, you can provide an object with validation requirements to the defineProps() macroprops option, instead of an array of strings. For example:jsdefineProps({ // Basic type check // (null and undefined values will allow any type) propA: Number, // Multiple possible types propB: [String, Number], // Required string propC: { type: String, required: true }, // Required but nullable string propD: { type: [String, null], required: true }, // Number with a default value propE: { type: Number, default: 100 }, // Object with a default value propF: { type: Object, // Object or array defaults must be returned from // a factory function. The function receives the raw // props received by the component as the argument. default(rawProps) { return { message: 'hello' } } }, // Custom validator function // full props passed as 2nd argument in 3.4+ propG: { validator(value, props) { // The value must match one of these strings return ['success', 'warning', 'danger'].includes(value) } }, // Function with a default value propH: { type: Function, // Unlike object or array default, this is not a factory // function - this is a function to serve as a default value default() { return 'Default function' } } })TIPCode inside the defineProps() argument cannot access other variables declared in script setup, because the entire expression is moved to an outer function scope when compiled.jsexport default { props: { // Basic type check // (null and undefined values will allow any type) propA: Number, // Multiple possible types propB: [String, Number], // Required string propC: { type: String, required: true }, // Required but nullable string propD: { type: [String, null], required: true }, // Number with a default value propE: { type: Number, default: 100 }, // Object with a default value propF: { type: Object, // Object or array defaults must be returned from // a factory function. The function receives the raw // props received by the component as the argument. default(rawProps) { return { message: 'hello' } } }, // Custom validator function // full props passed as 2nd argument in 3.4+ propG: { validator(value, props) { // The value must match one of these strings return ['success', 'warning', 'danger'].includes(value) } }, // Function with a default value propH: { type: Function, // Unlike object or array default, this is not a factory // function - this is a function to serve as a default value default() { return 'Default function' } } } }Additional details:All props are optional by default, unless required: true is specified.An absent optional prop other than Boolean will have undefined value.The Boolean absent props will be cast to false. You can change this by setting a default for it  i.e.: default: undefined to behave as a non-Boolean prop.If a default value is specified, it will be used if the resolved prop value is undefined - this includes both when the prop is absent, or an explicit undefined value is passed.When prop validation fails, Vue will produce a console warning (if using the development build).If using Type-based props declarations , Vue will try its best to compile the type annotations into equivalent runtime prop declarations. For example, defineProps{ msg: string } will be compiled into { msg: { type: String, required: true }}.NoteNote that props are validated before a component instance is created, so instance properties (e.g. data, computed, etc.) will not be available inside default or validator functions.Runtime Type Checks The type can be one of the following native constructors:StringNumberBooleanArrayObjectDateFunctionSymbolErrorIn addition, type can also be a custom class or constructor function and the assertion will be made with an instanceof check. For example, given the following class:jsclass Person { constructor(firstName, lastName) { this.firstName = firstName this.lastName = lastName } }You could use it as a prop's type:jsdefineProps({ author: Person })jsexport default { props: { author: Person } }Vue will use instanceof Person to validate whether the value of the author prop is indeed an instance of the Person class.Nullable Type If the type is required but nullable, you can use the array syntax that includes null:jsdefineProps({ id: { type: [String, null], required: true } })jsexport default { props: { id: { type: [String, null], required: true } } }Note that if type is just null without using the array syntax, it will allow any type.Boolean Casting Props with Boolean type have special casting rules to mimic the behavior of native boolean attributes. Given a MyComponent with the following declaration:jsdefineProps({ disabled: Boolean })jsexport default { props: { disabled: Boolean } }The component can be used like this:template!-- equivalent of passing :disabled=\"true\" -- MyComponent disabled / !-- equivalent of passing :disabled=\"false\" -- MyComponent /When a prop is declared to allow multiple types, the casting rules for Boolean will also be applied. However, there is an edge when both String and Boolean are allowed - the Boolean casting rule only applies if Boolean appears before String:js// disabled will be casted to true defineProps({ disabled: [Boolean, Number] }) // disabled will be casted to true defineProps({ disabled: [Boolean, String] }) // disabled will be casted to true defineProps({ disabled: [Number, Boolean] }) // disabled will be parsed as an empty string (disabled=\"\") defineProps({ disabled: [String, Boolean] })js// disabled will be casted to true export default { props: { disabled: [Boolean, Number] } } // disabled will be casted to true export default { props: { disabled: [Boolean, String] } } // disabled will be casted to true export default { props: { disabled: [Number, Boolean] } } // disabled will be parsed as an empty string (disabled=\"\") export default { props: { disabled: [String, Boolean] } }Edit this page on GitHub",
    "headings": [
      {
        "level": 1,
        "text": "Props ​",
        "id": "props"
      },
      {
        "level": 2,
        "text": "Props Declaration ​",
        "id": "props-declaration"
      },
      {
        "level": 2,
        "text": "Reactive Props Destructure  ​",
        "id": "reactive-props-destructure"
      },
      {
        "level": 2,
        "text": "Prop Passing Details ​",
        "id": "prop-passing-details"
      },
      {
        "level": 2,
        "text": "One-Way Data Flow ​",
        "id": "one-way-data-flow"
      },
      {
        "level": 2,
        "text": "Prop Validation ​",
        "id": "prop-validation"
      },
      {
        "level": 2,
        "text": "Boolean Casting ​",
        "id": "boolean-casting"
      },
      {
        "level": 3,
        "text": "Passing Destructured Props into Functions ​",
        "id": "passing-destructured-props-into-functions"
      },
      {
        "level": 3,
        "text": "Prop Name Casing ​",
        "id": "prop-name-casing"
      },
      {
        "level": 3,
        "text": "Static vs. Dynamic Props ​",
        "id": "static-vs-dynamic-props"
      },
      {
        "level": 3,
        "text": "Passing Different Value Types ​",
        "id": "passing-different-value-types"
      },
      {
        "level": 3,
        "text": "Binding Multiple Properties Using an Object ​",
        "id": "binding-multiple-properties-using-an-object"
      },
      {
        "level": 3,
        "text": "Mutating Object / Array Props ​",
        "id": "mutating-object-array-props"
      },
      {
        "level": 3,
        "text": "Runtime Type Checks ​",
        "id": "runtime-type-checks"
      },
      {
        "level": 3,
        "text": "Nullable Type ​",
        "id": "nullable-type"
      },
      {
        "level": 4,
        "text": "Number ​",
        "id": "number"
      },
      {
        "level": 4,
        "text": "Boolean ​",
        "id": "boolean"
      },
      {
        "level": 4,
        "text": "Array ​",
        "id": "array"
      },
      {
        "level": 4,
        "text": "Object ​",
        "id": "object"
      }
    ],
    "codeBlocks": [
      {
        "language": "text",
        "code": "<script setup>"
      },
      {
        "language": "text",
        "code": "defineProps()"
      },
      {
        "language": "text",
        "code": "<script setup>\nconst props = defineProps(['foo'])\n\nconsole.log(props.foo)\n</script>"
      },
      {
        "language": "text",
        "code": "<script setup>\nconst props = defineProps(['foo'])\n\nconsole.log(props.foo)\n</script>"
      },
      {
        "language": "text",
        "code": "<script setup>"
      },
      {
        "language": "text",
        "code": "export default {\n  props: ['foo'],\n  setup(props) {\n    // setup() receives props as the first argument.\n    console.log(props.foo)\n  }\n}"
      },
      {
        "language": "text",
        "code": "export default {\n  props: ['foo'],\n  setup(props) {\n    // setup() receives props as the first argument.\n    console.log(props.foo)\n  }\n}"
      },
      {
        "language": "text",
        "code": "defineProps()"
      },
      {
        "language": "text",
        "code": "export default {\n  props: ['foo'],\n  created() {\n    // props are exposed on `this`\n    console.log(this.foo)\n  }\n}"
      },
      {
        "language": "text",
        "code": "export default {\n  props: ['foo'],\n  created() {\n    // props are exposed on `this`\n    console.log(this.foo)\n  }\n}"
      },
      {
        "language": "text",
        "code": "export default {\n  props: {\n    title: String,\n    likes: Number\n  }\n}"
      },
      {
        "language": "text",
        "code": "export default {\n  props: {\n    title: String,\n    likes: Number\n  }\n}"
      },
      {
        "language": "text",
        "code": "// in <script setup>\ndefineProps({\n  title: String,\n  likes: Number\n})"
      },
      {
        "language": "text",
        "code": "// in <script setup>\ndefineProps({\n  title: String,\n  likes: Number\n})"
      },
      {
        "language": "text",
        "code": "// in non-<script setup>\nexport default {\n  props: {\n    title: String,\n    likes: Number\n  }\n}"
      },
      {
        "language": "text",
        "code": "// in non-<script setup>\nexport default {\n  props: {\n    title: String,\n    likes: Number\n  }\n}"
      },
      {
        "language": "text",
        "code": "<script setup>"
      },
      {
        "language": "text",
        "code": "<script setup lang=\"ts\">\ndefineProps<{\n  title?: string\n  likes?: number\n}>()\n</script>"
      },
      {
        "language": "text",
        "code": "<script setup lang=\"ts\">\ndefineProps<{\n  title?: string\n  likes?: number\n}>()\n</script>"
      },
      {
        "language": "text",
        "code": "const { foo } = defineProps(['foo'])\n\nwatchEffect(() => {\n  // runs only once before 3.5\n  // re-runs when the \"foo\" prop changes in 3.5+\n  console.log(foo)\n})"
      },
      {
        "language": "text",
        "code": "const { foo } = defineProps(['foo'])\n\nwatchEffect(() => {\n  // runs only once before 3.5\n  // re-runs when the \"foo\" prop changes in 3.5+\n  console.log(foo)\n})"
      },
      {
        "language": "text",
        "code": "<script setup>"
      },
      {
        "language": "text",
        "code": "defineProps"
      },
      {
        "language": "text",
        "code": "const props = defineProps(['foo'])\n\nwatchEffect(() => {\n  // `foo` transformed to `props.foo` by the compiler\n  console.log(props.foo)\n})"
      },
      {
        "language": "text",
        "code": "const props = defineProps(['foo'])\n\nwatchEffect(() => {\n  // `foo` transformed to `props.foo` by the compiler\n  console.log(props.foo)\n})"
      },
      {
        "language": "text",
        "code": "const { foo = 'hello' } = defineProps<{ foo?: string }>()"
      },
      {
        "language": "text",
        "code": "const { foo = 'hello' } = defineProps<{ foo?: string }>()"
      },
      {
        "language": "text",
        "code": "const { foo } = defineProps(['foo'])\n\nwatch(foo, /* ... */)"
      },
      {
        "language": "text",
        "code": "const { foo } = defineProps(['foo'])\n\nwatch(foo, /* ... */)"
      },
      {
        "language": "text",
        "code": "watch(props.foo, ...)"
      },
      {
        "language": "text",
        "code": "watch(() => props.foo, ...)"
      },
      {
        "language": "text",
        "code": "watch(() => foo, /* ... */)"
      },
      {
        "language": "text",
        "code": "watch(() => foo, /* ... */)"
      },
      {
        "language": "text",
        "code": "useComposable(() => foo)"
      },
      {
        "language": "text",
        "code": "useComposable(() => foo)"
      },
      {
        "language": "text",
        "code": "defineProps({\n  greetingMessage: String\n})"
      },
      {
        "language": "text",
        "code": "defineProps({\n  greetingMessage: String\n})"
      },
      {
        "language": "text",
        "code": "export default {\n  props: {\n    greetingMessage: String\n  }\n}"
      },
      {
        "language": "text",
        "code": "export default {\n  props: {\n    greetingMessage: String\n  }\n}"
      },
      {
        "language": "text",
        "code": "<span>{{ greetingMessage }}</span>"
      },
      {
        "language": "text",
        "code": "<span>{{ greetingMessage }}</span>"
      },
      {
        "language": "text",
        "code": "<MyComponent greeting-message=\"hello\" />"
      },
      {
        "language": "text",
        "code": "<MyComponent greeting-message=\"hello\" />"
      },
      {
        "language": "text",
        "code": "<BlogPost title=\"My journey with Vue\" />"
      },
      {
        "language": "text",
        "code": "<BlogPost title=\"My journey with Vue\" />"
      },
      {
        "language": "text",
        "code": "<!-- Dynamically assign the value of a variable -->\n<BlogPost :title=\"post.title\" />\n\n<!-- Dynamically assign the value of a complex expression -->\n<BlogPost :title=\"post.title + ' by ' + post.author.name\" />"
      },
      {
        "language": "text",
        "code": "<!-- Dynamically assign the value of a variable -->\n<BlogPost :title=\"post.title\" />\n\n<!-- Dynamically assign the value of a complex expression -->\n<BlogPost :title=\"post.title + ' by ' + post.author.name\" />"
      },
      {
        "language": "text",
        "code": "<!-- Even though `42` is static, we need v-bind to tell Vue that -->\n<!-- this is a JavaScript expression rather than a string.       -->\n<BlogPost :likes=\"42\" />\n\n<!-- Dynamically assign to the value of a variable. -->\n<BlogPost :likes=\"post.likes\" />"
      },
      {
        "language": "text",
        "code": "<!-- Even though `42` is static, we need v-bind to tell Vue that -->\n<!-- this is a JavaScript expression rather than a string.       -->\n<BlogPost :likes=\"42\" />\n\n<!-- Dynamically assign to the value of a variable. -->\n<BlogPost :likes=\"post.likes\" />"
      },
      {
        "language": "text",
        "code": "<!-- Including the prop with no value will imply `true`. -->\n<BlogPost is-published />\n\n<!-- Even though `false` is static, we need v-bind to tell Vue that -->\n<!-- this is a JavaScript expression rather than a string.          -->\n<BlogPost :is-published=\"false\" />\n\n<!-- Dynamically assign to the value of a variable. -->\n<BlogPost :is-published=\"post.isPublished\" />"
      },
      {
        "language": "text",
        "code": "<!-- Including the prop with no value will imply `true`. -->\n<BlogPost is-published />\n\n<!-- Even though `false` is static, we need v-bind to tell Vue that -->\n<!-- this is a JavaScript expression rather than a string.          -->\n<BlogPost :is-published=\"false\" />\n\n<!-- Dynamically assign to the value of a variable. -->\n<BlogPost :is-published=\"post.isPublished\" />"
      },
      {
        "language": "text",
        "code": "<!-- Even though the array is static, we need v-bind to tell Vue that -->\n<!-- this is a JavaScript expression rather than a string.            -->\n<BlogPost :comment-ids=\"[234, 266, 273]\" />\n\n<!-- Dynamically assign to the value of a variable. -->\n<BlogPost :comment-ids=\"post.commentIds\" />"
      },
      {
        "language": "text",
        "code": "<!-- Even though the array is static, we need v-bind to tell Vue that -->\n<!-- this is a JavaScript expression rather than a string.            -->\n<BlogPost :comment-ids=\"[234, 266, 273]\" />\n\n<!-- Dynamically assign to the value of a variable. -->\n<BlogPost :comment-ids=\"post.commentIds\" />"
      },
      {
        "language": "text",
        "code": "<!-- Even though the object is static, we need v-bind to tell Vue that -->\n<!-- this is a JavaScript expression rather than a string.             -->\n<BlogPost\n  :author=\"{\n    name: 'Veronica',\n    company: 'Veridian Dynamics'\n  }\"\n />\n\n<!-- Dynamically assign to the value of a variable. -->\n<BlogPost :author=\"post.author\" />"
      },
      {
        "language": "text",
        "code": "<!-- Even though the object is static, we need v-bind to tell Vue that -->\n<!-- this is a JavaScript expression rather than a string.             -->\n<BlogPost\n  :author=\"{\n    name: 'Veronica',\n    company: 'Veridian Dynamics'\n  }\"\n />\n\n<!-- Dynamically assign to the value of a variable. -->\n<BlogPost :author=\"post.author\" />"
      },
      {
        "language": "text",
        "code": "export default {\n  data() {\n    return {\n      post: {\n        id: 1,\n        title: 'My Journey with Vue'\n      }\n    }\n  }\n}"
      },
      {
        "language": "text",
        "code": "export default {\n  data() {\n    return {\n      post: {\n        id: 1,\n        title: 'My Journey with Vue'\n      }\n    }\n  }\n}"
      },
      {
        "language": "text",
        "code": "const post = {\n  id: 1,\n  title: 'My Journey with Vue'\n}"
      },
      {
        "language": "text",
        "code": "const post = {\n  id: 1,\n  title: 'My Journey with Vue'\n}"
      },
      {
        "language": "text",
        "code": "<BlogPost v-bind=\"post\" />"
      },
      {
        "language": "text",
        "code": "<BlogPost v-bind=\"post\" />"
      },
      {
        "language": "text",
        "code": "<BlogPost :id=\"post.id\" :title=\"post.title\" />"
      },
      {
        "language": "text",
        "code": "<BlogPost :id=\"post.id\" :title=\"post.title\" />"
      },
      {
        "language": "text",
        "code": "const props = defineProps(['foo'])\n\n// ❌ warning, props are readonly!\nprops.foo = 'bar'"
      },
      {
        "language": "text",
        "code": "const props = defineProps(['foo'])\n\n// ❌ warning, props are readonly!\nprops.foo = 'bar'"
      },
      {
        "language": "text",
        "code": "export default {\n  props: ['foo'],\n  created() {\n    // ❌ warning, props are readonly!\n    this.foo = 'bar'\n  }\n}"
      },
      {
        "language": "text",
        "code": "export default {\n  props: ['foo'],\n  created() {\n    // ❌ warning, props are readonly!\n    this.foo = 'bar'\n  }\n}"
      },
      {
        "language": "text",
        "code": "const props = defineProps(['initialCounter'])\n\n// counter only uses props.initialCounter as the initial value;\n// it is disconnected from future prop updates.\nconst counter = ref(props.initialCounter)"
      },
      {
        "language": "text",
        "code": "const props = defineProps(['initialCounter'])\n\n// counter only uses props.initialCounter as the initial value;\n// it is disconnected from future prop updates.\nconst counter = ref(props.initialCounter)"
      },
      {
        "language": "text",
        "code": "export default {\n  props: ['initialCounter'],\n  data() {\n    return {\n      // counter only uses this.initialCounter as the initial value;\n      // it is disconnected from future prop updates.\n      counter: this.initialCounter\n    }\n  }\n}"
      },
      {
        "language": "text",
        "code": "export default {\n  props: ['initialCounter'],\n  data() {\n    return {\n      // counter only uses this.initialCounter as the initial value;\n      // it is disconnected from future prop updates.\n      counter: this.initialCounter\n    }\n  }\n}"
      },
      {
        "language": "text",
        "code": "const props = defineProps(['size'])\n\n// computed property that auto-updates when the prop changes\nconst normalizedSize = computed(() => props.size.trim().toLowerCase())"
      },
      {
        "language": "text",
        "code": "const props = defineProps(['size'])\n\n// computed property that auto-updates when the prop changes\nconst normalizedSize = computed(() => props.size.trim().toLowerCase())"
      },
      {
        "language": "text",
        "code": "export default {\n  props: ['size'],\n  computed: {\n    // computed property that auto-updates when the prop changes\n    normalizedSize() {\n      return this.size.trim().toLowerCase()\n    }\n  }\n}"
      },
      {
        "language": "text",
        "code": "export default {\n  props: ['size'],\n  computed: {\n    // computed property that auto-updates when the prop changes\n    normalizedSize() {\n      return this.size.trim().toLowerCase()\n    }\n  }\n}"
      },
      {
        "language": "text",
        "code": "defineProps()"
      },
      {
        "language": "text",
        "code": "defineProps({\n  // Basic type check\n  //  (`null` and `undefined` values will allow any type)\n  propA: Number,\n  // Multiple possible types\n  propB: [String, Number],\n  // Required string\n  propC: {\n    type: String,\n    required: true\n  },\n  // Required but nullable string\n  propD: {\n    type: [String, null],\n    required: true\n  },\n  // Number with a default value\n  propE: {\n    type: Number,\n    default: 100\n  },\n  // Object with a default value\n  propF: {\n    type: Object,\n    // Object or array defaults must be returned from\n    // a factory function. The function receives the raw\n    // props received by the component as the argument.\n    default(rawProps) {\n      return { message: 'hello' }\n    }\n  },\n  // Custom validator function\n  // full props passed as 2nd argument in 3.4+\n  propG: {\n    validator(value, props) {\n      // The value must match one of these strings\n      return ['success', 'warning', 'danger'].includes(value)\n    }\n  },\n  // Function with a default value\n  propH: {\n    type: Function,\n    // Unlike object or array default, this is not a factory\n    // function - this is a function to serve as a default value\n    default() {\n      return 'Default function'\n    }\n  }\n})"
      },
      {
        "language": "text",
        "code": "defineProps({\n  // Basic type check\n  //  (`null` and `undefined` values will allow any type)\n  propA: Number,\n  // Multiple possible types\n  propB: [String, Number],\n  // Required string\n  propC: {\n    type: String,\n    required: true\n  },\n  // Required but nullable string\n  propD: {\n    type: [String, null],\n    required: true\n  },\n  // Number with a default value\n  propE: {\n    type: Number,\n    default: 100\n  },\n  // Object with a default value\n  propF: {\n    type: Object,\n    // Object or array defaults must be returned from\n    // a factory function. The function receives the raw\n    // props received by the component as the argument.\n    default(rawProps) {\n      return { message: 'hello' }\n    }\n  },\n  // Custom validator function\n  // full props passed as 2nd argument in 3.4+\n  propG: {\n    validator(value, props) {\n      // The value must match one of these strings\n      return ['success', 'warning', 'danger'].includes(value)\n    }\n  },\n  // Function with a default value\n  propH: {\n    type: Function,\n    // Unlike object or array default, this is not a factory\n    // function - this is a function to serve as a default value\n    default() {\n      return 'Default function'\n    }\n  }\n})"
      },
      {
        "language": "text",
        "code": "defineProps()"
      },
      {
        "language": "text",
        "code": "<script setup>"
      },
      {
        "language": "text",
        "code": "export default {\n  props: {\n    // Basic type check\n    //  (`null` and `undefined` values will allow any type)\n    propA: Number,\n    // Multiple possible types\n    propB: [String, Number],\n    // Required string\n    propC: {\n      type: String,\n      required: true\n    },\n    // Required but nullable string\n    propD: {\n      type: [String, null],\n      required: true\n    },\n    // Number with a default value\n    propE: {\n      type: Number,\n      default: 100\n    },\n    // Object with a default value\n    propF: {\n      type: Object,\n      // Object or array defaults must be returned from\n      // a factory function. The function receives the raw\n      // props received by the component as the argument.\n      default(rawProps) {\n        return { message: 'hello' }\n      }\n    },\n    // Custom validator function\n    // full props passed as 2nd argument in 3.4+\n    propG: {\n      validator(value, props) {\n        // The value must match one of these strings\n        return ['success', 'warning', 'danger'].includes(value)\n      }\n    },\n    // Function with a default value\n    propH: {\n      type: Function,\n      // Unlike object or array default, this is not a factory\n      // function - this is a function to serve as a default value\n      default() {\n        return 'Default function'\n      }\n    }\n  }\n}"
      },
      {
        "language": "text",
        "code": "export default {\n  props: {\n    // Basic type check\n    //  (`null` and `undefined` values will allow any type)\n    propA: Number,\n    // Multiple possible types\n    propB: [String, Number],\n    // Required string\n    propC: {\n      type: String,\n      required: true\n    },\n    // Required but nullable string\n    propD: {\n      type: [String, null],\n      required: true\n    },\n    // Number with a default value\n    propE: {\n      type: Number,\n      default: 100\n    },\n    // Object with a default value\n    propF: {\n      type: Object,\n      // Object or array defaults must be returned from\n      // a factory function. The function receives the raw\n      // props received by the component as the argument.\n      default(rawProps) {\n        return { message: 'hello' }\n      }\n    },\n    // Custom validator function\n    // full props passed as 2nd argument in 3.4+\n    propG: {\n      validator(value, props) {\n        // The value must match one of these strings\n        return ['success', 'warning', 'danger'].includes(value)\n      }\n    },\n    // Function with a default value\n    propH: {\n      type: Function,\n      // Unlike object or array default, this is not a factory\n      // function - this is a function to serve as a default value\n      default() {\n        return 'Default function'\n      }\n    }\n  }\n}"
      },
      {
        "language": "text",
        "code": "required: true"
      },
      {
        "language": "text",
        "code": "default: undefined"
      },
      {
        "language": "text",
        "code": "defineProps<{ msg: string }>"
      },
      {
        "language": "text",
        "code": "{ msg: { type: String, required: true }}"
      },
      {
        "language": "text",
        "code": "class Person {\n  constructor(firstName, lastName) {\n    this.firstName = firstName\n    this.lastName = lastName\n  }\n}"
      },
      {
        "language": "text",
        "code": "class Person {\n  constructor(firstName, lastName) {\n    this.firstName = firstName\n    this.lastName = lastName\n  }\n}"
      },
      {
        "language": "text",
        "code": "defineProps({\n  author: Person\n})"
      },
      {
        "language": "text",
        "code": "defineProps({\n  author: Person\n})"
      },
      {
        "language": "text",
        "code": "export default {\n  props: {\n    author: Person\n  }\n}"
      },
      {
        "language": "text",
        "code": "export default {\n  props: {\n    author: Person\n  }\n}"
      },
      {
        "language": "text",
        "code": "instanceof Person"
      },
      {
        "language": "text",
        "code": "defineProps({\n  id: {\n    type: [String, null],\n    required: true\n  }\n})"
      },
      {
        "language": "text",
        "code": "defineProps({\n  id: {\n    type: [String, null],\n    required: true\n  }\n})"
      },
      {
        "language": "text",
        "code": "export default {\n  props: {\n    id: {\n      type: [String, null],\n      required: true\n    }\n  }\n}"
      },
      {
        "language": "text",
        "code": "export default {\n  props: {\n    id: {\n      type: [String, null],\n      required: true\n    }\n  }\n}"
      },
      {
        "language": "text",
        "code": "<MyComponent>"
      },
      {
        "language": "text",
        "code": "defineProps({\n  disabled: Boolean\n})"
      },
      {
        "language": "text",
        "code": "defineProps({\n  disabled: Boolean\n})"
      },
      {
        "language": "text",
        "code": "export default {\n  props: {\n    disabled: Boolean\n  }\n}"
      },
      {
        "language": "text",
        "code": "export default {\n  props: {\n    disabled: Boolean\n  }\n}"
      },
      {
        "language": "text",
        "code": "<!-- equivalent of passing :disabled=\"true\" -->\n<MyComponent disabled />\n\n<!-- equivalent of passing :disabled=\"false\" -->\n<MyComponent />"
      },
      {
        "language": "text",
        "code": "<!-- equivalent of passing :disabled=\"true\" -->\n<MyComponent disabled />\n\n<!-- equivalent of passing :disabled=\"false\" -->\n<MyComponent />"
      },
      {
        "language": "text",
        "code": "// disabled will be casted to true\ndefineProps({\n  disabled: [Boolean, Number]\n})\n\n// disabled will be casted to true\ndefineProps({\n  disabled: [Boolean, String]\n})\n\n// disabled will be casted to true\ndefineProps({\n  disabled: [Number, Boolean]\n})\n\n// disabled will be parsed as an empty string (disabled=\"\")\ndefineProps({\n  disabled: [String, Boolean]\n})"
      },
      {
        "language": "text",
        "code": "// disabled will be casted to true\ndefineProps({\n  disabled: [Boolean, Number]\n})\n\n// disabled will be casted to true\ndefineProps({\n  disabled: [Boolean, String]\n})\n\n// disabled will be casted to true\ndefineProps({\n  disabled: [Number, Boolean]\n})\n\n// disabled will be parsed as an empty string (disabled=\"\")\ndefineProps({\n  disabled: [String, Boolean]\n})"
      },
      {
        "language": "text",
        "code": "// disabled will be casted to true\nexport default {\n  props: {\n    disabled: [Boolean, Number]\n  }\n}\n\n// disabled will be casted to true\nexport default {\n  props: {\n    disabled: [Boolean, String]\n  }\n}\n\n// disabled will be casted to true\nexport default {\n  props: {\n    disabled: [Number, Boolean]\n  }\n}\n\n// disabled will be parsed as an empty string (disabled=\"\")\nexport default {\n  props: {\n    disabled: [String, Boolean]\n  }\n}"
      },
      {
        "language": "text",
        "code": "// disabled will be casted to true\nexport default {\n  props: {\n    disabled: [Boolean, Number]\n  }\n}\n\n// disabled will be casted to true\nexport default {\n  props: {\n    disabled: [Boolean, String]\n  }\n}\n\n// disabled will be casted to true\nexport default {\n  props: {\n    disabled: [Number, Boolean]\n  }\n}\n\n// disabled will be parsed as an empty string (disabled=\"\")\nexport default {\n  props: {\n    disabled: [String, Boolean]\n  }\n}"
      }
    ],
    "links": [
      {
        "text": "Components Basics",
        "href": "/guide/essentials/component-basics"
      },
      {
        "text": "Watch a free video lesson on Vue School",
        "href": "https://vueschool.io/lessons/vue-3-reusable-components-with-props?friend=vuejs"
      },
      {
        "text": "its dedicated section",
        "href": "/guide/components/attrs"
      },
      {
        "text": "props",
        "href": "/api/options-state#props"
      },
      {
        "text": "props",
        "href": "/api/options-state#props"
      },
      {
        "text": "Typing Component Props",
        "href": "/guide/typescript/options-api#typing-component-props"
      },
      {
        "text": "Typing Component Props",
        "href": "/guide/typescript/composition-api#typing-component-props"
      },
      {
        "text": "toValue",
        "href": "/api/reactivity-utilities#tovalue"
      },
      {
        "text": "in-DOM templates",
        "href": "/guide/essentials/component-basics#in-dom-template-parsing-caveats"
      },
      {
        "text": "PascalCase for component tags",
        "href": "/guide/components/registration#component-name-casing"
      },
      {
        "text": "v-bind without an argument",
        "href": "/guide/essentials/template-syntax#dynamically-binding-multiple-attributes"
      },
      {
        "text": "emit an event",
        "href": "/guide/components/events"
      },
      {
        "text": "Type-based props declarations",
        "href": "/api/sfc-script-setup#type-only-props-emit-declarations"
      },
      {
        "text": "Edit this page on GitHub",
        "href": "https://github.com/vuejs/docs/edit/main/src/guide/components/props.md"
      }
    ],
    "meta": {
      "description": "Vue.js - The Progressive JavaScript Framework",
      "keywords": ""
    },
    "summary": "Props This page assumes you've already read the Components Basics. Read that first if you are new to components",
    "tags": [
      "react",
      "vue",
      "angular",
      "javascript",
      "typescript",
      "css",
      "html",
      "vite",
      "props",
      "passing"
    ],
    "id": "props-propshtml-part-1",
    "quality": 80
  },
  {
    "title": "Component Events",
    "url": "https://vuejs.org/guide/components/events.html",
    "category": "vue",
    "content": "Component Events This page assumes you've already read the Components Basics. Read that first if you are new to components.Watch a free video lesson on Vue SchoolEmitting and Listening to Events A component can emit custom events directly in template expressions (e.g. in a v-on handler) using the built-in $emit method:template!-- MyComponent -- button @click=\"$emit('someEvent')\"Click Me/buttonThe $emit() method is also available on the component instance as this.$emit():jsexport default { methods: { submit() { this.$emit('someEvent') } } }The parent can then listen to it using v-on:templateMyComponent @some-event=\"callback\" /The .once modifier is also supported on component event listeners:templateMyComponent @some-event.once=\"callback\" /Like components and props, event names provide an automatic case transformation. Notice we emitted a camelCase event, but can listen for it using a kebab-cased listener in the parent. As with props casing, we recommend using kebab-cased event listeners in templates.TIPUnlike native DOM events, component emitted events do not bubble. You can only listen to the events emitted by a direct child component. If there is a need to communicate between sibling or deeply nested components, use an external event bus or a global state management solution.Event Arguments It's sometimes useful to emit a specific value with an event. For example, we may want the BlogPost component to be in charge of how much to enlarge the text by. In those cases, we can pass extra arguments to $emit to provide this value:templatebutton @click=\"$emit('increaseBy', 1)\" Increase by 1 /buttonThen, when we listen to the event in the parent, we can use an inline arrow function as the listener, which allows us to access the event argument:templateMyButton @increase-by=\"(n) = count += n\" /Or, if the event handler is a method:templateMyButton @increase-by=\"increaseCount\" /Then the value will be passed as the first parameter of that method:jsmethods: { increaseCount(n) { this.count += n } }jsfunction increaseCount(n) { count.value += n }TIPAll extra arguments passed to $emit() after the event name will be forwarded to the listener. For example, with $emit('foo', 1, 2, 3) the listener function will receive three arguments.Declaring Emitted Events A component can explicitly declare the events it will emit using the defineEmits() macroemits option:vuescript setup defineEmits(['inFocus', 'submit']) /scriptThe $emit method that we used in the template isn't accessible within the script setup section of a component, but defineEmits() returns an equivalent function that we can use instead:vuescript setup const emit = defineEmits(['inFocus', 'submit']) function buttonClick() { emit('submit') } /scriptThe defineEmits() macro cannot be used inside a function, it must be placed directly within script setup, as in the example above.If you're using an explicit setup function instead of script setup, events should be declared using the emits option, and the emit function is exposed on the setup() context:jsexport default { emits: ['inFocus', 'submit'], setup(props, ctx) { ctx.emit('submit') } }As with other properties of the setup() context, emit can safely be destructured:jsexport default { emits: ['inFocus', 'submit'], setup(props, { emit }) { emit('submit') } }jsexport default { emits: ['inFocus', 'submit'] }The emits option and defineEmits() macro also support an object syntax. If using TypeScript you can type arguments, which allows us to perform runtime validation of the payload of the emitted events:vuescript setup lang=\"ts\" const emit = defineEmits({ submit(payload: { email: string, password: string }) { // return true or false to indicate // validation pass / fail } }) /scriptIf you are using TypeScript with script setup, it's also possible to declare emitted events using pure type annotations:vuescript setup lang=\"ts\" const emit = defineEmits{ (e: 'change', id: number): void (e: 'update', value: string): void }() /scriptMore details: Typing Component Emits jsexport default { emits: { submit(payload: { email: string, password: string }) { // return true or false to indicate // validation pass / fail } } }See also: Typing Component Emits Although optional, it is recommended to define all emitted events in order to better document how a component should work. It also allows Vue to exclude known listeners from fallthrough attributes, avoiding edge cases caused by DOM events manually dispatched by 3rd party code.TIPIf a native event (e.g., click) is defined in the emits option, the listener will now only listen to component-emitted click events and no longer respond to native click events.Events Validation Similar to prop type validation, an emitted event can be validated if it is defined with the object syntax instead of the array syntax.To add validation, the event is assigned a function that receives the arguments passed to the this.$emitemit call and returns a boolean to indicate whether the event is valid or not.vuescript setup const emit = defineEmits({ // No validation click: null, // Validate submit event submit: ({ email, password }) = { if (email && password) { return true } else { console.warn('Invalid submit event payload!') return false } } }) function submitForm(email, password) { emit('submit', { email, password }) } /scriptjsexport default { emits: { // No validation click: null, // Validate submit event submit: ({ email, password }) = { if (email && password) { return true } else { console.warn('Invalid submit event payload!') return false } } }, methods: { submitForm(email, password) { this.$emit('submit', { email, password }) } } }Edit this page on GitHub",
    "headings": [
      {
        "level": 1,
        "text": "Component Events ​",
        "id": "component-events"
      },
      {
        "level": 2,
        "text": "Emitting and Listening to Events ​",
        "id": "emitting-and-listening-to-events"
      },
      {
        "level": 2,
        "text": "Event Arguments ​",
        "id": "event-arguments"
      },
      {
        "level": 2,
        "text": "Declaring Emitted Events ​",
        "id": "declaring-emitted-events"
      },
      {
        "level": 2,
        "text": "Events Validation ​",
        "id": "events-validation"
      }
    ],
    "codeBlocks": [
      {
        "language": "text",
        "code": "<!-- MyComponent -->\n<button @click=\"$emit('someEvent')\">Click Me</button>"
      },
      {
        "language": "text",
        "code": "<!-- MyComponent -->\n<button @click=\"$emit('someEvent')\">Click Me</button>"
      },
      {
        "language": "text",
        "code": "this.$emit()"
      },
      {
        "language": "text",
        "code": "export default {\n  methods: {\n    submit() {\n      this.$emit('someEvent')\n    }\n  }\n}"
      },
      {
        "language": "text",
        "code": "export default {\n  methods: {\n    submit() {\n      this.$emit('someEvent')\n    }\n  }\n}"
      },
      {
        "language": "text",
        "code": "<MyComponent @some-event=\"callback\" />"
      },
      {
        "language": "text",
        "code": "<MyComponent @some-event=\"callback\" />"
      },
      {
        "language": "text",
        "code": "<MyComponent @some-event.once=\"callback\" />"
      },
      {
        "language": "text",
        "code": "<MyComponent @some-event.once=\"callback\" />"
      },
      {
        "language": "text",
        "code": "<button @click=\"$emit('increaseBy', 1)\">\n  Increase by 1\n</button>"
      },
      {
        "language": "text",
        "code": "<button @click=\"$emit('increaseBy', 1)\">\n  Increase by 1\n</button>"
      },
      {
        "language": "text",
        "code": "<MyButton @increase-by=\"(n) => count += n\" />"
      },
      {
        "language": "text",
        "code": "<MyButton @increase-by=\"(n) => count += n\" />"
      },
      {
        "language": "text",
        "code": "<MyButton @increase-by=\"increaseCount\" />"
      },
      {
        "language": "text",
        "code": "<MyButton @increase-by=\"increaseCount\" />"
      },
      {
        "language": "text",
        "code": "methods: {\n  increaseCount(n) {\n    this.count += n\n  }\n}"
      },
      {
        "language": "text",
        "code": "methods: {\n  increaseCount(n) {\n    this.count += n\n  }\n}"
      },
      {
        "language": "text",
        "code": "function increaseCount(n) {\n  count.value += n\n}"
      },
      {
        "language": "text",
        "code": "function increaseCount(n) {\n  count.value += n\n}"
      },
      {
        "language": "text",
        "code": "$emit('foo', 1, 2, 3)"
      },
      {
        "language": "text",
        "code": "defineEmits()"
      },
      {
        "language": "text",
        "code": "<script setup>\ndefineEmits(['inFocus', 'submit'])\n</script>"
      },
      {
        "language": "text",
        "code": "<script setup>\ndefineEmits(['inFocus', 'submit'])\n</script>"
      },
      {
        "language": "text",
        "code": "<script setup>"
      },
      {
        "language": "text",
        "code": "defineEmits()"
      },
      {
        "language": "text",
        "code": "<script setup>\nconst emit = defineEmits(['inFocus', 'submit'])\n\nfunction buttonClick() {\n  emit('submit')\n}\n</script>"
      },
      {
        "language": "text",
        "code": "<script setup>\nconst emit = defineEmits(['inFocus', 'submit'])\n\nfunction buttonClick() {\n  emit('submit')\n}\n</script>"
      },
      {
        "language": "text",
        "code": "defineEmits()"
      },
      {
        "language": "text",
        "code": "<script setup>"
      },
      {
        "language": "text",
        "code": "<script setup>"
      },
      {
        "language": "text",
        "code": "export default {\n  emits: ['inFocus', 'submit'],\n  setup(props, ctx) {\n    ctx.emit('submit')\n  }\n}"
      },
      {
        "language": "text",
        "code": "export default {\n  emits: ['inFocus', 'submit'],\n  setup(props, ctx) {\n    ctx.emit('submit')\n  }\n}"
      },
      {
        "language": "text",
        "code": "export default {\n  emits: ['inFocus', 'submit'],\n  setup(props, { emit }) {\n    emit('submit')\n  }\n}"
      },
      {
        "language": "text",
        "code": "export default {\n  emits: ['inFocus', 'submit'],\n  setup(props, { emit }) {\n    emit('submit')\n  }\n}"
      },
      {
        "language": "text",
        "code": "export default {\n  emits: ['inFocus', 'submit']\n}"
      },
      {
        "language": "text",
        "code": "export default {\n  emits: ['inFocus', 'submit']\n}"
      },
      {
        "language": "text",
        "code": "defineEmits()"
      },
      {
        "language": "text",
        "code": "<script setup lang=\"ts\">\nconst emit = defineEmits({\n  submit(payload: { email: string, password: string }) {\n    // return `true` or `false` to indicate\n    // validation pass / fail\n  }\n})\n</script>"
      },
      {
        "language": "text",
        "code": "<script setup lang=\"ts\">\nconst emit = defineEmits({\n  submit(payload: { email: string, password: string }) {\n    // return `true` or `false` to indicate\n    // validation pass / fail\n  }\n})\n</script>"
      },
      {
        "language": "text",
        "code": "<script setup>"
      },
      {
        "language": "text",
        "code": "<script setup lang=\"ts\">\nconst emit = defineEmits<{\n  (e: 'change', id: number): void\n  (e: 'update', value: string): void\n}>()\n</script>"
      },
      {
        "language": "text",
        "code": "<script setup lang=\"ts\">\nconst emit = defineEmits<{\n  (e: 'change', id: number): void\n  (e: 'update', value: string): void\n}>()\n</script>"
      },
      {
        "language": "text",
        "code": "export default {\n  emits: {\n    submit(payload: { email: string, password: string }) {\n      // return `true` or `false` to indicate\n      // validation pass / fail\n    }\n  }\n}"
      },
      {
        "language": "text",
        "code": "export default {\n  emits: {\n    submit(payload: { email: string, password: string }) {\n      // return `true` or `false` to indicate\n      // validation pass / fail\n    }\n  }\n}"
      },
      {
        "language": "text",
        "code": "<script setup>\nconst emit = defineEmits({\n  // No validation\n  click: null,\n\n  // Validate submit event\n  submit: ({ email, password }) => {\n    if (email && password) {\n      return true\n    } else {\n      console.warn('Invalid submit event payload!')\n      return false\n    }\n  }\n})\n\nfunction submitForm(email, password) {\n  emit('submit', { email, password })\n}\n</script>"
      },
      {
        "language": "text",
        "code": "<script setup>\nconst emit = defineEmits({\n  // No validation\n  click: null,\n\n  // Validate submit event\n  submit: ({ email, password }) => {\n    if (email && password) {\n      return true\n    } else {\n      console.warn('Invalid submit event payload!')\n      return false\n    }\n  }\n})\n\nfunction submitForm(email, password) {\n  emit('submit', { email, password })\n}\n</script>"
      },
      {
        "language": "text",
        "code": "export default {\n  emits: {\n    // No validation\n    click: null,\n\n    // Validate submit event\n    submit: ({ email, password }) => {\n      if (email && password) {\n        return true\n      } else {\n        console.warn('Invalid submit event payload!')\n        return false\n      }\n    }\n  },\n  methods: {\n    submitForm(email, password) {\n      this.$emit('submit', { email, password })\n    }\n  }\n}"
      },
      {
        "language": "text",
        "code": "export default {\n  emits: {\n    // No validation\n    click: null,\n\n    // Validate submit event\n    submit: ({ email, password }) => {\n      if (email && password) {\n        return true\n      } else {\n        console.warn('Invalid submit event payload!')\n        return false\n      }\n    }\n  },\n  methods: {\n    submitForm(email, password) {\n      this.$emit('submit', { email, password })\n    }\n  }\n}"
      }
    ],
    "links": [
      {
        "text": "Components Basics",
        "href": "/guide/essentials/component-basics"
      },
      {
        "text": "Watch a free video lesson on Vue School",
        "href": "https://vueschool.io/lessons/defining-custom-events-emits?friend=vuejs"
      },
      {
        "text": "props casing",
        "href": "/guide/components/props#prop-name-casing"
      },
      {
        "text": "global state management solution",
        "href": "/guide/scaling-up/state-management"
      },
      {
        "text": "defineEmits()",
        "href": "/api/sfc-script-setup#defineprops-defineemits"
      },
      {
        "text": "emits",
        "href": "/api/options-state#emits"
      },
      {
        "text": "emits",
        "href": "/api/options-state#emits"
      },
      {
        "text": "Typing Component Emits",
        "href": "/guide/typescript/composition-api#typing-component-emits"
      },
      {
        "text": "Typing Component Emits",
        "href": "/guide/typescript/options-api#typing-component-emits"
      },
      {
        "text": "fallthrough attributes",
        "href": "/guide/components/attrs#v-on-listener-inheritance"
      },
      {
        "text": "Edit this page on GitHub",
        "href": "https://github.com/vuejs/docs/edit/main/src/guide/components/events.md"
      }
    ],
    "meta": {
      "description": "Vue.js - The Progressive JavaScript Framework",
      "keywords": ""
    },
    "summary": "Component Events This page assumes you've already read the Components Basics. Read that first if you are new to components",
    "tags": [
      "react",
      "vue",
      "angular",
      "javascript",
      "typescript",
      "html",
      "events",
      "component",
      "emitting",
      "listening"
    ],
    "id": "component-events-eventshtml-part-1",
    "quality": 100
  },
  {
    "title": "Slots",
    "url": "https://vuejs.org/guide/components/slots.html",
    "category": "vue",
    "content": "Slots This page assumes you've already read the Components Basics. Read that first if you are new to components.Watch a free video lesson on Vue SchoolSlot Content and Outlet We have learned that components can accept props, which can be JavaScript values of any type. But how about template content? In some cases, we may want to pass a template fragment to a child component, and let the child component render the fragment within its own template.For example, we may have a FancyButton component that supports usage like this:templateFancyButton Click me! !-- slot content -- /FancyButtonThe template of FancyButton looks like this:templatebutton class=\"fancy-btn\" slot/slot !-- slot outlet -- /buttonThe slot element is a slot outlet that indicates where the parent-provided slot content should be rendered.And the final rendered DOM:htmlbutton class=\"fancy-btn\"Click me!/buttonTry it in the PlaygroundTry it in the PlaygroundWith slots, the FancyButton is responsible for rendering the outer button (and its fancy styling), while the inner content is provided by the parent component.Another way to understand slots is by comparing them to JavaScript functions:js// parent component passing slot content FancyButton('Click me!') // FancyButton renders slot content in its own template function FancyButton(slotContent) { return button class=\"fancy-btn\" ${slotContent} /button }Slot content is not just limited to text. It can be any valid template content. For example, we can pass in multiple elements, or even other components:templateFancyButton span style=\"color:red\"Click me!/span AwesomeIcon name=\"plus\" / /FancyButtonTry it in the PlaygroundTry it in the PlaygroundBy using slots, our FancyButton is more flexible and reusable. We can now use it in different places with different inner content, but all with the same fancy styling.Vue components' slot mechanism is inspired by the native Web Component slot element, but with additional capabilities that we will see later.Render Scope Slot content has access to the data scope of the parent component, because it is defined in the parent. For example:templatespan{{ message }}/span FancyButton{{ message }}/FancyButtonHere both {{ message }} interpolations will render the same content.Slot content does not have access to the child component's data. Expressions in Vue templates can only access the scope it is defined in, consistent with JavaScript's lexical scoping. In other words:Expressions in the parent template only have access to the parent scope; expressions in the child template only have access to the child scope.Fallback Content There are cases when it's useful to specify fallback (i.e. default) content for a slot, to be rendered only when no content is provided. For example, in a SubmitButton component:templatebutton type=\"submit\" slot/slot /buttonWe might want the text \"Submit\" to be rendered inside the button if the parent didn't provide any slot content. To make \"Submit\" the fallback content, we can place it in between the slot tags:templatebutton type=\"submit\" slot Submit !-- fallback content -- /slot /buttonNow when we use SubmitButton in a parent component, providing no content for the slot:templateSubmitButton /This will render the fallback content, \"Submit\":htmlbutton type=\"submit\"Submit/buttonBut if we provide content:templateSubmitButtonSave/SubmitButtonThen the provided content will be rendered instead:htmlbutton type=\"submit\"Save/buttonTry it in the PlaygroundTry it in the PlaygroundNamed Slots There are times when it's useful to have multiple slot outlets in a single component. For example, in a BaseLayout component with the following template:templatediv class=\"container\" header !-- We want header content here -- /header main !-- We want main content here -- /main footer !-- We want footer content here -- /footer /divFor these cases, the slot element has a special attribute, name, which can be used to assign a unique ID to different slots so you can determine where content should be rendered:templatediv class=\"container\" header slot name=\"header\"/slot /header main slot/slot /main footer slot name=\"footer\"/slot /footer /divA slot outlet without name implicitly has the name \"default\".In a parent component using BaseLayout, we need a way to pass multiple slot content fragments, each targeting a different slot outlet. This is where named slots come in.To pass a named slot, we need to use a template element with the v-slot directive, and then pass the name of the slot as an argument to v-slot:templateBaseLayout template v-slot:header !-- content for the header slot -- /template /BaseLayoutv-slot has a dedicated shorthand #, so template v-slot:header can be shortened to just template #header. Think of it as \"render this template fragment in the child component's 'header' slot\".Here's the code passing content for all three slots to BaseLayout using the shorthand syntax:templateBaseLayout template #header h1Here might be a page title/h1 /template template #default pA paragraph for the main content./p pAnd another one./p /template template #footer pHere's some contact info/p /template /BaseLayoutWhen a component accepts both a default slot and named slots, all top-level non-template nodes are implicitly treated as content for the default slot. So the above can also be written as:templateBaseLayout template #header h1Here might be a page title/h1 /template !-- implicit default slot -- pA paragraph for the main content./p pAnd another one./p template #footer pHere's some contact info/p /template /BaseLayoutNow everything inside the template elements will be passed to the corresponding slots. The final rendered HTML will be:htmldiv class=\"container\" header h1Here might be a page title/h1 /header main pA paragraph for the main content./p pAnd another one./p /main footer pHere's some contact info/p /footer /divTry it in the PlaygroundTry it in the PlaygroundAgain, it may help you understand named slots better using the JavaScript function analogy:js// passing multiple slot fragments with different names BaseLayout({ header: ..., default: ..., footer: ... }) // BaseLayout renders them in different places function BaseLayout(slots) { return div class=\"container\" header${slots.header}/header main${slots.default}/main footer${slots.footer}/footer /div }Conditional Slots Sometimes you want to render something based on whether or not content has been passed to a slot.You can use the $slots property in combination with a v-if to achieve this.In the example below we define a Card component with three conditional slots: header, footer and the default one. When content for the header / footer / default is present, we want to wrap it to provide additional styling:templatetemplate div class=\"card\" div v-if=\"$slots.header\" class=\"card-header\" slot name=\"header\" / /div div v-if=\"$slots.default\" class=\"card-content\" slot / /div div v-if=\"$slots.footer\" class=\"card-footer\" slot name=\"footer\" / /div /div /templateTry it in the PlaygroundDynamic Slot Names Dynamic directive arguments also work on v-slot, allowing the definition of dynamic slot names:templatebase-layout template v-slot:[dynamicSlotName] ... /template !-- with shorthand -- template #[dynamicSlotName] ... /template /base-layoutDo note the expression is subject to the syntax constraints of dynamic directive arguments.Scoped Slots As discussed in Render Scope, slot content does not have access to state in the child component.However, there are cases where it could be useful if a slot's content can make use of data from both the parent scope and the child scope. To achieve that, we need a way for the child to pass data to a slot when rendering it.In fact, we can do exactly that - we can pass attributes to a slot outlet just like passing props to a component:template!-- MyComponent template -- div slot :text=\"greetingMessage\" :count=\"1\"/slot /divReceiving the slot props is a bit different when using a single default slot vs. using named slots. We are going to show how to receive props using a single default slot first, by using v-slot directly on the child component tag:templateMyComponent v-slot=\"slotProps\" {{ slotProps.text }} {{ slotProps.count }} /MyComponentTry it in the PlaygroundTry it in the PlaygroundThe props passed to the slot by the child are available as the value of the corresponding v-slot directive, which can be accessed by expressions inside the slot.You can think of a scoped slot as a function being passed into the child component. The child component then calls it, passing props as arguments:jsMyComponent({ // passing the default slot, but as a function default: (slotProps) = { return ${slotProps.text} ${slotProps.count} } }) function MyComponent(slots) { const greetingMessage = 'hello' return div${ // call the slot function with props! slots.default({ text: greetingMessage, count: 1 }) }/div }In fact, this is very close to how scoped slots are compiled, and how you would use scoped slots in manual render functions.Notice how v-slot=\"slotProps\" matches the slot function signature. Just like with function arguments, we can use destructuring in v-slot:templateMyComponent v-slot=\"{ text, count }\" {{ text }} {{ count }} /MyComponentNamed Scoped Slots Named scoped slots work similarly - slot props are accessible as the value of the v-slot directive: v-slot:name=\"slotProps\". When using the shorthand, it looks like this:templateMyComponent template #header=\"headerProps\" {{ headerProps }} /template template #default=\"defaultProps\" {{ defaultProps }} /template template #footer=\"footerProps\" {{ footerProps }} /template /MyComponentPassing props to a named slot:templateslot name=\"header\" message=\"hello\"/slotNote the name of a slot won't be included in the props because it is reserved - so the resulting headerProps would be { message: 'hello' }.If you are mixing named slots with the default scoped slot, you need to use an explicit template tag for the default slot. Attempting to place the v-slot directive directly on the component will result in a compilation error. This is to avoid any ambiguity about the scope of the props of the default slot. For example:template!-- MyComponent template -- div slot :message=\"hello\"/slot slot name=\"footer\" / /divtemplate!-- This template won't compile -- MyComponent v-slot=\"{ message }\" p{{ message }}/p template #footer !-- message belongs to the default slot, and is not available here -- p{{ message }}/p /template /MyComponentUsing an explicit template tag for the default slot helps to make it clear that the message prop is not available inside the other slot:templateMyComponent !-- Use explicit default slot -- template #default=\"{ message }\" p{{ message }}/p /template template #footer pHere's some contact info/p /template /MyComponentFancy List Example You may be wondering what would be a good use case for scoped slots. Here's an example: imagine a FancyList component that renders a list of items - it may encapsulate the logic for loading remote data, using the data to display a list, or even advanced features like pagination or infinite scrolling. However, we want it to be flexible with how each item looks and leave the styling of each item to the parent component consuming it. So the desired usage may look like this:templateFancyList :api-url=\"url\" :per-page=\"10\" template #item=\"{ body, username, likes }\" div class=\"item\" p{{ body }}/p pby {{ username }}  {{ likes }} likes/p /div /template /FancyListInside FancyList, we can render the same slot multiple times with different item data (notice we are using v-bind to pass an object as slot props):templateul li v-for=\"item in items\" slot name=\"item\" v-bind=\"item\"/slot /li /ulTry it in the PlaygroundTry it in the PlaygroundRenderless Components The FancyList use case we discussed above encapsulates both reusable logic (data fetching, pagination etc.) and visual output, while delegating part of the visual output to the consumer component via scoped slots.If we push this concept a bit further, we can come up with components that only encapsulate logic and do not render anything by themselves - visual output is fully delegated to the consumer component with scoped slots. We call this type of component a Renderless Component.An example renderless component could be one that encapsulates the logic of tracking the current mouse position:templateMouseTracker v-slot=\"{ x, y }\" Mouse is at: {{ x }}, {{ y }} /MouseTrackerTry it in the PlaygroundTry it in the PlaygroundWhile an interesting pattern, most of what can be achieved with Renderless Components can be achieved in a more efficient fashion with Composition API, without incurring the overhead of extra component nesting. Later, we will see how we can implement the same mouse tracking functionality as a Composable.That said, scoped slots are still useful in cases where we need to both encapsulate logic and compose visual output, like in the FancyList example.Edit this page on GitHub",
    "headings": [
      {
        "level": 1,
        "text": "Slots ​",
        "id": "slots"
      },
      {
        "level": 2,
        "text": "Slot Content and Outlet ​",
        "id": "slot-content-and-outlet"
      },
      {
        "level": 2,
        "text": "Render Scope ​",
        "id": "render-scope"
      },
      {
        "level": 2,
        "text": "Fallback Content ​",
        "id": "fallback-content"
      },
      {
        "level": 2,
        "text": "Named Slots ​",
        "id": "named-slots"
      },
      {
        "level": 2,
        "text": "Conditional Slots ​",
        "id": "conditional-slots"
      },
      {
        "level": 2,
        "text": "Dynamic Slot Names ​",
        "id": "dynamic-slot-names"
      },
      {
        "level": 2,
        "text": "Scoped Slots ​",
        "id": "scoped-slots"
      },
      {
        "level": 3,
        "text": "Named Scoped Slots ​",
        "id": "named-scoped-slots"
      },
      {
        "level": 3,
        "text": "Fancy List Example ​",
        "id": "fancy-list-example"
      },
      {
        "level": 3,
        "text": "Renderless Components ​",
        "id": "renderless-components"
      }
    ],
    "codeBlocks": [
      {
        "language": "text",
        "code": "<FancyButton>"
      },
      {
        "language": "text",
        "code": "<FancyButton>\n  Click me! <!-- slot content -->\n</FancyButton>"
      },
      {
        "language": "text",
        "code": "<FancyButton>\n  Click me! <!-- slot content -->\n</FancyButton>"
      },
      {
        "language": "text",
        "code": "<FancyButton>"
      },
      {
        "language": "text",
        "code": "<button class=\"fancy-btn\">\n  <slot></slot> <!-- slot outlet -->\n</button>"
      },
      {
        "language": "text",
        "code": "<button class=\"fancy-btn\">\n  <slot></slot> <!-- slot outlet -->\n</button>"
      },
      {
        "language": "text",
        "code": "<button class=\"fancy-btn\">Click me!</button>"
      },
      {
        "language": "text",
        "code": "<button class=\"fancy-btn\">Click me!</button>"
      },
      {
        "language": "text",
        "code": "<FancyButton>"
      },
      {
        "language": "text",
        "code": "// parent component passing slot content\nFancyButton('Click me!')\n\n// FancyButton renders slot content in its own template\nfunction FancyButton(slotContent) {\n  return `<button class=\"fancy-btn\">\n      ${slotContent}\n    </button>`\n}"
      },
      {
        "language": "text",
        "code": "// parent component passing slot content\nFancyButton('Click me!')\n\n// FancyButton renders slot content in its own template\nfunction FancyButton(slotContent) {\n  return `<button class=\"fancy-btn\">\n      ${slotContent}\n    </button>`\n}"
      },
      {
        "language": "text",
        "code": "<FancyButton>\n  <span style=\"color:red\">Click me!</span>\n  <AwesomeIcon name=\"plus\" />\n</FancyButton>"
      },
      {
        "language": "text",
        "code": "<FancyButton>\n  <span style=\"color:red\">Click me!</span>\n  <AwesomeIcon name=\"plus\" />\n</FancyButton>"
      },
      {
        "language": "text",
        "code": "<FancyButton>"
      },
      {
        "language": "text",
        "code": "<span>{{ message }}</span>\n<FancyButton>{{ message }}</FancyButton>"
      },
      {
        "language": "text",
        "code": "<span>{{ message }}</span>\n<FancyButton>{{ message }}</FancyButton>"
      },
      {
        "language": "text",
        "code": "{{ message }}"
      },
      {
        "language": "text",
        "code": "<SubmitButton>"
      },
      {
        "language": "text",
        "code": "<button type=\"submit\">\n  <slot></slot>\n</button>"
      },
      {
        "language": "text",
        "code": "<button type=\"submit\">\n  <slot></slot>\n</button>"
      },
      {
        "language": "text",
        "code": "<button type=\"submit\">\n  <slot>\n    Submit <!-- fallback content -->\n  </slot>\n</button>"
      },
      {
        "language": "text",
        "code": "<button type=\"submit\">\n  <slot>\n    Submit <!-- fallback content -->\n  </slot>\n</button>"
      },
      {
        "language": "text",
        "code": "<SubmitButton>"
      },
      {
        "language": "text",
        "code": "<SubmitButton />"
      },
      {
        "language": "text",
        "code": "<SubmitButton />"
      },
      {
        "language": "text",
        "code": "<button type=\"submit\">Submit</button>"
      },
      {
        "language": "text",
        "code": "<button type=\"submit\">Submit</button>"
      },
      {
        "language": "text",
        "code": "<SubmitButton>Save</SubmitButton>"
      },
      {
        "language": "text",
        "code": "<SubmitButton>Save</SubmitButton>"
      },
      {
        "language": "text",
        "code": "<button type=\"submit\">Save</button>"
      },
      {
        "language": "text",
        "code": "<button type=\"submit\">Save</button>"
      },
      {
        "language": "text",
        "code": "<BaseLayout>"
      },
      {
        "language": "text",
        "code": "<div class=\"container\">\n  <header>\n    <!-- We want header content here -->\n  </header>\n  <main>\n    <!-- We want main content here -->\n  </main>\n  <footer>\n    <!-- We want footer content here -->\n  </footer>\n</div>"
      },
      {
        "language": "text",
        "code": "<div class=\"container\">\n  <header>\n    <!-- We want header content here -->\n  </header>\n  <main>\n    <!-- We want main content here -->\n  </main>\n  <footer>\n    <!-- We want footer content here -->\n  </footer>\n</div>"
      },
      {
        "language": "text",
        "code": "<div class=\"container\">\n  <header>\n    <slot name=\"header\"></slot>\n  </header>\n  <main>\n    <slot></slot>\n  </main>\n  <footer>\n    <slot name=\"footer\"></slot>\n  </footer>\n</div>"
      },
      {
        "language": "text",
        "code": "<div class=\"container\">\n  <header>\n    <slot name=\"header\"></slot>\n  </header>\n  <main>\n    <slot></slot>\n  </main>\n  <footer>\n    <slot name=\"footer\"></slot>\n  </footer>\n</div>"
      },
      {
        "language": "text",
        "code": "<BaseLayout>"
      },
      {
        "language": "text",
        "code": "<BaseLayout>\n  <template v-slot:header>\n    <!-- content for the header slot -->\n  </template>\n</BaseLayout>"
      },
      {
        "language": "text",
        "code": "<BaseLayout>\n  <template v-slot:header>\n    <!-- content for the header slot -->\n  </template>\n</BaseLayout>"
      },
      {
        "language": "text",
        "code": "<template v-slot:header>"
      },
      {
        "language": "text",
        "code": "<template #header>"
      },
      {
        "language": "text",
        "code": "<BaseLayout>"
      },
      {
        "language": "text",
        "code": "<BaseLayout>\n  <template #header>\n    <h1>Here might be a page title</h1>\n  </template>\n\n  <template #default>\n    <p>A paragraph for the main content.</p>\n    <p>And another one.</p>\n  </template>\n\n  <template #footer>\n    <p>Here's some contact info</p>\n  </template>\n</BaseLayout>"
      },
      {
        "language": "text",
        "code": "<BaseLayout>\n  <template #header>\n    <h1>Here might be a page title</h1>\n  </template>\n\n  <template #default>\n    <p>A paragraph for the main content.</p>\n    <p>And another one.</p>\n  </template>\n\n  <template #footer>\n    <p>Here's some contact info</p>\n  </template>\n</BaseLayout>"
      },
      {
        "language": "text",
        "code": "<BaseLayout>\n  <template #header>\n    <h1>Here might be a page title</h1>\n  </template>\n\n  <!-- implicit default slot -->\n  <p>A paragraph for the main content.</p>\n  <p>And another one.</p>\n\n  <template #footer>\n    <p>Here's some contact info</p>\n  </template>\n</BaseLayout>"
      },
      {
        "language": "text",
        "code": "<BaseLayout>\n  <template #header>\n    <h1>Here might be a page title</h1>\n  </template>\n\n  <!-- implicit default slot -->\n  <p>A paragraph for the main content.</p>\n  <p>And another one.</p>\n\n  <template #footer>\n    <p>Here's some contact info</p>\n  </template>\n</BaseLayout>"
      },
      {
        "language": "text",
        "code": "<div class=\"container\">\n  <header>\n    <h1>Here might be a page title</h1>\n  </header>\n  <main>\n    <p>A paragraph for the main content.</p>\n    <p>And another one.</p>\n  </main>\n  <footer>\n    <p>Here's some contact info</p>\n  </footer>\n</div>"
      },
      {
        "language": "text",
        "code": "<div class=\"container\">\n  <header>\n    <h1>Here might be a page title</h1>\n  </header>\n  <main>\n    <p>A paragraph for the main content.</p>\n    <p>And another one.</p>\n  </main>\n  <footer>\n    <p>Here's some contact info</p>\n  </footer>\n</div>"
      },
      {
        "language": "text",
        "code": "// passing multiple slot fragments with different names\nBaseLayout({\n  header: `...`,\n  default: `...`,\n  footer: `...`\n})\n\n// <BaseLayout> renders them in different places\nfunction BaseLayout(slots) {\n  return `<div class=\"container\">\n      <header>${slots.header}</header>\n      <main>${slots.default}</main>\n      <footer>${slots.footer}</footer>\n    </div>`\n}"
      },
      {
        "language": "text",
        "code": "// passing multiple slot fragments with different names\nBaseLayout({\n  header: `...`,\n  default: `...`,\n  footer: `...`\n})\n\n// <BaseLayout> renders them in different places\nfunction BaseLayout(slots) {\n  return `<div class=\"container\">\n      <header>${slots.header}</header>\n      <main>${slots.default}</main>\n      <footer>${slots.footer}</footer>\n    </div>`\n}"
      },
      {
        "language": "text",
        "code": "<template>\n  <div class=\"card\">\n    <div v-if=\"$slots.header\" class=\"card-header\">\n      <slot name=\"header\" />\n    </div>\n    \n    <div v-if=\"$slots.default\" class=\"card-content\">\n      <slot />\n    </div>\n    \n    <div v-if=\"$slots.footer\" class=\"card-footer\">\n      <slot name=\"footer\" />\n    </div>\n  </div>\n</template>"
      },
      {
        "language": "text",
        "code": "<template>\n  <div class=\"card\">\n    <div v-if=\"$slots.header\" class=\"card-header\">\n      <slot name=\"header\" />\n    </div>\n    \n    <div v-if=\"$slots.default\" class=\"card-content\">\n      <slot />\n    </div>\n    \n    <div v-if=\"$slots.footer\" class=\"card-footer\">\n      <slot name=\"footer\" />\n    </div>\n  </div>\n</template>"
      },
      {
        "language": "text",
        "code": "<base-layout>\n  <template v-slot:[dynamicSlotName]>\n    ...\n  </template>\n\n  <!-- with shorthand -->\n  <template #[dynamicSlotName]>\n    ...\n  </template>\n</base-layout>"
      },
      {
        "language": "text",
        "code": "<base-layout>\n  <template v-slot:[dynamicSlotName]>\n    ...\n  </template>\n\n  <!-- with shorthand -->\n  <template #[dynamicSlotName]>\n    ...\n  </template>\n</base-layout>"
      },
      {
        "language": "text",
        "code": "<!-- <MyComponent> template -->\n<div>\n  <slot :text=\"greetingMessage\" :count=\"1\"></slot>\n</div>"
      },
      {
        "language": "text",
        "code": "<!-- <MyComponent> template -->\n<div>\n  <slot :text=\"greetingMessage\" :count=\"1\"></slot>\n</div>"
      },
      {
        "language": "text",
        "code": "<MyComponent v-slot=\"slotProps\">\n  {{ slotProps.text }} {{ slotProps.count }}\n</MyComponent>"
      },
      {
        "language": "text",
        "code": "<MyComponent v-slot=\"slotProps\">\n  {{ slotProps.text }} {{ slotProps.count }}\n</MyComponent>"
      },
      {
        "language": "text",
        "code": "MyComponent({\n  // passing the default slot, but as a function\n  default: (slotProps) => {\n    return `${slotProps.text} ${slotProps.count}`\n  }\n})\n\nfunction MyComponent(slots) {\n  const greetingMessage = 'hello'\n  return `<div>${\n    // call the slot function with props!\n    slots.default({ text: greetingMessage, count: 1 })\n  }</div>`\n}"
      },
      {
        "language": "text",
        "code": "MyComponent({\n  // passing the default slot, but as a function\n  default: (slotProps) => {\n    return `${slotProps.text} ${slotProps.count}`\n  }\n})\n\nfunction MyComponent(slots) {\n  const greetingMessage = 'hello'\n  return `<div>${\n    // call the slot function with props!\n    slots.default({ text: greetingMessage, count: 1 })\n  }</div>`\n}"
      },
      {
        "language": "text",
        "code": "v-slot=\"slotProps\""
      },
      {
        "language": "text",
        "code": "<MyComponent v-slot=\"{ text, count }\">\n  {{ text }} {{ count }}\n</MyComponent>"
      },
      {
        "language": "text",
        "code": "<MyComponent v-slot=\"{ text, count }\">\n  {{ text }} {{ count }}\n</MyComponent>"
      },
      {
        "language": "text",
        "code": "v-slot:name=\"slotProps\""
      },
      {
        "language": "text",
        "code": "<MyComponent>\n  <template #header=\"headerProps\">\n    {{ headerProps }}\n  </template>\n\n  <template #default=\"defaultProps\">\n    {{ defaultProps }}\n  </template>\n\n  <template #footer=\"footerProps\">\n    {{ footerProps }}\n  </template>\n</MyComponent>"
      },
      {
        "language": "text",
        "code": "<MyComponent>\n  <template #header=\"headerProps\">\n    {{ headerProps }}\n  </template>\n\n  <template #default=\"defaultProps\">\n    {{ defaultProps }}\n  </template>\n\n  <template #footer=\"footerProps\">\n    {{ footerProps }}\n  </template>\n</MyComponent>"
      },
      {
        "language": "text",
        "code": "<slot name=\"header\" message=\"hello\"></slot>"
      },
      {
        "language": "text",
        "code": "<slot name=\"header\" message=\"hello\"></slot>"
      },
      {
        "language": "text",
        "code": "headerProps"
      },
      {
        "language": "text",
        "code": "{ message: 'hello' }"
      },
      {
        "language": "text",
        "code": "<!-- <MyComponent> template -->\n<div>\n  <slot :message=\"hello\"></slot>\n  <slot name=\"footer\" />\n</div>"
      },
      {
        "language": "text",
        "code": "<!-- <MyComponent> template -->\n<div>\n  <slot :message=\"hello\"></slot>\n  <slot name=\"footer\" />\n</div>"
      },
      {
        "language": "text",
        "code": "<!-- This template won't compile -->\n<MyComponent v-slot=\"{ message }\">\n  <p>{{ message }}</p>\n  <template #footer>\n    <!-- message belongs to the default slot, and is not available here -->\n    <p>{{ message }}</p>\n  </template>\n</MyComponent>"
      },
      {
        "language": "text",
        "code": "<!-- This template won't compile -->\n<MyComponent v-slot=\"{ message }\">\n  <p>{{ message }}</p>\n  <template #footer>\n    <!-- message belongs to the default slot, and is not available here -->\n    <p>{{ message }}</p>\n  </template>\n</MyComponent>"
      },
      {
        "language": "text",
        "code": "<MyComponent>\n  <!-- Use explicit default slot -->\n  <template #default=\"{ message }\">\n    <p>{{ message }}</p>\n  </template>\n\n  <template #footer>\n    <p>Here's some contact info</p>\n  </template>\n</MyComponent>"
      },
      {
        "language": "text",
        "code": "<MyComponent>\n  <!-- Use explicit default slot -->\n  <template #default=\"{ message }\">\n    <p>{{ message }}</p>\n  </template>\n\n  <template #footer>\n    <p>Here's some contact info</p>\n  </template>\n</MyComponent>"
      },
      {
        "language": "text",
        "code": "<FancyList>"
      },
      {
        "language": "text",
        "code": "<FancyList :api-url=\"url\" :per-page=\"10\">\n  <template #item=\"{ body, username, likes }\">\n    <div class=\"item\">\n      <p>{{ body }}</p>\n      <p>by {{ username }} | {{ likes }} likes</p>\n    </div>\n  </template>\n</FancyList>"
      },
      {
        "language": "text",
        "code": "<FancyList :api-url=\"url\" :per-page=\"10\">\n  <template #item=\"{ body, username, likes }\">\n    <div class=\"item\">\n      <p>{{ body }}</p>\n      <p>by {{ username }} | {{ likes }} likes</p>\n    </div>\n  </template>\n</FancyList>"
      },
      {
        "language": "text",
        "code": "<FancyList>"
      },
      {
        "language": "text",
        "code": "<ul>\n  <li v-for=\"item in items\">\n    <slot name=\"item\" v-bind=\"item\"></slot>\n  </li>\n</ul>"
      },
      {
        "language": "text",
        "code": "<ul>\n  <li v-for=\"item in items\">\n    <slot name=\"item\" v-bind=\"item\"></slot>\n  </li>\n</ul>"
      },
      {
        "language": "text",
        "code": "<FancyList>"
      },
      {
        "language": "text",
        "code": "<MouseTracker v-slot=\"{ x, y }\">\n  Mouse is at: {{ x }}, {{ y }}\n</MouseTracker>"
      },
      {
        "language": "text",
        "code": "<MouseTracker v-slot=\"{ x, y }\">\n  Mouse is at: {{ x }}, {{ y }}\n</MouseTracker>"
      },
      {
        "language": "text",
        "code": "<FancyList>"
      }
    ],
    "links": [
      {
        "text": "Components Basics",
        "href": "/guide/essentials/component-basics"
      },
      {
        "text": "Watch a free video lesson on Vue School",
        "href": "https://vueschool.io/lessons/vue-3-component-slots?friend=vuejs"
      },
      {
        "text": "Try it in the Playground",
        "href": "https://play.vuejs.org/#eNpdUdlqAyEU/ZVbQ0kLMdNsXabTQFvoV8yLcRkkjopLSQj596oTwqRvnuM9y9UT+rR2/hs5qlHjqZM2gOch2m2rZW+NC/BDND1+xRCMBuFMD9N5NeKyeNrqphrUSZdA4L1VJPCEAJrRdCEAvpWke+g5NHcYg1cmADU6cB0A4zzThmYckqimupqiGfpXILe/zdwNhaki3n+0SOR5vAu6ReU++efUajtqYGJQ/FIg5w8Wt9FlOx+OKh/nV1c4ZVNqlHE1TIQQ7xnvCN13zkTNalBSc+Jw5wiTac2H1WLDeDeDyXrJVm9LWG7uE3hev3AhHge1cYwnO200L4QljEnd1bCxB1g82UNhe+I6qQs5kuGcE30NrxeaRudzOWtkemeXuHP5tLIKOv8BN+mw3w=="
      },
      {
        "text": "Try it in the Playground",
        "href": "https://play.vuejs.org/#eNpdUdtOwzAM/RUThAbSurIbl1ImARJf0ZesSapoqROlKdo07d9x0jF1SHmIT+xzcY7sw7nZTy9Zwcqu9tqFTYW6ddYH+OZYHz77ECyC8raFySwfYXFsUiFAhXKfBoRUvDcBjhGtLbGgxNAVcLziOlVIp8wvelQE2TrDg6QKoBx1JwDgy+h6B62E8ibLoDM2kAAGoocsiz1VKMfmCCrzCymbsn/GY95rze1grja8694rpmJ/tg1YsfRO/FE134wc2D4YeTYQ9QeKa+mUrgsHE6+zC+vfjoz1Bdwqpd5iveX1rvG2R1GA0Si5zxrPhaaY98v5WshmCrerhVi+LmCxvqPiafUslXoYpq0XkuiQ1p4Ax4XQ2BSwdnuYP7p9QlvuG40JHI1lUaenv3o5w3Xvu2jOWU179oQNn5aisNMvLBvDOg=="
      },
      {
        "text": "Try it in the Playground",
        "href": "https://play.vuejs.org/#eNp1UmtOwkAQvspQYtCEgrx81EqCJibeoX+W7bRZaHc3+1AI4QyewH8ewvN4Aa/gbgtNIfFf5+vMfI/ZXbCQcvBmMYiCWFPFpAGNxsp5wlkphTLwQjjdPlljBIdMiRJ6g2EL88O9pnnxjlqU+EpbzS3s0BwPaypH4gqDpSyIQVcBxK3VFQDwXDC6hhJdlZi4zf3fRKwl4aDNtsDHJKCiECqiW8KTYH5c1gEnwnUdJ9rCh/XeM6Z42AgN+sFZAj6+Ux/LOjFaEK2diMz3h0vjNfj/zokuhPFU3lTdfcpShVOZcJ+DZgHs/HxtCrpZlj34eknoOlfC8jSCgnEkKswVSRlyczkZzVLM+9CdjtPJ/RjGswtX3ExvMcuu6mmhUnTruOBYAZKkKeN5BDO5gdG13FRoSVTOeAW2xkLPY3UEdweYWqW9OCkYN6gctq9uXllx2Z09CJ9dJwzBascI7nBYihWDldUGMqEgdTVIq6TQqCEMfUpNSD+fX7/fH+3b7P8AdGP6wA=="
      },
      {
        "text": "Try it in the Playground",
        "href": "https://play.vuejs.org/#eNptUltu2zAQvMpGQZEWsOzGiftQ1QBpgQK9g35oaikwkUiCj9aGkTPkBPnLIXKeXCBXyJKKBdoIoA/tYGd3doa74tqY+b+ARVXUjltp/FWj5GC09fCHKb79FbzXCoTVA5zNFxkWaWdT8/V/dHrAvzxrzrC3ZoBG4SYRWhQs9B52EeWapihU3lWwyxfPDgbfNYq+ejEppcLjYHrmkSqAOqMmAOB3L/ktDEhV4+v8gMR/l1M7wxQ4v+3xZ1Nw3Wtb8S1TTXG1H3cCJIO69oxc5mLUcrSrXkxSi1lxZGT0//CS9Wg875lzJELE/nLto4bko69dr31cFc8auw+3JHvSEfQ7nwbsHY9HwakQ4kes14zfdlYH1VbQS4XMlp1lraRMPl6cr1rsZnB6uWwvvi9hufpAxZfLryjEp5GtbYs0TlGICTCsbaXqKliZDZx/NpuEDsx2UiUwo5VxT6Dkv73BPFgXxRktlUdL2Jh6OoW8O3pX0buTsoTgaCNQcDjoGwk3wXkQ2tJLGzSYYI126KAso0uTSc8Pjy9P93k2d6+NyRKa"
      },
      {
        "text": "native Web Component <slot> element",
        "href": "https://developer.mozilla.org/en-US/docs/Web/HTML/Element/slot"
      },
      {
        "text": "Try it in the Playground",
        "href": "https://play.vuejs.org/#eNp1kMsKwjAQRX9lzMaNbfcSC/oL3WbT1ikU8yKZFEX8d5MGgi2YVeZxZ86dN7taWy8B2ZlxP7rZEnikYFuhZ2WNI+jCoGa6BSKjYXJGwbFufpNJfhSaN1kflTEgVFb2hDEC4IeqguARpl7KoR8fQPgkqKpc3Wxo1lxRWWeW+Y4wBk9x9V9d2/UL8g1XbOJN4WAntodOnrecQ2agl8WLYH7tFyw5olj10iR3EJ+gPCxDFluj0YS6EAqKR8mi9M3Td1ifLxWShcU="
      },
      {
        "text": "Try it in the Playground",
        "href": "https://play.vuejs.org/#eNp1UEEOwiAQ/MrKxYu1d4Mm+gWvXChuk0YKpCyNxvh3lxIb28SEA8zuDDPzEucQ9mNCcRAymqELdFKu64MfCK6p6Tu6JCLvoB18D9t9/Qtm4lY5AOXwMVFu2OpkCV4ZNZ51HDqKhwLAQjIjb+X4yHr+mh+EfbCakF8AclNVkCJCq61ttLkD4YOgqsp0YbGesJkVBj92NwSTIrH3v7zTVY8oF8F4SdazD7ET69S5rqXPpnigZ8CjEnHaVyInIp5G63O6XIGiIlZMzrGMd8RVfR0q4lIKKV+L+srW+wNTTZq3"
      },
      {
        "text": "Try it in the Playground",
        "href": "https://play.vuejs.org/#eNp9UsFuwjAM/RWrHLgMOi5o6jIkdtphn9BLSF0aKU2ixEVjiH+fm8JoQdvRfu/5xS8+ZVvvl4cOsyITUQXtCSJS5zel1a13geBdRvyUR9cR1MG1MF/mt1YvnZdW5IOWVVwQtt5IQq4AxI2cau5ccZg1KCsMlz4jzWrzgQGh1fuGYIcgwcs9AmkyKHKGLyPykcfD1Apr2ZmrHUN+s+U5Qe6D9A3ULgA1bCK1BeUsoaWlyPuVb3xbgbSOaQGcxRH8v3XtHI0X8mmfeYToWkxmUhFoW7s/JvblJLERmj1l0+T7T5tqK30AZWSMb2WW3LTFUGZXp/u8o3EEVrbI9AFjLn8mt38fN9GIPrSp/p4/Yoj7OMZ+A/boN9KInPeZZpAOLNLRDAsPZDgN4p0L/NQFOV/Ayn9x6EZXMFNKvQ4E5YwLBczW6/WlU3NIi6i/sYDn5Qu2qX1OF51MsvMPkrIEHg=="
      },
      {
        "text": "Try it in the Playground",
        "href": "https://play.vuejs.org/#eNp9UkFuwjAQ/MoqHLiUpFxQlaZI9NRDn5CLSTbEkmNb9oKgiL934wRwQK3ky87O7njGPicba9PDHpM8KXzlpKV1qWVnjSP4FB6/xcnsCRpnOpin2R3qh+alBig1HgO9xkbsFcG5RyvDOzRq8vkAQLSury+l5lNkN1EuCDurBCFXAMWdH2pGrn2YtShqdCPOnXa5/kKH0MldS7BFEGDFDoEkKSwybo8rskjjaevo4L7Wrje8x4mdE7aFxjiglkWE1GxQE9tLi8xO+LoGoQ3THLD/qP2/dGMMxYZs8DP34E2HQUxUBFI35o+NfTlJLOomL8n04frXns7W8gCVEt5/lElQkxpdmVyVHvP2yhBo0SHThx5z+TEZvl1uMlP0oU3nH/kRo3iMI9Ybes960UyRsZ9pBuGDeTqpwfBAvn7NrXF81QUZm8PSHjl0JWuYVVX1PhAqo4zLYbZarUak4ZAWXv5gDq/pG3YBHn50EEkuv5irGBk="
      },
      {
        "text": "$slots",
        "href": "/api/component-instance#slots"
      },
      {
        "text": "v-if",
        "href": "/guide/essentials/conditional#v-if"
      },
      {
        "text": "Try it in the Playground",
        "href": "https://play.vuejs.org/#eNqVVMtu2zAQ/BWCLZBLIjVoTq4aoA1yaA9t0eaoCy2tJcYUSZCUKyPwv2dJioplOw4C+EDuzM4+ONYT/aZ1tumBLmhhK8O1IxZcr29LyTutjCN3zNRkZVRHLrLcXzz9opRFHvnIxIuDTgvmAG+EFJ4WTnhOCPnQAqvBjHFE2uvbh5Zbgj/XAolwkWN4TM33VI/UalixXvjyo5yeqVVKOpCuyP0ob6utlHL7vUE3U4twkWP4hJq/jiPP4vSSOouNrHiTPVolcclPnl3SSnWaCzC/teNK2pIuSEA8xoRQ/3+GmDM9XKZ41UK1PhF/tIOPlfSPAQtmAyWdMMdMAy7C9/9+wYDnCexU3QtknwH/glWi9z1G2vde1tj2Hi90+yNYhcvmwd4PuHabhvKNeuYu8EuK1rk7M/pLu5+zm5BXyh1uMdnOu3S+95pvSCWYtV9xQcgqaXogj2yu+AqBj1YoZ7NosJLOEq5S9OXtPZtI1gFSppx8engUHs+vVhq9eVhq9ORRrXdpRyseSqfo6SmmnONK6XTw9yis24q448wXSG+0VAb3sSDXeiBoDV6TpWDV+ktENatrdMGCfAoBfL1JYNzzpINJjVFoJ9yKUKho19ul6OFQ6UYPx1rjIpPYeXIc/vXCgjetawzbni0dPnhhJ3T3DMVSruI="
      },
      {
        "text": "Dynamic directive arguments",
        "href": "/guide/essentials/template-syntax#dynamic-arguments"
      },
      {
        "text": "syntax constraints",
        "href": "/guide/essentials/template-syntax#dynamic-argument-syntax-constraints"
      },
      {
        "text": "Try it in the Playground",
        "href": "https://play.vuejs.org/#eNp9kMEKgzAMhl8l9OJlU3aVOhg7C3uAXsRlTtC2tFE2pO++dA5xMnZqk+b/8/2dxMnadBxQ5EL62rWWwCMN9qh021vjCMrn2fBNoya4OdNDkmarXhQnSstsVrOOC8LedhVhrEiuHca97wwVSsTj4oz1SvAUgKJpgqWZEj4IQoCvZm0Gtgghzss1BDvIbFkqdmID+CNdbbQnaBwitbop0fuqQSgguWPXmX+JePe1HT/QMtJBHnE51MZOCcjfzPx04JxsydPzp2Szxxo7vABY1I/p"
      },
      {
        "text": "Try it in the Playground",
        "href": "https://play.vuejs.org/#eNqFkNFqxCAQRX9l8CUttAl9DbZQ+rzQD/AlJLNpwKjoJGwJ/nvHpAnusrAg6FzHO567iE/nynlCUQsZWj84+lBmGJ31BKffL8sng4bg7O0IRVllWnpWKAOgDF7WBx2em0kTLElt975QbwLkhkmIyvCS1TGXC8LR6YYwVSTzH8yvQVt6VyJt3966oAR38XhaFjjEkvBCECNcia2d2CLyOACZQ7CDrI6h4kXcAF7lcg+za6h5et4JPdLkzV4B9B6RBtOfMISmxxqKH9TarrGtATxMgf/bDfM/qExEUCdEDuLGXAmoV06+euNs2JK7tyCrzSNHjX9aurQf"
      },
      {
        "text": "render functions",
        "href": "/guide/extras/render-function"
      },
      {
        "text": "Try it in the Playground",
        "href": "https://play.vuejs.org/#eNqFU2Fv0zAQ/StHJtROapNuZTBCNwnQQKBpTGxCQss+uMml8+bYlu2UlZL/zjlp0lQa40sU3/nd3Xv3vA7eax0uSwziYGZTw7UDi67Up4nkhVbGwScm09U5tw5yowoYhFEX8cBBImdRgyQMHRwWWjCHdAKYbdFM83FpxEkS0DcJINZoxpotkCIHkySo7xOixcMep19KrmGustUISotGsgJHIPgDWqg6DKEyvoRUMGsJ4HG9HGX16bqpAlU1izy5baqDFegYweYroMttMwLAHx/Y9Kyan36RWUTN2+mjXfpbrei8k6SjdSuBYFOlMaNI6AeAtcflSrqx5b8xhkl4jMU7H0yVUCaGvVeH8+PjKYWqWnpf5DQYBTtb+fc612Awh2qzzGaBiUyVpBVpo7SFE8gw5xIv/Wl4M9gsbjCCQbuywe3+FuXl9iiqO7xpElEEhUofKFQo2mTGiFiOLr3jcpFImuiaF6hKNxzuw8lpw7kuEy6ZKJGK3TR6NluLYXBVqwRXQjkLn0ueIc3TLonyZ0sm4acqKVovKIbDCVQjGsb1qvyg2telU4Yzz6eHv6ARBWdwjVqUNCbbFjqgQn6aW1J8RKfJhDg+5/lStG4QHJZjnpO5XjT0BMqFu+uZ81yxjEQJw7A1kOA76FyZjaWBy0akvu8tCQKeQ+d7wsy5zLpz1FlzU3kW1QP+x40ApWgWAySEJTv6/NitNMkllcTakwCaZZ5ADEf6cROas/RhYVQps5igEpkZLwzRROmG04OjDBcj7+Js+vYQDo9e0uH1qzeY5/s1vtaaqG969+vTTrsmBTMLLv12nuy7l+d5W673SBzxkzlfhPdWSXokdZMkSFWhuUDzTTtOnk6CuG2fBEwI9etrHXOmRLJUE0/vMH14In5vH30sCS4Nkr+WmARdztHQ6Jr02dUFPtJ/lyxUVgq6/UzyO1olSj9jc+0DcaWxe/fqab/UT51Uu7Znjw6lbUn5QWtR6vtJQM//4zPUt+NOw+lGzCqo/gLm1QS8"
      },
      {
        "text": "Try it in the Playground",
        "href": "https://play.vuejs.org/#eNqNVNtq20AQ/ZWpQnECujhO0qaqY+hD25fQl4RCifKwllbKktXushcT1/W/d1bSSnYJNCCEZmbPmcuZ1S76olS6cTTKo6UpNVN2VQjWKqktfCOi3N4yY6HWsoVZmo0eD5kVAqAQ9KU7XNGaOG5h572lRAZBhTV574CJzJv7QuCzzMaMaFjaKk4sRQtgOeUmiiVO85siwncRQa6oThRpKHrO50XUnUdEwMMJw08M7mAtq20MzlAtSEtj4OyZGkweMIiq2AZKToxBgMcdxDCqVrueBfb7ZaaOQiOspZYgbL0FPBySIQD+eMeQc99/HJIsM0weqs+O258mjfZREE1jt5yCKaWiFXpSX0A/5loKmxj2m+YwT69p+7kXg0udw8nlYn19fYGufvSeZBXF0ZGmR2vwmrJKS4WiPswGWWYxzIIgs8fYH6mIJadnQXdNrdMiWAB+yJ7gsXdgLfjqcK10wtJqgmYZ+spnpGgl6up5oaa2fGKi6U8Yau9ZS6Wzpwi7WU1p7BMzaZcLbuBh0q2XM4fZXTc+uOPSGvjuWEWxlaAexr9uiIBf0qG3Uy6HxXwo9B+mn47CvbNSM+LHccDxAyvmjMA9Vdxh1WQiO0eywBVGEaN3Pj972wVxPKwOZ7BJWI2b+K5rOOVUNPbpYJNvJalwZmmahm3j7AhdSz3sPzDRS3R4SQwOCXxP4yVBzJqJarSzcY8H5mXWFfif1QVwPGjGcQWTLp7YrcLxCfyDdAuMW0cq30AOV+plcK1J+dxoXJkqR6igRCeNxjbxp3N6cX5V0Sb2K19dfFrA4uo9Gh8uP9K6Puvw3eyx9SH3IT/qPCZpiW6Y8Gq9mvekrutAN96o/V99ALPj"
      },
      {
        "text": "Try it in the Playground",
        "href": "https://play.vuejs.org/#eNqNUcFqhDAQ/ZUhF12w2rO4Cz301t5aaCEX0dki1SQko6uI/96J7i4qLPQQmHmZ9+Y9ZhQvxsRdiyIVmStsZQgcUmtOUlWN0ZbgXbcOP2xe/KKFs9UNBHGyBj09kCpLFj4zuSFsTJ0T+o6yjUb35GpNRylG6CMYYJKCpwAkzWNQOcgphZG/YZoiX/DQNAttFjMrS+6LRCT2rh6HGsHiOQKtmKIIS19+qmZpYLrmXIKxM1Vo5Yj9HD0vfD7ckGGF3LDWlOyHP/idYPQCfdzldTtjscl/8MuDww78lsqHVHdTYXjwCpdKlfoS52X52qGit8oRKrRhwHYdNrrDILouPbCNVZCtgJ1n/6Xx8JYAmT8epD3fr5cC0oGLQYpkd4zpD27R0vA="
      },
      {
        "text": "Try it in the Playground",
        "href": "https://play.vuejs.org/#eNqVUU1rwzAM/SvCl7SQJTuHdLDDbttthw18MbW6hjW2seU0oeS/T0lounQfUDBGepaenvxO4tG5rIkoClGGra8cPUhT1c56ghcbA756tf1EDztva0iy/Ds4NCbSAEiD7diicafigeA0oFvLPAYNhWICYEE5IL00fMp8Hs0JYe0OinDIqFyIaO7CwdJGihO0KXTcLriK59NYBlUARTyMn6Hv0yHgIp7ARAvl3FXm8yCRiuu1Fv/x23JakVqtz3t5pOjNOQNoC7hPz0nHyRSzEr7Ghxppb/XlZ6JjRlzhTAlA+ypkLWwAM6c+8G2BdzP+/pPbRkOoL/KOldH2mCmtnxr247kKhAb9KuHKgLVtMEkn2knG+sIVzV9sfmy8hfB/swHKwV0oWja4lQKKjoNOivzKrf4L/JPqaQ=="
      },
      {
        "text": "Composable",
        "href": "/guide/reusability/composables"
      },
      {
        "text": "Edit this page on GitHub",
        "href": "https://github.com/vuejs/docs/edit/main/src/guide/components/slots.md"
      }
    ],
    "meta": {
      "description": "Vue.js - The Progressive JavaScript Framework",
      "keywords": ""
    },
    "summary": "Slots This page assumes you've already read the Components Basics. Read that first if you are new to components",
    "tags": [
      "react",
      "vue",
      "angular",
      "javascript",
      "typescript",
      "css",
      "html",
      "node",
      "slots",
      "slot"
    ],
    "id": "slots-slotshtml-part-1",
    "quality": 80
  }
]