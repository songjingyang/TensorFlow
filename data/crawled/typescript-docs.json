[
  {
    "title": "TypeScript: Documentation",
    "url": "https://www.typescriptlang.org/docs/handbook/2/basic-types.html",
    "category": "typescript",
    "content": "Each and every value in JavaScript has a set of behaviors you can observe from running different operations. That sounds abstract, but as a quick example, consider some operations we might run on a variable named message. js// Accessing the property 'toLowerCase'// on 'message' and then calling itmessage.toLowerCase();// Calling 'message'message(); If we break this down, the first runnable line of code accesses a property called toLowerCase and then calls it. The second one tries to call message directly. But assuming we dont know the value of message - and thats pretty common - we cant reliably say what results well get from trying to run any of this code. The behavior of each operation depends entirely on what value we had in the first place. Is message callable? Does it have a property called toLowerCase on it? If it does, is toLowerCase even callable? If both of these values are callable, what do they return? The answers to these questions are usually things we keep in our heads when we write JavaScript, and we have to hope we got all the details right. Lets say message was defined in the following way. jsconst message = \"Hello World!\"; As you can probably guess, if we try to run message.toLowerCase(), well get the same string only in lower-case. What about that second line of code? If youre familiar with JavaScript, youll know this fails with an exception: txtTypeError: message is not a function Itd be great if we could avoid mistakes like this. When we run our code, the way that our JavaScript runtime chooses what to do is by figuring out the type of the value - what sorts of behaviors and capabilities it has. Thats part of what that TypeError is alluding to - its saying that the string \"Hello World!\" cannot be called as a function. For some values, such as the primitives string and number, we can identify their type at runtime using the typeof operator. But for other things like functions, theres no corresponding runtime mechanism to identify their types. For example, consider this function: jsfunction fn(x) { return x.flip();} We can observe by reading the code that this function will only work if given an object with a callable flip property, but JavaScript doesnt surface this information in a way that we can check while the code is running. The only way in pure JavaScript to tell what fn does with a particular value is to call it and see what happens. This kind of behavior makes it hard to predict what the code will do before it runs, which means its harder to know what your code is going to do while youre writing it. Seen in this way, a type is the concept of describing which values can be passed to fn and which will crash. JavaScript only truly provides dynamic typing - running the code to see what happens. The alternative is to use a static type system to make predictions about what the code is expected to do before it runs. Static type-checking Think back to that TypeError we got earlier from trying to call a string as a function. Most people dont like to get any sorts of errors when running their code - those are considered bugs! And when we write new code, we try our best to avoid introducing new bugs. If we add just a bit of code, save our file, re-run the code, and immediately see the error, we might be able to isolate the problem quickly; but thats not always the case. We might not have tested the feature thoroughly enough, so we might never actually run into a potential error that would be thrown! Or if we were lucky enough to witness the error, we might have ended up doing large refactorings and adding a lot of different code that were forced to dig through. Ideally, we could have a tool that helps us find these bugs before our code runs. Thats what a static type-checker like TypeScript does. Static type systems describe the shapes and behaviors of what our values will be when we run our programs. A type-checker like TypeScript uses that information and tells us when things might be going off the rails. tsconst message = \"hello!\"; message();This expression is not callable. Type 'String' has no call signatures.2349This expression is not callable. Type 'String' has no call signatures.Try Running that last sample with TypeScript will give us an error message before we run the code in the first place. Non-exception Failures So far weve been discussing certain things like runtime errors - cases where the JavaScript runtime tells us that it thinks something is nonsensical. Those cases come up because the ECMAScript specification has explicit instructions on how the language should behave when it runs into something unexpected. For example, the specification says that trying to call something that isnt callable should throw an error. Maybe that sounds like obvious behavior, but you could imagine that accessing a property that doesnt exist on an object should throw an error too. Instead, JavaScript gives us different behavior and returns the value undefined: jsconst user = { name: \"Daniel\", age: 26,};user.location; // returns undefined Ultimately, a static type system has to make the call over what code should be flagged as an error in its system, even if its valid JavaScript that wont immediately throw an error. In TypeScript, the following code produces an error about location not being defined: tsconst user = { name: \"Daniel\", age: 26,}; user.location;Property 'location' does not exist on type '{ name: string; age: number; }'.2339Property 'location' does not exist on type '{ name: string; age: number; }'.Try While sometimes that implies a trade-off in what you can express, the intent is to catch legitimate bugs in our programs. And TypeScript catches a lot of legitimate bugs. For example: typos, tsconst announcement = \"Hello World!\"; // How quickly can you spot the typos?announcement.toLocaleLowercase();announcement.toLocalLowerCase(); // We probably meant to write this...announcement.toLocaleLowerCase();Try uncalled functions, tsfunction flipCoin() { // Meant to be Math.random() return Math.random  0.5;Operator '' cannot be applied to types '() = number' and 'number'.2365Operator '' cannot be applied to types '() = number' and 'number'.}Try or basic logic errors. tsconst value = Math.random()  0.5 ? \"a\" : \"b\";if (value !== \"a\") { // ...} else if (value === \"b\") {This comparison appears to be unintentional because the types '\"a\"' and '\"b\"' have no overlap.2367This comparison appears to be unintentional because the types '\"a\"' and '\"b\"' have no overlap. // Oops, unreachable}Try Types for Tooling TypeScript can catch bugs when we make mistakes in our code. Thats great, but TypeScript can also prevent us from making those mistakes in the first place. The type-checker has information to check things like whether were accessing the right properties on variables and other properties. Once it has that information, it can also start suggesting which properties you might want to use. That means TypeScript can be leveraged for editing code too, and the core type-checker can provide error messages and code completion as you type in the editor. Thats part of what people often refer to when they talk about tooling in TypeScript. tsimport express from \"express\";const app = express(); app.get(\"/\", function (req, res) { res.sen sendsendDatesendfilesendFilesendStatus}); app.listen(3000);Try TypeScript takes tooling seriously, and that goes beyond completions and errors as you type. An editor that supports TypeScript can deliver quick fixes to automatically fix errors, refactorings to easily re-organize code, and useful navigation features for jumping to definitions of a variable, or finding all references to a given variable. All of this is built on top of the type-checker and is fully cross-platform, so its likely that your favorite editor has TypeScript support available. tsc, the TypeScript compiler Weve been talking about type-checking, but we havent yet used our type-checker. Lets get acquainted with our new friend tsc, the TypeScript compiler. First well need to grab it via npm. shnpm install -g typescript This installs the TypeScript Compiler tsc globally. You can use npx or similar tools if youd prefer to run tsc from a local node_modules package instead. Now lets move to an empty folder and try writing our first TypeScript program: hello.ts: ts// Greets the world.console.log(\"Hello world!\");Try Notice there are no frills here; this hello world program looks identical to what youd write for a hello world program in JavaScript. And now lets type-check it by running the command tsc which was installed for us by the typescript package. shtsc hello.ts Tada! Wait, tada what exactly? We ran tsc and nothing happened! Well, there were no type errors, so we didnt get any output in our console since there was nothing to report. But check again - we got some file output instead. If we look in our current directory, well see a hello.js file next to hello.ts. Thats the output from our hello.ts file after tsc compiles or transforms it into a plain JavaScript file. And if we check the contents, well see what TypeScript spits out after it processes a .ts file: js// Greets the world.console.log(\"Hello world!\"); In this case, there was very little for TypeScript to transform, so it looks identical to what we wrote. The compiler tries to emit clean readable code that looks like something a person would write. While thats not always so easy, TypeScript indents consistently, is mindful of when our code spans across different lines of code, and tries to keep comments around. What about if we did introduce a type-checking error? Lets rewrite hello.ts: ts// This is an industrial-grade general-purpose greeter function:function greet(person, date) { console.log(Hello ${person}, today is ${date}!);} greet(\"Brendan\");Try If we run tsc hello.ts again, notice that we get an error on the command line! txtExpected 2 arguments, but got 1. TypeScript is telling us we forgot to pass an argument to the greet function, and rightfully so. So far weve only written standard JavaScript, and yet type-checking was still able to find problems with our code. Thanks TypeScript! Emitting with Errors One thing you might not have noticed from the last example was that our hello.js file changed again. If we open that file up then well see that the contents still basically look the same as our input file. That might be a bit surprising given the fact that tsc reported an error about our code, but this is based on one of TypeScripts core values: much of the time, you will know better than TypeScript. To reiterate from earlier, type-checking code limits the sorts of programs you can run, and so theres a tradeoff on what sorts of things a type-checker finds acceptable. Most of the time thats okay, but there are scenarios where those checks get in the way. For example, imagine yourself migrating JavaScript code over to TypeScript and introducing type-checking errors. Eventually youll get around to cleaning things up for the type-checker, but that original JavaScript code was already working! Why should converting it over to TypeScript stop you from running it? So TypeScript doesnt get in your way. Of course, over time, you may want to be a bit more defensive against mistakes, and make TypeScript act a bit more strictly. In that case, you can use the noEmitOnError compiler option. Try changing your hello.ts file and running tsc with that flag: shtsc --noEmitOnError hello.ts Youll notice that hello.js never gets updated. Explicit Types Up until now, we havent told TypeScript what person or date are. Lets edit the code to tell TypeScript that person is a string, and that date should be a Date object. Well also use the toDateString() method on date. tsfunction greet(person: string, date: Date) { console.log(Hello ${person}, today is ${date.toDateString()}!);}Try What we did was add type annotations on person and date to describe what types of values greet can be called with. You can read that signature as greet takes a person of type string, and a date of type Date. With this, TypeScript can tell us about other cases where greet might have been called incorrectly. For example tsfunction greet(person: string, date: Date) { console.log(Hello ${person}, today is ${date.toDateString()}!);} greet(\"Maddison\", Date());Argument of type 'string' is not assignable to parameter of type 'Date'.2345Argument of type 'string' is not assignable to parameter of type 'Date'.Try Huh? TypeScript reported an error on our second argument, but why? Perhaps surprisingly, calling Date() in JavaScript returns a string. On the other hand, constructing a Date with new Date() actually gives us what we were expecting. Anyway, we can quickly fix up the error: tsfunction greet(person: string, date: Date) { console.log(Hello ${person}, today is ${date.toDateString()}!);} greet(\"Maddison\", new Date());Try Keep in mind, we dont always have to write explicit type annotations. In many cases, TypeScript can even just infer (or figure out) the types for us even if we omit them. tslet msg = \"hello there!\"; let msg: stringTry Even though we didnt tell TypeScript that msg had the type string it was able to figure that out. Thats a feature, and its best not to add annotations when the type system would end up inferring the same type anyway. Note: The message bubble inside the previous code sample is what your editor would show if you had hovered over the word. Erased Types Lets take a look at what happens when we compile the above function greet with tsc to output JavaScript: ts\"use strict\";function greet(person, date) { console.log(\"Hello \".concat(person, \", today is \").concat(date.toDateString(), \"!\"));}greet(\"Maddison\", new Date()); Try Notice two things here: Our person and date parameters no longer have type annotations. Our template string - that string that used backticks (the  character) - was converted to plain strings with concatenations. More on that second point later, but lets now focus on that first point. Type annotations arent part of JavaScript (or ECMAScript to be pedantic), so there really arent any browsers or other runtimes that can just run TypeScript unmodified. Thats why TypeScript needs a compiler in the first place - it needs some way to strip out or transform any TypeScript-specific code so that you can run it. Most TypeScript-specific code gets erased away, and likewise, here our type annotations were completely erased. Remember: Type annotations never change the runtime behavior of your program. Downleveling One other difference from the above was that our template string was rewritten from jsHello ${person}, today is ${date.toDateString()}!; to js\"Hello \".concat(person, \", today is \").concat(date.toDateString(), \"!\"); Why did this happen? Template strings are a feature from a version of ECMAScript called ECMAScript 2015 (a.k.a. ECMAScript 6, ES2015, ES6, etc. - dont ask). TypeScript has the ability to rewrite code from newer versions of ECMAScript to older ones such as ECMAScript 3 or ECMAScript 5 (a.k.a. ES5). This process of moving from a newer or higher version of ECMAScript down to an older or lower one is sometimes called downleveling. By default TypeScript targets ES5, an extremely old version of ECMAScript. We could have chosen something a little bit more recent by using the target option. Running with --target es2015 changes TypeScript to target ECMAScript 2015, meaning code should be able to run wherever ECMAScript 2015 is supported. So running tsc --target es2015 hello.ts gives us the following output: jsfunction greet(person, date) { console.log(Hello ${person}, today is ${date.toDateString()}!);}greet(\"Maddison\", new Date()); While the default target is ES5, the great majority of current browsers support ES2015. Most developers can therefore safely specify ES2015 or above as a target, unless compatibility with certain ancient browsers is important. Strictness Different users come to TypeScript looking for different things in a type-checker. Some people are looking for a more loose opt-in experience which can help validate only some parts of their program, and still have decent tooling. This is the default experience with TypeScript, where types are optional, inference takes the most lenient types, and theres no checking for potentially null/undefined values. Much like how tsc emits in the face of errors, these defaults are put in place to stay out of your way. If youre migrating existing JavaScript, that might be a desirable first step. In contrast, a lot of users prefer to have TypeScript validate as much as it can straight away, and thats why the language provides strictness settings as well. These strictness settings turn static type-checking from a switch (either your code is checked or not) into something closer to a dial. The further you turn this dial up, the more TypeScript will check for you. This can require a little extra work, but generally speaking it pays for itself in the long run, and enables more thorough checks and more accurate tooling. When possible, a new codebase should always turn these strictness checks on. TypeScript has several type-checking strictness flags that can be turned on or off, and all of our examples will be written with all of them enabled unless otherwise stated. The strict flag in the CLI, or \"strict\": true in a tsconfig.json toggles them all on simultaneously, but we can opt out of them individually. The two biggest ones you should know about are noImplicitAny and strictNullChecks. noImplicitAny Recall that in some places, TypeScript doesnt try to infer types for us and instead falls back to the most lenient type: any. This isnt the worst thing that can happen - after all, falling back to any is just the plain JavaScript experience anyway. However, using any often defeats the purpose of using TypeScript in the first place. The more typed your program is, the more validation and tooling youll get, meaning youll run into fewer bugs as you code. Turning on the noImplicitAny flag will issue an error on any variables whose type is implicitly inferred as any. strictNullChecks By default, values like null and undefined are assignable to any other type. This can make writing some code easier, but forgetting to handle null and undefined is the cause of countless bugs in the world - some consider it a billion dollar mistake! The strictNullChecks flag makes handling null and undefined more explicit, and spares us from worrying about whether we forgot to handle null and undefined.",
    "headings": [
      {
        "level": 2,
        "text": "Static type-checking",
        "id": "static-type-checking"
      },
      {
        "level": 2,
        "text": "Non-exception Failures",
        "id": "non-exception-failures"
      },
      {
        "level": 2,
        "text": "Types for Tooling",
        "id": "types-for-tooling"
      },
      {
        "level": 2,
        "text": "tsc, the TypeScript compiler",
        "id": "tsc-the-typescript-compiler"
      },
      {
        "level": 2,
        "text": "Emitting with Errors",
        "id": "emitting-with-errors"
      },
      {
        "level": 2,
        "text": "Explicit Types",
        "id": "explicit-types"
      },
      {
        "level": 2,
        "text": "Erased Types",
        "id": "erased-types"
      },
      {
        "level": 2,
        "text": "Downleveling",
        "id": "downleveling"
      },
      {
        "level": 2,
        "text": "Strictness",
        "id": "strictness"
      },
      {
        "level": 2,
        "text": "noImplicitAny",
        "id": "noimplicitany"
      },
      {
        "level": 2,
        "text": "strictNullChecks",
        "id": "strictnullchecks"
      }
    ],
    "codeBlocks": [
      {
        "language": "text",
        "code": "js// Accessing the property 'toLowerCase'// on 'message' and then calling itmessage.toLowerCase();// Calling 'message'message();"
      },
      {
        "language": "text",
        "code": "// Accessing the property 'toLowerCase'// on 'message' and then calling itmessage.toLowerCase();// Calling 'message'message();"
      },
      {
        "language": "text",
        "code": "toLowerCase"
      },
      {
        "language": "text",
        "code": "toLowerCase"
      },
      {
        "language": "text",
        "code": "toLowerCase"
      },
      {
        "language": "text",
        "code": "jsconst message = \"Hello World!\";"
      },
      {
        "language": "text",
        "code": "const message = \"Hello World!\";"
      },
      {
        "language": "text",
        "code": "message.toLowerCase()"
      },
      {
        "language": "text",
        "code": "txtTypeError: message is not a function"
      },
      {
        "language": "text",
        "code": "TypeError: message is not a function"
      },
      {
        "language": "text",
        "code": "\"Hello World!\""
      },
      {
        "language": "text",
        "code": "jsfunction fn(x) {  return x.flip();}"
      },
      {
        "language": "text",
        "code": "function fn(x) {  return x.flip();}"
      },
      {
        "language": "text",
        "code": "tsconst message = \"hello!\"; message();This expression is not callable.\n  Type 'String' has no call signatures.2349This expression is not callable.\n  Type 'String' has no call signatures.Try"
      },
      {
        "language": "text",
        "code": "const message = \"hello!\"; message();This expression is not callable.\n  Type 'String' has no call signatures.2349This expression is not callable.\n  Type 'String' has no call signatures."
      },
      {
        "language": "text",
        "code": "jsconst user = {  name: \"Daniel\",  age: 26,};user.location; // returns undefined"
      },
      {
        "language": "text",
        "code": "const user = {  name: \"Daniel\",  age: 26,};user.location; // returns undefined"
      },
      {
        "language": "text",
        "code": "tsconst user = {  name: \"Daniel\",  age: 26,}; user.location;Property 'location' does not exist on type '{ name: string; age: number; }'.2339Property 'location' does not exist on type '{ name: string; age: number; }'.Try"
      },
      {
        "language": "text",
        "code": "const user = {  name: \"Daniel\",  age: 26,}; user.location;Property 'location' does not exist on type '{ name: string; age: number; }'.2339Property 'location' does not exist on type '{ name: string; age: number; }'."
      },
      {
        "language": "text",
        "code": "tsconst announcement = \"Hello World!\"; // How quickly can you spot the typos?announcement.toLocaleLowercase();announcement.toLocalLowerCase(); // We probably meant to write this...announcement.toLocaleLowerCase();Try"
      },
      {
        "language": "text",
        "code": "const announcement = \"Hello World!\"; // How quickly can you spot the typos?announcement.toLocaleLowercase();announcement.toLocalLowerCase(); // We probably meant to write this...announcement.toLocaleLowerCase();"
      },
      {
        "language": "text",
        "code": "tsfunction flipCoin() {  // Meant to be Math.random()  return Math.random < 0.5;Operator '<' cannot be applied to types '() => number' and 'number'.2365Operator '<' cannot be applied to types '() => number' and 'number'.}Try"
      },
      {
        "language": "text",
        "code": "function flipCoin() {  // Meant to be Math.random()  return Math.random < 0.5;Operator '<' cannot be applied to types '() => number' and 'number'.2365Operator '<' cannot be applied to types '() => number' and 'number'.}"
      },
      {
        "language": "text",
        "code": "tsconst value = Math.random() < 0.5 ? \"a\" : \"b\";if (value !== \"a\") {  // ...} else if (value === \"b\") {This comparison appears to be unintentional because the types '\"a\"' and '\"b\"' have no overlap.2367This comparison appears to be unintentional because the types '\"a\"' and '\"b\"' have no overlap.  // Oops, unreachable}Try"
      },
      {
        "language": "text",
        "code": "const value = Math.random() < 0.5 ? \"a\" : \"b\";if (value !== \"a\") {  // ...} else if (value === \"b\") {This comparison appears to be unintentional because the types '\"a\"' and '\"b\"' have no overlap.2367This comparison appears to be unintentional because the types '\"a\"' and '\"b\"' have no overlap.  // Oops, unreachable}"
      },
      {
        "language": "text",
        "code": "tsimport express from \"express\";const app = express(); app.get(\"/\", function (req, res) {  res.sen         sendsendDatesendfilesendFilesendStatus}); app.listen(3000);Try"
      },
      {
        "language": "text",
        "code": "import express from \"express\";const app = express(); app.get(\"/\", function (req, res) {  res.sen         sendsendDatesendfilesendFilesendStatus}); app.listen(3000);"
      },
      {
        "language": "text",
        "code": "shnpm install -g typescript"
      },
      {
        "language": "text",
        "code": "npm install -g typescript"
      },
      {
        "language": "text",
        "code": "node_modules"
      },
      {
        "language": "text",
        "code": "ts// Greets the world.console.log(\"Hello world!\");Try"
      },
      {
        "language": "text",
        "code": "// Greets the world.console.log(\"Hello world!\");"
      },
      {
        "language": "text",
        "code": "shtsc hello.ts"
      },
      {
        "language": "text",
        "code": "tsc hello.ts"
      },
      {
        "language": "text",
        "code": "js// Greets the world.console.log(\"Hello world!\");"
      },
      {
        "language": "text",
        "code": "// Greets the world.console.log(\"Hello world!\");"
      },
      {
        "language": "text",
        "code": "ts// This is an industrial-grade general-purpose greeter function:function greet(person, date) {  console.log(`Hello ${person}, today is ${date}!`);} greet(\"Brendan\");Try"
      },
      {
        "language": "text",
        "code": "// This is an industrial-grade general-purpose greeter function:function greet(person, date) {  console.log(`Hello ${person}, today is ${date}!`);} greet(\"Brendan\");"
      },
      {
        "language": "text",
        "code": "tsc hello.ts"
      },
      {
        "language": "text",
        "code": "txtExpected 2 arguments, but got 1."
      },
      {
        "language": "text",
        "code": "Expected 2 arguments, but got 1."
      },
      {
        "language": "text",
        "code": "noEmitOnError"
      },
      {
        "language": "text",
        "code": "shtsc --noEmitOnError hello.ts"
      },
      {
        "language": "text",
        "code": "tsc --noEmitOnError hello.ts"
      },
      {
        "language": "text",
        "code": "toDateString()"
      },
      {
        "language": "text",
        "code": "tsfunction greet(person: string, date: Date) {  console.log(`Hello ${person}, today is ${date.toDateString()}!`);}Try"
      },
      {
        "language": "text",
        "code": "function greet(person: string, date: Date) {  console.log(`Hello ${person}, today is ${date.toDateString()}!`);}"
      },
      {
        "language": "text",
        "code": "tsfunction greet(person: string, date: Date) {  console.log(`Hello ${person}, today is ${date.toDateString()}!`);} greet(\"Maddison\", Date());Argument of type 'string' is not assignable to parameter of type 'Date'.2345Argument of type 'string' is not assignable to parameter of type 'Date'.Try"
      },
      {
        "language": "text",
        "code": "function greet(person: string, date: Date) {  console.log(`Hello ${person}, today is ${date.toDateString()}!`);} greet(\"Maddison\", Date());Argument of type 'string' is not assignable to parameter of type 'Date'.2345Argument of type 'string' is not assignable to parameter of type 'Date'."
      },
      {
        "language": "text",
        "code": "tsfunction greet(person: string, date: Date) {  console.log(`Hello ${person}, today is ${date.toDateString()}!`);} greet(\"Maddison\", new Date());Try"
      },
      {
        "language": "text",
        "code": "function greet(person: string, date: Date) {  console.log(`Hello ${person}, today is ${date.toDateString()}!`);} greet(\"Maddison\", new Date());"
      },
      {
        "language": "text",
        "code": "tslet msg = \"hello there!\";    let msg: stringTry"
      },
      {
        "language": "text",
        "code": "let msg = \"hello there!\";    let msg: string"
      },
      {
        "language": "text",
        "code": "ts\"use strict\";function greet(person, date) {    console.log(\"Hello \".concat(person, \", today is \").concat(date.toDateString(), \"!\"));}greet(\"Maddison\", new Date()); Try"
      },
      {
        "language": "text",
        "code": "\"use strict\";function greet(person, date) {    console.log(\"Hello \".concat(person, \", today is \").concat(date.toDateString(), \"!\"));}greet(\"Maddison\", new Date());"
      },
      {
        "language": "text",
        "code": "js`Hello ${person}, today is ${date.toDateString()}!`;"
      },
      {
        "language": "text",
        "code": "`Hello ${person}, today is ${date.toDateString()}!`;"
      },
      {
        "language": "text",
        "code": "js\"Hello \".concat(person, \", today is \").concat(date.toDateString(), \"!\");"
      },
      {
        "language": "text",
        "code": "\"Hello \".concat(person, \", today is \").concat(date.toDateString(), \"!\");"
      },
      {
        "language": "text",
        "code": "--target es2015"
      },
      {
        "language": "text",
        "code": "tsc --target es2015 hello.ts"
      },
      {
        "language": "text",
        "code": "jsfunction greet(person, date) {  console.log(`Hello ${person}, today is ${date.toDateString()}!`);}greet(\"Maddison\", new Date());"
      },
      {
        "language": "text",
        "code": "function greet(person, date) {  console.log(`Hello ${person}, today is ${date.toDateString()}!`);}greet(\"Maddison\", new Date());"
      },
      {
        "language": "text",
        "code": "\"strict\": true"
      },
      {
        "language": "text",
        "code": "tsconfig.json"
      },
      {
        "language": "text",
        "code": "noImplicitAny"
      },
      {
        "language": "text",
        "code": "strictNullChecks"
      },
      {
        "language": "text",
        "code": "noImplicitAny"
      },
      {
        "language": "text",
        "code": "noImplicitAny"
      },
      {
        "language": "text",
        "code": "strictNullChecks"
      },
      {
        "language": "text",
        "code": "strictNullChecks"
      }
    ],
    "links": [
      {
        "text": "Try",
        "href": "https://www.typescriptlang.org/play/#code/PTAEAEFMCdoe2gZwFygEwGYAsBOAUAMZwB2iALqALaSKICGA5pKALygBEAFpADY9wBCdgG48earUaQAFAEphQA"
      },
      {
        "text": "the ECMAScript specification",
        "href": "https://tc39.github.io/ecma262/"
      },
      {
        "text": "Try",
        "href": "https://www.typescriptlang.org/play/#code/PTAEAEFMCdoe2gZwFygEwGYME4BQBjOAO0QBdQBXRGUAXlAG9dRQiBDAW0lQCIARNkQCWkADY8ANM1BsA5t3QA2KQF8A3LlxUYAOlFx8bUkOJqgA"
      },
      {
        "text": "Try",
        "href": "https://www.typescriptlang.org/play/#code/PTAEAEDsHsFECd7XgZwFAGNqRQF1AIaQwCukGApgLYWT4C8oARABIUA270oA6suwBMAhEwDcaNCFAtoAd1ABHEgEsMAa3YBPUBiKhN0EqBQAHaPlwALCqFyazKAPxoipctVq4AdLmgAZaF12CgDZCnhdFAoACgBKcVdDdxo6H39AgnZQ8IBhAii48UkwHhsTJAAjAgqtUBoiC25ZeGVcGytlFC9ul2IkyhTvXwCgkLlc-Jj4oA"
      },
      {
        "text": "Try",
        "href": "https://www.typescriptlang.org/play/#code/PTAEAEDsHsFVIK4GcCmATAMtAxgQwDZIBQIEKATudOUgFygBMAzAGwCsRAZgpNgC4BLaJFCd8AgA4BhaAMgAKAJSgA3kVChSAWRS5IfUH2igARilBbcfABYA6cnrTQAtkvWhyKPgnIjLN+0cXUAAeUAAGWzYAbiIAXyA"
      },
      {
        "text": "Try",
        "href": "https://www.typescriptlang.org/play/#code/PTAEAEFMCdoe2gZwFygEwGYBsB2AUAMZwB2iALqAG4CGANgK6SgC8oAstWQBYB001xACZwAtgAoAlKAA8oAAw8ArKAD8oAETV1oVOoBG6gNx4AlgDNQYmgyYBCZq03qpAbzyhQIUDx94AvqCQtIhM5pbWjCwOGgau7p5gAPJwAA6IADSg9MTQkNQEXNR6tJD+QA"
      },
      {
        "text": "Try",
        "href": "https://www.typescriptlang.org/play/#code/PTAEAEDsHsFECd7XgZwFAggUxQWWgCYCuANlgJKQAuWSADmgJYC2dyVoWAHnfDiqABmSZqABE3XvzEBuNAGNokFBwCGdOqAC8nHnxQoAFAEo5adXQB0AcyxVDY4GIA0QopHlVGS0Ib4BHV31jUABvNFBQfUsULEgMMEik0AA9AB80AF9TNHMNSxJGFTjDAGYABkrTIA"
      },
      {
        "text": "your favorite editor has TypeScript support available",
        "href": "https://github.com/Microsoft/TypeScript/wiki/TypeScript-Editor-Support"
      },
      {
        "text": "Try",
        "href": "https://www.typescriptlang.org/play/#code/PTAEHECcFNoFwM6jgC2qA7ge0gGwCYB0AUAMZYB2CWu0huWA5gBQBEAEtLg5jgQISsAlAG4gA"
      },
      {
        "text": "Try",
        "href": "https://www.typescriptlang.org/play/#code/PTAEAEDsHsFECd7XgZwFAlAFQBYEsVQDQBDSIyAEwFcUAXePEgGwFoBzeEygU1HZ6QeXNgAdq8UdBR9OPHnWGgAZtUgBjOnmiQAXGlUatO-vHl0AFKOEodAGlCUSigJSgA3mlCh1O28x4AOmZodgsAAwAJHmYQ0AASd2tUHQBfBzpoJwBPIkJEp0VUgEJwlwBuNFS0NDkFCwAiACEzKjIGiqA"
      },
      {
        "text": "noEmitOnError",
        "href": "/tsconfig#noEmitOnError"
      },
      {
        "text": "Try",
        "href": "https://www.typescriptlang.org/play/#code/GYVwdgxgLglg9mABAcwE4FN1QBQAd2oDOCAXIoVKjGMgDSIAmAhlOmQCIvoCUiA3gChEiCAmIAbdADpxcZNgAGACXTjZiACR98RBAF96UOMwCeiGIU19mrKUc6sAypWrzuegIQLuAbgF6gA"
      },
      {
        "text": "Try",
        "href": "https://www.typescriptlang.org/play/#code/PTAEAEFMCdoe2gZwFygEwGYAsBWAUAGYCuAdgMYAuAlnCaAObSSQUAUADjIraohdFRL0ANKAAmAQwqRUAESmQAlKADeeUKDK1uAG0gA6HXHqsABgAlIOo6AAkKzkloBfURTiSAnqCqI7KyWl9d3lpAGV+QRNFZwBCU0UAbjxnPDxGZjYAIgBZCTExX1os0VDIVkUkoA"
      },
      {
        "text": "Try",
        "href": "https://www.typescriptlang.org/play/#code/GYVwdgxgLglg9mABAcwE4FN1QBQAd2oDOCAXIoVKjGMgDSIAmAhlOmQCIvoCUiA3gChEiCAmIAbdADpxcZNgAGACXTjZiACR98RBAF96UOMwCeiGIU19mrKUc6sAypWrzuegIQLuAbgF6BATRMHAAiAFkmBgYLBFD6MHQAd0QHdGxuXyA"
      },
      {
        "text": "Try",
        "href": "https://www.typescriptlang.org/play/#code/DYUwLgBAtgzg5hAvBARACxMYB7CYMBOIAhCgNwBQA9FRBAHoD8QA"
      },
      {
        "text": "Try",
        "href": "https://www.typescriptlang.org/play/#code/PTAEAEGcAsHsHcCiBbAlgFwFAgughgE4DmApugFygmQCsmAZgK4B2AxuqrM6EQSWQAoADiQKQulSOgKpmRADSgAJnnQlKAEVUkAlKADemUKFZdxAGxIA6c7CICABgAkS526AAk+kWK4BfRXRYFQBPUFRIT30VNSsgrTUAZWlZex0-AEIHHQBuTD9MTF5+dAEAIgBZPCUlCK4yxWYSeFAEkgEdXKA"
      },
      {
        "text": "target",
        "href": "/tsconfig#target"
      },
      {
        "text": "strict",
        "href": "/tsconfig#strict"
      },
      {
        "text": "tsconfig.json",
        "href": "https://www.typescriptlang.org/docs/handbook/tsconfig-json.html"
      },
      {
        "text": "noImplicitAny",
        "href": "/tsconfig#noImplicitAny"
      },
      {
        "text": "strictNullChecks",
        "href": "/tsconfig#strictNullChecks"
      },
      {
        "text": "noImplicitAny",
        "href": "/tsconfig#noImplicitAny"
      },
      {
        "text": "billion dollar mistake",
        "href": "https://www.youtube.com/watch?v=ybrQvs4x0Ps"
      },
      {
        "text": "strictNullChecks",
        "href": "/tsconfig#strictNullChecks"
      }
    ],
    "meta": {
      "description": "Step one in learning TypeScript: The basic types.",
      "keywords": ""
    },
    "summary": "Each and every value in JavaScript has a set of behaviors you can observe from running different operations",
    "tags": [
      "react",
      "angular",
      "javascript",
      "typescript",
      "html",
      "node",
      "vite",
      "types",
      "documentation",
      "static"
    ],
    "id": "typescript-documentation-basictypeshtml-part-1",
    "quality": 100
  },
  {
    "title": "TypeScript: Documentation",
    "url": "https://www.typescriptlang.org/docs/handbook/2/objects.html",
    "category": "typescript",
    "content": "In JavaScript, the fundamental way that we group and pass around data is through objects. In TypeScript, we represent those through object types. As weve seen, they can be anonymous: tsfunction greet(person: { name: string; age: number }) { return \"Hello \" + person.name;}Try or they can be named by using either an interface: tsinterface Person { name: string; age: number;} function greet(person: Person) { return \"Hello \" + person.name;}Try or a type alias: tstype Person = { name: string; age: number;}; function greet(person: Person) { return \"Hello \" + person.name;}Try In all three examples above, weve written functions that take objects that contain the property name (which must be a string) and age (which must be a number). Quick Reference We have cheat-sheets available for both type and interface, if you want a quick look at the important every-day syntax at a glance. Property Modifiers Each property in an object type can specify a couple of things: the type, whether the property is optional, and whether the property can be written to. Optional Properties Much of the time, well find ourselves dealing with objects that might have a property set. In those cases, we can mark those properties as optional by adding a question mark (?) to the end of their names. tsinterface PaintOptions { shape: Shape; xPos?: number; yPos?: number;} function paintShape(opts: PaintOptions) { // ...} const shape = getShape();paintShape({ shape });paintShape({ shape, xPos: 100 });paintShape({ shape, yPos: 100 });paintShape({ shape, xPos: 100, yPos: 100 });Try In this example, both xPos and yPos are considered optional. We can choose to provide either of them, so every call above to paintShape is valid. All optionality really says is that if the property is set, it better have a specific type. We can also read from those properties - but when we do under strictNullChecks, TypeScript will tell us theyre potentially undefined. tsfunction paintShape(opts: PaintOptions) { let xPos = opts.xPos; (property) PaintOptions.xPos?: number  undefined let yPos = opts.yPos; (property) PaintOptions.yPos?: number  undefined // ...}Try In JavaScript, even if the property has never been set, we can still access it - its just going to give us the value undefined. We can just handle undefined specially by checking for it. tsfunction paintShape(opts: PaintOptions) { let xPos = opts.xPos === undefined ? 0 : opts.xPos; let xPos: number let yPos = opts.yPos === undefined ? 0 : opts.yPos; let yPos: number // ...}Try Note that this pattern of setting defaults for unspecified values is so common that JavaScript has syntax to support it. tsfunction paintShape({ shape, xPos = 0, yPos = 0 }: PaintOptions) { console.log(\"x coordinate at\", xPos); (parameter) xPos: number console.log(\"y coordinate at\", yPos); (parameter) yPos: number // ...}Try Here we used a destructuring pattern for paintShapes parameter, and provided default values for xPos and yPos. Now xPos and yPos are both definitely present within the body of paintShape, but optional for any callers to paintShape. Note that there is currently no way to place type annotations within destructuring patterns. This is because the following syntax already means something different in JavaScript. tsfunction draw({ shape: Shape, xPos: number = 100 /*...*/ }) { render(shape);Cannot find name 'shape'. Did you mean 'Shape'?2552Cannot find name 'shape'. Did you mean 'Shape'? render(xPos);Cannot find name 'xPos'.2304Cannot find name 'xPos'.}Try In an object destructuring pattern, shape: Shape means grab the property shape and redefine it locally as a variable named Shape. Likewise xPos: number creates a variable named number whose value is based on the parameters xPos. readonly Properties Properties can also be marked as readonly for TypeScript. While it wont change any behavior at runtime, a property marked as readonly cant be written to during type-checking. tsinterface SomeType { readonly prop: string;} function doSomething(obj: SomeType) { // We can read from 'obj.prop'. console.log(prop has the value '${obj.prop}'.); // But we can't re-assign it. obj.prop = \"hello\";Cannot assign to 'prop' because it is a read-only property.2540Cannot assign to 'prop' because it is a read-only property.}Try Using the readonly modifier doesnt necessarily imply that a value is totally immutable - or in other words, that its internal contents cant be changed. It just means the property itself cant be re-written to. tsinterface Home { readonly resident: { name: string; age: number };} function visitForBirthday(home: Home) { // We can read and update properties from 'home.resident'. console.log(Happy birthday ${home.resident.name}!); home.resident.age++;} function evict(home: Home) { // But we can't write to the 'resident' property itself on a 'Home'. home.resident = {Cannot assign to 'resident' because it is a read-only property.2540Cannot assign to 'resident' because it is a read-only property. name: \"Victor the Evictor\", age: 42, };}Try Its important to manage expectations of what readonly implies. Its useful to signal intent during development time for TypeScript on how an object should be used. TypeScript doesnt factor in whether properties on two types are readonly when checking whether those types are compatible, so readonly properties can also change via aliasing. tsinterface Person { name: string; age: number;} interface ReadonlyPerson { readonly name: string; readonly age: number;} let writablePerson: Person = { name: \"Person McPersonface\", age: 42,}; // workslet readonlyPerson: ReadonlyPerson = writablePerson; console.log(readonlyPerson.age); // prints '42'writablePerson.age++;console.log(readonlyPerson.age); // prints '43'Try Using mapping modifiers, you can remove readonly attributes. Index Signatures Sometimes you dont know all the names of a types properties ahead of time, but you do know the shape of the values. In those cases you can use an index signature to describe the types of possible values, for example: tsinterface StringArray { [index: number]: string;} const myArray: StringArray = getStringArray();const secondItem = myArray[1]; const secondItem: stringTry Above, we have a StringArray interface which has an index signature. This index signature states that when a StringArray is indexed with a number, it will return a string. Only some types are allowed for index signature properties: string, number, symbol, template string patterns, and union types consisting only of these. It is possible to support multiple types of indexers... It is possible to support multiple types of indexers. Note that when using both number and string indexers, the type returned from a numeric indexer must be a subtype of the type returned from the string indexer. This is because when indexing with a number, JavaScript will actually convert that to a string before indexing into an object. That means that indexing with 100 (a number) is the same thing as indexing with \"100\" (a string), so the two need to be consistent. tsinterface Animal { name: string;} interface Dog extends Animal { breed: string;} // Error: indexing with a numeric string might get you a completely separate type of Animal!interface NotOkay { [x: number]: Animal;'number' index type 'Animal' is not assignable to 'string' index type 'Dog'.2413'number' index type 'Animal' is not assignable to 'string' index type 'Dog'. [x: string]: Dog;}Try While string index signatures are a powerful way to describe the dictionary pattern, they also enforce that all properties match their return type. This is because a string index declares that obj.property is also available as obj[\"property\"]. In the following example, names type does not match the string indexs type, and the type checker gives an error: tsinterface NumberDictionary { [index: string]: number; length: number; // ok name: string;Property 'name' of type 'string' is not assignable to 'string' index type 'number'.2411Property 'name' of type 'string' is not assignable to 'string' index type 'number'.}Try However, properties of different types are acceptable if the index signature is a union of the property types: tsinterface NumberOrStringDictionary { [index: string]: number  string; length: number; // ok, length is a number name: string; // ok, name is a string}Try Finally, you can make index signatures readonly in order to prevent assignment to their indices: tsinterface ReadonlyStringArray { readonly [index: number]: string;} let myArray: ReadonlyStringArray = getReadOnlyStringArray();myArray[2] = \"Mallory\";Index signature in type 'ReadonlyStringArray' only permits reading.2542Index signature in type 'ReadonlyStringArray' only permits reading.Try You cant set myArray[2] because the index signature is readonly. Excess Property Checks Where and how an object is assigned a type can make a difference in the type system. One of the key examples of this is in excess property checking, which validates the object more thoroughly when it is created and assigned to an object type during creation. tsinterface SquareConfig { color?: string; width?: number;} function createSquare(config: SquareConfig): { color: string; area: number } { return { color: config.color  \"red\", area: config.width ? config.width * config.width : 20, };} let mySquare = createSquare({ colour: \"red\", width: 100 });Object literal may only specify known properties, but 'colour' does not exist in type 'SquareConfig'. Did you mean to write 'color'?2561Object literal may only specify known properties, but 'colour' does not exist in type 'SquareConfig'. Did you mean to write 'color'?Try Notice the given argument to createSquare is spelled colour instead of color. In plain JavaScript, this sort of thing fails silently. You could argue that this program is correctly typed, since the width properties are compatible, theres no color property present, and the extra colour property is insignificant. However, TypeScript takes the stance that theres probably a bug in this code. Object literals get special treatment and undergo excess property checking when assigning them to other variables, or passing them as arguments. If an object literal has any properties that the target type doesnt have, youll get an error: tslet mySquare = createSquare({ colour: \"red\", width: 100 });Object literal may only specify known properties, but 'colour' does not exist in type 'SquareConfig'. Did you mean to write 'color'?2561Object literal may only specify known properties, but 'colour' does not exist in type 'SquareConfig'. Did you mean to write 'color'?Try Getting around these checks is actually really simple. The easiest method is to just use a type assertion: tslet mySquare = createSquare({ width: 100, opacity: 0.5 } as SquareConfig);Try However, a better approach might be to add a string index signature if youre sure that the object can have some extra properties that are used in some special way. If SquareConfig can have color and width properties with the above types, but could also have any number of other properties, then we could define it like so: tsinterface SquareConfig { color?: string; width?: number; [propName: string]: unknown;}Try Here were saying that SquareConfig can have any number of properties, and as long as they arent color or width, their types dont matter. One final way to get around these checks, which might be a bit surprising, is to assign the object to another variable: Since assigning squareOptions wont undergo excess property checks, the compiler wont give you an error: tslet squareOptions = { colour: \"red\", width: 100 };let mySquare = createSquare(squareOptions);Try The above workaround will work as long as you have a common property between squareOptions and SquareConfig. In this example, it was the property width. It will however, fail if the variable does not have any common object property. For example: tslet squareOptions = { colour: \"red\" };let mySquare = createSquare(squareOptions);Type '{ colour: string; }' has no properties in common with type 'SquareConfig'.2559Type '{ colour: string; }' has no properties in common with type 'SquareConfig'.Try Keep in mind that for simple code like above, you probably shouldnt be trying to get around these checks. For more complex object literals that have methods and hold state, you might need to keep these techniques in mind, but a majority of excess property errors are actually bugs. That means if youre running into excess property checking problems for something like option bags, you might need to revise some of your type declarations. In this instance, if its okay to pass an object with both a color or colour property to createSquare, you should fix up the definition of SquareConfig to reflect that. Extending Types Its pretty common to have types that might be more specific versions of other types. For example, we might have a BasicAddress type that describes the fields necessary for sending letters and packages in the U.S. tsinterface BasicAddress { name?: string; street: string; city: string; country: string; postalCode: string;}Try In some situations thats enough, but addresses often have a unit number associated with them if the building at an address has multiple units. We can then describe an AddressWithUnit. tsinterface AddressWithUnit { name?: string; unit: string; street: string; city: string; country: string; postalCode: string;}Try This does the job, but the downside here is that we had to repeat all the other fields from BasicAddress when our changes were purely additive. Instead, we can extend the original BasicAddress type and just add the new fields that are unique to AddressWithUnit. tsinterface BasicAddress { name?: string; street: string; city: string; country: string; postalCode: string;} interface AddressWithUnit extends BasicAddress { unit: string;}Try The extends keyword on an interface allows us to effectively copy members from other named types, and add whatever new members we want. This can be useful for cutting down the amount of type declaration boilerplate we have to write, and for signaling intent that several different declarations of the same property might be related. For example, AddressWithUnit didnt need to repeat the street property, and because street originates from BasicAddress, a reader will know that those two types are related in some way. interfaces can also extend from multiple types. tsinterface Colorful { color: string;} interface Circle { radius: number;} interface ColorfulCircle extends Colorful, Circle {} const cc: ColorfulCircle = { color: \"red\", radius: 42,};Try Intersection Types interfaces allowed us to build up new types from other types by extending them. TypeScript provides another construct called intersection types that is mainly used to combine existing object types. An intersection type is defined using the & operator. tsinterface Colorful { color: string;}interface Circle { radius: number;} type ColorfulCircle = Colorful & Circle;Try Here, weve intersected Colorful and Circle to produce a new type that has all the members of Colorful and Circle. tsfunction draw(circle: Colorful & Circle) { console.log(Color was ${circle.color}); console.log(Radius was ${circle.radius});} // okaydraw({ color: \"blue\", radius: 42 }); // oopsdraw({ color: \"red\", raidus: 42 });Object literal may only specify known properties, but 'raidus' does not exist in type 'Colorful & Circle'. Did you mean to write 'radius'?2561Object literal may only specify known properties, but 'raidus' does not exist in type 'Colorful & Circle'. Did you mean to write 'radius'?Try Interface Extension vs. Intersection We just looked at two ways to combine types which are similar, but are actually subtly different. With interfaces, we could use an extends clause to extend from other types, and we were able to do something similar with intersections and name the result with a type alias. The principal difference between the two is how conflicts are handled, and that difference is typically one of the main reasons why youd pick one over the other between an interface and a type alias of an intersection type. If interfaces are defined with the same name, TypeScript will attempt to merge them if the properties are compatible. If the properties are not compatible (i.e., they have the same property name but different types), TypeScript will raise an error. In the case of intersection types, properties with different types will be merged automatically. When the type is used later, TypeScript will expect the property to satisfy both types simultaneously, which may produce unexpected results. For example, the following code will throw an error because the properties are incompatible: tsinterface Person { name: string;}interface Person { name: number;} In contrast, the following code will compile, but it results in a never type: tsinterface Person1 { name: string;} interface Person2 { name: number;} type Staff = Person1 & Person2 declare const staffer: Staff;staffer.name; (property) name: neverTry In this case, Staff would require the name property to be both a string and a number, which results in property being of type never. Generic Object Types Lets imagine a Box type that can contain any value - strings, numbers, Giraffes, whatever. tsinterface Box { contents: any;}Try Right now, the contents property is typed as any, which works, but can lead to accidents down the line. We could instead use unknown, but that would mean that in cases where we already know the type of contents, wed need to do precautionary checks, or use error-prone type assertions. tsinterface Box { contents: unknown;} let x: Box = { contents: \"hello world\",}; // we could check 'x.contents'if (typeof x.contents === \"string\") { console.log(x.contents.toLowerCase());} // or we could use a type assertionconsole.log((x.contents as string).toLowerCase());Try One type safe approach would be to instead scaffold out different Box types for every type of contents. tsinterface NumberBox { contents: number;} interface StringBox { contents: string;} interface BooleanBox { contents: boolean;}Try But that means well have to create different functions, or overloads of functions, to operate on these types. tsfunction setContents(box: StringBox, newContents: string): void;function setContents(box: NumberBox, newContents: number): void;function setContents(box: BooleanBox, newContents: boolean): void;function setContents(box: { contents: any }, newContents: any) { box.contents = newContents;}Try Thats a lot of boilerplate. Moreover, we might later need to introduce new types and overloads. This is frustrating, since our box types and overloads are all effectively the same. Instead, we can make a generic Box type which declares a type parameter. tsinterface BoxType { contents: Type;}Try You might read this as A Box of Type is something whose contents have type Type. Later on, when we refer to Box, we have to give a type argument in place of Type. tslet box: Boxstring;Try Think of Box as a template for a real type, where Type is a placeholder that will get replaced with some other type. When TypeScript sees Boxstring, it will replace every instance of Type in BoxType with string, and end up working with something like { contents: string }. In other words, Boxstring and our earlier StringBox work identically. tsinterface BoxType { contents: Type;}interface StringBox { contents: string;} let boxA: Boxstring = { contents: \"hello\" };boxA.contents; (property) Boxstring.contents: string let boxB: StringBox = { contents: \"world\" };boxB.contents; (property) StringBox.contents: stringTry Box is reusable in that Type can be substituted with anything. That means that when we need a box for a new type, we dont need to declare a new Box type at all (though we certainly could if we wanted to). tsinterface BoxType { contents: Type;} interface Apple { // ....} // Same as '{ contents: Apple }'.type AppleBox = BoxApple;Try This also means that we can avoid overloads entirely by instead using generic functions. tsfunction setContentsType(box: BoxType, newContents: Type) { box.contents = newContents;}Try It is worth noting that type aliases can also be generic. We could have defined our new BoxType interface, which was: tsinterface BoxType { contents: Type;}Try by using a type alias instead: tstype BoxType = { contents: Type;};Try Since type aliases, unlike interfaces, can describe more than just object types, we can also use them to write other kinds of generic helper types. tstype OrNullType = Type  null; type OneOrManyType = Type  Type[]; type OneOrManyOrNullType = OrNullOneOrManyType; type OneOrManyOrNullType = OneOrManyType  null type OneOrManyOrNullStrings = OneOrManyOrNullstring; type OneOrManyOrNullStrings = OneOrManystring  nullTry Well circle back to type aliases in just a little bit. The Array Type Generic object types are often some sort of container type that work independently of the type of elements they contain. Its ideal for data structures to work this way so that theyre re-usable across different data types. It turns out weve been working with a type just like that throughout this handbook: the Array type. Whenever we write out types like number[] or string[], thats really just a shorthand for Arraynumber and Arraystring. tsfunction doSomething(value: Arraystring) { // ...} let myArray: string[] = [\"hello\", \"world\"]; // either of these work!doSomething(myArray);doSomething(new Array(\"hello\", \"world\"));Try Much like the Box type above, Array itself is a generic type. tsinterface ArrayType { /** * Gets or sets the length of the array. */ length: number; /** * Removes the last element from an array and returns it. */ pop(): Type  undefined; /** * Appends new elements to an array, and returns the new length of the array. */ push(...items: Type[]): number; // ...}Try Modern JavaScript also provides other data structures which are generic, like MapK, V, SetT, and PromiseT. All this really means is that because of how Map, Set, and Promise behave, they can work with any sets of types. The ReadonlyArray Type The ReadonlyArray is a special type that describes arrays that shouldnt be changed. tsfunction doStuff(values: ReadonlyArraystring) { // We can read from 'values'... const copy = values.slice(); console.log(The first value is ${values[0]}); // ...but we can't mutate 'values'. values.push(\"hello!\");Property 'push' does not exist on type 'readonly string[]'.2339Property 'push' does not exist on type 'readonly string[]'.}Try Much like the readonly modifier for properties, its mainly a tool we can use for intent. When we see a function that returns ReadonlyArrays, it tells us were not meant to change the contents at all, and when we see a function that consumes ReadonlyArrays, it tells us that we can pass any array into that function without worrying that it will change its contents. Unlike Array, there isnt a ReadonlyArray constructor that we can use. tsnew ReadonlyArray(\"red\", \"green\", \"blue\");'ReadonlyArray' only refers to a type, but is being used as a value here.2693'ReadonlyArray' only refers to a type, but is being used as a value here.Try Instead, we can assign regular Arrays to ReadonlyArrays. tsconst roArray: ReadonlyArraystring = [\"red\", \"green\", \"blue\"];Try Just as TypeScript provides a shorthand syntax for ArrayType with Type[], it also provides a shorthand syntax for ReadonlyArrayType with readonly Type[]. tsfunction doStuff(values: readonly string[]) { // We can read from 'values'... const copy = values.slice(); console.log(The first value is ${values[0]}); // ...but we can't mutate 'values'. values.push(\"hello!\");Property 'push' does not exist on type 'readonly string[]'.2339Property 'push' does not exist on type 'readonly string[]'.}Try One last thing to note is that unlike the readonly property modifier, assignability isnt bidirectional between regular Arrays and ReadonlyArrays. tslet x: readonly string[] = [];let y: string[] = []; x = y;y = x;The type 'readonly string[]' is 'readonly' and cannot be assigned to the mutable type 'string[]'.4104The type 'readonly string[]' is 'readonly' and cannot be assigned to the mutable type 'string[]'.Try Tuple Types A tuple type is another sort of Array type that knows exactly how many elements it contains, and exactly which types it contains at specific positions. tstype StringNumberPair = [string, number];Try Here, StringNumberPair is a tuple type of string and number. Like ReadonlyArray, it has no representation at runtime, but is significant to TypeScript. To the type system, StringNumberPair describes arrays whose 0 index contains a string and whose 1 index contains a number. tsfunction doSomething(pair: [string, number]) { const a = pair[0]; const a: string const b = pair[1]; const b: number // ...} doSomething([\"hello\", 42]);Try If we try to index past the number of elements, well get an error. tsfunction doSomething(pair: [string, number]) { // ... const c = pair[2];Tuple type '[string, number]' of length '2' has no element at index '2'.2493Tuple type '[string, number]' of length '2' has no element at index '2'.}Try We can also destructure tuples using JavaScripts array destructuring. tsfunction doSomething(stringHash: [string, number]) { const [inputString, hash] = stringHash; console.log(inputString); const inputString: string console.log(hash); const hash: number}Try Tuple types are useful in heavily convention-based APIs, where each elements meaning is obvious. This gives us flexibility in whatever we want to name our variables when we destructure them. In the above example, we were able to name elements 0 and 1 to whatever we wanted. However, since not every user holds the same view of whats obvious, it may be worth reconsidering whether using objects with descriptive property names may be better for your API. Other than those length checks, simple tuple types like these are equivalent to types which are versions of Arrays that declare properties for specific indexes, and that declare length with a numeric literal type. tsinterface StringNumberPair { // specialized properties length: 2; 0: string; 1: number; // Other 'Arraystring  number' members... slice(start?: number, end?: number): Arraystring  number;}Try Another thing you may be interested in is that tuples can have optional properties by writing out a question mark (? after an elements type). Optional tuple elements can only come at the end, and also affect the type of length. tstype Either2dOr3d = [number, number, number?]; function setCoordinate(coord: Either2dOr3d) { const [x, y, z] = coord; const z: number  undefined console.log(Provided coordinates had ${coord.length} dimensions); (property) length: 2  3}Try Tuples can also have rest elements, which have to be an array/tuple type. tstype StringNumberBooleans = [string, number, ...boolean[]];type StringBooleansNumber = [string, ...boolean[], number];type BooleansStringNumber = [...boolean[], string, number];Try StringNumberBooleans describes a tuple whose first two elements are string and number respectively, but which may have any number of booleans following. StringBooleansNumber describes a tuple whose first element is string and then any number of booleans and ending with a number. BooleansStringNumber describes a tuple whose starting elements are any number of booleans and ending with a string then a number. A tuple with a rest element has no set length - it only has a set of well-known elements in different positions. tsconst a: StringNumberBooleans = [\"hello\", 1];const b: StringNumberBooleans = [\"beautiful\", 2, true];const c: StringNumberBooleans = [\"world\", 3, true, false, true, false, true];Try Why might optional and rest elements be useful? Well, it allows TypeScript to correspond tuples with parameter lists. Tuples types can be used in rest parameters and arguments, so that the following: tsfunction readButtonInput(...args: [string, number, ...boolean[]]) { const [name, version, ...input] = args; // ...}Try is basically equivalent to: tsfunction readButtonInput(name: string, version: number, ...input: boolean[]) { // ...}Try This is handy when you want to take a variable number of arguments with a rest parameter, and you need a minimum number of elements, but you dont want to introduce intermediate variables. readonly Tuple Types One final note about tuple types - tuple types have readonly variants, and can be specified by sticking a readonly modifier in front of them - just like with array shorthand syntax. tsfunction doSomething(pair: readonly [string, number]) { // ...}Try As you might expect, writing to any property of a readonly tuple isnt allowed in TypeScript. tsfunction doSomething(pair: readonly [string, number]) { pair[0] = \"hello!\";Cannot assign to '0' because it is a read-only property.2540Cannot assign to '0' because it is a read-only property.}Try Tuples tend to be created and left un-modified in most code, so annotating types as readonly tuples when possible is a good default. This is also important given that array literals with const assertions will be inferred with readonly tuple types. tslet point = [3, 4] as const; function distanceFromOrigin([x, y]: [number, number]) { return Math.sqrt(x ** 2 + y ** 2);} distanceFromOrigin(point);Argument of type 'readonly [3, 4]' is not assignable to parameter of type '[number, number]'. The type 'readonly [3, 4]' is 'readonly' and cannot be assigned to the mutable type '[number, number]'.2345Argument of type 'readonly [3, 4]' is not assignable to parameter of type '[number, number]'. The type 'readonly [3, 4]' is 'readonly' and cannot be assigned to the mutable type '[number, number]'.Try Here, distanceFromOrigin never modifies its elements, but expects a mutable tuple. Since points type was inferred as readonly [3, 4], it wont be compatible with [number, number] since that type cant guarantee points elements wont be mutated.",
    "headings": [
      {
        "level": 2,
        "text": "Quick Reference",
        "id": "quick-reference"
      },
      {
        "level": 2,
        "text": "Property Modifiers",
        "id": "property-modifiers"
      },
      {
        "level": 2,
        "text": "Excess Property Checks",
        "id": "excess-property-checks"
      },
      {
        "level": 2,
        "text": "Extending Types",
        "id": "extending-types"
      },
      {
        "level": 2,
        "text": "Intersection Types",
        "id": "intersection-types"
      },
      {
        "level": 2,
        "text": "Interface Extension vs. Intersection",
        "id": "interface-extension-vs-intersection"
      },
      {
        "level": 2,
        "text": "Generic Object Types",
        "id": "generic-object-types"
      },
      {
        "level": 3,
        "text": "Optional Properties",
        "id": "optional-properties"
      },
      {
        "level": 3,
        "text": "readonly Properties",
        "id": "readonly-properties"
      },
      {
        "level": 3,
        "text": "Index Signatures",
        "id": "index-signatures"
      },
      {
        "level": 3,
        "text": "The Array Type",
        "id": "the-array-type"
      },
      {
        "level": 3,
        "text": "The ReadonlyArray Type",
        "id": "the-readonlyarray-type"
      },
      {
        "level": 3,
        "text": "Tuple Types",
        "id": "tuple-types"
      },
      {
        "level": 3,
        "text": "readonly Tuple Types",
        "id": "readonly-tuple-types"
      }
    ],
    "codeBlocks": [
      {
        "language": "text",
        "code": "tsfunction greet(person: { name: string; age: number }) {  return \"Hello \" + person.name;}Try"
      },
      {
        "language": "text",
        "code": "function greet(person: { name: string; age: number }) {  return \"Hello \" + person.name;}"
      },
      {
        "language": "text",
        "code": "tsinterface Person {  name: string;  age: number;} function greet(person: Person) {  return \"Hello \" + person.name;}Try"
      },
      {
        "language": "text",
        "code": "interface Person {  name: string;  age: number;} function greet(person: Person) {  return \"Hello \" + person.name;}"
      },
      {
        "language": "text",
        "code": "tstype Person = {  name: string;  age: number;}; function greet(person: Person) {  return \"Hello \" + person.name;}Try"
      },
      {
        "language": "text",
        "code": "type Person = {  name: string;  age: number;}; function greet(person: Person) {  return \"Hello \" + person.name;}"
      },
      {
        "language": "text",
        "code": "tsinterface PaintOptions {  shape: Shape;  xPos?: number;  yPos?: number;} function paintShape(opts: PaintOptions) {  // ...} const shape = getShape();paintShape({ shape });paintShape({ shape, xPos: 100 });paintShape({ shape, yPos: 100 });paintShape({ shape, xPos: 100, yPos: 100 });Try"
      },
      {
        "language": "text",
        "code": "interface PaintOptions {  shape: Shape;  xPos?: number;  yPos?: number;} function paintShape(opts: PaintOptions) {  // ...} const shape = getShape();paintShape({ shape });paintShape({ shape, xPos: 100 });paintShape({ shape, yPos: 100 });paintShape({ shape, xPos: 100, yPos: 100 });"
      },
      {
        "language": "text",
        "code": "strictNullChecks"
      },
      {
        "language": "text",
        "code": "tsfunction paintShape(opts: PaintOptions) {  let xPos = opts.xPos;                   (property) PaintOptions.xPos?: number | undefined  let yPos = opts.yPos;                   (property) PaintOptions.yPos?: number | undefined  // ...}Try"
      },
      {
        "language": "text",
        "code": "function paintShape(opts: PaintOptions) {  let xPos = opts.xPos;                   (property) PaintOptions.xPos?: number | undefined  let yPos = opts.yPos;                   (property) PaintOptions.yPos?: number | undefined  // ...}"
      },
      {
        "language": "text",
        "code": "tsfunction paintShape(opts: PaintOptions) {  let xPos = opts.xPos === undefined ? 0 : opts.xPos;       let xPos: number  let yPos = opts.yPos === undefined ? 0 : opts.yPos;       let yPos: number  // ...}Try"
      },
      {
        "language": "text",
        "code": "function paintShape(opts: PaintOptions) {  let xPos = opts.xPos === undefined ? 0 : opts.xPos;       let xPos: number  let yPos = opts.yPos === undefined ? 0 : opts.yPos;       let yPos: number  // ...}"
      },
      {
        "language": "text",
        "code": "tsfunction paintShape({ shape, xPos = 0, yPos = 0 }: PaintOptions) {  console.log(\"x coordinate at\", xPos);                                  (parameter) xPos: number  console.log(\"y coordinate at\", yPos);                                  (parameter) yPos: number  // ...}Try"
      },
      {
        "language": "text",
        "code": "function paintShape({ shape, xPos = 0, yPos = 0 }: PaintOptions) {  console.log(\"x coordinate at\", xPos);                                  (parameter) xPos: number  console.log(\"y coordinate at\", yPos);                                  (parameter) yPos: number  // ...}"
      },
      {
        "language": "text",
        "code": "tsfunction draw({ shape: Shape, xPos: number = 100 /*...*/ }) {  render(shape);Cannot find name 'shape'. Did you mean 'Shape'?2552Cannot find name 'shape'. Did you mean 'Shape'?  render(xPos);Cannot find name 'xPos'.2304Cannot find name 'xPos'.}Try"
      },
      {
        "language": "text",
        "code": "function draw({ shape: Shape, xPos: number = 100 /*...*/ }) {  render(shape);Cannot find name 'shape'. Did you mean 'Shape'?2552Cannot find name 'shape'. Did you mean 'Shape'?  render(xPos);Cannot find name 'xPos'.2304Cannot find name 'xPos'.}"
      },
      {
        "language": "text",
        "code": "shape: Shape"
      },
      {
        "language": "text",
        "code": "xPos: number"
      },
      {
        "language": "text",
        "code": "tsinterface SomeType {  readonly prop: string;} function doSomething(obj: SomeType) {  // We can read from 'obj.prop'.  console.log(`prop has the value '${obj.prop}'.`);   // But we can't re-assign it.  obj.prop = \"hello\";Cannot assign to 'prop' because it is a read-only property.2540Cannot assign to 'prop' because it is a read-only property.}Try"
      },
      {
        "language": "text",
        "code": "interface SomeType {  readonly prop: string;} function doSomething(obj: SomeType) {  // We can read from 'obj.prop'.  console.log(`prop has the value '${obj.prop}'.`);   // But we can't re-assign it.  obj.prop = \"hello\";Cannot assign to 'prop' because it is a read-only property.2540Cannot assign to 'prop' because it is a read-only property.}"
      },
      {
        "language": "text",
        "code": "tsinterface Home {  readonly resident: { name: string; age: number };} function visitForBirthday(home: Home) {  // We can read and update properties from 'home.resident'.  console.log(`Happy birthday ${home.resident.name}!`);  home.resident.age++;} function evict(home: Home) {  // But we can't write to the 'resident' property itself on a 'Home'.  home.resident = {Cannot assign to 'resident' because it is a read-only property.2540Cannot assign to 'resident' because it is a read-only property.    name: \"Victor the Evictor\",    age: 42,  };}Try"
      },
      {
        "language": "text",
        "code": "interface Home {  readonly resident: { name: string; age: number };} function visitForBirthday(home: Home) {  // We can read and update properties from 'home.resident'.  console.log(`Happy birthday ${home.resident.name}!`);  home.resident.age++;} function evict(home: Home) {  // But we can't write to the 'resident' property itself on a 'Home'.  home.resident = {Cannot assign to 'resident' because it is a read-only property.2540Cannot assign to 'resident' because it is a read-only property.    name: \"Victor the Evictor\",    age: 42,  };}"
      },
      {
        "language": "text",
        "code": "tsinterface Person {  name: string;  age: number;} interface ReadonlyPerson {  readonly name: string;  readonly age: number;} let writablePerson: Person = {  name: \"Person McPersonface\",  age: 42,}; // workslet readonlyPerson: ReadonlyPerson = writablePerson; console.log(readonlyPerson.age); // prints '42'writablePerson.age++;console.log(readonlyPerson.age); // prints '43'Try"
      },
      {
        "language": "text",
        "code": "interface Person {  name: string;  age: number;} interface ReadonlyPerson {  readonly name: string;  readonly age: number;} let writablePerson: Person = {  name: \"Person McPersonface\",  age: 42,}; // workslet readonlyPerson: ReadonlyPerson = writablePerson; console.log(readonlyPerson.age); // prints '42'writablePerson.age++;console.log(readonlyPerson.age); // prints '43'"
      },
      {
        "language": "text",
        "code": "tsinterface StringArray {  [index: number]: string;} const myArray: StringArray = getStringArray();const secondItem = myArray[1];          const secondItem: stringTry"
      },
      {
        "language": "text",
        "code": "interface StringArray {  [index: number]: string;} const myArray: StringArray = getStringArray();const secondItem = myArray[1];          const secondItem: string"
      },
      {
        "language": "text",
        "code": "StringArray"
      },
      {
        "language": "text",
        "code": "StringArray"
      },
      {
        "language": "text",
        "code": "tsinterface Animal {  name: string;} interface Dog extends Animal {  breed: string;} // Error: indexing with a numeric string might get you a completely separate type of Animal!interface NotOkay {  [x: number]: Animal;'number' index type 'Animal' is not assignable to 'string' index type 'Dog'.2413'number' index type 'Animal' is not assignable to 'string' index type 'Dog'.  [x: string]: Dog;}Try"
      },
      {
        "language": "text",
        "code": "interface Animal {  name: string;} interface Dog extends Animal {  breed: string;} // Error: indexing with a numeric string might get you a completely separate type of Animal!interface NotOkay {  [x: number]: Animal;'number' index type 'Animal' is not assignable to 'string' index type 'Dog'.2413'number' index type 'Animal' is not assignable to 'string' index type 'Dog'.  [x: string]: Dog;}"
      },
      {
        "language": "text",
        "code": "obj.property"
      },
      {
        "language": "text",
        "code": "obj[\"property\"]"
      },
      {
        "language": "text",
        "code": "tsinterface NumberDictionary {  [index: string]: number;   length: number; // ok  name: string;Property 'name' of type 'string' is not assignable to 'string' index type 'number'.2411Property 'name' of type 'string' is not assignable to 'string' index type 'number'.}Try"
      },
      {
        "language": "text",
        "code": "interface NumberDictionary {  [index: string]: number;   length: number; // ok  name: string;Property 'name' of type 'string' is not assignable to 'string' index type 'number'.2411Property 'name' of type 'string' is not assignable to 'string' index type 'number'.}"
      },
      {
        "language": "text",
        "code": "tsinterface NumberOrStringDictionary {  [index: string]: number | string;  length: number; // ok, length is a number  name: string; // ok, name is a string}Try"
      },
      {
        "language": "text",
        "code": "interface NumberOrStringDictionary {  [index: string]: number | string;  length: number; // ok, length is a number  name: string; // ok, name is a string}"
      },
      {
        "language": "text",
        "code": "tsinterface ReadonlyStringArray {  readonly [index: number]: string;} let myArray: ReadonlyStringArray = getReadOnlyStringArray();myArray[2] = \"Mallory\";Index signature in type 'ReadonlyStringArray' only permits reading.2542Index signature in type 'ReadonlyStringArray' only permits reading.Try"
      },
      {
        "language": "text",
        "code": "interface ReadonlyStringArray {  readonly [index: number]: string;} let myArray: ReadonlyStringArray = getReadOnlyStringArray();myArray[2] = \"Mallory\";Index signature in type 'ReadonlyStringArray' only permits reading.2542Index signature in type 'ReadonlyStringArray' only permits reading."
      },
      {
        "language": "text",
        "code": "tsinterface SquareConfig {  color?: string;  width?: number;} function createSquare(config: SquareConfig): { color: string; area: number } {  return {    color: config.color || \"red\",    area: config.width ? config.width * config.width : 20,  };} let mySquare = createSquare({ colour: \"red\", width: 100 });Object literal may only specify known properties, but 'colour' does not exist in type 'SquareConfig'. Did you mean to write 'color'?2561Object literal may only specify known properties, but 'colour' does not exist in type 'SquareConfig'. Did you mean to write 'color'?Try"
      },
      {
        "language": "text",
        "code": "interface SquareConfig {  color?: string;  width?: number;} function createSquare(config: SquareConfig): { color: string; area: number } {  return {    color: config.color || \"red\",    area: config.width ? config.width * config.width : 20,  };} let mySquare = createSquare({ colour: \"red\", width: 100 });Object literal may only specify known properties, but 'colour' does not exist in type 'SquareConfig'. Did you mean to write 'color'?2561Object literal may only specify known properties, but 'colour' does not exist in type 'SquareConfig'. Did you mean to write 'color'?"
      },
      {
        "language": "text",
        "code": "createSquare"
      },
      {
        "language": "text",
        "code": "tslet mySquare = createSquare({ colour: \"red\", width: 100 });Object literal may only specify known properties, but 'colour' does not exist in type 'SquareConfig'. Did you mean to write 'color'?2561Object literal may only specify known properties, but 'colour' does not exist in type 'SquareConfig'. Did you mean to write 'color'?Try"
      },
      {
        "language": "text",
        "code": "let mySquare = createSquare({ colour: \"red\", width: 100 });Object literal may only specify known properties, but 'colour' does not exist in type 'SquareConfig'. Did you mean to write 'color'?2561Object literal may only specify known properties, but 'colour' does not exist in type 'SquareConfig'. Did you mean to write 'color'?"
      },
      {
        "language": "text",
        "code": "tslet mySquare = createSquare({ width: 100, opacity: 0.5 } as SquareConfig);Try"
      },
      {
        "language": "text",
        "code": "let mySquare = createSquare({ width: 100, opacity: 0.5 } as SquareConfig);"
      },
      {
        "language": "text",
        "code": "SquareConfig"
      },
      {
        "language": "text",
        "code": "tsinterface SquareConfig {  color?: string;  width?: number;  [propName: string]: unknown;}Try"
      },
      {
        "language": "text",
        "code": "interface SquareConfig {  color?: string;  width?: number;  [propName: string]: unknown;}"
      },
      {
        "language": "text",
        "code": "SquareConfig"
      },
      {
        "language": "text",
        "code": "squareOptions"
      },
      {
        "language": "text",
        "code": "tslet squareOptions = { colour: \"red\", width: 100 };let mySquare = createSquare(squareOptions);Try"
      },
      {
        "language": "text",
        "code": "let squareOptions = { colour: \"red\", width: 100 };let mySquare = createSquare(squareOptions);"
      },
      {
        "language": "text",
        "code": "squareOptions"
      },
      {
        "language": "text",
        "code": "SquareConfig"
      },
      {
        "language": "text",
        "code": "tslet squareOptions = { colour: \"red\" };let mySquare = createSquare(squareOptions);Type '{ colour: string; }' has no properties in common with type 'SquareConfig'.2559Type '{ colour: string; }' has no properties in common with type 'SquareConfig'.Try"
      },
      {
        "language": "text",
        "code": "let squareOptions = { colour: \"red\" };let mySquare = createSquare(squareOptions);Type '{ colour: string; }' has no properties in common with type 'SquareConfig'.2559Type '{ colour: string; }' has no properties in common with type 'SquareConfig'."
      },
      {
        "language": "text",
        "code": "createSquare"
      },
      {
        "language": "text",
        "code": "SquareConfig"
      },
      {
        "language": "text",
        "code": "BasicAddress"
      },
      {
        "language": "text",
        "code": "tsinterface BasicAddress {  name?: string;  street: string;  city: string;  country: string;  postalCode: string;}Try"
      },
      {
        "language": "text",
        "code": "interface BasicAddress {  name?: string;  street: string;  city: string;  country: string;  postalCode: string;}"
      },
      {
        "language": "text",
        "code": "AddressWithUnit"
      },
      {
        "language": "text",
        "code": "tsinterface AddressWithUnit {  name?: string;  unit: string;  street: string;  city: string;  country: string;  postalCode: string;}Try"
      },
      {
        "language": "text",
        "code": "interface AddressWithUnit {  name?: string;  unit: string;  street: string;  city: string;  country: string;  postalCode: string;}"
      },
      {
        "language": "text",
        "code": "BasicAddress"
      },
      {
        "language": "text",
        "code": "BasicAddress"
      },
      {
        "language": "text",
        "code": "AddressWithUnit"
      },
      {
        "language": "text",
        "code": "tsinterface BasicAddress {  name?: string;  street: string;  city: string;  country: string;  postalCode: string;} interface AddressWithUnit extends BasicAddress {  unit: string;}Try"
      },
      {
        "language": "text",
        "code": "interface BasicAddress {  name?: string;  street: string;  city: string;  country: string;  postalCode: string;} interface AddressWithUnit extends BasicAddress {  unit: string;}"
      },
      {
        "language": "text",
        "code": "AddressWithUnit"
      },
      {
        "language": "text",
        "code": "BasicAddress"
      },
      {
        "language": "text",
        "code": "tsinterface Colorful {  color: string;} interface Circle {  radius: number;} interface ColorfulCircle extends Colorful, Circle {} const cc: ColorfulCircle = {  color: \"red\",  radius: 42,};Try"
      },
      {
        "language": "text",
        "code": "interface Colorful {  color: string;} interface Circle {  radius: number;} interface ColorfulCircle extends Colorful, Circle {} const cc: ColorfulCircle = {  color: \"red\",  radius: 42,};"
      },
      {
        "language": "text",
        "code": "tsinterface Colorful {  color: string;}interface Circle {  radius: number;} type ColorfulCircle = Colorful & Circle;Try"
      },
      {
        "language": "text",
        "code": "interface Colorful {  color: string;}interface Circle {  radius: number;} type ColorfulCircle = Colorful & Circle;"
      },
      {
        "language": "text",
        "code": "tsfunction draw(circle: Colorful & Circle) {  console.log(`Color was ${circle.color}`);  console.log(`Radius was ${circle.radius}`);} // okaydraw({ color: \"blue\", radius: 42 }); // oopsdraw({ color: \"red\", raidus: 42 });Object literal may only specify known properties, but 'raidus' does not exist in type 'Colorful & Circle'. Did you mean to write 'radius'?2561Object literal may only specify known properties, but 'raidus' does not exist in type 'Colorful & Circle'. Did you mean to write 'radius'?Try"
      },
      {
        "language": "text",
        "code": "function draw(circle: Colorful & Circle) {  console.log(`Color was ${circle.color}`);  console.log(`Radius was ${circle.radius}`);} // okaydraw({ color: \"blue\", radius: 42 }); // oopsdraw({ color: \"red\", raidus: 42 });Object literal may only specify known properties, but 'raidus' does not exist in type 'Colorful & Circle'. Did you mean to write 'radius'?2561Object literal may only specify known properties, but 'raidus' does not exist in type 'Colorful & Circle'. Did you mean to write 'radius'?"
      },
      {
        "language": "text",
        "code": "tsinterface Person {  name: string;}interface Person {  name: number;}"
      },
      {
        "language": "text",
        "code": "interface Person {  name: string;}interface Person {  name: number;}"
      },
      {
        "language": "text",
        "code": "tsinterface Person1 {  name: string;} interface Person2 {  name: number;} type Staff = Person1 & Person2 declare const staffer: Staff;staffer.name;         (property) name: neverTry"
      },
      {
        "language": "text",
        "code": "interface Person1 {  name: string;} interface Person2 {  name: number;} type Staff = Person1 & Person2 declare const staffer: Staff;staffer.name;         (property) name: never"
      },
      {
        "language": "text",
        "code": "tsinterface Box {  contents: any;}Try"
      },
      {
        "language": "text",
        "code": "interface Box {  contents: any;}"
      },
      {
        "language": "text",
        "code": "tsinterface Box {  contents: unknown;} let x: Box = {  contents: \"hello world\",}; // we could check 'x.contents'if (typeof x.contents === \"string\") {  console.log(x.contents.toLowerCase());} // or we could use a type assertionconsole.log((x.contents as string).toLowerCase());Try"
      },
      {
        "language": "text",
        "code": "interface Box {  contents: unknown;} let x: Box = {  contents: \"hello world\",}; // we could check 'x.contents'if (typeof x.contents === \"string\") {  console.log(x.contents.toLowerCase());} // or we could use a type assertionconsole.log((x.contents as string).toLowerCase());"
      },
      {
        "language": "text",
        "code": "tsinterface NumberBox {  contents: number;} interface StringBox {  contents: string;} interface BooleanBox {  contents: boolean;}Try"
      },
      {
        "language": "text",
        "code": "interface NumberBox {  contents: number;} interface StringBox {  contents: string;} interface BooleanBox {  contents: boolean;}"
      },
      {
        "language": "text",
        "code": "tsfunction setContents(box: StringBox, newContents: string): void;function setContents(box: NumberBox, newContents: number): void;function setContents(box: BooleanBox, newContents: boolean): void;function setContents(box: { contents: any }, newContents: any) {  box.contents = newContents;}Try"
      },
      {
        "language": "text",
        "code": "function setContents(box: StringBox, newContents: string): void;function setContents(box: NumberBox, newContents: number): void;function setContents(box: BooleanBox, newContents: boolean): void;function setContents(box: { contents: any }, newContents: any) {  box.contents = newContents;}"
      },
      {
        "language": "text",
        "code": "tsinterface Box<Type> {  contents: Type;}Try"
      },
      {
        "language": "text",
        "code": "interface Box<Type> {  contents: Type;}"
      },
      {
        "language": "text",
        "code": "tslet box: Box<string>;Try"
      },
      {
        "language": "text",
        "code": "let box: Box<string>;"
      },
      {
        "language": "text",
        "code": "Box<string>"
      },
      {
        "language": "text",
        "code": "{ contents: string }"
      },
      {
        "language": "text",
        "code": "Box<string>"
      },
      {
        "language": "text",
        "code": "tsinterface Box<Type> {  contents: Type;}interface StringBox {  contents: string;} let boxA: Box<string> = { contents: \"hello\" };boxA.contents;        (property) Box<string>.contents: string let boxB: StringBox = { contents: \"world\" };boxB.contents;        (property) StringBox.contents: stringTry"
      },
      {
        "language": "text",
        "code": "interface Box<Type> {  contents: Type;}interface StringBox {  contents: string;} let boxA: Box<string> = { contents: \"hello\" };boxA.contents;        (property) Box<string>.contents: string let boxB: StringBox = { contents: \"world\" };boxB.contents;        (property) StringBox.contents: string"
      },
      {
        "language": "text",
        "code": "tsinterface Box<Type> {  contents: Type;} interface Apple {  // ....} // Same as '{ contents: Apple }'.type AppleBox = Box<Apple>;Try"
      },
      {
        "language": "text",
        "code": "interface Box<Type> {  contents: Type;} interface Apple {  // ....} // Same as '{ contents: Apple }'.type AppleBox = Box<Apple>;"
      },
      {
        "language": "text",
        "code": "tsfunction setContents<Type>(box: Box<Type>, newContents: Type) {  box.contents = newContents;}Try"
      },
      {
        "language": "text",
        "code": "function setContents<Type>(box: Box<Type>, newContents: Type) {  box.contents = newContents;}"
      },
      {
        "language": "text",
        "code": "tsinterface Box<Type> {  contents: Type;}Try"
      },
      {
        "language": "text",
        "code": "interface Box<Type> {  contents: Type;}"
      },
      {
        "language": "text",
        "code": "tstype Box<Type> = {  contents: Type;};Try"
      },
      {
        "language": "text",
        "code": "type Box<Type> = {  contents: Type;};"
      },
      {
        "language": "text",
        "code": "tstype OrNull<Type> = Type | null; type OneOrMany<Type> = Type | Type[]; type OneOrManyOrNull<Type> = OrNull<OneOrMany<Type>>;           type OneOrManyOrNull<Type> = OneOrMany<Type> | null type OneOrManyOrNullStrings = OneOrManyOrNull<string>;               type OneOrManyOrNullStrings = OneOrMany<string> | nullTry"
      },
      {
        "language": "text",
        "code": "type OrNull<Type> = Type | null; type OneOrMany<Type> = Type | Type[]; type OneOrManyOrNull<Type> = OrNull<OneOrMany<Type>>;           type OneOrManyOrNull<Type> = OneOrMany<Type> | null type OneOrManyOrNullStrings = OneOrManyOrNull<string>;               type OneOrManyOrNullStrings = OneOrMany<string> | null"
      },
      {
        "language": "text",
        "code": "Array<number>"
      },
      {
        "language": "text",
        "code": "Array<string>"
      },
      {
        "language": "text",
        "code": "tsfunction doSomething(value: Array<string>) {  // ...} let myArray: string[] = [\"hello\", \"world\"]; // either of these work!doSomething(myArray);doSomething(new Array(\"hello\", \"world\"));Try"
      },
      {
        "language": "text",
        "code": "function doSomething(value: Array<string>) {  // ...} let myArray: string[] = [\"hello\", \"world\"]; // either of these work!doSomething(myArray);doSomething(new Array(\"hello\", \"world\"));"
      },
      {
        "language": "text",
        "code": "tsinterface Array<Type> {  /**   * Gets or sets the length of the array.   */  length: number;   /**   * Removes the last element from an array and returns it.   */  pop(): Type | undefined;   /**   * Appends new elements to an array, and returns the new length of the array.   */  push(...items: Type[]): number;   // ...}Try"
      },
      {
        "language": "text",
        "code": "interface Array<Type> {  /**   * Gets or sets the length of the array.   */  length: number;   /**   * Removes the last element from an array and returns it.   */  pop(): Type | undefined;   /**   * Appends new elements to an array, and returns the new length of the array.   */  push(...items: Type[]): number;   // ...}"
      },
      {
        "language": "text",
        "code": "ReadonlyArray"
      },
      {
        "language": "text",
        "code": "ReadonlyArray"
      },
      {
        "language": "text",
        "code": "tsfunction doStuff(values: ReadonlyArray<string>) {  // We can read from 'values'...  const copy = values.slice();  console.log(`The first value is ${values[0]}`);   // ...but we can't mutate 'values'.  values.push(\"hello!\");Property 'push' does not exist on type 'readonly string[]'.2339Property 'push' does not exist on type 'readonly string[]'.}Try"
      },
      {
        "language": "text",
        "code": "function doStuff(values: ReadonlyArray<string>) {  // We can read from 'values'...  const copy = values.slice();  console.log(`The first value is ${values[0]}`);   // ...but we can't mutate 'values'.  values.push(\"hello!\");Property 'push' does not exist on type 'readonly string[]'.2339Property 'push' does not exist on type 'readonly string[]'.}"
      },
      {
        "language": "text",
        "code": "ReadonlyArray"
      },
      {
        "language": "text",
        "code": "ReadonlyArray"
      },
      {
        "language": "text",
        "code": "ReadonlyArray"
      },
      {
        "language": "text",
        "code": "tsnew ReadonlyArray(\"red\", \"green\", \"blue\");'ReadonlyArray' only refers to a type, but is being used as a value here.2693'ReadonlyArray' only refers to a type, but is being used as a value here.Try"
      },
      {
        "language": "text",
        "code": "new ReadonlyArray(\"red\", \"green\", \"blue\");'ReadonlyArray' only refers to a type, but is being used as a value here.2693'ReadonlyArray' only refers to a type, but is being used as a value here."
      },
      {
        "language": "text",
        "code": "ReadonlyArray"
      },
      {
        "language": "text",
        "code": "tsconst roArray: ReadonlyArray<string> = [\"red\", \"green\", \"blue\"];Try"
      },
      {
        "language": "text",
        "code": "const roArray: ReadonlyArray<string> = [\"red\", \"green\", \"blue\"];"
      },
      {
        "language": "text",
        "code": "Array<Type>"
      },
      {
        "language": "text",
        "code": "ReadonlyArray<Type>"
      },
      {
        "language": "text",
        "code": "readonly Type[]"
      },
      {
        "language": "text",
        "code": "tsfunction doStuff(values: readonly string[]) {  // We can read from 'values'...  const copy = values.slice();  console.log(`The first value is ${values[0]}`);   // ...but we can't mutate 'values'.  values.push(\"hello!\");Property 'push' does not exist on type 'readonly string[]'.2339Property 'push' does not exist on type 'readonly string[]'.}Try"
      },
      {
        "language": "text",
        "code": "function doStuff(values: readonly string[]) {  // We can read from 'values'...  const copy = values.slice();  console.log(`The first value is ${values[0]}`);   // ...but we can't mutate 'values'.  values.push(\"hello!\");Property 'push' does not exist on type 'readonly string[]'.2339Property 'push' does not exist on type 'readonly string[]'.}"
      },
      {
        "language": "text",
        "code": "ReadonlyArray"
      },
      {
        "language": "text",
        "code": "tslet x: readonly string[] = [];let y: string[] = []; x = y;y = x;The type 'readonly string[]' is 'readonly' and cannot be assigned to the mutable type 'string[]'.4104The type 'readonly string[]' is 'readonly' and cannot be assigned to the mutable type 'string[]'.Try"
      },
      {
        "language": "text",
        "code": "let x: readonly string[] = [];let y: string[] = []; x = y;y = x;The type 'readonly string[]' is 'readonly' and cannot be assigned to the mutable type 'string[]'.4104The type 'readonly string[]' is 'readonly' and cannot be assigned to the mutable type 'string[]'."
      },
      {
        "language": "text",
        "code": "tstype StringNumberPair = [string, number];Try"
      },
      {
        "language": "text",
        "code": "type StringNumberPair = [string, number];"
      },
      {
        "language": "text",
        "code": "StringNumberPair"
      },
      {
        "language": "text",
        "code": "ReadonlyArray"
      },
      {
        "language": "text",
        "code": "StringNumberPair"
      },
      {
        "language": "text",
        "code": "tsfunction doSomething(pair: [string, number]) {  const a = pair[0];       const a: string  const b = pair[1];       const b: number  // ...} doSomething([\"hello\", 42]);Try"
      },
      {
        "language": "text",
        "code": "function doSomething(pair: [string, number]) {  const a = pair[0];       const a: string  const b = pair[1];       const b: number  // ...} doSomething([\"hello\", 42]);"
      },
      {
        "language": "text",
        "code": "tsfunction doSomething(pair: [string, number]) {  // ...   const c = pair[2];Tuple type '[string, number]' of length '2' has no element at index '2'.2493Tuple type '[string, number]' of length '2' has no element at index '2'.}Try"
      },
      {
        "language": "text",
        "code": "function doSomething(pair: [string, number]) {  // ...   const c = pair[2];Tuple type '[string, number]' of length '2' has no element at index '2'.2493Tuple type '[string, number]' of length '2' has no element at index '2'.}"
      },
      {
        "language": "text",
        "code": "tsfunction doSomething(stringHash: [string, number]) {  const [inputString, hash] = stringHash;   console.log(inputString);                  const inputString: string   console.log(hash);               const hash: number}Try"
      },
      {
        "language": "text",
        "code": "function doSomething(stringHash: [string, number]) {  const [inputString, hash] = stringHash;   console.log(inputString);                  const inputString: string   console.log(hash);               const hash: number}"
      },
      {
        "language": "text",
        "code": "tsinterface StringNumberPair {  // specialized properties  length: 2;  0: string;  1: number;   // Other 'Array<string | number>' members...  slice(start?: number, end?: number): Array<string | number>;}Try"
      },
      {
        "language": "text",
        "code": "interface StringNumberPair {  // specialized properties  length: 2;  0: string;  1: number;   // Other 'Array<string | number>' members...  slice(start?: number, end?: number): Array<string | number>;}"
      },
      {
        "language": "text",
        "code": "tstype Either2dOr3d = [number, number, number?]; function setCoordinate(coord: Either2dOr3d) {  const [x, y, z] = coord;              const z: number | undefined   console.log(`Provided coordinates had ${coord.length} dimensions`);                                                  (property) length: 2 | 3}Try"
      },
      {
        "language": "text",
        "code": "type Either2dOr3d = [number, number, number?]; function setCoordinate(coord: Either2dOr3d) {  const [x, y, z] = coord;              const z: number | undefined   console.log(`Provided coordinates had ${coord.length} dimensions`);                                                  (property) length: 2 | 3}"
      },
      {
        "language": "text",
        "code": "tstype StringNumberBooleans = [string, number, ...boolean[]];type StringBooleansNumber = [string, ...boolean[], number];type BooleansStringNumber = [...boolean[], string, number];Try"
      },
      {
        "language": "text",
        "code": "type StringNumberBooleans = [string, number, ...boolean[]];type StringBooleansNumber = [string, ...boolean[], number];type BooleansStringNumber = [...boolean[], string, number];"
      },
      {
        "language": "text",
        "code": "StringNumberBooleans"
      },
      {
        "language": "text",
        "code": "StringBooleansNumber"
      },
      {
        "language": "text",
        "code": "BooleansStringNumber"
      },
      {
        "language": "text",
        "code": "tsconst a: StringNumberBooleans = [\"hello\", 1];const b: StringNumberBooleans = [\"beautiful\", 2, true];const c: StringNumberBooleans = [\"world\", 3, true, false, true, false, true];Try"
      },
      {
        "language": "text",
        "code": "const a: StringNumberBooleans = [\"hello\", 1];const b: StringNumberBooleans = [\"beautiful\", 2, true];const c: StringNumberBooleans = [\"world\", 3, true, false, true, false, true];"
      },
      {
        "language": "text",
        "code": "tsfunction readButtonInput(...args: [string, number, ...boolean[]]) {  const [name, version, ...input] = args;  // ...}Try"
      },
      {
        "language": "text",
        "code": "function readButtonInput(...args: [string, number, ...boolean[]]) {  const [name, version, ...input] = args;  // ...}"
      },
      {
        "language": "text",
        "code": "tsfunction readButtonInput(name: string, version: number, ...input: boolean[]) {  // ...}Try"
      },
      {
        "language": "text",
        "code": "function readButtonInput(name: string, version: number, ...input: boolean[]) {  // ...}"
      },
      {
        "language": "text",
        "code": "tsfunction doSomething(pair: readonly [string, number]) {  // ...}Try"
      },
      {
        "language": "text",
        "code": "function doSomething(pair: readonly [string, number]) {  // ...}"
      },
      {
        "language": "text",
        "code": "tsfunction doSomething(pair: readonly [string, number]) {  pair[0] = \"hello!\";Cannot assign to '0' because it is a read-only property.2540Cannot assign to '0' because it is a read-only property.}Try"
      },
      {
        "language": "text",
        "code": "function doSomething(pair: readonly [string, number]) {  pair[0] = \"hello!\";Cannot assign to '0' because it is a read-only property.2540Cannot assign to '0' because it is a read-only property.}"
      },
      {
        "language": "text",
        "code": "tslet point = [3, 4] as const; function distanceFromOrigin([x, y]: [number, number]) {  return Math.sqrt(x ** 2 + y ** 2);} distanceFromOrigin(point);Argument of type 'readonly [3, 4]' is not assignable to parameter of type '[number, number]'.\n  The type 'readonly [3, 4]' is 'readonly' and cannot be assigned to the mutable type '[number, number]'.2345Argument of type 'readonly [3, 4]' is not assignable to parameter of type '[number, number]'.\n  The type 'readonly [3, 4]' is 'readonly' and cannot be assigned to the mutable type '[number, number]'.Try"
      },
      {
        "language": "text",
        "code": "let point = [3, 4] as const; function distanceFromOrigin([x, y]: [number, number]) {  return Math.sqrt(x ** 2 + y ** 2);} distanceFromOrigin(point);Argument of type 'readonly [3, 4]' is not assignable to parameter of type '[number, number]'.\n  The type 'readonly [3, 4]' is 'readonly' and cannot be assigned to the mutable type '[number, number]'.2345Argument of type 'readonly [3, 4]' is not assignable to parameter of type '[number, number]'.\n  The type 'readonly [3, 4]' is 'readonly' and cannot be assigned to the mutable type '[number, number]'."
      },
      {
        "language": "text",
        "code": "distanceFromOrigin"
      },
      {
        "language": "text",
        "code": "readonly [3, 4]"
      },
      {
        "language": "text",
        "code": "[number, number]"
      }
    ],
    "links": [
      {
        "text": "Try",
        "href": "https://www.typescriptlang.org/play/#code/GYVwdgxgLglg9mABAcwE4FN1QBQAd2oDOCAXIgN6JgCGAtumYVKjGMgNyLXINUi0AjAogC+ASgoAoRIgD0smYqXLlAPXUbNW7TtXTEGKCFRIARAAl0AGytxEpxAGpE+IggB0Neu0kigA"
      },
      {
        "text": "Try",
        "href": "https://www.typescriptlang.org/play/#code/JYOwLgpgTgZghgYwgAgArQM4HsTIN4BQyyA9CcRcgHo21HIhwC2EAXMhmFKAOYDc9ODzYMArkwBG0AQF8CBGKJAIwwHMh5QIEMAAoADphzt0UbCACU+elrCiouAEQAJCABs3WZI+QBqZIZmOAB0jCyyQA"
      },
      {
        "text": "Try",
        "href": "https://www.typescriptlang.org/play/#code/C4TwDgpgBAChBOBnA9gOygXigbwFBSgHpCoA9ci-KVAQwFsIAuKRYeAS1QHMBuKmrk2oBXOgCMEfAL59cAM2GoAxsHZooXeBAjAAFJCRpmcQ6gCUOKluDD46AEQAJCABsXyKPagBqKAZSoAHS0DNJAA"
      },
      {
        "text": "type and interface",
        "href": "https://www.typescriptlang.org/cheatsheets"
      },
      {
        "text": "Try",
        "href": "https://www.typescriptlang.org/play/#code/JYOwLgpgTgZghgYwgAgMoAs4AcUG8C+AUACYQIA2cUKMAriAmMAPYjIDmEYG2EAFAEoAXGkw4A3IUIB6acgC0ihLTCL5hUJFiIUABTiaA8liasAzslyFkyM2IgieE68gAeu5mYD8IkLQC2AEbQkjayNgB6LgCeHt6+AcFQocjhyFFEhHQMpmxYBuBO-MwmZiL6RiYsIGYCli7hAHTNhJkI5mC29sgAvBxcRYKS+ZqDuF28yPgCwwXc9nzjdrwANG5xIgCMAAzbUzOEI4ULS-ZrsZ5bu-uzoycTOGvul8g72+cbr9fT4kA"
      },
      {
        "text": "strictNullChecks",
        "href": "/tsconfig#strictNullChecks"
      },
      {
        "text": "Try",
        "href": "https://www.typescriptlang.org/play/#code/JYOwLgpgTgZghgYwgAgMoAs4AcUG8C+AUACYQIA2cUKMAriAmMAPYjIDmEYG2EAFAEoAXGkw4A3IUKhIsRCgAKcGQHksTVgGdkuQsmSaxEETwl7kADwXNNAfhEhaAWwBG0SfoCe1uw+duoSSJCAHoQ5ABaKIRaMCiIwjoGDTYsZXBTfmZ1TRElVXUWEE0BHXNyLksfZABeZGywTQA6KxsPZDD9Lu6egD1bcsrvG1r6nKbhzXbOntn9fvNOpuXCfCA"
      },
      {
        "text": "Try",
        "href": "https://www.typescriptlang.org/play/#code/JYOwLgpgTgZghgYwgAgMoAs4AcUG8C+AUACYQIA2cUKMAriAmMAPYjIDmEYG2EAFAEoAXGkw4A3IUKhIsRCgAKcGQHksTVgGdkuQsmSaxEETwl7kADwXNNAfhEhaAWwBG0SfoCe1uw+duoSSJCAHoQ5ABaKIRaMCiIwjoGDTYsZXBTfmZ1TRElVXUWEE0BHXNyLksfZABeZGywTQA6Kxtamrr6UhhQCGJkW2QABmQRBubWzQ9kMP0APVtyyu82uvGmle0OzpBu3v7BkbGcjZ9p2eQF81mm28J8IA"
      },
      {
        "text": "Try",
        "href": "https://www.typescriptlang.org/play/#code/JYOwLgpgTgZghgYwgAgMoAs4AcUG8C+AUACYQIA2cUKMAriAmMAPYjIDmEYG2EAFAEoAXGkw4A3IUKhIsRCgAKcGQHksTVgGdkuQsmSaxEETwl7kADwXNNAfhEhaAWwBG0SfoCe1uw+duoSSJCAHoQ5ABaKIRaMCiIwjoGDTYsZXBTflwDIwAaSx9kAF5kAAZ87xtisuR8ESVVdRYQTQEdcwQtZnIIADpyZnY+ACILZE7mKGJQOEhkWeH8qxsBD2Qw-U2t7Z3d-QA9Ww6unv7Bkc9x5knpkFmUBYqfVfMNvfeP5EPX8N6-wnwQA"
      },
      {
        "text": "a destructuring pattern",
        "href": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/Destructuring_assignment"
      },
      {
        "text": "default values",
        "href": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/Destructuring_assignment#Default_values"
      },
      {
        "text": "Try",
        "href": "https://www.typescriptlang.org/play/#code/PTAEAEDsHsEkFsAOAbAlgY1QFwIKQJ4BcoAZgIbIDOApgFAgTUBOT0TlxATAKzeeicAzAAYALLVSQszcumqgAygAsyieQG8AvrQAm1dMjJN5JAK6R0WVNEihjkPUwAUAD2LmA1jADukAJQA3PRgALRh6KZYYSG0ZhZWNqA6TGTeTuqglCpqxMqq1AA0oC4ACtAcoJCm8ABGzKAAvKAAjMLCoMAAVAB0vZ1gmn6g6rSgdtQOzE5Z+YGj45POpeVzmkA"
      },
      {
        "text": "Try",
        "href": "https://www.typescriptlang.org/play/#code/PTAEAEFMCdoe2gZwFygEwFYAsAGAUAJYB2ALjAGYCGAxpKAMpwC2kAKgJ4AOdA3nqKGiRKAEzhEANu1Cd4nVIhLRiAcwDceAL5485AK5FqJAuNBjGLEgAtVACjgAjAFaoLbLpACUoPgJCgAdTpqSiJBYRFQcngmUAByRycAOlk4Tjik-lBqcUQ4CUgkiTgVWwADVM5QK0pEUGs6ADdKCT06OIASHkSUuU0Mss8NLP8AIT0SUAB3YNC4yaEAWlrEAhUwghJMgR7K0ABeUAAiK0gJYqONTSA"
      },
      {
        "text": "Try",
        "href": "https://www.typescriptlang.org/play/#code/PTAEAEFMCdoe2gZwFygEwFYAsAGAUAJYB2ALjAGYCGAxpKABJwC2dA3nqKNJJQCZxEANgE8ukRAV6RSqVqCKUWqRCWjEA5gG5QldZFREArkwBGMUAF9NeC3jzlDRaiQIDQANwISSAMQQAhAmgSAAteSmEAChDmfQZYgEpQdk4QUAB1OmpKIjE+HSJeUEMAB3CyUBL4EpgXcVByeCZQAHIYlgA6bgkpUhaOjlBqAUQ4QUgOwTh1SIADekoSktETINDw0QASVnaJ7slpEg6FFgsAQlmE605drvED0g7dSABqF+tbe0dnV1zIT2c0ViqEYLCSKVAaX8hhIoAA7lkci1YXC1BUSHBQKE6C19r0SC1KtVaqICCREJBBORQG5KK1QZB+oNbnjDqAALzJQacE5xABEADUCM4EFiQnQAKIAjHQPkAGm5Oj0qCwaAVnCsNiAA"
      },
      {
        "text": "Try",
        "href": "https://www.typescriptlang.org/play/#code/JYOwLgpgTgZghgYwgAgArQM4HsTIN4BQyyIcAthAFzIZhSgDmA3EcnA1SQK5kBG0LAL4ECoSLEQoAShDgATHABsAnuijZchYlFkKQKkuU616IZqx3ylyth2oge-KEJGKIYZAHd6YOLzdqGtSBOMgAvPispBTUAEQhuACyCAnwSLEANKzsnAAsAExZgiwEAPSlXlhQANYYBG4elnoqCdQyVvqqmKER3sC+-hAJJQg42G4AdIpYDAAUTdYJEzkAlEzI5cgADqZgGMgA5AUHBH0DAd0gyxwA1DcsoyDjEFMz87qLl9cQaxsVO2J9kcAMwHIA"
      },
      {
        "text": "mapping modifiers",
        "href": "/docs/handbook/2/mapped-types.html#mapping-modifiers"
      },
      {
        "text": "Try",
        "href": "https://www.typescriptlang.org/play/#code/CYUwxgNghgTiAEAzArgOzAFwJYHtXwHMQMBlDGLVAgQRhigE8AKASgC54yKrb6GBuAFAB6YfAC0ksMgyTxgyhhAxEUMAi6UadRvADeg+PADalUAA8OqZAFsARsoC6HAM7ktQgL6DBYPG-gbBl5GDk0eHQZ4AF5CYnDtPlYhP1QAl3A8YABJJRsYwODI4wBGRyFRIyqAPQB+IA"
      },
      {
        "text": "Try",
        "href": "https://www.typescriptlang.org/play/#code/PTAEAEFMCdoe2gZwFygEwBYCMBmAUCBIgC7QCWAxsQArwAOMxAngJIB2ZxZAhgDZkAvblzhtUAMz6JIeMm2IxJFSKACCHALZ9QAbzyhQbbhsioS5NgHMA3HgC+eWfMXdloACJxLoSAA8FbAAmiGqa2noGAEbQkJCBZqRyNvaOhACisAiocoF+SaAA7pwAFqDchgCuJuQUoOb5GmSWxcSglpCtTHAVZaAUcBp0vB2QvEx1kHTc0MIqzAygcOKhZFq8AIROCtBKKgBycMQA8gDW3OMRoADavqhsVZEwALqo6qt8tgY3CRaWLx5eWx2IA"
      },
      {
        "text": "Try",
        "href": "https://www.typescriptlang.org/play/#code/PTAEAEFMCdoe2gZwFygEwBYCMWBQIIZ4lVMdcBLAOwBcYAzAQwGNJQA5AVwFsAjGACIVmNCnCqNoAT1ABvXKFABtagBNIAD1SIa0agHMAuqio9+0ANy4FoADaQq+mgAsTZmBdAE4AaxsTuSG1dAysAXyA"
      },
      {
        "text": "Try",
        "href": "https://www.typescriptlang.org/play/#code/JYOwLgpgTgZghgYwgAgHIFcC2AjaB5KAZTClAHMARYBMYAexDigE9kBvAKGWQG1QATCAA8AXMgDOJcgF0xILLijIAPhKkgyAbi7IANhA1gAFnIXRNyAPSXkdANYAaPQbLHkwccjjJ5OaDsZMCDFJUg0La1tHHzgg909vUPIOAF8gA"
      },
      {
        "text": "Try",
        "href": "https://www.typescriptlang.org/play/#code/CYUwxgNghgTiAEAzArgOzAFwJYHtXwHMQMAlEKYAeVQgE8BlDGLVAgQRhiloAoBKAFzwyFPHUbNWHLrQDcAKAD0i+AFp1YZBnWqlKgAIhOOGAGchAJgCsAFgvyWGI4ihgEI4GIZMW7Tt3gAb3l4eDhRGlp4AG0WUAAPIVRkAFsAIyMAXSFTH1YFAF95eQhieBTaaW4hDy8JXyqogF5CYg9qcTy-GX4FCsboi0z4FoAiAFkoCAgTWlHZIA"
      },
      {
        "text": "Try",
        "href": "https://www.typescriptlang.org/play/#code/PTAEAEFMCdoe2gZwFygEwGYAsBWdB2DATgCgBLAOwBcYAzAQwGNJQBlARwFd7pIBhOBVpkA5qADeJUKEZwANggD8qRFWiURAbimgA7mQAmVABbLQFTgFsARjG0BfEiVqcKjKmUEze9Gh268ABSyQqKo-jz8gsIiAJSo4jLyCCpqGpqgkfSoFjYwoPYSOrxUnNAURdLSsgrQqCExAHQ1CKAAPm2gAES8Bl0ANDrSWfXRoo36RsagikmhIhOGJqAAVHNNk8uoaAAMg9L2Dk5ykFSglgCeEbygALzekL6Q15CBiS1lqD2Qff16S8ZUABGHY7AqxTRAA"
      },
      {
        "text": "Try",
        "href": "https://www.typescriptlang.org/play/#code/PTAEAEFMCdoe2gZwFygEwGYAsBWdB2DATgCgBLAOwBcYAzAQwGNJQBlARwFd7pIBhOBVpkA5qADeJUKEZwANggD8qRFWiURAbimgA7mQAmVABbLQFTgFsARjG0BfEiVqcKjKmUEze9Gh268ABSyQqKo-jz8gsIiAJSo4jLyCCpqGpqgkfSoFjYwoPYSOrxUnNAURdLSsgrQqCExAHQ1CKAAPm2gAES8Bl0ANDrSWfXRoo36RsagikmhIhOGJqAAVHNNk8uoaAAMg9L2DiQgoAC054ycVOenJHKQVKCWAJ4RvKAAvN6QvpBvkIFEi0yqgepA+v09EtjKgAIw7HYFWKaIA"
      },
      {
        "text": "Try",
        "href": "https://www.typescriptlang.org/play/#code/PTAEAEFMCdoe2gZwFygEwGYAsBWdB2DATgCgBLAOwBcYAzAQwGNJQBlARwFd7pIBhOBVpkA5qADeJUKEZwANggD8qRFWiURAbimgA7mQAmVABbLQFTgFsARjG0BfEiVqcKjKmUEze9Gh268ABSyQqKo-jz8gsIiAJSo4jLyCCpqGpqgkfSoFjYwoPYSOrxUnNAURdLSsgrQqCExAHQ1CKAAPm2gAES8Bl0ANDrSWfXRoo36RsagikmhIhOGJqAAVHNNk8uoaAAMg9L2DiQgoAC054ycVOenJHKQVKCWAJ4RvKAAvN6QvpBvkIFEptjKgAIw7PagOAAByYZCoz1QO0aeEK9EQbC4kQE81imiAA"
      },
      {
        "text": "Try",
        "href": "https://www.typescriptlang.org/play/#code/JYOwLgpgTgZghgYwgAgMoEcCucoQMID2IMwA5sgN4BQyyCBANgVAPwBcyAzmFKKQNw1kAd2AATMAAt2yEJgC2AI2iDaAbQAOUAhoByceRA7deIUgF0OmEAGsQBYSEEBfIA"
      },
      {
        "text": "Try",
        "href": "https://www.typescriptlang.org/play/#code/JYOwLgpgTgZghgYwgAgMoEcCucoQMID2IMwA5sgN4BQyyCBANgVAPwBcyAzmFKKQNw1kAd2AATMAAt2yEJgC2AI2iCAvlSoxMIBGGBE6uOJAzZcACnrEyHUznxESpAJQcKdRsw7deIAcns4DjklaGRVSiFcMEwoEEjaWnomKA4rJwA6ZOZkAB9c5AAiXDFCgBohWkC0xzIM0QlJZBYPa1J68SlkACpWzIaujgAmAAYK2lU1KgB6aeQAWkWETDBF+aoGCDAuLHsAeQAHPSJOZABeSg8mWI5iiFKykU7JDgBGEZHwwU3t+QBPOy4c6GCDGCCAiDmTi7XCHY4gTjOfhAA"
      },
      {
        "text": "Try",
        "href": "https://www.typescriptlang.org/play/#code/PTAEAEFMCdoe2gZwFygEwFYME4BQBLAOwBcYAzAQwGNJQBlARwFcLpIBhOQs-Ac1ADeuUKCpwANggD8qRMWhFeAbmGgA7vgAmxABYzQhJgFsARjBUBfXLjJNCVYvi6i2FUoxZsAFGO59UHqwcXDy8AJSoAqISCLLyikqgQRSohqYwoBaCqmzETNCE2SIiYpLQqL6hAHSlCKAAPvWgAERsms0ANKoiyRUhfFUa2jqgUtF+vINauqAAVOPVQzOoaAAMXSIWlrggoAC0B1RMxAd7uOKQxKCIzEEA8gAOjlyIoAC8gtGS+aitkO2ZFQXK5GACegTY7xckDckAhkC8N08kEez0IiDCSiAA"
      },
      {
        "text": "Try",
        "href": "https://www.typescriptlang.org/play/#code/JYOwLgpgTgZghgYwgAgEJwM7AQQQCZ5QQYbIDeAUMsiHALYQD8AXMhmFKAOYDcVbHCBDCt2nEL34JgYAJ6iO3PtQQB7AK7go8geMnUADqvZwANgGFVeCAr18AvkA"
      },
      {
        "text": "Try",
        "href": "https://www.typescriptlang.org/play/#code/JYOwLgpgTgZghgYwgAgIIBN1QgZxwdWDAAsBVEI5AbwChlkQ4BbCAfgC5kcwpQBzANx1kAVwphO3XiEE0A9HIB6ylapXCpECBK49+Q+giIBPSXpkHkCAPZiep3dNn0ADte5wANgGFr6CGZOQgC+QA"
      },
      {
        "text": "Try",
        "href": "https://www.typescriptlang.org/play/#code/JYOwLgpgTgZghgYwgAgEJwM7AQQQCZ5QQYbIDeAUMsiHALYQD8AXMhmFKAOYDcVbHCBDCt2nEL34JgYAJ6iO3PtQQB7AK7go8geMnUADqvZwANgGFVeCAr18AvhQqhIsRCnyFiGAOoyAFgCqIDLIEAAekCB4pOhYuAREJOT8mjK2ShT2QA"
      },
      {
        "text": "Try",
        "href": "https://www.typescriptlang.org/play/#code/JYOwLgpgTgZghgYwgAgMIHsA27YFdPIDeAUMsgljgFzIDOYUoA5gNzEC+xxoksiKqYFASYUJMlDgATYLlo0QuALYAjaG07dw0eEjSU8mQcNHIIAD0ggptfdkMAaNEJFjNFEPXIIaGezHxjV2QAXiJScgMaACIoCClohwjJGTkaABYAJiT2FiA"
      },
      {
        "text": "Try",
        "href": "https://www.typescriptlang.org/play/#code/JYOwLgpgTgZghgYwgAgMIHsA27YFdPIDeAUMsgljgFzIDOYUoA5gNzEC+xoksiKqwKAkwoSZKHAAmwXLRohcAWwBG0Np2JgAngAd+lPJgFCRyALxoDMfMgBkaQcIgsgA"
      },
      {
        "text": "Try",
        "href": "https://www.typescriptlang.org/play/#code/PTAEAEFMCdoe2gZwFygEwGYAsBWAUAJYB2ALjAGYCGAxpKAMJwA2C5Ark6AN56ijXMEqRCWjEA5gG48AX0KkKNOvQLRqTOjz7RKAEwJsUoImwC2AIxjS5IUAFoH1NiQd287ItRIE4RULp0AdwAKalV1SFRGFmh2TgAyBnCNAEpuXn5fRGZIADoWcWCAA2iEUEDKRFAAEi4wtQ1cgRiZIpTpPgEibMaC4oAlPQMqiqra+ojcnX1DVvbZPDxbOABrSgBPPADKEK5MmNQAInMmNkhDgBpQaeHULDRQGXmlsDg4AAdELaDgveahUCHaCQXSXa6UAi6Qx3B5PSRAA"
      },
      {
        "text": "Try",
        "href": "https://www.typescriptlang.org/play/#code/JYOwLgpgTgZghgYwgAgArQM4HsQEZkDeAUMsiHALYQBcyGYUoA5gNxEC+RRoksiK6KNhAAmQiTKUaZAK4UARtDaciYAJ4AHFAGUwcGDGQBeNJhz4AZKaE4RXACYQEAGzhQUCHPTp6D0Wrr6MGz0QdAAdORUbAD0MaQJpAB6APxAA"
      },
      {
        "text": "Try",
        "href": "https://www.typescriptlang.org/play/#code/JYOwLgpgTgZghgYwgAgEIHsAeyDeAoZZBdcCcAZwC5k4QBPAbjwF8g"
      },
      {
        "text": "Try",
        "href": "https://www.typescriptlang.org/play/#code/JYOwLgpgTgZghgYwgAgEIHsAeyDeAoZZBdcCcAZwC5kBXEAaxHQHcQBuPAXzzwBsIwyTNQzYAvLgJESkCtQBEACwi9e6ZM3RReAE3kAaLhzwB6ExpTEauosoT1kAckwA6YqQqO8wGMgAUYACeAA4Q6L6u7rJg5Mhi8cjy5GBQoADm8gCUkoTu5Oj8LmppfpEyZDEuYOgAMizQAMJw5BB+mZkc3KbmWhbS1jq0LchwyEGhI+QtUGDAJHh5BRBF6CWlbuUUk8jJqSBpmVW19VBNLW0dQA"
      },
      {
        "text": "Try",
        "href": "https://www.typescriptlang.org/play/#code/PTAEAEFMCdoe2gZwFygEwGY1oFAEsA7AFxgDMBDAY0lADkBXAWwCMYAhOAD1AG8dRQlOMUjEUoAk1bQA3DgC+OfCOgVqoAMpFohAOYdufAUJFjUibXrmLlJVVRoc4AG0jkCB3v0HCSZ0MxwLm4E1kA"
      },
      {
        "text": "Try",
        "href": "https://www.typescriptlang.org/play/#code/JYOwLgpgTgZghgYwgAgHIFcC2AjaAhAewA9kBvAKGWQQPAnAGcAuZELXKAbnIF9zzQkWIhQBlMFFABzQiQpUadRiwYTp3PgLrCkyQgQA2EOCFllK1WpGXJsBQ8ZAbyAehfIAtF4TowXj+Qw6CAIYMC0yAwQYADCVvRgDAAUdkQs4pIgMsQANKwQAO5xSokqalkAlCwAbgTAACbcQSFhEVGx8YwpxCwYOPi5+UWdpazs0FXItQ1NwaHhIJHRxdaJ3Wl69kYmsnkghSsJzLZbjpPTjYFzrYvth12pLKSWJccmAJ7IPHsHI28g7wq5ioqQAdIpVgxkABeIb3RIaIA"
      },
      {
        "text": "Try",
        "href": "https://www.typescriptlang.org/play/#code/JYOwLgpgTgZghgYwgAgEIHsAeAeAKgTwAcIA+ZAbwChlkF1wJwBnALmQOIG5KBfIA"
      },
      {
        "text": "Try",
        "href": "https://www.typescriptlang.org/play/#code/JYOwLgpgTgZghgYwgAgEIHsAeAeAKgTwAcIA+ZAbwChlkF1wJwBnALmQOIG5KBfSgen7IAtKIQBXMKOGUANhDDIARljYYcTMFFABzEpyA"
      },
      {
        "text": "Try",
        "href": "https://www.typescriptlang.org/play/#code/JYOwLgpgTgZghgYwgAgEIHsAeAeAKgTwAcIA+ZAbwChlkF1wJwBnALmQOIG5KBfS0SLEQoAymCigA5hkwVqtepGZsm4qdz6UANhDDIARlgCCbGdlUSQksgF4KChsuQAiABYQtW9M+Q9uhzCMAOjpHMCZuAHpImmQAPQB+Sm1dAyxUNjFLaSxkO3IHJXC2ZwB3dCgtABMfP0oA1BDFRnComJpEoA"
      },
      {
        "text": "Try",
        "href": "https://www.typescriptlang.org/play/#code/JYOwLgpgTgZghgYwgAgEIHsAeAeAKgTwAcIA+ZAbwChlkF1wJwBnALmQOIG5KBfSy0JFiIUAQUKEANiio0A9HOQA6FUt78FyAMpwAtijhNkAcnK16kZm3FSUPY2rBExE6RkzIAvGizYb0kk4gA"
      },
      {
        "text": "generic functions",
        "href": "/docs/handbook/2/functions.html#generic-functions"
      },
      {
        "text": "Try",
        "href": "https://www.typescriptlang.org/play/#code/JYOwLgpgTgZghgYwgAgEIHsAeAeAKgTwAcIA+ZAbwChlkF1wJwBnALmQOIG5KBfSygPQDkAWjEIArmDEjKMCSARhg9ZEwhgAwvUjM8RUgAoARljYYcHUgBpkICAHdtDZmysBKCtWSnMAOjoXMCZkAF47R2ddYO4eIA"
      },
      {
        "text": "Try",
        "href": "https://www.typescriptlang.org/play/#code/JYOwLgpgTgZghgYwgAgEIHsAeAeAKgTwAcIA+ZAbwChlkF1wJwBnALmQOIG5KBfIA"
      },
      {
        "text": "Try",
        "href": "https://www.typescriptlang.org/play/#code/C4TwDgpgBAQg9gDwDwBVwQHxQLxQN4BQUUAxnAHbASUDOAXFGpANwEC+zQA"
      },
      {
        "text": "Try",
        "href": "https://www.typescriptlang.org/play/#code/PTAEAEFMCdoe2gZwFygEwFYDsGBQAXATwAdJQB5aAOQFcAbOgHgBUTIA+UAXlFdNAA+oAHb06AblwE2FYZEoBZAIbDCLNpx58yQ7QG0AupOn9ycxSsKVaDdaU0VqYxmfnRlqux3aSQofwB6APxSRKbm7pbWYgDK+NAAlsIA5ojcsm4eVk62iPFJyT64foFBQA"
      },
      {
        "text": "Try",
        "href": "https://www.typescriptlang.org/play/#code/GYVwdgxgLglg9mABAEzgZTgWwKZQBYxgDmAFAG4CGANiNgFyICCATsxQJ4A8AzlM4UQB8ASkQBvAFCJEAehmIAdEokBfCRKq5EmdizbsGvfsQDaAXUQBeRCYBEebFSpxbAGkS2A7nGZVktswBudTlEbBh8bGZEOGBESO5sRG9mAGsAQglUDBx8ARIdPQ5hYOysXAJiEjBsTyZWDhJ7R2c3DxS-W2ESoA"
      },
      {
        "text": "Try",
        "href": "https://www.typescriptlang.org/play/#code/PTAEAEDsHsBkEsBGAuUAXATgVwKYCh5I0cMAzAQwGMdQA5LAW0RNAG8BfAoki60AZUyEA5m06FiZKjQBC0aABsc5SGK6TeNfgE8mitSFABaE5SxoTR9T2mgAghgzltAHgAq2gA44AfGzygoMAAVMEBgcGgAOI4aADOoNAYoHGxCWgAFjRKkMKZiaToWaDkjs4AdOGgwcDhOXkZqJCMzBgA3HjhIWGB1aAASjgM0ABuOOnFCuRxaKA4Sgw4RKCkGNAMJaqlTtqbACagGLFYGJAJ8GiVvTXhntCeABQAlKge3qAAPqBYkHs4pIQcHsOl1QlVInZPN5fglIDgAO5zBZLeLoaCbEplbQAGn2h2OpwmNDhiPq+WghUyNG2FXBtUCniwcQyD3KbIuQziry8OAA2gBdF6gZpMEggwKGNmVdhAA"
      },
      {
        "text": "Try",
        "href": "https://www.typescriptlang.org/play/#code/PTAEAEFMCdoe2gZwFygEwGYME4BQAzAVwDsBjAFwEs5jQATOAZXMP3wAoA3AQwBtDIKUACVI3BsV4BPAIKxuUgDyJy0SsQDmAPgCUoAN65QoEKADqkUKW61oYuqHzwAtqADkPfoLcA6P0asaFUCABylQAF5QTwFEH0ReSlJIdh0AbgDSILheSB9eOA12AAMAFQALS3xKJHJovgFQSkRQABJ9GMEAbQAGAF0AX2L03ADTPx8AI0I6gHdLa2I3OucZ7nJLDwbvHwDOuJDCRHL2ACJK3gKAQlORgaA"
      },
      {
        "text": "Try",
        "href": "https://www.typescriptlang.org/play/#code/PTAEAEFMCdoe2gZwFygEwDYCcBmAUAHaQDuoASpAIYAmcBANgJ4CCsljAFAETSTVcAaUFwDmvSAUHCARvQCukLgEoA3EA"
      },
      {
        "text": "Try",
        "href": "https://www.typescriptlang.org/play/#code/MYewdgzgLgBATiAgnOBDAngLhgJQKaoAm4ANusmugDzRwCWYA5gHwwC8MA2gERx6HcANDG6M+eMEJEAjEgFc83ALoBuIA"
      },
      {
        "text": "Try",
        "href": "https://www.typescriptlang.org/play/#code/PTAEAEFMCdoe2gZwFygEwGYME4BQAzAVwDsBjAFwEs5jQATOAZXMP3wAoA3AQwBtDIKUNEjcGxXgE9QictErEA5gG0AugEpQAb1yhQIPYaPGToAHoXLV6xd36wAdUihS3WiLGh88ALagA5Dz8gv4AdOF2pDSyLnAADtIAvKBBAoihiLyUpJDs6gDckdFwvJChvHCK7AAGACoAFs74lEjkKXwCoJSIoAAkWqmCygAMqgC+1QW4dgbhoQBGhG0A7s6uxP5tPkvc5M6BHSGhdoPpcYSI9ewARI28FQCE11NjQA"
      },
      {
        "text": "Try",
        "href": "https://www.typescriptlang.org/play/#code/PTAEAEFMCdoe2gZwFygCwEYAMaBQAbSAF1AA9VpIBDAEzgDt8BPURI6AS3oHMBtAXVABeUAIDcBYqCao2nHgOGj+E3KSVMJLEaTFA"
      },
      {
        "text": "Try",
        "href": "https://www.typescriptlang.org/play/#code/C4TwDgpgBAysBOBLAdgcwHIFcC2AjC8ACgIaLxQC8UA2gM4IqoA0UyO+8AugNwBQA9PyjCRoseKgA9aTNlzJQA"
      },
      {
        "text": "Try",
        "href": "https://www.typescriptlang.org/play/#code/GYVwdgxgLglg9mABAEzgZTgWwKZQBYxgDmAFAA4CGMATgFyIDaAzlNYUQDSJgiYBG2agF0AlIgDeAKESIICFogqIAvIko0GABiEBuaYgD0BmTIB6Afn1ywCvirVVqDAIy79Rk4gvvjAOn+SAL6SkqgYOPjsJAwARHjYADYJcDFcACwATKI6QA"
      },
      {
        "text": "Try",
        "href": "https://www.typescriptlang.org/play/#code/PTAEAEFMCdoe2gZwFygEwBYCcBmAUAGYCuAdgMYAuAlnCaACZwDKcAtpBQBZUkDmAFAAcAhlWioA2ogrQevADSgSRVgCMYAXQCUoAN55QoEKAB0ZvAdBla0q6AC8oEWIloNAbjwBfIA"
      },
      {
        "text": "destructure tuples",
        "href": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/Destructuring_assignment#Array_destructuring"
      },
      {
        "text": "Try",
        "href": "https://www.typescriptlang.org/play/#code/GYVwdgxgLglg9mABAEzgZTgWwKZQBYxgDmAFAM5QBOhRAEgIZl4BciA2hdcQDSJgiYARtkoBdAJSIA3gChEiCAgrtCABxBQ0VGrzyM8oxAF5EnGgyYBuGXIVK4AG2wA6B3FJqNWrkXHX5APQB8iGhiAB6APw28opgZI4ubqR6TH62QWFhUTIAvkA"
      },
      {
        "text": "Try",
        "href": "https://www.typescriptlang.org/play/#code/JYOwLgpgTgZghgYwgAgMpiqA5gOQK4C2ARtAApzBTIDeAUMsgPSPIDOADhAsHADbAAvCABNk7KAHtOUMMAit6yXhBBYwACwBcyAEwBuRQAZtrDNgMMAjNpCESUA4ubIA8hujIA5AEEoUOACeADymmKrIAD7ItsTQAHyeyAQQsVCsAHSZiqz8SAAUpnAyAPw2dtAANMgqwqXR5VAAlNq+-sGh2JH1qXEGAL5AA"
      },
      {
        "text": "Try",
        "href": "https://www.typescriptlang.org/play/#code/C4TwDgpgBAoglsAFhATgJgCYHkUGYNQC8UA2gHYCuAtgEaoA0UltDT1dKA-ALoDcAUPwBmFMgGNgcAPZkoAZwjAAwlKkoMcMgENgEABRjV6gFywEydNjwYAlFADe-KFENk5wUgA9GIRgC9uIhcjDAFnAHpw52iY5wA9TkFnVzkpABsIADo0qQBzPQADAAUUKQA3OAwIAkM1DW1dOShELQIAEnta9WyIMlykAF8oDSpeuWk3ApswqEjY+YXFpaWE-gGgA"
      },
      {
        "text": "Try",
        "href": "https://www.typescriptlang.org/play/#code/C4TwDgpgBAysBOBLAdgcwHIFcC2AjC8AQgPbEA2EAhsgM5QC8UA2jQiqgDRTI77xcA6IblIVqTALoSA3AChQkWGzQlyVWljwEGzVkjSDho9ZK48t8GfPDRVY2nH0Ze2xkyECRa8RK572Zi6W0kA"
      },
      {
        "text": "Try",
        "href": "https://www.typescriptlang.org/play/#code/C4TwDgpgBAysBOBLAdgcwHIFcC2AjC8AQgPbEA2EAhsgM5QC8UA2jQiqgDRTI77xcA6IblIVqTALoSA3ACgA9PKgBaVQGNMwVctlritYFEoAuWGzRY8BEuSq0GzAEQALCGTLFHXAIwzd+1ihcUzgkC15rUTs6RiZHfEpNRAAzTDIvKAAmLgRMCD89Ayg1EPMMCKIo6hinAHdieDIAEwyAZhz4PK5kyjIaCA6uqB6+gahc-OkgA"
      },
      {
        "text": "rest parameters and arguments",
        "href": "/docs/handbook/2/functions.html#rest-parameters-and-arguments"
      },
      {
        "text": "Try",
        "href": "https://www.typescriptlang.org/play/#code/GYVwdgxgLglg9mABAJwKYEMAmAhEUoICSYADngBQB016yA5gM4BciA2g1MjGHQDSJgQAWwBGqZP2qURcOABsMYVgF1lASkQBvAFCJEEBBzZh0Q1PwBu4hvDCTq3MlGWIAvIlqMA3LsQB6P0QpbQBfIA"
      },
      {
        "text": "Try",
        "href": "https://www.typescriptlang.org/play/#code/GYVwdgxgLglg9mABAJwKYEMAmAhEUoICSYADngBRjoC2qAXIgM5TIxgDmANIgG6rKN4YBmBDUARv24A6WWzJQG4uHAA2GMAG0AugEpEAbwBQiRAHoziWdKMBfIA"
      },
      {
        "text": "Try",
        "href": "https://www.typescriptlang.org/play/#code/GYVwdgxgLglg9mABAEzgZTgWwKZQBYxgDmAFAA4CGMATgFyLXYWpgA2AnogNoDOU1hIgBpEYEJgBG2agF0AlIgDeAKESIA9OrXaduvdoB6R4ydNmTqjVoB0t5QF8gA"
      },
      {
        "text": "Try",
        "href": "https://www.typescriptlang.org/play/#code/PTAEAEFMCdoe2gZwFygEwFYAsAGAUAGYCuAdgMYAuAlnCaACZwDKcAtpBQBZUkDmAFAAcAhlWipokYYxIAbAJ6gA2ogrQevADSgSRVgCMYAXQCUoAN55QoEWKU4joALygARJ0izZcAISuA3HgAvkA"
      },
      {
        "text": "Try",
        "href": "https://www.typescriptlang.org/play/#code/PTAEAEFMCdoe2gZwFygEwGYAsBWAUADaQAuoADnAJYB2pAvKANoYA0oWAuqAIaKgDGcaomIBuPHgBmAV2r9ilIaAAmlEdzmQAYvAC2AeWiUA5jQAUjAB5sAnh1SNq03QCMYbJ65gcAlKADeeKCg0CTS0NSgALLcxAAWAHSIAI7QxGaWoABUWeigANSgNtm5aD7iAL4SquqaOnAGRqbUZhQ0xOVAA"
      }
    ],
    "meta": {
      "description": "How TypeScript describes the shapes of JavaScript objects.",
      "keywords": ""
    },
    "summary": "In JavaScript, the fundamental way that we group and pass around data is through objects. In TypeScript, we represent those through object types",
    "tags": [
      "react",
      "javascript",
      "typescript",
      "html",
      "vite",
      "types",
      "property",
      "properties",
      "readonly",
      "intersection"
    ],
    "id": "typescript-documentation-objectshtml-part-1",
    "quality": 100
  },
  {
    "title": "TypeScript: Documentation",
    "url": "https://www.typescriptlang.org/docs/handbook/2/functions.html",
    "category": "typescript",
    "content": "Functions are the basic building block of any application, whether theyre local functions, imported from another module, or methods on a class. Theyre also values, and just like other values, TypeScript has many ways to describe how functions can be called. Lets learn about how to write types that describe functions. Function Type Expressions The simplest way to describe a function is with a function type expression. These types are syntactically similar to arrow functions: tsfunction greeter(fn: (a: string) = void) { fn(\"Hello, World\");} function printToConsole(s: string) { console.log(s);} greeter(printToConsole);Try The syntax (a: string) = void means a function with one parameter, named a, of type string, that doesnt have a return value. Just like with function declarations, if a parameter type isnt specified, its implicitly any. Note that the parameter name is required. The function type (string) = void means a function with a parameter named string of type any! Of course, we can use a type alias to name a function type: tstype GreetFunction = (a: string) = void;function greeter(fn: GreetFunction) { // ...}Try Call Signatures In JavaScript, functions can have properties in addition to being callable. However, the function type expression syntax doesnt allow for declaring properties. If we want to describe something callable with properties, we can write a call signature in an object type: tstype DescribableFunction = { description: string; (someArg: number): boolean;};function doSomething(fn: DescribableFunction) { console.log(fn.description + \" returned \" + fn(6));} function myFunc(someArg: number) { return someArg  3;}myFunc.description = \"default description\"; doSomething(myFunc);Try Note that the syntax is slightly different compared to a function type expression - use : between the parameter list and the return type rather than =. Construct Signatures JavaScript functions can also be invoked with the new operator. TypeScript refers to these as constructors because they usually create a new object. You can write a construct signature by adding the new keyword in front of a call signature: tstype SomeConstructor = { new (s: string): SomeObject;};function fn(ctor: SomeConstructor) { return new ctor(\"hello\");}Try Some objects, like JavaScripts Date object, can be called with or without new. You can combine call and construct signatures in the same type arbitrarily: tsinterface CallOrConstruct { (n?: number): string; new (s: string): Date;} function fn(ctor: CallOrConstruct) { // Passing an argument of type number to ctor matches it against // the first definition in the CallOrConstruct interface. console.log(ctor(10)); (parameter) ctor: CallOrConstruct (n?: number) = string // Similarly, passing an argument of type string to ctor matches it // against the second definition in the CallOrConstruct interface. console.log(new ctor(\"10\")); (parameter) ctor: CallOrConstruct new (s: string) = Date} fn(Date);Try Generic Functions Its common to write a function where the types of the input relate to the type of the output, or where the types of two inputs are related in some way. Lets consider for a moment a function that returns the first element of an array: tsfunction firstElement(arr: any[]) { return arr[0];}Try This function does its job, but unfortunately has the return type any. Itd be better if the function returned the type of the array element. In TypeScript, generics are used when we want to describe a correspondence between two values. We do this by declaring a type parameter in the function signature: tsfunction firstElementType(arr: Type[]): Type  undefined { return arr[0];}Try By adding a type parameter Type to this function and using it in two places, weve created a link between the input of the function (the array) and the output (the return value). Now when we call it, a more specific type comes out: ts// s is of type 'string'const s = firstElement([\"a\", \"b\", \"c\"]);// n is of type 'number'const n = firstElement([1, 2, 3]);// u is of type undefinedconst u = firstElement([]);Try Inference Note that we didnt have to specify Type in this sample. The type was inferred - chosen automatically - by TypeScript. We can use multiple type parameters as well. For example, a standalone version of map would look like this: tsfunction mapInput, Output(arr: Input[], func: (arg: Input) = Output): Output[] { return arr.map(func);} // Parameter 'n' is of type 'string'// 'parsed' is of type 'number[]'const parsed = map([\"1\", \"2\", \"3\"], (n) = parseInt(n));Try Note that in this example, TypeScript could infer both the type of the Input type parameter (from the given string array), as well as the Output type parameter based on the return value of the function expression (number). Constraints Weve written some generic functions that can work on any kind of value. Sometimes we want to relate two values, but can only operate on a certain subset of values. In this case, we can use a constraint to limit the kinds of types that a type parameter can accept. Lets write a function that returns the longer of two values. To do this, we need a length property thats a number. We constrain the type parameter to that type by writing an extends clause: tsfunction longestType extends { length: number }(a: Type, b: Type) { if (a.length = b.length) { return a; } else { return b; }} // longerArray is of type 'number[]'const longerArray = longest([1, 2], [1, 2, 3]);// longerString is of type 'alice'  'bob'const longerString = longest(\"alice\", \"bob\");// Error! Numbers don't have a 'length' propertyconst notOK = longest(10, 100);Argument of type 'number' is not assignable to parameter of type '{ length: number; }'.2345Argument of type 'number' is not assignable to parameter of type '{ length: number; }'.Try There are a few interesting things to note in this example. We allowed TypeScript to infer the return type of longest. Return type inference also works on generic functions. Because we constrained Type to { length: number }, we were allowed to access the .length property of the a and b parameters. Without the type constraint, we wouldnt be able to access those properties because the values might have been some other type without a length property. The types of longerArray and longerString were inferred based on the arguments. Remember, generics are all about relating two or more values with the same type! Finally, just as wed like, the call to longest(10, 100) is rejected because the number type doesnt have a .length property. Working with Constrained Values Heres a common error when working with generic constraints: tsfunction minimumLengthType extends { length: number }( obj: Type, minimum: number): Type { if (obj.length = minimum) { return obj; } else { return { length: minimum };Type '{ length: number; }' is not assignable to type 'Type'. '{ length: number; }' is assignable to the constraint of type 'Type', but 'Type' could be instantiated with a different subtype of constraint '{ length: number; }'.2322Type '{ length: number; }' is not assignable to type 'Type'. '{ length: number; }' is assignable to the constraint of type 'Type', but 'Type' could be instantiated with a different subtype of constraint '{ length: number; }'. }}Try It might look like this function is OK - Type is constrained to { length: number }, and the function either returns Type or a value matching that constraint. The problem is that the function promises to return the same kind of object as was passed in, not just some object matching the constraint. If this code were legal, you could write code that definitely wouldnt work: ts// 'arr' gets value { length: 6 }const arr = minimumLength([1, 2, 3], 6);// and crashes here because arrays have// a 'slice' method, but not the returned object!console.log(arr.slice(0));Try Specifying Type Arguments TypeScript can usually infer the intended type arguments in a generic call, but not always. For example, lets say you wrote a function to combine two arrays: tsfunction combineType(arr1: Type[], arr2: Type[]): Type[] { return arr1.concat(arr2);}Try Normally it would be an error to call this function with mismatched arrays: tsconst arr = combine([1, 2, 3], [\"hello\"]);Type 'string' is not assignable to type 'number'.2322Type 'string' is not assignable to type 'number'.Try If you intended to do this, however, you could manually specify Type: tsconst arr = combinestring  number([1, 2, 3], [\"hello\"]);Try Guidelines for Writing Good Generic Functions Writing generic functions is fun, and it can be easy to get carried away with type parameters. Having too many type parameters or using constraints where they arent needed can make inference less successful, frustrating callers of your function. Push Type Parameters Down Here are two ways of writing a function that appear similar: tsfunction firstElement1Type(arr: Type[]) { return arr[0];} function firstElement2Type extends any[](arr: Type) { return arr[0];} // a: number (good)const a = firstElement1([1, 2, 3]);// b: any (bad)const b = firstElement2([1, 2, 3]);Try These might seem identical at first glance, but firstElement1 is a much better way to write this function. Its inferred return type is Type, but firstElement2s inferred return type is any because TypeScript has to resolve the arr[0] expression using the constraint type, rather than waiting to resolve the element during a call. Rule: When possible, use the type parameter itself rather than constraining it Use Fewer Type Parameters Heres another pair of similar functions: tsfunction filter1Type(arr: Type[], func: (arg: Type) = boolean): Type[] { return arr.filter(func);} function filter2Type, Func extends (arg: Type) = boolean( arr: Type[], func: Func): Type[] { return arr.filter(func);}Try Weve created a type parameter Func that doesnt relate two values. Thats always a red flag, because it means callers wanting to specify type arguments have to manually specify an extra type argument for no reason. Func doesnt do anything but make the function harder to read and reason about! Rule: Always use as few type parameters as possible Type Parameters Should Appear Twice Sometimes we forget that a function might not need to be generic: tsfunction greetStr extends string(s: Str) { console.log(\"Hello, \" + s);} greet(\"world\");Try We could just as easily have written a simpler version: tsfunction greet(s: string) { console.log(\"Hello, \" + s);}Try Remember, type parameters are for relating the types of multiple values. If a type parameter is only used once in the function signature, its not relating anything. This includes the inferred return type; for example, if Str was part of the inferred return type of greet, it would be relating the argument and return types, so would be used twice despite appearing only once in the written code. Rule: If a type parameter only appears in one location, strongly reconsider if you actually need it Optional Parameters Functions in JavaScript often take a variable number of arguments. For example, the toFixed method of number takes an optional digit count: tsfunction f(n: number) { console.log(n.toFixed()); // 0 arguments console.log(n.toFixed(3)); // 1 argument}Try We can model this in TypeScript by marking the parameter as optional with ?: tsfunction f(x?: number) { // ...}f(); // OKf(10); // OKTry Although the parameter is specified as type number, the x parameter will actually have the type number  undefined because unspecified parameters in JavaScript get the value undefined. You can also provide a parameter default: tsfunction f(x = 10) { // ...}Try Now in the body of f, x will have type number because any undefined argument will be replaced with 10. Note that when a parameter is optional, callers can always pass undefined, as this simply simulates a missing argument: ts// All OKf();f(10);f(undefined);Try Optional Parameters in Callbacks Once youve learned about optional parameters and function type expressions, its very easy to make the following mistakes when writing functions that invoke callbacks: tsfunction myForEach(arr: any[], callback: (arg: any, index?: number) = void) { for (let i = 0; i  arr.length; i++) { callback(arr[i], i); }}Try What people usually intend when writing index? as an optional parameter is that they want both of these calls to be legal: tsmyForEach([1, 2, 3], (a) = console.log(a));myForEach([1, 2, 3], (a, i) = console.log(a, i));Try What this actually means is that callback might get invoked with one argument. In other words, the function definition says that the implementation might look like this: tsfunction myForEach(arr: any[], callback: (arg: any, index?: number) = void) { for (let i = 0; i  arr.length; i++) { // I don't feel like providing the index today callback(arr[i]); }}Try In turn, TypeScript will enforce this meaning and issue errors that arent really possible: tsmyForEach([1, 2, 3], (a, i) = { console.log(i.toFixed());'i' is possibly 'undefined'.18048'i' is possibly 'undefined'.});Try In JavaScript, if you call a function with more arguments than there are parameters, the extra arguments are simply ignored. TypeScript behaves the same way. Functions with fewer parameters (of the same types) can always take the place of functions with more parameters. Rule: When writing a function type for a callback, never write an optional parameter unless you intend to call the function without passing that argument Function Overloads Some JavaScript functions can be called in a variety of argument counts and types. For example, you might write a function to produce a Date that takes either a timestamp (one argument) or a month/day/year specification (three arguments). In TypeScript, we can specify a function that can be called in different ways by writing overload signatures. To do this, write some number of function signatures (usually two or more), followed by the body of the function: tsfunction makeDate(timestamp: number): Date;function makeDate(m: number, d: number, y: number): Date;function makeDate(mOrTimestamp: number, d?: number, y?: number): Date { if (d !== undefined && y !== undefined) { return new Date(y, mOrTimestamp, d); } else { return new Date(mOrTimestamp); }}const d1 = makeDate(12345678);const d2 = makeDate(5, 5, 5);const d3 = makeDate(1, 3);No overload expects 2 arguments, but overloads do exist that expect either 1 or 3 arguments.2575No overload expects 2 arguments, but overloads do exist that expect either 1 or 3 arguments.Try In this example, we wrote two overloads: one accepting one argument, and another accepting three arguments. These first two signatures are called the overload signatures. Then, we wrote a function implementation with a compatible signature. Functions have an implementation signature, but this signature cant be called directly. Even though we wrote a function with two optional parameters after the required one, it cant be called with two parameters! Overload Signatures and the Implementation Signature This is a common source of confusion. Often people will write code like this and not understand why there is an error: tsfunction fn(x: string): void;function fn() { // ...}// Expected to be able to call with zero argumentsfn();Expected 1 arguments, but got 0.2554Expected 1 arguments, but got 0.Try Again, the signature used to write the function body cant be seen from the outside. The signature of the implementation is not visible from the outside. When writing an overloaded function, you should always have two or more signatures above the implementation of the function. The implementation signature must also be compatible with the overload signatures. For example, these functions have errors because the implementation signature doesnt match the overloads in a correct way: tsfunction fn(x: boolean): void;// Argument type isn't rightfunction fn(x: string): void;This overload signature is not compatible with its implementation signature.2394This overload signature is not compatible with its implementation signature.function fn(x: boolean) {}Try tsfunction fn(x: string): string;// Return type isn't rightfunction fn(x: number): boolean;This overload signature is not compatible with its implementation signature.2394This overload signature is not compatible with its implementation signature.function fn(x: string  number) { return \"oops\";}Try Writing Good Overloads Like generics, there are a few guidelines you should follow when using function overloads. Following these principles will make your function easier to call, easier to understand, and easier to implement. Lets consider a function that returns the length of a string or an array: tsfunction len(s: string): number;function len(arr: any[]): number;function len(x: any) { return x.length;}Try This function is fine; we can invoke it with strings or arrays. However, we cant invoke it with a value that might be a string or an array, because TypeScript can only resolve a function call to a single overload: tslen(\"\"); // OKlen([0]); // OKlen(Math.random()  0.5 ? \"hello\" : [0]);No overload matches this call. Overload 1 of 2, '(s: string): number', gave the following error. Argument of type 'number[]  \"hello\"' is not assignable to parameter of type 'string'. Type 'number[]' is not assignable to type 'string'. Overload 2 of 2, '(arr: any[]): number', gave the following error. Argument of type 'number[]  \"hello\"' is not assignable to parameter of type 'any[]'. Type 'string' is not assignable to type 'any[]'.2769No overload matches this call. Overload 1 of 2, '(s: string): number', gave the following error. Argument of type 'number[]  \"hello\"' is not assignable to parameter of type 'string'. Type 'number[]' is not assignable to type 'string'. Overload 2 of 2, '(arr: any[]): number', gave the following error. Argument of type 'number[]  \"hello\"' is not assignable to parameter of type 'any[]'. Type 'string' is not assignable to type 'any[]'.Try Because both overloads have the same argument count and same return type, we can instead write a non-overloaded version of the function: tsfunction len(x: any[]  string) { return x.length;}Try This is much better! Callers can invoke this with either sort of value, and as an added bonus, we dont have to figure out a correct implementation signature. Always prefer parameters with union types instead of overloads when possible Declaring this in a Function TypeScript will infer what the this should be in a function via code flow analysis, for example in the following: tsconst user = { id: 123, admin: false, becomeAdmin: function () { this.admin = true; },};Try TypeScript understands that the function user.becomeAdmin has a corresponding this which is the outer object user. this, heh, can be enough for a lot of cases, but there are a lot of cases where you need more control over what object this represents. The JavaScript specification states that you cannot have a parameter called this, and so TypeScript uses that syntax space to let you declare the type for this in the function body. tsinterface DB { filterUsers(filter: (this: User) = boolean): User[];} const db = getDB();const admins = db.filterUsers(function (this: User) { return this.admin;});Try This pattern is common with callback-style APIs, where another object typically controls when your function is called. Note that you need to use function and not arrow functions to get this behavior: tsinterface DB { filterUsers(filter: (this: User) = boolean): User[];} const db = getDB();const admins = db.filterUsers(() = this.admin);The containing arrow function captures the global value of 'this'.Element implicitly has an 'any' type because type 'typeof globalThis' has no index signature.70417017The containing arrow function captures the global value of 'this'.Element implicitly has an 'any' type because type 'typeof globalThis' has no index signature.Try Other Types to Know About There are some additional types youll want to recognize that appear often when working with function types. Like all types, you can use them everywhere, but these are especially relevant in the context of functions. void void represents the return value of functions which dont return a value. Its the inferred type any time a function doesnt have any return statements, or doesnt return any explicit value from those return statements: ts// The inferred return type is voidfunction noop() { return;}Try In JavaScript, a function that doesnt return any value will implicitly return the value undefined. However, void and undefined are not the same thing in TypeScript. There are further details at the end of this chapter. void is not the same as undefined. object The special type object refers to any value that isnt a primitive (string, number, bigint, boolean, symbol, null, or undefined). This is different from the empty object type { }, and also different from the global type Object. Its very likely you will never use Object. object is not Object. Always use object! Note that in JavaScript, function values are objects: They have properties, have Object.prototype in their prototype chain, are instanceof Object, you can call Object.keys on them, and so on. For this reason, function types are considered to be objects in TypeScript. unknown The unknown type represents any value. This is similar to the any type, but is safer because its not legal to do anything with an unknown value: tsfunction f1(a: any) { a.b(); // OK}function f2(a: unknown) { a.b();'a' is of type 'unknown'.18046'a' is of type 'unknown'.}Try This is useful when describing function types because you can describe functions that accept any value without having any values in your function body. Conversely, you can describe a function that returns a value of unknown type: tsfunction safeParse(s: string): unknown { return JSON.parse(s);} // Need to be careful with 'obj'!const obj = safeParse(someRandomString);Try never Some functions never return a value: tsfunction fail(msg: string): never { throw new Error(msg);}Try The never type represents values which are never observed. In a return type, this means that the function throws an exception or terminates execution of the program. never also appears when TypeScript determines theres nothing left in a union. tsfunction fn(x: string  number) { if (typeof x === \"string\") { // do something } else if (typeof x === \"number\") { // do something else } else { x; // has type 'never'! }}Try Function The global type Function describes properties like bind, call, apply, and others present on all function values in JavaScript. It also has the special property that values of type Function can always be called; these calls return any: tsfunction doSomething(f: Function) { return f(1, 2, 3);}Try This is an untyped function call and is generally best avoided because of the unsafe any return type. If you need to accept an arbitrary function but dont intend to call it, the type () = void is generally safer. Rest Parameters and Arguments Background Reading: Rest Parameters Spread Syntax Rest Parameters In addition to using optional parameters or overloads to make functions that can accept a variety of fixed argument counts, we can also define functions that take an unbounded number of arguments using rest parameters. A rest parameter appears after all other parameters, and uses the ... syntax: tsfunction multiply(n: number, ...m: number[]) { return m.map((x) = n * x);}// 'a' gets value [10, 20, 30, 40]const a = multiply(10, 1, 2, 3, 4);Try In TypeScript, the type annotation on these parameters is implicitly any[] instead of any, and any type annotation given must be of the form ArrayT or T[], or a tuple type (which well learn about later). Rest Arguments Conversely, we can provide a variable number of arguments from an iterable object (for example, an array) using the spread syntax. For example, the push method of arrays takes any number of arguments: tsconst arr1 = [1, 2, 3];const arr2 = [4, 5, 6];arr1.push(...arr2);Try Note that in general, TypeScript does not assume that arrays are immutable. This can lead to some surprising behavior: ts// Inferred type is number[] -- \"an array with zero or more numbers\",// not specifically two numbersconst args = [8, 5];const angle = Math.atan2(...args);A spread argument must either have a tuple type or be passed to a rest parameter.2556A spread argument must either have a tuple type or be passed to a rest parameter.Try The best fix for this situation depends a bit on your code, but in general a const context is the most straightforward solution: ts// Inferred as 2-length tupleconst args = [8, 5] as const;// OKconst angle = Math.atan2(...args);Try Using rest arguments may require turning on downlevelIteration when targeting older runtimes. Parameter Destructuring Background Reading: Destructuring Assignment You can use parameter destructuring to conveniently unpack objects provided as an argument into one or more local variables in the function body. In JavaScript, it looks like this: jsfunction sum({ a, b, c }) { console.log(a + b + c);}sum({ a: 10, b: 3, c: 9 }); The type annotation for the object goes after the destructuring syntax: tsfunction sum({ a, b, c }: { a: number; b: number; c: number }) { console.log(a + b + c);}Try This can look a bit verbose, but you can use a named type here as well: ts// Same as prior exampletype ABC = { a: number; b: number; c: number };function sum({ a, b, c }: ABC) { console.log(a + b + c);}Try Assignability of Functions Return type void The void return type for functions can produce some unusual, but expected behavior. Contextual typing with a return type of void does not force functions to not return something. Another way to say this is a contextual function type with a void return type (type voidFunc = () = void), when implemented, can return any other value, but it will be ignored. Thus, the following implementations of the type () = void are valid: tstype voidFunc = () = void; const f1: voidFunc = () = { return true;}; const f2: voidFunc = () = true; const f3: voidFunc = function () { return true;};Try And when the return value of one of these functions is assigned to another variable, it will retain the type of void: tsconst v1 = f1(); const v2 = f2(); const v3 = f3();Try This behavior exists so that the following code is valid even though Array.prototype.push returns a number and the Array.prototype.forEach method expects a function with a return type of void. tsconst src = [1, 2, 3];const dst = [0]; src.forEach((el) = dst.push(el));Try There is one other special case to be aware of, when a literal function definition has a void return type, that function must not return anything. tsfunction f2(): void { // @ts-expect-error return true;} const f3 = function (): void { // @ts-expect-error return true;};Try For more on void please refer to these other documentation entries: FAQ - Why are functions returning non-void assignable to function returning void?",
    "headings": [
      {
        "level": 2,
        "text": "Function Type Expressions",
        "id": "function-type-expressions"
      },
      {
        "level": 2,
        "text": "Call Signatures",
        "id": "call-signatures"
      },
      {
        "level": 2,
        "text": "Construct Signatures",
        "id": "construct-signatures"
      },
      {
        "level": 2,
        "text": "Generic Functions",
        "id": "generic-functions"
      },
      {
        "level": 2,
        "text": "Optional Parameters",
        "id": "optional-parameters"
      },
      {
        "level": 2,
        "text": "Function Overloads",
        "id": "function-overloads"
      },
      {
        "level": 2,
        "text": "Declaring this in a Function",
        "id": "declaring-this-in-a-function"
      },
      {
        "level": 2,
        "text": "Other Types to Know About",
        "id": "other-types-to-know-about"
      },
      {
        "level": 2,
        "text": "Rest Parameters and Arguments",
        "id": "rest-parameters-and-arguments"
      },
      {
        "level": 2,
        "text": "Parameter Destructuring",
        "id": "parameter-destructuring"
      },
      {
        "level": 2,
        "text": "Assignability of Functions",
        "id": "assignability-of-functions"
      },
      {
        "level": 3,
        "text": "Inference",
        "id": "inference"
      },
      {
        "level": 3,
        "text": "Constraints",
        "id": "constraints"
      },
      {
        "level": 3,
        "text": "Working with Constrained Values",
        "id": "working-with-constrained-values"
      },
      {
        "level": 3,
        "text": "Specifying Type Arguments",
        "id": "specifying-type-arguments"
      },
      {
        "level": 3,
        "text": "Guidelines for Writing Good Generic Functions",
        "id": "guidelines-for-writing-good-generic-functions"
      },
      {
        "level": 3,
        "text": "Optional Parameters in Callbacks",
        "id": "optional-parameters-in-callbacks"
      },
      {
        "level": 3,
        "text": "Overload Signatures and the Implementation Signature",
        "id": "overload-signatures-and-the-implementation-signature"
      },
      {
        "level": 3,
        "text": "Writing Good Overloads",
        "id": "writing-good-overloads"
      },
      {
        "level": 3,
        "text": "void",
        "id": "void"
      },
      {
        "level": 3,
        "text": "object",
        "id": "object"
      },
      {
        "level": 3,
        "text": "unknown",
        "id": "unknown"
      },
      {
        "level": 3,
        "text": "never",
        "id": "never"
      },
      {
        "level": 3,
        "text": "Function",
        "id": "function"
      },
      {
        "level": 3,
        "text": "Rest Parameters",
        "id": "rest-parameters"
      },
      {
        "level": 3,
        "text": "Rest Arguments",
        "id": "rest-arguments"
      },
      {
        "level": 3,
        "text": "Return type void",
        "id": "return-type-void"
      },
      {
        "level": 4,
        "text": "Push Type Parameters Down",
        "id": "push-type-parameters-down"
      },
      {
        "level": 4,
        "text": "Use Fewer Type Parameters",
        "id": "use-fewer-type-parameters"
      },
      {
        "level": 4,
        "text": "Type Parameters Should Appear Twice",
        "id": "type-parameters-should-appear-twice"
      }
    ],
    "codeBlocks": [
      {
        "language": "text",
        "code": "tsfunction greeter(fn: (a: string) => void) {  fn(\"Hello, World\");} function printToConsole(s: string) {  console.log(s);} greeter(printToConsole);Try"
      },
      {
        "language": "text",
        "code": "function greeter(fn: (a: string) => void) {  fn(\"Hello, World\");} function printToConsole(s: string) {  console.log(s);} greeter(printToConsole);"
      },
      {
        "language": "text",
        "code": "(a: string) => void"
      },
      {
        "language": "text",
        "code": "(string) => void"
      },
      {
        "language": "text",
        "code": "tstype GreetFunction = (a: string) => void;function greeter(fn: GreetFunction) {  // ...}Try"
      },
      {
        "language": "text",
        "code": "type GreetFunction = (a: string) => void;function greeter(fn: GreetFunction) {  // ...}"
      },
      {
        "language": "text",
        "code": "tstype DescribableFunction = {  description: string;  (someArg: number): boolean;};function doSomething(fn: DescribableFunction) {  console.log(fn.description + \" returned \" + fn(6));} function myFunc(someArg: number) {  return someArg > 3;}myFunc.description = \"default description\"; doSomething(myFunc);Try"
      },
      {
        "language": "text",
        "code": "type DescribableFunction = {  description: string;  (someArg: number): boolean;};function doSomething(fn: DescribableFunction) {  console.log(fn.description + \" returned \" + fn(6));} function myFunc(someArg: number) {  return someArg > 3;}myFunc.description = \"default description\"; doSomething(myFunc);"
      },
      {
        "language": "text",
        "code": "tstype SomeConstructor = {  new (s: string): SomeObject;};function fn(ctor: SomeConstructor) {  return new ctor(\"hello\");}Try"
      },
      {
        "language": "text",
        "code": "type SomeConstructor = {  new (s: string): SomeObject;};function fn(ctor: SomeConstructor) {  return new ctor(\"hello\");}"
      },
      {
        "language": "text",
        "code": "tsinterface CallOrConstruct {  (n?: number): string;  new (s: string): Date;} function fn(ctor: CallOrConstruct) {  // Passing an argument of type `number` to `ctor` matches it against  // the first definition in the `CallOrConstruct` interface.  console.log(ctor(10));               (parameter) ctor: CallOrConstruct\n(n?: number) => string   // Similarly, passing an argument of type `string` to `ctor` matches it  // against the second definition in the `CallOrConstruct` interface.  console.log(new ctor(\"10\"));                   (parameter) ctor: CallOrConstruct\nnew (s: string) => Date} fn(Date);Try"
      },
      {
        "language": "text",
        "code": "interface CallOrConstruct {  (n?: number): string;  new (s: string): Date;} function fn(ctor: CallOrConstruct) {  // Passing an argument of type `number` to `ctor` matches it against  // the first definition in the `CallOrConstruct` interface.  console.log(ctor(10));               (parameter) ctor: CallOrConstruct\n(n?: number) => string   // Similarly, passing an argument of type `string` to `ctor` matches it  // against the second definition in the `CallOrConstruct` interface.  console.log(new ctor(\"10\"));                   (parameter) ctor: CallOrConstruct\nnew (s: string) => Date} fn(Date);"
      },
      {
        "language": "text",
        "code": "tsfunction firstElement(arr: any[]) {  return arr[0];}Try"
      },
      {
        "language": "text",
        "code": "function firstElement(arr: any[]) {  return arr[0];}"
      },
      {
        "language": "text",
        "code": "tsfunction firstElement<Type>(arr: Type[]): Type | undefined {  return arr[0];}Try"
      },
      {
        "language": "text",
        "code": "function firstElement<Type>(arr: Type[]): Type | undefined {  return arr[0];}"
      },
      {
        "language": "text",
        "code": "ts// s is of type 'string'const s = firstElement([\"a\", \"b\", \"c\"]);// n is of type 'number'const n = firstElement([1, 2, 3]);// u is of type undefinedconst u = firstElement([]);Try"
      },
      {
        "language": "text",
        "code": "// s is of type 'string'const s = firstElement([\"a\", \"b\", \"c\"]);// n is of type 'number'const n = firstElement([1, 2, 3]);// u is of type undefinedconst u = firstElement([]);"
      },
      {
        "language": "text",
        "code": "tsfunction map<Input, Output>(arr: Input[], func: (arg: Input) => Output): Output[] {  return arr.map(func);} // Parameter 'n' is of type 'string'// 'parsed' is of type 'number[]'const parsed = map([\"1\", \"2\", \"3\"], (n) => parseInt(n));Try"
      },
      {
        "language": "text",
        "code": "function map<Input, Output>(arr: Input[], func: (arg: Input) => Output): Output[] {  return arr.map(func);} // Parameter 'n' is of type 'string'// 'parsed' is of type 'number[]'const parsed = map([\"1\", \"2\", \"3\"], (n) => parseInt(n));"
      },
      {
        "language": "text",
        "code": "tsfunction longest<Type extends { length: number }>(a: Type, b: Type) {  if (a.length >= b.length) {    return a;  } else {    return b;  }} // longerArray is of type 'number[]'const longerArray = longest([1, 2], [1, 2, 3]);// longerString is of type 'alice' | 'bob'const longerString = longest(\"alice\", \"bob\");// Error! Numbers don't have a 'length' propertyconst notOK = longest(10, 100);Argument of type 'number' is not assignable to parameter of type '{ length: number; }'.2345Argument of type 'number' is not assignable to parameter of type '{ length: number; }'.Try"
      },
      {
        "language": "text",
        "code": "function longest<Type extends { length: number }>(a: Type, b: Type) {  if (a.length >= b.length) {    return a;  } else {    return b;  }} // longerArray is of type 'number[]'const longerArray = longest([1, 2], [1, 2, 3]);// longerString is of type 'alice' | 'bob'const longerString = longest(\"alice\", \"bob\");// Error! Numbers don't have a 'length' propertyconst notOK = longest(10, 100);Argument of type 'number' is not assignable to parameter of type '{ length: number; }'.2345Argument of type 'number' is not assignable to parameter of type '{ length: number; }'."
      },
      {
        "language": "text",
        "code": "{ length: number }"
      },
      {
        "language": "text",
        "code": "longerArray"
      },
      {
        "language": "text",
        "code": "longerString"
      },
      {
        "language": "text",
        "code": "longest(10, 100)"
      },
      {
        "language": "text",
        "code": "tsfunction minimumLength<Type extends { length: number }>(  obj: Type,  minimum: number): Type {  if (obj.length >= minimum) {    return obj;  } else {    return { length: minimum };Type '{ length: number; }' is not assignable to type 'Type'.\n  '{ length: number; }' is assignable to the constraint of type 'Type', but 'Type' could be instantiated with a different subtype of constraint '{ length: number; }'.2322Type '{ length: number; }' is not assignable to type 'Type'.\n  '{ length: number; }' is assignable to the constraint of type 'Type', but 'Type' could be instantiated with a different subtype of constraint '{ length: number; }'.  }}Try"
      },
      {
        "language": "text",
        "code": "function minimumLength<Type extends { length: number }>(  obj: Type,  minimum: number): Type {  if (obj.length >= minimum) {    return obj;  } else {    return { length: minimum };Type '{ length: number; }' is not assignable to type 'Type'.\n  '{ length: number; }' is assignable to the constraint of type 'Type', but 'Type' could be instantiated with a different subtype of constraint '{ length: number; }'.2322Type '{ length: number; }' is not assignable to type 'Type'.\n  '{ length: number; }' is assignable to the constraint of type 'Type', but 'Type' could be instantiated with a different subtype of constraint '{ length: number; }'.  }}"
      },
      {
        "language": "text",
        "code": "{ length: number }"
      },
      {
        "language": "text",
        "code": "ts// 'arr' gets value { length: 6 }const arr = minimumLength([1, 2, 3], 6);// and crashes here because arrays have// a 'slice' method, but not the returned object!console.log(arr.slice(0));Try"
      },
      {
        "language": "text",
        "code": "// 'arr' gets value { length: 6 }const arr = minimumLength([1, 2, 3], 6);// and crashes here because arrays have// a 'slice' method, but not the returned object!console.log(arr.slice(0));"
      },
      {
        "language": "text",
        "code": "tsfunction combine<Type>(arr1: Type[], arr2: Type[]): Type[] {  return arr1.concat(arr2);}Try"
      },
      {
        "language": "text",
        "code": "function combine<Type>(arr1: Type[], arr2: Type[]): Type[] {  return arr1.concat(arr2);}"
      },
      {
        "language": "text",
        "code": "tsconst arr = combine([1, 2, 3], [\"hello\"]);Type 'string' is not assignable to type 'number'.2322Type 'string' is not assignable to type 'number'.Try"
      },
      {
        "language": "text",
        "code": "const arr = combine([1, 2, 3], [\"hello\"]);Type 'string' is not assignable to type 'number'.2322Type 'string' is not assignable to type 'number'."
      },
      {
        "language": "text",
        "code": "tsconst arr = combine<string | number>([1, 2, 3], [\"hello\"]);Try"
      },
      {
        "language": "text",
        "code": "const arr = combine<string | number>([1, 2, 3], [\"hello\"]);"
      },
      {
        "language": "text",
        "code": "tsfunction firstElement1<Type>(arr: Type[]) {  return arr[0];} function firstElement2<Type extends any[]>(arr: Type) {  return arr[0];} // a: number (good)const a = firstElement1([1, 2, 3]);// b: any (bad)const b = firstElement2([1, 2, 3]);Try"
      },
      {
        "language": "text",
        "code": "function firstElement1<Type>(arr: Type[]) {  return arr[0];} function firstElement2<Type extends any[]>(arr: Type) {  return arr[0];} // a: number (good)const a = firstElement1([1, 2, 3]);// b: any (bad)const b = firstElement2([1, 2, 3]);"
      },
      {
        "language": "text",
        "code": "firstElement1"
      },
      {
        "language": "text",
        "code": "firstElement2"
      },
      {
        "language": "text",
        "code": "tsfunction filter1<Type>(arr: Type[], func: (arg: Type) => boolean): Type[] {  return arr.filter(func);} function filter2<Type, Func extends (arg: Type) => boolean>(  arr: Type[],  func: Func): Type[] {  return arr.filter(func);}Try"
      },
      {
        "language": "text",
        "code": "function filter1<Type>(arr: Type[], func: (arg: Type) => boolean): Type[] {  return arr.filter(func);} function filter2<Type, Func extends (arg: Type) => boolean>(  arr: Type[],  func: Func): Type[] {  return arr.filter(func);}"
      },
      {
        "language": "text",
        "code": "tsfunction greet<Str extends string>(s: Str) {  console.log(\"Hello, \" + s);} greet(\"world\");Try"
      },
      {
        "language": "text",
        "code": "function greet<Str extends string>(s: Str) {  console.log(\"Hello, \" + s);} greet(\"world\");"
      },
      {
        "language": "text",
        "code": "tsfunction greet(s: string) {  console.log(\"Hello, \" + s);}Try"
      },
      {
        "language": "text",
        "code": "function greet(s: string) {  console.log(\"Hello, \" + s);}"
      },
      {
        "language": "text",
        "code": "tsfunction f(n: number) {  console.log(n.toFixed()); // 0 arguments  console.log(n.toFixed(3)); // 1 argument}Try"
      },
      {
        "language": "text",
        "code": "function f(n: number) {  console.log(n.toFixed()); // 0 arguments  console.log(n.toFixed(3)); // 1 argument}"
      },
      {
        "language": "text",
        "code": "tsfunction f(x?: number) {  // ...}f(); // OKf(10); // OKTry"
      },
      {
        "language": "text",
        "code": "function f(x?: number) {  // ...}f(); // OKf(10); // OK"
      },
      {
        "language": "text",
        "code": "number | undefined"
      },
      {
        "language": "text",
        "code": "tsfunction f(x = 10) {  // ...}Try"
      },
      {
        "language": "text",
        "code": "function f(x = 10) {  // ...}"
      },
      {
        "language": "text",
        "code": "ts// All OKf();f(10);f(undefined);Try"
      },
      {
        "language": "text",
        "code": "// All OKf();f(10);f(undefined);"
      },
      {
        "language": "text",
        "code": "tsfunction myForEach(arr: any[], callback: (arg: any, index?: number) => void) {  for (let i = 0; i < arr.length; i++) {    callback(arr[i], i);  }}Try"
      },
      {
        "language": "text",
        "code": "function myForEach(arr: any[], callback: (arg: any, index?: number) => void) {  for (let i = 0; i < arr.length; i++) {    callback(arr[i], i);  }}"
      },
      {
        "language": "text",
        "code": "tsmyForEach([1, 2, 3], (a) => console.log(a));myForEach([1, 2, 3], (a, i) => console.log(a, i));Try"
      },
      {
        "language": "text",
        "code": "myForEach([1, 2, 3], (a) => console.log(a));myForEach([1, 2, 3], (a, i) => console.log(a, i));"
      },
      {
        "language": "text",
        "code": "tsfunction myForEach(arr: any[], callback: (arg: any, index?: number) => void) {  for (let i = 0; i < arr.length; i++) {    // I don't feel like providing the index today    callback(arr[i]);  }}Try"
      },
      {
        "language": "text",
        "code": "function myForEach(arr: any[], callback: (arg: any, index?: number) => void) {  for (let i = 0; i < arr.length; i++) {    // I don't feel like providing the index today    callback(arr[i]);  }}"
      },
      {
        "language": "text",
        "code": "tsmyForEach([1, 2, 3], (a, i) => {  console.log(i.toFixed());'i' is possibly 'undefined'.18048'i' is possibly 'undefined'.});Try"
      },
      {
        "language": "text",
        "code": "myForEach([1, 2, 3], (a, i) => {  console.log(i.toFixed());'i' is possibly 'undefined'.18048'i' is possibly 'undefined'.});"
      },
      {
        "language": "text",
        "code": "tsfunction makeDate(timestamp: number): Date;function makeDate(m: number, d: number, y: number): Date;function makeDate(mOrTimestamp: number, d?: number, y?: number): Date {  if (d !== undefined && y !== undefined) {    return new Date(y, mOrTimestamp, d);  } else {    return new Date(mOrTimestamp);  }}const d1 = makeDate(12345678);const d2 = makeDate(5, 5, 5);const d3 = makeDate(1, 3);No overload expects 2 arguments, but overloads do exist that expect either 1 or 3 arguments.2575No overload expects 2 arguments, but overloads do exist that expect either 1 or 3 arguments.Try"
      },
      {
        "language": "text",
        "code": "function makeDate(timestamp: number): Date;function makeDate(m: number, d: number, y: number): Date;function makeDate(mOrTimestamp: number, d?: number, y?: number): Date {  if (d !== undefined && y !== undefined) {    return new Date(y, mOrTimestamp, d);  } else {    return new Date(mOrTimestamp);  }}const d1 = makeDate(12345678);const d2 = makeDate(5, 5, 5);const d3 = makeDate(1, 3);No overload expects 2 arguments, but overloads do exist that expect either 1 or 3 arguments.2575No overload expects 2 arguments, but overloads do exist that expect either 1 or 3 arguments."
      },
      {
        "language": "text",
        "code": "tsfunction fn(x: string): void;function fn() {  // ...}// Expected to be able to call with zero argumentsfn();Expected 1 arguments, but got 0.2554Expected 1 arguments, but got 0.Try"
      },
      {
        "language": "text",
        "code": "function fn(x: string): void;function fn() {  // ...}// Expected to be able to call with zero argumentsfn();Expected 1 arguments, but got 0.2554Expected 1 arguments, but got 0."
      },
      {
        "language": "text",
        "code": "tsfunction fn(x: boolean): void;// Argument type isn't rightfunction fn(x: string): void;This overload signature is not compatible with its implementation signature.2394This overload signature is not compatible with its implementation signature.function fn(x: boolean) {}Try"
      },
      {
        "language": "text",
        "code": "function fn(x: boolean): void;// Argument type isn't rightfunction fn(x: string): void;This overload signature is not compatible with its implementation signature.2394This overload signature is not compatible with its implementation signature.function fn(x: boolean) {}"
      },
      {
        "language": "text",
        "code": "tsfunction fn(x: string): string;// Return type isn't rightfunction fn(x: number): boolean;This overload signature is not compatible with its implementation signature.2394This overload signature is not compatible with its implementation signature.function fn(x: string | number) {  return \"oops\";}Try"
      },
      {
        "language": "text",
        "code": "function fn(x: string): string;// Return type isn't rightfunction fn(x: number): boolean;This overload signature is not compatible with its implementation signature.2394This overload signature is not compatible with its implementation signature.function fn(x: string | number) {  return \"oops\";}"
      },
      {
        "language": "text",
        "code": "tsfunction len(s: string): number;function len(arr: any[]): number;function len(x: any) {  return x.length;}Try"
      },
      {
        "language": "text",
        "code": "function len(s: string): number;function len(arr: any[]): number;function len(x: any) {  return x.length;}"
      },
      {
        "language": "text",
        "code": "tslen(\"\"); // OKlen([0]); // OKlen(Math.random() > 0.5 ? \"hello\" : [0]);No overload matches this call.\n  Overload 1 of 2, '(s: string): number', gave the following error.\n    Argument of type 'number[] | \"hello\"' is not assignable to parameter of type 'string'.\n      Type 'number[]' is not assignable to type 'string'.\n  Overload 2 of 2, '(arr: any[]): number', gave the following error.\n    Argument of type 'number[] | \"hello\"' is not assignable to parameter of type 'any[]'.\n      Type 'string' is not assignable to type 'any[]'.2769No overload matches this call.\n  Overload 1 of 2, '(s: string): number', gave the following error.\n    Argument of type 'number[] | \"hello\"' is not assignable to parameter of type 'string'.\n      Type 'number[]' is not assignable to type 'string'.\n  Overload 2 of 2, '(arr: any[]): number', gave the following error.\n    Argument of type 'number[] | \"hello\"' is not assignable to parameter of type 'any[]'.\n      Type 'string' is not assignable to type 'any[]'.Try"
      },
      {
        "language": "text",
        "code": "len(\"\"); // OKlen([0]); // OKlen(Math.random() > 0.5 ? \"hello\" : [0]);No overload matches this call.\n  Overload 1 of 2, '(s: string): number', gave the following error.\n    Argument of type 'number[] | \"hello\"' is not assignable to parameter of type 'string'.\n      Type 'number[]' is not assignable to type 'string'.\n  Overload 2 of 2, '(arr: any[]): number', gave the following error.\n    Argument of type 'number[] | \"hello\"' is not assignable to parameter of type 'any[]'.\n      Type 'string' is not assignable to type 'any[]'.2769No overload matches this call.\n  Overload 1 of 2, '(s: string): number', gave the following error.\n    Argument of type 'number[] | \"hello\"' is not assignable to parameter of type 'string'.\n      Type 'number[]' is not assignable to type 'string'.\n  Overload 2 of 2, '(arr: any[]): number', gave the following error.\n    Argument of type 'number[] | \"hello\"' is not assignable to parameter of type 'any[]'.\n      Type 'string' is not assignable to type 'any[]'."
      },
      {
        "language": "text",
        "code": "tsfunction len(x: any[] | string) {  return x.length;}Try"
      },
      {
        "language": "text",
        "code": "function len(x: any[] | string) {  return x.length;}"
      },
      {
        "language": "text",
        "code": "tsconst user = {  id: 123,   admin: false,  becomeAdmin: function () {    this.admin = true;  },};Try"
      },
      {
        "language": "text",
        "code": "const user = {  id: 123,   admin: false,  becomeAdmin: function () {    this.admin = true;  },};"
      },
      {
        "language": "text",
        "code": "user.becomeAdmin"
      },
      {
        "language": "text",
        "code": "tsinterface DB {  filterUsers(filter: (this: User) => boolean): User[];} const db = getDB();const admins = db.filterUsers(function (this: User) {  return this.admin;});Try"
      },
      {
        "language": "text",
        "code": "interface DB {  filterUsers(filter: (this: User) => boolean): User[];} const db = getDB();const admins = db.filterUsers(function (this: User) {  return this.admin;});"
      },
      {
        "language": "text",
        "code": "tsinterface DB {  filterUsers(filter: (this: User) => boolean): User[];} const db = getDB();const admins = db.filterUsers(() => this.admin);The containing arrow function captures the global value of 'this'.Element implicitly has an 'any' type because type 'typeof globalThis' has no index signature.70417017The containing arrow function captures the global value of 'this'.Element implicitly has an 'any' type because type 'typeof globalThis' has no index signature.Try"
      },
      {
        "language": "text",
        "code": "interface DB {  filterUsers(filter: (this: User) => boolean): User[];} const db = getDB();const admins = db.filterUsers(() => this.admin);The containing arrow function captures the global value of 'this'.Element implicitly has an 'any' type because type 'typeof globalThis' has no index signature.70417017The containing arrow function captures the global value of 'this'.Element implicitly has an 'any' type because type 'typeof globalThis' has no index signature."
      },
      {
        "language": "text",
        "code": "ts// The inferred return type is voidfunction noop() {  return;}Try"
      },
      {
        "language": "text",
        "code": "// The inferred return type is voidfunction noop() {  return;}"
      },
      {
        "language": "text",
        "code": "Object.prototype"
      },
      {
        "language": "text",
        "code": "instanceof Object"
      },
      {
        "language": "text",
        "code": "Object.keys"
      },
      {
        "language": "text",
        "code": "tsfunction f1(a: any) {  a.b(); // OK}function f2(a: unknown) {  a.b();'a' is of type 'unknown'.18046'a' is of type 'unknown'.}Try"
      },
      {
        "language": "text",
        "code": "function f1(a: any) {  a.b(); // OK}function f2(a: unknown) {  a.b();'a' is of type 'unknown'.18046'a' is of type 'unknown'.}"
      },
      {
        "language": "text",
        "code": "tsfunction safeParse(s: string): unknown {  return JSON.parse(s);} // Need to be careful with 'obj'!const obj = safeParse(someRandomString);Try"
      },
      {
        "language": "text",
        "code": "function safeParse(s: string): unknown {  return JSON.parse(s);} // Need to be careful with 'obj'!const obj = safeParse(someRandomString);"
      },
      {
        "language": "text",
        "code": "tsfunction fail(msg: string): never {  throw new Error(msg);}Try"
      },
      {
        "language": "text",
        "code": "function fail(msg: string): never {  throw new Error(msg);}"
      },
      {
        "language": "text",
        "code": "tsfunction fn(x: string | number) {  if (typeof x === \"string\") {    // do something  } else if (typeof x === \"number\") {    // do something else  } else {    x; // has type 'never'!  }}Try"
      },
      {
        "language": "text",
        "code": "function fn(x: string | number) {  if (typeof x === \"string\") {    // do something  } else if (typeof x === \"number\") {    // do something else  } else {    x; // has type 'never'!  }}"
      },
      {
        "language": "text",
        "code": "tsfunction doSomething(f: Function) {  return f(1, 2, 3);}Try"
      },
      {
        "language": "text",
        "code": "function doSomething(f: Function) {  return f(1, 2, 3);}"
      },
      {
        "language": "text",
        "code": "tsfunction multiply(n: number, ...m: number[]) {  return m.map((x) => n * x);}// 'a' gets value [10, 20, 30, 40]const a = multiply(10, 1, 2, 3, 4);Try"
      },
      {
        "language": "text",
        "code": "function multiply(n: number, ...m: number[]) {  return m.map((x) => n * x);}// 'a' gets value [10, 20, 30, 40]const a = multiply(10, 1, 2, 3, 4);"
      },
      {
        "language": "text",
        "code": "tsconst arr1 = [1, 2, 3];const arr2 = [4, 5, 6];arr1.push(...arr2);Try"
      },
      {
        "language": "text",
        "code": "const arr1 = [1, 2, 3];const arr2 = [4, 5, 6];arr1.push(...arr2);"
      },
      {
        "language": "text",
        "code": "ts// Inferred type is number[] -- \"an array with zero or more numbers\",// not specifically two numbersconst args = [8, 5];const angle = Math.atan2(...args);A spread argument must either have a tuple type or be passed to a rest parameter.2556A spread argument must either have a tuple type or be passed to a rest parameter.Try"
      },
      {
        "language": "text",
        "code": "// Inferred type is number[] -- \"an array with zero or more numbers\",// not specifically two numbersconst args = [8, 5];const angle = Math.atan2(...args);A spread argument must either have a tuple type or be passed to a rest parameter.2556A spread argument must either have a tuple type or be passed to a rest parameter."
      },
      {
        "language": "text",
        "code": "ts// Inferred as 2-length tupleconst args = [8, 5] as const;// OKconst angle = Math.atan2(...args);Try"
      },
      {
        "language": "text",
        "code": "// Inferred as 2-length tupleconst args = [8, 5] as const;// OKconst angle = Math.atan2(...args);"
      },
      {
        "language": "text",
        "code": "downlevelIteration"
      },
      {
        "language": "text",
        "code": "jsfunction sum({ a, b, c }) {  console.log(a + b + c);}sum({ a: 10, b: 3, c: 9 });"
      },
      {
        "language": "text",
        "code": "function sum({ a, b, c }) {  console.log(a + b + c);}sum({ a: 10, b: 3, c: 9 });"
      },
      {
        "language": "text",
        "code": "tsfunction sum({ a, b, c }: { a: number; b: number; c: number }) {  console.log(a + b + c);}Try"
      },
      {
        "language": "text",
        "code": "function sum({ a, b, c }: { a: number; b: number; c: number }) {  console.log(a + b + c);}"
      },
      {
        "language": "text",
        "code": "ts// Same as prior exampletype ABC = { a: number; b: number; c: number };function sum({ a, b, c }: ABC) {  console.log(a + b + c);}Try"
      },
      {
        "language": "text",
        "code": "// Same as prior exampletype ABC = { a: number; b: number; c: number };function sum({ a, b, c }: ABC) {  console.log(a + b + c);}"
      },
      {
        "language": "text",
        "code": "type voidFunc = () => void"
      },
      {
        "language": "text",
        "code": "tstype voidFunc = () => void; const f1: voidFunc = () => {  return true;}; const f2: voidFunc = () => true; const f3: voidFunc = function () {  return true;};Try"
      },
      {
        "language": "text",
        "code": "type voidFunc = () => void; const f1: voidFunc = () => {  return true;}; const f2: voidFunc = () => true; const f3: voidFunc = function () {  return true;};"
      },
      {
        "language": "text",
        "code": "tsconst v1 = f1(); const v2 = f2(); const v3 = f3();Try"
      },
      {
        "language": "text",
        "code": "const v1 = f1(); const v2 = f2(); const v3 = f3();"
      },
      {
        "language": "text",
        "code": "Array.prototype.push"
      },
      {
        "language": "text",
        "code": "Array.prototype.forEach"
      },
      {
        "language": "text",
        "code": "tsconst src = [1, 2, 3];const dst = [0]; src.forEach((el) => dst.push(el));Try"
      },
      {
        "language": "text",
        "code": "const src = [1, 2, 3];const dst = [0]; src.forEach((el) => dst.push(el));"
      },
      {
        "language": "text",
        "code": "tsfunction f2(): void {  // @ts-expect-error  return true;} const f3 = function (): void {  // @ts-expect-error  return true;};Try"
      },
      {
        "language": "text",
        "code": "function f2(): void {  // @ts-expect-error  return true;} const f3 = function (): void {  // @ts-expect-error  return true;};"
      }
    ],
    "links": [
      {
        "text": "Try",
        "href": "https://www.typescriptlang.org/play/#code/GYVwdgxgLglg9mABAcwE4FN1XagFMMALkVwENiBnKVGMZASkQF4A+RANzhgBNGBvALAAoRIgK4ARAAl0AG1lwANIgDqcVLO4T6AbmEBfYcNCRYCRAAcaYKABU4AYQQU4s9LgqVqtBokEjECGdXdAA6BWQPXQMjITRMbDwrWjtHYLddIA"
      },
      {
        "text": "Try",
        "href": "https://www.typescriptlang.org/play/#code/C4TwDgpgBA4gThCwBiBXAdgY2ASwPbpQC8UAFAIYBcUAzsHDugOYCUxAfFAG544AmAbgCwAKABmGbPkJMESCHFJj01eIhSTcBNgG9RUKAHpDUAHTnRAXyA"
      },
      {
        "text": "Try",
        "href": "https://www.typescriptlang.org/play/#code/C4TwDgpgBAIhDOBjATgSwEYEN0BsIDEBXAO0WFQHtioBeKAbwFgAoKKAEwRVTHKoC4o8YGmIBzANws2ACngUAthACCyMYOKEF6CMgCUg9BQp5MxKcwC+FgGYkylauwoBlRRGAALVOJk3ignBIaFi4BPZ8xHoM0lCIVPJ4AHQ4FGJ+xEmcwTyRUADUUABEUMgehMjEEOzFBVD+MgBsenoWliwsdqR5CiBEpHLuqupQmtq60UyspeWVQkNqUAB8UADMbSy9-YhZXGi8jrTFnDaYhDjAHHu5jkUWLM5uSl4+6Vv2rUA"
      },
      {
        "text": "Try",
        "href": "https://www.typescriptlang.org/play/#code/C4TwDgpgBAyg9gWwgeQEYCsIGNhQLxQCGAdiANwCwAUAPQ1QC0TWArsEw9aJLIhAMJxiAZ2AAnFjjhj8UAN7UoUYhADuUABTCAXFFFiAlsQDmASl3wkaTDkpUAvnYBmLYjgNCoT4hqliLfIIi4pLA0qbyilBiEMAsYsTKalB+GgBEABYQADbZcGmmdvZAA"
      },
      {
        "text": "Try",
        "href": "https://www.typescriptlang.org/play/#code/JYOwLgpgTgZghgYwgAgMJwDYYPJVQexAGcwoBXBMZAbwFgAoZZAChAH4AuZEMgWwCNoASi4kooAOYBuBkxAQA7iyKjSkkcgAicSDPoBfBgxhkQlYIWQwQzSvihd0WXAWKkKYITVnIA9L+QABTgiIklkOBAIqAk+CHBkfBhkMABPAAcUAAMeAWgslPxkLLsoAt4dBAALCCJkYCo4CThQEh9-FJqrYCgSZAATCBhQBoso0E7spxw8QjEPAtBIWEQIADofBDn8DHWMfAlbMHtmAEYABiEhPSZbu-uOgD02I0Y-AIBlYF5gDDgoDCpAA0yHSITCIAkESi-1ivHiVCSKQy2TEkgKx2KpXKlRqdQa7QCTRabkmyCIEC2IH6AyGIzAY3qUTAXSy0xcc3clEW4Gg8CQGzeVKIOz2B1YimQpWYACILjKrjd7srlU8XgZXtZmNpINcgA"
      },
      {
        "text": "Try",
        "href": "https://www.typescriptlang.org/play/#code/GYVwdgxgLglg9mABMGAnAzlAogGwKYC2eYUAFAIaqoBci5YAngNoC6AlIgN4CwAUIolR4oIVEkqomABhYBuPgF8gA"
      },
      {
        "text": "Try",
        "href": "https://www.typescriptlang.org/play/#code/GYVwdgxgLglg9mABMGAnAzlAogGwKYC2eYUAPACoCeADngHwAUAhqqgFyJW0DaAugJQcueRAB9E4ACZ4UYPJMQBvALAAoRIlR4oIVEhapuABl4BuNQF8gA"
      },
      {
        "text": "Try",
        "href": "https://www.typescriptlang.org/play/#code/CYUwxgNghgTiAEAzArgOzAFwJYHtVKxgGcMBRCEAWxFQwB4AVATwAcQA+AClhgC55mbANoBdAJT9BCAD7w0oRFlQhgAbgCwAKAD02+AFpDYZBkP6tu+EXhZrORPAysEAchIwlAcxdaweElbwALwExGQU1LScQgBEUDEANPAxAEaJyWAx4ho6evi28PaOzvAuqMiUKSAwPpp+qAH4IYph5FQ0GNEAjEkATEkAzNkWesg2dg5ObHKoCkoqvv4YcsGhJG2RnaJiqkA"
      },
      {
        "text": "Try",
        "href": "https://www.typescriptlang.org/play/#code/PTAEAcCcFMBdYJbUgWgQcwHYHsYFgAoAMwFdMBjRbTUAWwENwAeASU3BNgBpQB5TjrAB8ACnqRIALlBtBAbQC6PUhWljI6abM4BKUAF4hfAbun9Y8haADehUKBiwSkGuMgA6BuBEryOgNyEAL6EhCCgAAri9LRwyKAA5JgJoAgAzqDYRKCwAJ7g0IlpsJAImOgJYWAJ4OJp0AAmKemZ2XkFiZgktABGyIqVBOTUxRB1jQZ0jCJyAEQAjLM8swBMS6CzAMyzSqAimHqGY5D1bLD7OgFAA"
      },
      {
        "text": "Try",
        "href": "https://www.typescriptlang.org/play/#code/PTAEAEFMCdoe2gZwFygEwGYAsBWdG00BYAKADMBXAOwGMAXASzitABtmBzSROgHgBUAngAdIoSAA86kKgBNEoAN5sZHOgAtUVCgFsARjFABfAHwAKAIaohogDSg91kZACUS0qFAMyoSwDpWVQ1QEwBeBwCg9TdFD09QaEg6CmgWCwBuOKNxVkQxWJJ4hKSUlj1MwuNSI1JSEDZOGABBWAtBLwU4HzpnUABybX0YAG0AXT7SGmYeBqouaBboNtBw9jnuOjNhgEZ7NFH7Hb37DFGXCvq1+YBlOmgGOY7QLtAe0X6LVgYaSD7QAB9+no4HoJiQplQZlcYLd7o9Vo0eGYAESfb6QZH2ZHAvTI851MAAUVgCAAhKAAHK6AxIUCyZh9OigdQWABuYgs-UCcw0f2E8FE0B6k2mTKocDoAHkANIrWZcJHbAAM9mVSvOQA"
      },
      {
        "text": "Try",
        "href": "https://www.typescriptlang.org/play/#code/PTAEAEFMCdoe2gZwFygEwGY1oLACgAzAVwDsBjAFwEs4TQBbKkq+o+gGUhIHMKALADwAVAJ4AHSKEgAPClwAmiUAG9QAGy68+qEmwBGMUAF8AfAAp8oUHD0ArVKIkAaSwyYs2O-THwBKB+KSyq5UBKBmNrYAdBo8-KAmALxuzKz0viquVtCQFETQdJEA3K5GUmqIQVmgOXkFKuqa-KiMqWzGJXhWRvhGQA"
      },
      {
        "text": "Try",
        "href": "https://www.typescriptlang.org/play/#code/CYUwxgNghgTiAEAzArgOzAFwJYHtXwFstUsDkCAZEVAcwwAsAeAFQE8AHBEADw2uADO8AN7wI1OvQBc8VOQBGIGPAC+APgAUAWABQ8eDnkArGW04AaXfqIkyBGXIKKYugJSmOIANy6A9L-gAWmCwZAxgwL8AgHJYGGj4GhAMIQA3KAhkBFFxWgYZADZVXTA8AQx4OPgAXkJiUnIqPPoNAG0ARnN4ACYugGYAXS6C1x8df0rUYHgwGCgBehAhRbh4RTAoZAEEOKhWZahUkCjK+GiBCCwwEASCZPocYC75MNkcCoYEOAxkGFQQaaGIzgDAAQhKZRw4gAdBAcDQNHFoRcriANAAGVyjIA"
      },
      {
        "text": "Try",
        "href": "https://www.typescriptlang.org/play/#code/GYVwdgxgLglg9mABBOBbARjMBTAPAFQE8AHbAPgAoBDAJxoEYAuRI0gbQF0AaRWmgJmatsnAJRCSIjogDeAWABQiRDWxQQNJH3oA6FJCpRqdfqIDcigL5A"
      },
      {
        "text": "Try",
        "href": "https://www.typescriptlang.org/play/#code/PTAEAEFMCdoe2gZwFygEwGY1oLACgATSAYwBsBDaSUAMwFcA7YgFwEs4HRi4BbAI1YNIAHgAqATwAOkAHwAKStACMqCdIDaAXQA0oRWlVTIWgJSGNmgNz4QoALQPidZg7v5uDRMz2xQAXi5eASE5dSVdNF0MHVB1ACIAC0hSUjg4zRNLIA"
      },
      {
        "text": "Try",
        "href": "https://www.typescriptlang.org/play/#code/CYUwxgNghgTiAEAzArgOzAFwJYHtXzBwFsAjLVEAHgBUBPABxAD4AKWGARgC547GBtALoAaeOwBMPPiCEBKKQxmCA3AFgAUAHpN8ALT6wyDPt0bCqAM4YxMGPAC8BYmQqUrMcgHN4AH3ipkUhAYVn4OUXFRAGYReH4AIgALEAgIHHjBWWUgA"
      },
      {
        "text": "Try",
        "href": "https://www.typescriptlang.org/play/#code/GYVwdgxgLglg9mABMGAnAzlAogGwKYC2eYUAjADwAqAngA54B8AFAIaqoBciN9A2gLoBKRAG8AsAChEiVHighUSNql4AGfgG5JAX0mTQkWAmRpMuQsSgAmKnTyI8ADyjEAJukQsw1Ac2VcePGFxKRk5BSV2NU0dPQkAenjPLjAQAgAjPFREJgBzODhXQUkIBExPRABeEwxsfCISUiZeUgAaRCt2gGYhLQSk9K4vahz0liKSsqhEdKqas3rLK2a2ju7eoA"
      },
      {
        "text": "Try",
        "href": "https://www.typescriptlang.org/play/#code/GYVwdgxgLglg9mABMGAbKBTATgRgDwAqAngA4YB8AFAIZZYBcixZA2gLoA0y4EjNWAc0bMMASkQBecogBGcOKgzUwo4aQztEAbwCwAKESIsGKCCxJaWAHQp02SqEiiA3PoC++-Y+jwktzFgATITqXABiPIgYAB6YYAAmAM6I-EJM6uJSsvKKylT6hpZqrJwF3JCMEZD6qukl2mXGpuaIljZoAQ48Lu5AA"
      },
      {
        "text": "Try",
        "href": "https://www.typescriptlang.org/play/#code/GYVwdgxgLglg9mABAcwE4FN1QDwGUqqLoAeU6YAJgM6JUExjIB8AFFQFyL6oCUiA3gFgAUIkQQEVOABt0AOmlxkLAEQAJdNMUAaRCsQBqWjwDcIgL4iRaTFFUB3OKmkUVpoA"
      },
      {
        "text": "Try",
        "href": "https://www.typescriptlang.org/play/#code/GYVwdgxgLglg9mABAcwE4FN1QBQGcBciuUqMYyAlIgN4CwAUIohArnADboB07cy2AIgAS6drwA0iAYgDURCgG4GAXyA"
      },
      {
        "text": "Try",
        "href": "https://www.typescriptlang.org/play/#code/GYVwdgxgLglg9mABMAFGAXIsIC2AjAUwCcBKRAbwFgAoRRCBAZzgBsCA6FuAczXajgAxGAA8CAExQkSAbkQB6eYgAMiAIZFuuAmCiMadBmGZtOPPgOFjJAZmlzFiAIzrN23TQC+QA"
      },
      {
        "text": "Try",
        "href": "https://www.typescriptlang.org/play/#code/GYVwdgxgLglg9mABMAFADwPwC5FhAWwCMBTAJwEpEBvAWAChFEB6JxAOg-oF97VyBuZqwDyAaV4oAjAAYBQxGKA"
      },
      {
        "text": "Try",
        "href": "https://www.typescriptlang.org/play/#code/GYVwdgxgLglg9mABMAFAD0QXkQRgAwCUiA3gLABQiiA9NYgHSMUC+QA"
      },
      {
        "text": "Try",
        "href": "https://www.typescriptlang.org/play/#code/CYUwxgNghgTiAEAzArgOzAFwJYHtVIAoAPAfgC55VkBbAIxBgEoKA3HLYAbgFgAoAen7wAtKLDIMo4X0HwAghAjwA8gGk+iAox69NARgAM2jQTShEWVCGDagA"
      },
      {
        "text": "Try",
        "href": "https://www.typescriptlang.org/play/#code/GYVwdgxgLglg9mABAWwJ4DE4CcCiBDCACwAo8ssAuRPMVAbQF0AaRCPAG3YCMCBrK0lgDmVGqhYwwAEwCmADwD8VMCGRcZWAJSIAvAD5EANzgwp2gN4BYAFCJEwbImLsZURDF2IADAG53iAB5qcgA6FzAhKEI-GABqWIsbOzs2Th4IXkEsOhhmd00fJMQAXxtioA"
      },
      {
        "text": "Try",
        "href": "https://www.typescriptlang.org/play/#code/PTAEAEFMCdoe2gZwFygEwFYDMbQEYAOABgBYCBYAKABNIBjAGwENpJQAzAVwDs6AXAJZxuoALYBPAGIIAokzoALABRVQoFtFRNu4gNoBdADSrQdJgwYAjeQGtUSlgHMtOw6AHdaADwD8qbpyiljAAlKAAvAB8oABucALUVCGocQkA3FQgoAC0uXScfLnZVBLS0HKKSrp4bmhuWEagDmFRpsKIcAyQAHQMcI7NIRmUpbLyytW19Y0ObgIt0XTtnT19A0xzIUNAA"
      },
      {
        "text": "Try",
        "href": "https://www.typescriptlang.org/play/#code/PTAEAEFMCdoe2gZwFygEwFYDMbQEYAOABgBYCBYAKADMBXAOwGMAXASzntAFsBPAMQQBRAIaMAFgAphsVMPo8A2gF0ANKEbCANpoBGogNaop0AOaz5a1vQAmkAB4B+VPVpcdMAJSgAvAD5QAG5wrNZeAN5UoKDUCKASmpDMoKw+oEQA3MmgADyg0tAAdAn0JsximawA1JXhkVGgIKAAkqDWHADkSdSQkJqgmqz6kKAADvABIVYmoGXDVrZ2M3DWwjx1URraeoz6xtAKrEoe6XUAvlSnQA"
      },
      {
        "text": "Try",
        "href": "https://www.typescriptlang.org/play/#code/PTAEAEFMCdoe2gZwFygEwFYDMbQEYAOABgBYCBYAKABNIBjAGwENpJQAzAVwDs6AXAJZxuoALYBPAGIIAokzoALABRVQoFtFRNu4gNoBdADSrQdJgwYAjeQGtUSlgHMtOw6AHdaADwD8qbpyiljAAlKAAvAB8oABucALUVCGocQkA3FQgoAC0uXScfLnZVBLS0HKKSrp4bmhuWEagDm4CYVGgAN4mdMKIcAyQAHQMcI5KAoN8cJICXpDUSiEhGZQAvstAA"
      },
      {
        "text": "Try",
        "href": "https://www.typescriptlang.org/play/#code/PTAEAEFMCdoe2gZwFygEwFYDsGCwAoAMwFcA7AYwBcBLOU0AWwEMBrSAEScsgAoaHIiSkwYAHVKWIMARjACUqTtwDcBEhRp1GrDl14MJU2dAA0oACaGZMMwE8rxhaCWRVRMlVr1mbFzwYA8tAAKtQCQiLioJLWphYA-A42oLaJ0UbyinqgAN4EoKDUhKA85qAAhAC8laBk5pCE1KSQZQBkrSkV1bWk9Y3N5nK5+QWg0JCUxND0zQDuzno8tmaBIWGCwmJmg24FAL6gkAA2iJDD+KNjE1MzkPN+q6Hhm6Jyu6B7BJ-45HRCFgBGUA1Hy6bg8AFoADMABYMAA2LAADjeBF+pH+5jQwO0vkWGDMBNAGFRPz+lAsUJxoL8ALMULeQA"
      },
      {
        "text": "Try",
        "href": "https://www.typescriptlang.org/play/#code/PTAEAEFMCdoe2gZwFygEwFYMBYCwAoAMwFcA7AYwBcBLOU0Q0gCgA9VFLprSBzASlQA3ONQAmAbgIkKNOg2Z9QAbwKhQIUADptBAL4ENAURYAHSFUijQlOKABGkUAEM7AG0c3Q5J69egA7tSUABagAF4wtk7QPMQAtpCklIhSCuJAA"
      },
      {
        "text": "Try",
        "href": "https://www.typescriptlang.org/play/#code/PTAEAEFMCdoe2gZwFygEwGYCcAWAsAFABmArgHYDGALgJZxmhFkAUAHqgEZxwA2kAhmQCUqAG5waAEwDchEKACC0AOYkAtpDJVQVAJ4AHSKBqIyAcm3QaygBZVCpSrXqMW7UIipWyykaHFSssTk1HQMTGyc3HyCQqAA3gC+QA"
      },
      {
        "text": "Try",
        "href": "https://www.typescriptlang.org/play/#code/PTAEAEFMCdoe2gZwFygEwGYCcAWAsAFABmArgHYDGALgJZxmhFkAUAHqoldDWQOYCUHLj14BuQiFAAlSFRLQGVAJ4AHSKBqIyAciqhuvABZVCpSrXqMW7UGRIBbAEYxBoR3DgAbSAEMy44nJqOgYmNiFuPlAAH1sHZ2h+UABvQlB9WXkGACIPFURsgIBfIA"
      },
      {
        "text": "Try",
        "href": "https://www.typescriptlang.org/play/#code/GYVwdgxgLglg9mABAGwKZgBQGcBcitQBOMYA5gJR5ggC2ARqoQNwCwAUKJLAiuhgIaFCefmACeAbQC6lRNXqNWHcNHhI0mAB4jx5RAG92iRIVRQQhJJoB0G0lAAWSgL5A"
      },
      {
        "text": "Try",
        "href": "https://www.typescriptlang.org/play/#code/PTAEAEFMCdoe2gZwFygEwHYBsBOAsAFAAmkAxgDYCG0koAZgK4B2pALgJZxOjmRMAUKUIlbR2TAOYBKVEwYBbAEYwA3IRIVqtRiw5cefftWipKTAJ4BtALozQcpasIhQAWnekGrd68K8BAEQBUiqgLgDyANJ+hpYADLahEdEE-vwAspSsABYAdNBmRHDy-FKgAHygcbkArKAA-KAB2ZDk5HABoKjxiUA"
      },
      {
        "text": "Try",
        "href": "https://www.typescriptlang.org/play/#code/GYVwdgxgLglg9mABAGwKZgBQA8BciCGYAngNoC6iAPogM5QBOMYA5gJSIDeAsAFCKL1UUEPSRYAdGhZQAFgG5eAXyA"
      },
      {
        "text": "Try",
        "href": "https://www.typescriptlang.org/play/#code/MYewdgzgLgBArhApgJxgXhgbwLACgYwCWAJgFwwCMATAMwA0eeBAhsQLaFjkBmzANkgb4YAI0Sg2iAILtOPOGGBRC4GAAoAlFiYEYUABaEIAOlYcw6PcjiIA3DoC+Qh7aA"
      },
      {
        "text": "Try",
        "href": "https://www.typescriptlang.org/play/#code/JYOwLgpgTgZghgYwgAgKoGdrIN4FgBQyywAJgFzIgCuAtgEbQDcBRcJNoFdA9twDYQ4IZvgC+BEhAR84UFAm4h0YZAHMIYACIAhCgAoAlMgC8APmQ6RAeivIAtA4RUwDuwVCRYiFDpwtkMMB8nhjQ6HqBwdD6YAAWwOgUoVBGZsg8-IIgBkmYUADaALoi4vgECkoqJHQmaho6hiIVyshsHEq11QB0kSF54TBUIAhgwIrIenEJudBGeITIcmBUUCDIU+hdbaAlBoxAA"
      },
      {
        "text": "Try",
        "href": "https://www.typescriptlang.org/play/#code/PTAEAEFMCdoe2gZwFygOwAYAsBGdGc0BYAKAEsA7AFxgDMBDAY0lAFVEZQBvU0UMgCaoKAVwC2AIxgBuXqHoCxlVBLhwANpHoVZJAL6kBkRuvrQWjOBURVQAc0hUAIgCFUACgCUoALwA+UFddEFAAWnDGESpw0NJKGmgGZkCXbjlaMnUE9hhEdwysmA8qAAsyFDYOaG9-UFUNLQpPVBzoAG0AXV0DElJLa1sBCV97R1cvXX6beUVKRBGhgDoC7Kq8r18A0vLFhSUm6SA"
      },
      {
        "text": "Try",
        "href": "https://www.typescriptlang.org/play/#code/PTAEBUAsFNQSwHYDNoCdXQCagwFwK6oKi4CeADrHAM6gBuA9nJgLABQS+CAxrnA8QQMG5ABQBKUAG92oHNAJEA3OwC+QA"
      },
      {
        "text": "Try",
        "href": "https://www.typescriptlang.org/play/#code/PTAEAEFMCdoe2gZwFygEwFYDsBGUOAOABgBYA2AWACgAzAVwDsBjAFwEs4HQacAKAQ1T8GATwCUoAN7VQofgDoARrzEBuUCFAB5ANLUAvtXrN2nbmgGpGAawZwA7gwnSqshcrUGgA"
      },
      {
        "text": "Try",
        "href": "https://www.typescriptlang.org/play/#code/CYUwxgNghgTiAEYD2A7AzgF3mpBbEASlCsHgMoYwCWKA5gFzaU20DcAsAFAD038AtILABXDIP5cAZsJRgMVVNiiSQABVhoQACjSNM1OgEpGMgNYokAdxTwA3l3jw4GYTBsApMgHkAcgDoABw1tNEMOTgBfLi5eeB8QEGB4DCR4ACMEMFgQaQh4SyoMAAt4AHIkNIArUoBCLmR0LArK+ABeJRV1GE0dPEJiUlwKA1owoA"
      },
      {
        "text": "Try",
        "href": "https://www.typescriptlang.org/play/#code/GYVwdgxgLglg9mABMAhjANgCgLYGcDmAXIrlAE4xj4CUxYApgG71mIDeAsAFCKJQAWZOAHdEDUQFEyQsjgLUA3NwC+QA"
      },
      {
        "text": "Try",
        "href": "https://www.typescriptlang.org/play/#code/GYVwdgxgLglg9mABMMAKAHgLkQZygJxjAHNEAfRMEAWwCMBTfASkQG8BYAKEURmEVRQAngAd6cfukQBeWYgBEeQiXksO3HogD0WxABM4uONXpQAFkWJceAX0T0ANjnq9+g0eMky58qnUaqbNaaOvqGOMamFiT2TvTBdo7OQRo86ADc2rpmAIY4iMJiiADkYPQAbozFAIQJXDZAA"
      },
      {
        "text": "Try",
        "href": "https://www.typescriptlang.org/play/#code/GYVwdgxgLglg9mABAEzgZTgWwKZQBYxgDmAFMAFyIBi408YAlIgN4CwAUIogE64jdJgJAIwAaRACZxAZgYBuDgF8gA"
      },
      {
        "text": "Rest Parameters",
        "href": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Functions/rest_parameters"
      },
      {
        "text": "Spread Syntax",
        "href": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/Spread_syntax"
      },
      {
        "text": "Try",
        "href": "https://www.typescriptlang.org/play/#code/GYVwdgxgLglg9mABAWxAG1gBzQTwBRgBciYIyARgKYBOANIgHRPLGkU0DaAugJSIDeAWABQiRNUpQQ1JMgbIAhpjx4AHnwC8APhKIAVInUBuEQF8RAeguIA5ApuIA5pIDOiAG4K0ISog4BGAAZ6ACZgxABmcIAWQK4RCAQXKEQFRA0UdCxcPCD6f1D6CPponiMgA"
      },
      {
        "text": "Try",
        "href": "https://www.typescriptlang.org/play/#code/MYewdgzgLgBAhgJwQRhgXhgbWQGhgJjwGYBdAbgFgAoUSWRBfdLAFjwFY8A2c6h5AHQAHAK4QAFgAoBMhvgCUZIA"
      },
      {
        "text": "Try",
        "href": "https://www.typescriptlang.org/play/#code/PTAEAEFMCdoe2gZwFygEwFYMDYCwAoEUASQDsAzGaSAE1ABcBPAB0lAEtFRSBXAWwBGMANoBdUAFoJoAEQBDUqDmw5jUAHd29ABagAXjDigEoPgja9BMRDIA0BIqTj1QiVgGN25du7kAbPzV6dSNLISQCdzhSRBdlAHMuAF5QYQAOW1AMUQBuSOjYpVJ4vzYUgFk5HQA6KoU0AApq5oTEAEocoA"
      },
      {
        "text": "Try",
        "href": "https://www.typescriptlang.org/play/#code/PTAEEkDsDMFMCd6wCagIYGdQCYC0AbWSAcwBcALUUgVwAdCBYAKAGMB7SDU9eYrAXlABtABwAaUAFYAuuiztOpANzMQoAPIBpZgq7oShUIICyaCgDozaSNgAU5h2l4YAlEqA"
      },
      {
        "text": "downlevelIteration",
        "href": "/tsconfig#downlevelIteration"
      },
      {
        "text": "Destructuring Assignment",
        "href": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/Destructuring_assignment"
      },
      {
        "text": "Try",
        "href": "https://www.typescriptlang.org/play/#code/GYVwdgxgLglg9mABAZxAWwBQG9EEMA0iARoRIgL4BciOu1Y6RApgE4Dcx9jrHEXazFhQCUNALAAoRIggJkcADZMAdArgBzDLkQBqYrpnC2k8kA"
      },
      {
        "text": "Try",
        "href": "https://www.typescriptlang.org/play/#code/PTAEGUEMFsFNUgZ1ABwE4EsD2bSwB4woA2sAsAFAAuAnivAIIBCAwqALygDeCAXKADsArtABGsNAG5Qo-sLETpAYzkjxuAL6TKAMyEClVbANCIRACh6QANDNtLQG-sxYBKbpVCglWAYiykAHTEWADm5pCgANQy0d6u2hQaQA"
      },
      {
        "text": "Try",
        "href": "https://www.typescriptlang.org/play/#code/C4TwDgpgBAbg9gSwCYDECuA7AxlAvFACgEo8A+WRJAbgFgAoerODAZ2CgDMBGALguXTY8hErnIBvelCgAnCMDQyMUYDLQRadAL6bGzNpwBMfeAMw58xMirUb6e1uw4BmE5UEXO54AmYioknTScgpKNuqaOkA"
      },
      {
        "text": "Try",
        "href": "https://www.typescriptlang.org/play/#code/C4TwDgpgBAbg9gSwCYDECuA7AxlAvFACgEo8A+WRJAbgFgAoerODAZ2CgDMBGALguXTY8hErnIBvelCgAnCMDQyMUYDLQRadAL6bGzNpwBMfeAMw58xMirUb6e1uw4BmE5UEXO54AmYioknTScgpKNuqaOvQA9NFQALSJWGjAifEOBjBcwtzEunRMjrCGOYZ59gX67DDOOc55QA"
      },
      {
        "text": "Try",
        "href": "https://www.typescriptlang.org/play/#code/MYewdgzgLgBBBOwYF4YG0CMAaGAmHAzALoDcAsAFCiSwAm0K6ADKZZQsAHQBmI8AogENgACwAUYgKYAbAJQoAfDHpROABwCuEcTNmySQA"
      },
      {
        "text": "Try",
        "href": "https://www.typescriptlang.org/play/#code/GYVwdgxgLglg9mABMATACgJQC5EDc4wAmiA3gLABQiiA9DYgAJQDOAtAKYAeADu9BwCcBcAZWoD2UEAKRQBIdgG5KAX0qUICZlGQBmRAF5k4aPCSYc+IqTG16TNl1792QkbYlSZiOQuUUVRSA"
      },
      {
        "text": "FAQ - “Why are functions returning non-void assignable to function returning void?”",
        "href": "https://github.com/Microsoft/TypeScript/wiki/FAQ#why-are-functions-returning-non-void-assignable-to-function-returning-void"
      }
    ],
    "meta": {
      "description": "Learn about how Functions work in TypeScript.",
      "keywords": ""
    },
    "summary": "Functions are the basic building block of any application, whether theyre local functions, imported from another module, or methods on a class",
    "tags": [
      "react",
      "angular",
      "javascript",
      "typescript",
      "css",
      "html",
      "node",
      "vite",
      "parameters",
      "type"
    ],
    "id": "typescript-documentation-functionshtml-part-1",
    "quality": 100
  },
  {
    "title": "TypeScript: Documentation",
    "url": "https://www.typescriptlang.org/docs/handbook/2/generics.html",
    "category": "typescript",
    "content": "A major part of software engineering is building components that not only have well-defined and consistent APIs, but are also reusable. Components that are capable of working on the data of today as well as the data of tomorrow will give you the most flexible capabilities for building up large software systems. In languages like C# and Java, one of the main tools in the toolbox for creating reusable components is generics, that is, being able to create a component that can work over a variety of types rather than a single one. This allows users to consume these components and use their own types. Hello World of Generics To start off, lets do the hello world of generics: the identity function. The identity function is a function that will return back whatever is passed in. You can think of this in a similar way to the echo command. Without generics, we would either have to give the identity function a specific type: tsfunction identity(arg: number): number { return arg;}Try Or, we could describe the identity function using the any type: tsfunction identity(arg: any): any { return arg;}Try While using any is certainly generic in that it will cause the function to accept any and all types for the type of arg, we actually are losing the information about what that type was when the function returns. If we passed in a number, the only information we have is that any type could be returned. Instead, we need a way of capturing the type of the argument in such a way that we can also use it to denote what is being returned. Here, we will use a type variable, a special kind of variable that works on types rather than values. tsfunction identityType(arg: Type): Type { return arg;}Try Weve now added a type variable Type to the identity function. This Type allows us to capture the type the user provides (e.g. number), so that we can use that information later. Here, we use Type again as the return type. On inspection, we can now see the same type is used for the argument and the return type. This allows us to traffic that type information in one side of the function and out the other. We say that this version of the identity function is generic, as it works over a range of types. Unlike using any, its also just as precise (i.e., it doesnt lose any information) as the first identity function that used numbers for the argument and return type. Once weve written the generic identity function, we can call it in one of two ways. The first way is to pass all of the arguments, including the type argument, to the function: tslet output = identitystring(\"myString\"); let output: stringTry Here we explicitly set Type to be string as one of the arguments to the function call, denoted using the  around the arguments rather than (). The second way is also perhaps the most common. Here we use type argument inference  that is, we want the compiler to set the value of Type for us automatically based on the type of the argument we pass in: tslet output = identity(\"myString\"); let output: stringTry Notice that we didnt have to explicitly pass the type in the angle brackets (); the compiler just looked at the value \"myString\", and set Type to its type. While type argument inference can be a helpful tool to keep code shorter and more readable, you may need to explicitly pass in the type arguments as we did in the previous example when the compiler fails to infer the type, as may happen in more complex examples. Working with Generic Type Variables When you begin to use generics, youll notice that when you create generic functions like identity, the compiler will enforce that you use any generically typed parameters in the body of the function correctly. That is, that you actually treat these parameters as if they could be any and all types. Lets take our identity function from earlier: tsfunction identityType(arg: Type): Type { return arg;}Try What if we want to also log the length of the argument arg to the console with each call? We might be tempted to write this: tsfunction loggingIdentityType(arg: Type): Type { console.log(arg.length);Property 'length' does not exist on type 'Type'.2339Property 'length' does not exist on type 'Type'. return arg;}Try When we do, the compiler will give us an error that were using the .length member of arg, but nowhere have we said that arg has this member. Remember, we said earlier that these type variables stand in for any and all types, so someone using this function could have passed in a number instead, which does not have a .length member. Lets say that weve actually intended this function to work on arrays of Type rather than Type directly. Since were working with arrays, the .length member should be available. We can describe this just like we would create arrays of other types: tsfunction loggingIdentityType(arg: Type[]): Type[] { console.log(arg.length); return arg;}Try You can read the type of loggingIdentity as the generic function loggingIdentity takes a type parameter Type, and an argument arg which is an array of Types, and returns an array of Types. If we passed in an array of numbers, wed get an array of numbers back out, as Type would bind to number. This allows us to use our generic type variable Type as part of the types were working with, rather than the whole type, giving us greater flexibility. We can alternatively write the sample example this way: tsfunction loggingIdentityType(arg: ArrayType): ArrayType { console.log(arg.length); // Array has a .length, so no more error return arg;}Try You may already be familiar with this style of type from other languages. In the next section, well cover how you can create your own generic types like ArrayType. Generic Types In previous sections, we created generic identity functions that worked over a range of types. In this section, well explore the type of the functions themselves and how to create generic interfaces. The type of generic functions is just like those of non-generic functions, with the type parameters listed first, similarly to function declarations: tsfunction identityType(arg: Type): Type { return arg;} let myIdentity: Type(arg: Type) = Type = identity;Try We could also have used a different name for the generic type parameter in the type, so long as the number of type variables and how the type variables are used line up. tsfunction identityType(arg: Type): Type { return arg;} let myIdentity: Input(arg: Input) = Input = identity;Try We can also write the generic type as a call signature of an object literal type: tsfunction identityType(arg: Type): Type { return arg;} let myIdentity: { Type(arg: Type): Type } = identity;Try Which leads us to writing our first generic interface. Lets take the object literal from the previous example and move it to an interface: tsinterface GenericIdentityFn { Type(arg: Type): Type;} function identityType(arg: Type): Type { return arg;} let myIdentity: GenericIdentityFn = identity;Try In a similar example, we may want to move the generic parameter to be a parameter of the whole interface. This lets us see what type(s) were generic over (e.g. Dictionarystring rather than just Dictionary). This makes the type parameter visible to all the other members of the interface. tsinterface GenericIdentityFnType { (arg: Type): Type;} function identityType(arg: Type): Type { return arg;} let myIdentity: GenericIdentityFnnumber = identity;Try Notice that our example has changed to be something slightly different. Instead of describing a generic function, we now have a non-generic function signature that is a part of a generic type. When we use GenericIdentityFn, we now will also need to specify the corresponding type argument (here: number), effectively locking in what the underlying call signature will use. Understanding when to put the type parameter directly on the call signature and when to put it on the interface itself will be helpful in describing what aspects of a type are generic. In addition to generic interfaces, we can also create generic classes. Note that it is not possible to create generic enums and namespaces. Generic Classes A generic class has a similar shape to a generic interface. Generic classes have a generic type parameter list in angle brackets () following the name of the class. tsclass GenericNumberNumType { zeroValue: NumType; add: (x: NumType, y: NumType) = NumType;} let myGenericNumber = new GenericNumbernumber();myGenericNumber.zeroValue = 0;myGenericNumber.add = function (x, y) { return x + y;};Try This is a pretty literal use of the GenericNumber class, but you may have noticed that nothing is restricting it to only use the number type. We could have instead used string or even more complex objects. tslet stringNumeric = new GenericNumberstring();stringNumeric.zeroValue = \"\";stringNumeric.add = function (x, y) { return x + y;}; console.log(stringNumeric.add(stringNumeric.zeroValue, \"test\"));Try Just as with interface, putting the type parameter on the class itself lets us make sure all of the properties of the class are working with the same type. As we cover in our section on classes, a class has two sides to its type: the static side and the instance side. Generic classes are only generic over their instance side rather than their static side, so when working with classes, static members can not use the classs type parameter. Generic Constraints If you remember from an earlier example, you may sometimes want to write a generic function that works on a set of types where you have some knowledge about what capabilities that set of types will have. In our loggingIdentity example, we wanted to be able to access the .length property of arg, but the compiler could not prove that every type had a .length property, so it warns us that we cant make this assumption. tsfunction loggingIdentityType(arg: Type): Type { console.log(arg.length);Property 'length' does not exist on type 'Type'.2339Property 'length' does not exist on type 'Type'. return arg;}Try Instead of working with any and all types, wed like to constrain this function to work with any and all types that also have the .length property. As long as the type has this member, well allow it, but its required to have at least this member. To do so, we must list our requirement as a constraint on what Type can be. To do so, well create an interface that describes our constraint. Here, well create an interface that has a single .length property and then well use this interface and the extends keyword to denote our constraint: tsinterface Lengthwise { length: number;} function loggingIdentityType extends Lengthwise(arg: Type): Type { console.log(arg.length); // Now we know it has a .length property, so no more error return arg;}Try Because the generic function is now constrained, it will no longer work over any and all types: tsloggingIdentity(3);Argument of type 'number' is not assignable to parameter of type 'Lengthwise'.2345Argument of type 'number' is not assignable to parameter of type 'Lengthwise'.Try Instead, we need to pass in values whose type has all the required properties: tsloggingIdentity({ length: 10, value: 3 });Try Using Type Parameters in Generic Constraints You can declare a type parameter that is constrained by another type parameter. For example, here wed like to get a property from an object given its name. Wed like to ensure that were not accidentally grabbing a property that does not exist on the obj, so well place a constraint between the two types: tsfunction getPropertyType, Key extends keyof Type(obj: Type, key: Key) { return obj[key];} let x = { a: 1, b: 2, c: 3, d: 4 }; getProperty(x, \"a\");getProperty(x, \"m\");Argument of type '\"m\"' is not assignable to parameter of type '\"a\"  \"b\"  \"c\"  \"d\"'.2345Argument of type '\"m\"' is not assignable to parameter of type '\"a\"  \"b\"  \"c\"  \"d\"'.Try Using Class Types in Generics When creating factories in TypeScript using generics, it is necessary to refer to class types by their constructor functions. For example, tsfunction createType(c: { new (): Type }): Type { return new c();}Try A more advanced example uses the prototype property to infer and constrain relationships between the constructor function and the instance side of class types. tsclass BeeKeeper { hasMask: boolean = true;} class ZooKeeper { nametag: string = \"Mikle\";} class Animal { numLegs: number = 4;} class Bee extends Animal { numLegs = 6; keeper: BeeKeeper = new BeeKeeper();} class Lion extends Animal { keeper: ZooKeeper = new ZooKeeper();} function createInstanceA extends Animal(c: new () = A): A { return new c();} createInstance(Lion).keeper.nametag;createInstance(Bee).keeper.hasMask;Try This pattern is used to power the mixins design pattern. Generic Parameter Defaults By declaring a default for a generic type parameter, you make it optional to specify the corresponding type argument. For example, a function which creates a new HTMLElement. Calling the function with no arguments generates a HTMLDivElement; calling the function with an element as the first argument generates an element of the arguments type. You can optionally pass a list of children as well. Previously you would have to define the function as: tsdeclare function create(): ContainerHTMLDivElement, HTMLDivElement[];declare function createT extends HTMLElement(element: T): ContainerT, T[];declare function createT extends HTMLElement, U extends HTMLElement( element: T, children: U[]): ContainerT, U[];Try With generic parameter defaults we can reduce it to: tsdeclare function createT extends HTMLElement = HTMLDivElement, U extends HTMLElement[] = T[]( element?: T, children?: U): ContainerT, U; const div = create(); const div: ContainerHTMLDivElement, HTMLDivElement[] const p = create(new HTMLParagraphElement()); const p: ContainerHTMLParagraphElement, HTMLParagraphElement[]Try A generic parameter default follows the following rules: A type parameter is deemed optional if it has a default. Required type parameters must not follow optional type parameters. Default types for a type parameter must satisfy the constraint for the type parameter, if it exists. When specifying type arguments, you are only required to specify type arguments for the required type parameters. Unspecified type parameters will resolve to their default types. If a default type is specified and inference cannot choose a candidate, the default type is inferred. A class or interface declaration that merges with an existing class or interface declaration may introduce a default for an existing type parameter. A class or interface declaration that merges with an existing class or interface declaration may introduce a new type parameter as long as it specifies a default. Variance Annotations This is an advanced feature for solving a very specific problem, and should only be used in situations where youve identified a reason to use it Covariance and contravariance are type theory terms that describe what the relationship between two generic types is. Heres a brief primer on the concept. For example, if you have an interface representing an object that can make a certain type: tsinterface ProducerT { make(): T;} We can use a ProducerCat where a ProducerAnimal is expected, because a Cat is an Animal. This relationship is called covariance: the relationship from ProducerT to ProducerU is the same as the relationship from T to U. Conversely, if you have an interface that can consume a certain type: tsinterface ConsumerT { consume: (arg: T) = void;} Then we can use a ConsumerAnimal where a ConsumerCat is expected, because any function that is capable of accepting an Animal must also be capable of accepting a Cat. This relationship is called contravariance: the relationship from ConsumerT to ConsumerU is the same as the relationship from U to T. Note the reversal of direction as compared to covariance! This is why contravariance cancels itself out but covariance doesnt. In a structural type system like TypeScripts, covariance and contravariance are naturally emergent behaviors that follow from the definition of types. Even in the absence of generics, we would see covariant (and contravariant) relationships: tsinterface AnimalProducer { make(): Animal;}// A CatProducer can be used anywhere an// Animal producer is expectedinterface CatProducer { make(): Cat;} TypeScript has a structural type system, so when comparing two types, e.g. to see if a ProducerCat can be used where a ProducerAnimal is expected, the usual algorithm would be structurally expand both of those definitions, and compare their structures. However, variance allows for an extremely useful optimization: if ProducerT is covariant on T, then we can simply check Cat and Animal instead, as we know theyll have the same relationship as ProducerCat and ProducerAnimal. Note that this logic can only be used when were examining two instantiations of the same type. If we have a ProducerT and a FastProducerU, theres no guarantee that T and U necessarily refer to the same positions in these types, so this check will always be performed structurally. Because variance is a naturally emergent property of structural types, TypeScript automatically infers the variance of every generic type. In extremely rare cases involving certain kinds of circular types, this measurement can be inaccurate. If this happens, you can add a variance annotation to a type parameter to force a particular variance: ts// Contravariant annotationinterface Consumerin T { consume: (arg: T) = void;}// Covariant annotationinterface Producerout T { make(): T;}// Invariant annotationinterface ProducerConsumerin out T { consume: (arg: T) = void; make(): T;} Only do this if you are writing the same variance that should occur structurally. Never write a variance annotation that doesnt match the structural variance! Its critical to reinforce that variance annotations are only in effect during an instantiation-based comparison. They have no effect during a structural comparison. For example, you cant use variance annotations to force a type to be actually invariant: ts// DON'T DO THIS - variance annotation// does not match structural behaviorinterface Producerin out T { make(): T;}// Not a type error -- this is a structural// comparison, so variance annotations are// not in effectconst p: Producerstring  number = { make(): number { return 42; }} Here, the object literals make function returns number, which we might expect to cause an error because number isnt string  number. However, this isnt an instantiation-based comparison, because the object literal is an anonymous type, not a Producerstring  number. Variance annotations dont change structural behavior and are only consulted in specific situations Its very important to only write variance annotations if you absolutely know why youre doing it, what their limitations are, and when they arent in effect. Whether TypeScript uses an instantiation-based comparison or structural comparison is not a specified behavior and may change from version to version for correctness or performance reasons, so you should only ever write variance annotations when they match the structural behavior of a type. Dont use variance annotations to try to force a particular variance; this will cause unpredictable behavior in your code. Do NOT write variance annotations unless they match the structural behavior of a type Remember, TypeScript can automatically infer variance from your generic types. Its almost never necessary to write a variance annotation, and you should only do so when youve identified a specific need. Variance annotations do not change the structural behavior of a type, and depending on the situation, you might see a structural comparison made when you expected an instantiation-based comparison. Variance annotations cant be used to modify how types behave in these structural contexts, and shouldnt be written unless the annotation is the same as the structural definition. Because this is difficult to get right, and TypeScript can correctly infer variance in the vast majority of cases, you should not find yourself writing variance annotations in normal code. Dont try to use variance annotations to change typechecking behavior; this is not what they are for You may find temporary variance annotations useful in a type debugging situation, because variance annotations are checked. TypeScript will issue an error if the annotated variance is identifiably wrong: ts// Error, this interface is definitely contravariant on Tinterface Fooout T { consume: (arg: T) = void;} However, variance annotations are allowed to be stricter (e.g. in out is valid if the actual variance is covariant). Be sure to remove your variance annotations once youre done debugging. Lastly, if youre trying to maximize your typechecking performance, and have run a profiler, and have identified a specific type thats slow, and have identified variance inference specifically is slow, and have carefully validated the variance annotation you want to write, you may see a small performance benefit in extraordinarily complex types by adding variance annotations. Dont try to use variance annotations to change typechecking behavior; this is not what they are for",
    "headings": [
      {
        "level": 2,
        "text": "Hello World of Generics",
        "id": "hello-world-of-generics"
      },
      {
        "level": 2,
        "text": "Working with Generic Type Variables",
        "id": "working-with-generic-type-variables"
      },
      {
        "level": 2,
        "text": "Generic Types",
        "id": "generic-types"
      },
      {
        "level": 2,
        "text": "Generic Classes",
        "id": "generic-classes"
      },
      {
        "level": 2,
        "text": "Generic Constraints",
        "id": "generic-constraints"
      },
      {
        "level": 2,
        "text": "Using Type Parameters in Generic Constraints",
        "id": "using-type-parameters-in-generic-constraints"
      },
      {
        "level": 2,
        "text": "Using Class Types in Generics",
        "id": "using-class-types-in-generics"
      },
      {
        "level": 2,
        "text": "Generic Parameter Defaults",
        "id": "generic-parameter-defaults"
      },
      {
        "level": 2,
        "text": "Variance Annotations",
        "id": "variance-annotations"
      }
    ],
    "codeBlocks": [
      {
        "language": "text",
        "code": "tsfunction identity(arg: number): number {  return arg;}Try"
      },
      {
        "language": "text",
        "code": "function identity(arg: number): number {  return arg;}"
      },
      {
        "language": "text",
        "code": "tsfunction identity(arg: any): any {  return arg;}Try"
      },
      {
        "language": "text",
        "code": "function identity(arg: any): any {  return arg;}"
      },
      {
        "language": "text",
        "code": "tsfunction identity<Type>(arg: Type): Type {  return arg;}Try"
      },
      {
        "language": "text",
        "code": "function identity<Type>(arg: Type): Type {  return arg;}"
      },
      {
        "language": "text",
        "code": "tslet output = identity<string>(\"myString\");      let output: stringTry"
      },
      {
        "language": "text",
        "code": "let output = identity<string>(\"myString\");      let output: string"
      },
      {
        "language": "text",
        "code": "tslet output = identity(\"myString\");      let output: stringTry"
      },
      {
        "language": "text",
        "code": "let output = identity(\"myString\");      let output: string"
      },
      {
        "language": "text",
        "code": "tsfunction identity<Type>(arg: Type): Type {  return arg;}Try"
      },
      {
        "language": "text",
        "code": "function identity<Type>(arg: Type): Type {  return arg;}"
      },
      {
        "language": "text",
        "code": "tsfunction loggingIdentity<Type>(arg: Type): Type {  console.log(arg.length);Property 'length' does not exist on type 'Type'.2339Property 'length' does not exist on type 'Type'.  return arg;}Try"
      },
      {
        "language": "text",
        "code": "function loggingIdentity<Type>(arg: Type): Type {  console.log(arg.length);Property 'length' does not exist on type 'Type'.2339Property 'length' does not exist on type 'Type'.  return arg;}"
      },
      {
        "language": "text",
        "code": "tsfunction loggingIdentity<Type>(arg: Type[]): Type[] {  console.log(arg.length);  return arg;}Try"
      },
      {
        "language": "text",
        "code": "function loggingIdentity<Type>(arg: Type[]): Type[] {  console.log(arg.length);  return arg;}"
      },
      {
        "language": "text",
        "code": "loggingIdentity"
      },
      {
        "language": "text",
        "code": "loggingIdentity"
      },
      {
        "language": "text",
        "code": "tsfunction loggingIdentity<Type>(arg: Array<Type>): Array<Type> {  console.log(arg.length); // Array has a .length, so no more error  return arg;}Try"
      },
      {
        "language": "text",
        "code": "function loggingIdentity<Type>(arg: Array<Type>): Array<Type> {  console.log(arg.length); // Array has a .length, so no more error  return arg;}"
      },
      {
        "language": "text",
        "code": "Array<Type>"
      },
      {
        "language": "text",
        "code": "tsfunction identity<Type>(arg: Type): Type {  return arg;} let myIdentity: <Type>(arg: Type) => Type = identity;Try"
      },
      {
        "language": "text",
        "code": "function identity<Type>(arg: Type): Type {  return arg;} let myIdentity: <Type>(arg: Type) => Type = identity;"
      },
      {
        "language": "text",
        "code": "tsfunction identity<Type>(arg: Type): Type {  return arg;} let myIdentity: <Input>(arg: Input) => Input = identity;Try"
      },
      {
        "language": "text",
        "code": "function identity<Type>(arg: Type): Type {  return arg;} let myIdentity: <Input>(arg: Input) => Input = identity;"
      },
      {
        "language": "text",
        "code": "tsfunction identity<Type>(arg: Type): Type {  return arg;} let myIdentity: { <Type>(arg: Type): Type } = identity;Try"
      },
      {
        "language": "text",
        "code": "function identity<Type>(arg: Type): Type {  return arg;} let myIdentity: { <Type>(arg: Type): Type } = identity;"
      },
      {
        "language": "text",
        "code": "tsinterface GenericIdentityFn {  <Type>(arg: Type): Type;} function identity<Type>(arg: Type): Type {  return arg;} let myIdentity: GenericIdentityFn = identity;Try"
      },
      {
        "language": "text",
        "code": "interface GenericIdentityFn {  <Type>(arg: Type): Type;} function identity<Type>(arg: Type): Type {  return arg;} let myIdentity: GenericIdentityFn = identity;"
      },
      {
        "language": "text",
        "code": "Dictionary<string>"
      },
      {
        "language": "text",
        "code": "tsinterface GenericIdentityFn<Type> {  (arg: Type): Type;} function identity<Type>(arg: Type): Type {  return arg;} let myIdentity: GenericIdentityFn<number> = identity;Try"
      },
      {
        "language": "text",
        "code": "interface GenericIdentityFn<Type> {  (arg: Type): Type;} function identity<Type>(arg: Type): Type {  return arg;} let myIdentity: GenericIdentityFn<number> = identity;"
      },
      {
        "language": "text",
        "code": "GenericIdentityFn"
      },
      {
        "language": "text",
        "code": "tsclass GenericNumber<NumType> {  zeroValue: NumType;  add: (x: NumType, y: NumType) => NumType;} let myGenericNumber = new GenericNumber<number>();myGenericNumber.zeroValue = 0;myGenericNumber.add = function (x, y) {  return x + y;};Try"
      },
      {
        "language": "text",
        "code": "class GenericNumber<NumType> {  zeroValue: NumType;  add: (x: NumType, y: NumType) => NumType;} let myGenericNumber = new GenericNumber<number>();myGenericNumber.zeroValue = 0;myGenericNumber.add = function (x, y) {  return x + y;};"
      },
      {
        "language": "text",
        "code": "GenericNumber"
      },
      {
        "language": "text",
        "code": "tslet stringNumeric = new GenericNumber<string>();stringNumeric.zeroValue = \"\";stringNumeric.add = function (x, y) {  return x + y;}; console.log(stringNumeric.add(stringNumeric.zeroValue, \"test\"));Try"
      },
      {
        "language": "text",
        "code": "let stringNumeric = new GenericNumber<string>();stringNumeric.zeroValue = \"\";stringNumeric.add = function (x, y) {  return x + y;}; console.log(stringNumeric.add(stringNumeric.zeroValue, \"test\"));"
      },
      {
        "language": "text",
        "code": "loggingIdentity"
      },
      {
        "language": "text",
        "code": "tsfunction loggingIdentity<Type>(arg: Type): Type {  console.log(arg.length);Property 'length' does not exist on type 'Type'.2339Property 'length' does not exist on type 'Type'.  return arg;}Try"
      },
      {
        "language": "text",
        "code": "function loggingIdentity<Type>(arg: Type): Type {  console.log(arg.length);Property 'length' does not exist on type 'Type'.2339Property 'length' does not exist on type 'Type'.  return arg;}"
      },
      {
        "language": "text",
        "code": "tsinterface Lengthwise {  length: number;} function loggingIdentity<Type extends Lengthwise>(arg: Type): Type {  console.log(arg.length); // Now we know it has a .length property, so no more error  return arg;}Try"
      },
      {
        "language": "text",
        "code": "interface Lengthwise {  length: number;} function loggingIdentity<Type extends Lengthwise>(arg: Type): Type {  console.log(arg.length); // Now we know it has a .length property, so no more error  return arg;}"
      },
      {
        "language": "text",
        "code": "tsloggingIdentity(3);Argument of type 'number' is not assignable to parameter of type 'Lengthwise'.2345Argument of type 'number' is not assignable to parameter of type 'Lengthwise'.Try"
      },
      {
        "language": "text",
        "code": "loggingIdentity(3);Argument of type 'number' is not assignable to parameter of type 'Lengthwise'.2345Argument of type 'number' is not assignable to parameter of type 'Lengthwise'."
      },
      {
        "language": "text",
        "code": "tsloggingIdentity({ length: 10, value: 3 });Try"
      },
      {
        "language": "text",
        "code": "loggingIdentity({ length: 10, value: 3 });"
      },
      {
        "language": "text",
        "code": "tsfunction getProperty<Type, Key extends keyof Type>(obj: Type, key: Key) {  return obj[key];} let x = { a: 1, b: 2, c: 3, d: 4 }; getProperty(x, \"a\");getProperty(x, \"m\");Argument of type '\"m\"' is not assignable to parameter of type '\"a\" | \"b\" | \"c\" | \"d\"'.2345Argument of type '\"m\"' is not assignable to parameter of type '\"a\" | \"b\" | \"c\" | \"d\"'.Try"
      },
      {
        "language": "text",
        "code": "function getProperty<Type, Key extends keyof Type>(obj: Type, key: Key) {  return obj[key];} let x = { a: 1, b: 2, c: 3, d: 4 }; getProperty(x, \"a\");getProperty(x, \"m\");Argument of type '\"m\"' is not assignable to parameter of type '\"a\" | \"b\" | \"c\" | \"d\"'.2345Argument of type '\"m\"' is not assignable to parameter of type '\"a\" | \"b\" | \"c\" | \"d\"'."
      },
      {
        "language": "text",
        "code": "tsfunction create<Type>(c: { new (): Type }): Type {  return new c();}Try"
      },
      {
        "language": "text",
        "code": "function create<Type>(c: { new (): Type }): Type {  return new c();}"
      },
      {
        "language": "text",
        "code": "tsclass BeeKeeper {  hasMask: boolean = true;} class ZooKeeper {  nametag: string = \"Mikle\";} class Animal {  numLegs: number = 4;} class Bee extends Animal {  numLegs = 6;  keeper: BeeKeeper = new BeeKeeper();} class Lion extends Animal {  keeper: ZooKeeper = new ZooKeeper();} function createInstance<A extends Animal>(c: new () => A): A {  return new c();} createInstance(Lion).keeper.nametag;createInstance(Bee).keeper.hasMask;Try"
      },
      {
        "language": "text",
        "code": "class BeeKeeper {  hasMask: boolean = true;} class ZooKeeper {  nametag: string = \"Mikle\";} class Animal {  numLegs: number = 4;} class Bee extends Animal {  numLegs = 6;  keeper: BeeKeeper = new BeeKeeper();} class Lion extends Animal {  keeper: ZooKeeper = new ZooKeeper();} function createInstance<A extends Animal>(c: new () => A): A {  return new c();} createInstance(Lion).keeper.nametag;createInstance(Bee).keeper.hasMask;"
      },
      {
        "language": "text",
        "code": "HTMLElement"
      },
      {
        "language": "text",
        "code": "HTMLDivElement"
      },
      {
        "language": "text",
        "code": "tsdeclare function create(): Container<HTMLDivElement, HTMLDivElement[]>;declare function create<T extends HTMLElement>(element: T): Container<T, T[]>;declare function create<T extends HTMLElement, U extends HTMLElement>(  element: T,  children: U[]): Container<T, U[]>;Try"
      },
      {
        "language": "text",
        "code": "declare function create(): Container<HTMLDivElement, HTMLDivElement[]>;declare function create<T extends HTMLElement>(element: T): Container<T, T[]>;declare function create<T extends HTMLElement, U extends HTMLElement>(  element: T,  children: U[]): Container<T, U[]>;"
      },
      {
        "language": "text",
        "code": "tsdeclare function create<T extends HTMLElement = HTMLDivElement, U extends HTMLElement[] = T[]>(  element?: T,  children?: U): Container<T, U>; const div = create();      const div: Container<HTMLDivElement, HTMLDivElement[]> const p = create(new HTMLParagraphElement());     const p: Container<HTMLParagraphElement, HTMLParagraphElement[]>Try"
      },
      {
        "language": "text",
        "code": "declare function create<T extends HTMLElement = HTMLDivElement, U extends HTMLElement[] = T[]>(  element?: T,  children?: U): Container<T, U>; const div = create();      const div: Container<HTMLDivElement, HTMLDivElement[]> const p = create(new HTMLParagraphElement());     const p: Container<HTMLParagraphElement, HTMLParagraphElement[]>"
      },
      {
        "language": "text",
        "code": "tsinterface Producer<T> {  make(): T;}"
      },
      {
        "language": "text",
        "code": "interface Producer<T> {  make(): T;}"
      },
      {
        "language": "text",
        "code": "Producer<Cat>"
      },
      {
        "language": "text",
        "code": "Producer<Animal>"
      },
      {
        "language": "text",
        "code": "Producer<T>"
      },
      {
        "language": "text",
        "code": "Producer<U>"
      },
      {
        "language": "text",
        "code": "tsinterface Consumer<T> {  consume: (arg: T) => void;}"
      },
      {
        "language": "text",
        "code": "interface Consumer<T> {  consume: (arg: T) => void;}"
      },
      {
        "language": "text",
        "code": "Consumer<Animal>"
      },
      {
        "language": "text",
        "code": "Consumer<Cat>"
      },
      {
        "language": "text",
        "code": "Consumer<T>"
      },
      {
        "language": "text",
        "code": "Consumer<U>"
      },
      {
        "language": "text",
        "code": "tsinterface AnimalProducer {  make(): Animal;}// A CatProducer can be used anywhere an// Animal producer is expectedinterface CatProducer {  make(): Cat;}"
      },
      {
        "language": "text",
        "code": "interface AnimalProducer {  make(): Animal;}// A CatProducer can be used anywhere an// Animal producer is expectedinterface CatProducer {  make(): Cat;}"
      },
      {
        "language": "text",
        "code": "Producer<Cat>"
      },
      {
        "language": "text",
        "code": "Producer<Animal>"
      },
      {
        "language": "text",
        "code": "Producer<T>"
      },
      {
        "language": "text",
        "code": "Producer<Cat>"
      },
      {
        "language": "text",
        "code": "Producer<Animal>"
      },
      {
        "language": "text",
        "code": "Producer<T>"
      },
      {
        "language": "text",
        "code": "FastProducer<U>"
      },
      {
        "language": "text",
        "code": "ts// Contravariant annotationinterface Consumer<in T> {  consume: (arg: T) => void;}// Covariant annotationinterface Producer<out T> {  make(): T;}// Invariant annotationinterface ProducerConsumer<in out T> {  consume: (arg: T) => void;  make(): T;}"
      },
      {
        "language": "text",
        "code": "// Contravariant annotationinterface Consumer<in T> {  consume: (arg: T) => void;}// Covariant annotationinterface Producer<out T> {  make(): T;}// Invariant annotationinterface ProducerConsumer<in out T> {  consume: (arg: T) => void;  make(): T;}"
      },
      {
        "language": "text",
        "code": "ts// DON'T DO THIS - variance annotation// does not match structural behaviorinterface Producer<in out T> {  make(): T;}// Not a type error -- this is a structural// comparison, so variance annotations are// not in effectconst p: Producer<string | number> = {    make(): number {        return 42;    }}"
      },
      {
        "language": "text",
        "code": "// DON'T DO THIS - variance annotation// does not match structural behaviorinterface Producer<in out T> {  make(): T;}// Not a type error -- this is a structural// comparison, so variance annotations are// not in effectconst p: Producer<string | number> = {    make(): number {        return 42;    }}"
      },
      {
        "language": "text",
        "code": "string | number"
      },
      {
        "language": "text",
        "code": "Producer<string | number>"
      },
      {
        "language": "text",
        "code": "ts// Error, this interface is definitely contravariant on Tinterface Foo<out T> {  consume: (arg: T) => void;}"
      },
      {
        "language": "text",
        "code": "// Error, this interface is definitely contravariant on Tinterface Foo<out T> {  consume: (arg: T) => void;}"
      }
    ],
    "links": [
      {
        "text": "Try",
        "href": "https://www.typescriptlang.org/play/#code/GYVwdgxgLglg9mABDAJgUzLKBPAFAQwCcBzALkTBAFsAjNQgSnMtvsQG8AoRRQtKEISRFiAbk4BfIA"
      },
      {
        "text": "Try",
        "href": "https://www.typescriptlang.org/play/#code/GYVwdgxgLglg9mABDAJgUzLKBPAFAQwCcBzALkXzGwEpzLtEBvAKEUULShEKSOIG5mAXyA"
      },
      {
        "text": "Try",
        "href": "https://www.typescriptlang.org/play/#code/GYVwdgxgLglg9mABDAJgUzLKBPAPAFWwAc0A+ACgEMAnAcwC5FCSBKR5tRAbwChFFqaKCGpIatANw8AvkA"
      },
      {
        "text": "Try",
        "href": "https://www.typescriptlang.org/play/#code/GYVwdgxgLglg9mABDAJgUzLKBPAPAFWwAc0A+ACgEMAnAcwC5FCSBKR5tRAbwChFFqaKCGpIatANw8AvjwD0cxAFoVEEFBVKeAGyGI46ousQBeZOkwwcuAM5RqMMLQoAiALbYAyvce0XLKQV+YP4APQB+IA"
      },
      {
        "text": "Try",
        "href": "https://www.typescriptlang.org/play/#code/GYVwdgxgLglg9mABDAJgUzLKBPAPAFWwAc0A+ACgEMAnAcwC5FCSBKR5tRAbwChFFqaKCGpIatANw8AvjwD0cxAFoVEEFBVKeAGyGI46ousQBeZOkwwc5AEQBbbAGUo1GGFo2WUhf1-8AegD8QA"
      },
      {
        "text": "Try",
        "href": "https://www.typescriptlang.org/play/#code/GYVwdgxgLglg9mABDAJgUzLKBPAPAFWwAc0A+ACgEMAnAcwC5FCSBKR5tRAbwChFFqaKCGpIatANw8AvkA"
      },
      {
        "text": "Try",
        "href": "https://www.typescriptlang.org/play/#code/PTAEAEFMCdoe2gZwFygEwGYME4BQAzAVwDsBjAFwEs5jQAbOAc0cuMYEkATSYq8gTwA8AFX4AHSAD4AFAENojVKIkBKJeMigA3rlChSNRHDqQAdA0ZyF5no3IALFQG5doaJHKFoteYxcBfIA"
      },
      {
        "text": "Try",
        "href": "https://www.typescriptlang.org/play/#code/GYVwdgxgLglg9mABAGzgczTMaCSATAUzFigE8AeAFVIAcCA+ACgEMAnNALkWroG0BdAJRceBAYgDeAKESIICAM5xkBAHSo0LduqJooAC0EBuGYlYEoIVkjZoTAXyA"
      },
      {
        "text": "Try",
        "href": "https://www.typescriptlang.org/play/#code/GYVwdgxgLglg9mABAGzgczTMaCSATAUzFigE8AeAFVIAcCA+ACgEMAnNALkQEFXXmK1OvQCUXXv0G0GiAN4AoRIggIAznGQEAdKjQt2OomigALEQG5EAeis8+AxCearEzRIeymANInWIwcIgAtnCsBIgEfKGKiGFQIKxIbGjm8gC+QA"
      },
      {
        "text": "Try",
        "href": "https://www.typescriptlang.org/play/#code/GYVwdgxgLglg9mABDAJgUzLKBPAPAFWwAc0A+ACgEMAnAcwC5FCSBKR5tRAbwChFFqaKCGpIatANw8Avjx4AbIYgC22AJLpMMHIwLEyVOu30tEAXlJN955JqzYJQA"
      },
      {
        "text": "Try",
        "href": "https://www.typescriptlang.org/play/#code/GYVwdgxgLglg9mABDAJgUzLKBPAPAFWwAc0A+ACgEMAnAcwC5FCSBKR5tRAbwChFFqaKCGpIatANw8Avjx4AbIYgC22AJLpMMHI1xqwREFArjG+w1BaIAvKUTmjN5JqzYJQA"
      },
      {
        "text": "Try",
        "href": "https://www.typescriptlang.org/play/#code/GYVwdgxgLglg9mABDAJgUzLKBPAPAFWwAc0A+ACgEMAnAcwC5FCSBKR5tRAbwChFFqaKCGpIatANw8Avjx4AbIYgC22AJLpMMHIy6ICxMlTrtDbJocTTEAXmSas2CUA"
      },
      {
        "text": "Try",
        "href": "https://www.typescriptlang.org/play/#code/JYOwLgpgTgZghgYwgAgOIRNYCCSATDMYMATwDERkBvAKGWQB4AVEgBwgD4AKOKAcwBcyFuwCUQkRADcNAL40aMAK4gERAPaVgBcMRLM2nHvwmHxww9TrIoEMEqiVefGfJoAbO8gC2JfIT0hdEwobH9dUgpkAF5kbQDSKSA"
      },
      {
        "text": "Try",
        "href": "https://www.typescriptlang.org/play/#code/JYOwLgpgTgZghgYwgAgOIRNYCCSATDMYMATwDEQAeAFRIAcIA+ZAbwChlkAKOKAcwBcyWgwCUQkRADcbAL5s2MAK4gERAPYhkwAuGIka9Jj34Sj44UdYdkUCGCVQtvPjPlsANveQBbEvkJ9IXRMKGwAvVIKShAlHwAjaGYAXm1dIlIpIA"
      },
      {
        "text": "Try",
        "href": "https://www.typescriptlang.org/play/#code/PTAEAEGcBcCcEsDG0BcoBmBDANpApgFCLaaSSgDieAdngogHICuAtgEZ0A8zLAKgJ4AHPAD5QAbwKhQALzoB7AGo4meNDwHCA3FNCYAJvrQAKAB7rWmvABpQ-C3yF4AlKAC8YjU50BfAgWw8aFAWfipaeh4OWHdQWgB3Sho6JCiualZokWNnHVDwlMZMugA6OVglFTxYgAY8sOTI4tgSg31Y9CZqZHh5alAzW35XSWlYIKZYftNQAGo7Xy0gA"
      },
      {
        "text": "Try",
        "href": "https://www.typescriptlang.org/play/#code/PTAEAEGcBcCcEsDG0BcoBmBDANpApgFCLaaSSgDieAdngogHICuAtgEZ0A8zLAKgJ4AHPAD5QAbwKhQALzoB7AGo4meNDwHCA3FNCYAJvrQAKAB7rWmvABpQ-C3yF4AlKAC8YjU50BfAiFAAWmDEJmhgwIJsPGhQGARqAHMeOiR3UFoAd0oaVMZWDlhOePgkkWNnHRKklPoAOjlYJRU8dIAiNqq4UuTWPLqDfXT0JmpkeHlqUDNbfldJaVgYplgp01AAajtfHSJJyHlouux5RONq3pZ+wfPumr76xubsVVs26DwYNudKoA"
      },
      {
        "text": "our section on classes",
        "href": "/docs/handbook/2/classes.html"
      },
      {
        "text": "Try",
        "href": "https://www.typescriptlang.org/play/#code/PTAEAEFMCdoe2gZwFygEwGYME4BQAzAVwDsBjAFwEs5jQAbOAc0cuMYEkATSYq8gTwA8AFX4AHSAD4AFAENojVKIkBKJeMigA3rlChSNRHDqQAdA0ZyF5no3IALFQG5doaJHKFoteYxcBfIA"
      },
      {
        "text": "Try",
        "href": "https://www.typescriptlang.org/play/#code/JYOwLgpgTgZghgYwgAgDIRAczACwO7ADOKA3gFDLIA2G2OAXMiAK4C2ARtANxkC+ZZGMxAIwwAPYhq4zJlCYAkgBMMYsAE8APABV1ABxQQAHpBBLCaWrgLEAfAAo4UTI10GAlK-2kKyBJMJxGgA6KhlHZ1CrHHcuZAB6eOQAOXE8ZDwUAGsQNORgMGQcOAs4ZCisXGQ9KHEDKA0AGmRApnFkVnEoQyhaqF9usGYoKSdMHl4gA"
      },
      {
        "text": "Try",
        "href": "https://www.typescriptlang.org/play/#code/PTAEAEFMCdoe2gZwFygEwGYAsBWAUAJYB2ALjAGYCGAxpKADKREDmJAFgO4GJ0DeeoUABsmrNqiIBXALYAjGAG48AXzx5ykotRIE4RYXGbNizAJIATJjpIBPADwAVGwAc6kAB5ki5xA1HsuHgA+AApKaGZUJ1cASiiXPgFQaj1EOBEAOiFDMIis-zYYpUFoSBJJaH1w5iVVEFAAWibqSRImhrxsoxMLKwJbEIwioA"
      },
      {
        "text": "Try",
        "href": "https://www.typescriptlang.org/play/#code/JYOwLgpgTgZghgYwgAgDIRAczACwO7ADOKA3gFDLIA2G2OAXMiAK4C2ARtANxkC+ZZGMxAIwwAPYhq4zJlCYAkgBMMYsAE8APABV1ABxQQAHpBBLCaWrgLEAfAAo4UTI10GAlK-2kKyBJMJxGgA6KhlHZ1CrHHceSigIMGYoKSdMHn4AekzkAFp8hGYwfNyyMNl5ZVVgDXsSamjGAEYABgAaZAA3OCpmCEYAZmReWKA"
      },
      {
        "text": "Try",
        "href": "https://www.typescriptlang.org/play/#code/PTAEAEFMCdoe2gZwFygEwGYAsBWAUAGYCuAdgMYAuAlnCaAOaQUAK8ADjBQJ4A8AKlw4AaUAGlIXUJAAeFSCQAmiUAGsJcAqAEcAfAAo4AIwBWqbZBFquqcVwCUoAN55QoaEyLQ6R4wG0rALoA3HgAvnh4ADZMoNKgALxOoACGqACMIoaoaCJkqBgiCqhYoKEheIws7JxcetIiAETJDXYhlaxwHNDcdY0Ati1BQA"
      },
      {
        "text": "Try",
        "href": "https://www.typescriptlang.org/play/#code/GYVwdgxgLglg9mABBATgUwIZTQHgCoCeADmgHwAUEAXIgN6JhoDui5AlDYSYgL4eJc0dAFCJE6KCBRJGLCOwDcwnkA"
      },
      {
        "text": "Try",
        "href": "https://www.typescriptlang.org/play/#code/PTAEAEGcBcCcEsDG0BcoBmBDANpApgFCLaaSSgBCeeA0tQA56ygDeBooAFqQLKkDWaAEYB7EdjyYAdqAC8oOAFc8AbgIBfAkRJlQALTF08jZmw5TMAWzzRMAczQwEUu3NAAiHvH4T3azdqk5ACCUvCWOKzsoFKKlgAyeHaQaLGWQkxuACz+WsRBlNSgeAAe0HhSACYhYRHYUeZxicluAGxqHPwMTGhUtN3M8lJ4AO6F-cZMABQAlLmBuvHwIjKl5VU14ZFmoF2TsGgGIkYmbsNjRyfTcxpa6IpSyMsyiLCS5QCSUjDSiHgAPMFimUKtVQKEttgAHxTRCpUagWZyKHgmZoIE7N7QRSwGTnUCIWbzV7vPBfH6PPBTJYrGYAOj2JjpFmstjsahJmE+31slKmfXpjKYdO4kD4kH4KiAA"
      },
      {
        "text": "mixins",
        "href": "/docs/handbook/mixins.html"
      },
      {
        "text": "Try",
        "href": "https://www.typescriptlang.org/play/#code/C4TwDgpgBAwg9gO2AQwJYIgJwDwBUA0UAqgHxQC8UA3gFBRQQA2EAthEgFxS4DcdUAYwAWqRgBNM7LkT4BfPjQD0iqAFp1AgK7B1qmmIgDGySVABmmhAOCpEgycmAQAFAEou8JGgw4AErgBZABkAEVQANwBRZjYkQn9gsKiY9mAAbQBdEj4DIxNoCysbOwEHJzwGAA8nBDEAZygEoOjWVJJnJlbObndYRBR0LDxCXEzs-UNjU0LrWwR7CEcICohq9nrGwOaUuOIqmo2mltjgdv5Ok64CfmFRCSliTJpezwGfYcesniA"
      },
      {
        "text": "Try",
        "href": "https://www.typescriptlang.org/play/#code/C4TwDgpgBAwg9gO2AQwJYIgJwDwBUA0UAqgHxQC8UA3gFBRQQA2EAthEgFxS4DcdUAYwAWqRgBNM7LkT4BfPjQD0iqAFp1AgK7B1qmmIgDGySVABmmhAOCpEgycmAQ8DAB5OEYgM5QAErgBZABkAUWY2JAo-QKCAEVQANzDWdmBCIjcPb2jg5IjgAG0AXSjcYpIACn4mFKQAfi4CfmFRCXYG4hoASi54JDQMHAJiEgUBRC9gKDFEqIEHJwquvmV6egA9OpoacYRJqDA5hYgKjAB3HKCABRNkAHNMZDAhPNSl5aUVNc2gA"
      },
      {
        "text": "Covariance and contravariance",
        "href": "https://en.wikipedia.org/wiki/Covariance_and_contravariance_(computer_science)"
      }
    ],
    "meta": {
      "description": "Types which take parameters",
      "keywords": ""
    },
    "summary": "A major part of software engineering is building components that not only have well-defined and consistent APIs, but are also reusable",
    "tags": [
      "react",
      "angular",
      "javascript",
      "typescript",
      "css",
      "html",
      "vite",
      "generic",
      "generics",
      "type"
    ],
    "id": "typescript-documentation-genericshtml-part-1",
    "quality": 100
  },
  {
    "title": "TypeScript: Documentation",
    "url": "https://www.typescriptlang.org/docs/handbook/2/classes.html",
    "category": "typescript",
    "content": "Background Reading:Classes (MDN) TypeScript offers full support for the class keyword introduced in ES2015. As with other JavaScript language features, TypeScript adds type annotations and other syntax to allow you to express relationships between classes and other types. Class Members Heres the most basic class - an empty one: tsclass Point {}Try This class isnt very useful yet, so lets start adding some members. Fields A field declaration creates a public writeable property on a class: tsclass Point { x: number; y: number;} const pt = new Point();pt.x = 0;pt.y = 0;Try As with other locations, the type annotation is optional, but will be an implicit any if not specified. Fields can also have initializers; these will run automatically when the class is instantiated: tsclass Point { x = 0; y = 0;} const pt = new Point();// Prints 0, 0console.log(${pt.x}, ${pt.y});Try Just like with const, let, and var, the initializer of a class property will be used to infer its type: tsconst pt = new Point();pt.x = \"0\";Type 'string' is not assignable to type 'number'.2322Type 'string' is not assignable to type 'number'.Try --strictPropertyInitialization The strictPropertyInitialization setting controls whether class fields need to be initialized in the constructor. tsclass BadGreeter { name: string;Property 'name' has no initializer and is not definitely assigned in the constructor.2564Property 'name' has no initializer and is not definitely assigned in the constructor.}Try tsclass GoodGreeter { name: string; constructor() { this.name = \"hello\"; }}Try Note that the field needs to be initialized in the constructor itself. TypeScript does not analyze methods you invoke from the constructor to detect initializations, because a derived class might override those methods and fail to initialize the members. If you intend to definitely initialize a field through means other than the constructor (for example, maybe an external library is filling in part of your class for you), you can use the definite assignment assertion operator, !: tsclass OKGreeter { // Not initialized, but no error name!: string;}Try readonly Fields may be prefixed with the readonly modifier. This prevents assignments to the field outside of the constructor. tsclass Greeter { readonly name: string = \"world\"; constructor(otherName?: string) { if (otherName !== undefined) { this.name = otherName; } } err() { this.name = \"not ok\";Cannot assign to 'name' because it is a read-only property.2540Cannot assign to 'name' because it is a read-only property. }}const g = new Greeter();g.name = \"also not ok\";Cannot assign to 'name' because it is a read-only property.2540Cannot assign to 'name' because it is a read-only property.Try Constructors Background Reading: Constructor (MDN) Class constructors are very similar to functions. You can add parameters with type annotations, default values, and overloads: tsclass Point { x: number; y: number; // Normal signature with defaults constructor(x = 0, y = 0) { this.x = x; this.y = y; }}Try tsclass Point { x: number = 0; y: number = 0; // Constructor overloads constructor(x: number, y: number); constructor(xy: string); constructor(x: string  number, y: number = 0) { // Code logic here }}Try There are just a few differences between class constructor signatures and function signatures: Constructors cant have type parameters - these belong on the outer class declaration, which well learn about later Constructors cant have return type annotations - the class instance type is always whats returned Super Calls Just as in JavaScript, if you have a base class, youll need to call super(); in your constructor body before using any this. members: tsclass Base { k = 4;} class Derived extends Base { constructor() { // Prints a wrong value in ES5; throws exception in ES6 console.log(this.k);'super' must be called before accessing 'this' in the constructor of a derived class.17009'super' must be called before accessing 'this' in the constructor of a derived class. super(); }}Try Forgetting to call super is an easy mistake to make in JavaScript, but TypeScript will tell you when its necessary. Methods Background Reading: Method definitions A function property on a class is called a method. Methods can use all the same type annotations as functions and constructors: tsclass Point { x = 10; y = 10; scale(n: number): void { this.x *= n; this.y *= n; }}Try Other than the standard type annotations, TypeScript doesnt add anything else new to methods. Note that inside a method body, it is still mandatory to access fields and other methods via this.. An unqualified name in a method body will always refer to something in the enclosing scope: tslet x: number = 0; class C { x: string = \"hello\"; m() { // This is trying to modify 'x' from line 1, not the class property x = \"world\";Type 'string' is not assignable to type 'number'.2322Type 'string' is not assignable to type 'number'. }}Try Getters / Setters Classes can also have accessors: tsclass C { _length = 0; get length() { return this._length; } set length(value) { this._length = value; }}Try Note that a field-backed get/set pair with no extra logic is very rarely useful in JavaScript. Its fine to expose public fields if you dont need to add additional logic during the get/set operations. TypeScript has some special inference rules for accessors: If get exists but no set, the property is automatically readonly If the type of the setter parameter is not specified, it is inferred from the return type of the getter Since TypeScript 4.3, it is possible to have accessors with different types for getting and setting. tsclass Thing { _size = 0; get size(): number { return this._size; } set size(value: string  number  boolean) { let num = Number(value); // Don't allow NaN, Infinity, etc if (!Number.isFinite(num)) { this._size = 0; return; } this._size = num; }}Try Index Signatures Classes can declare index signatures; these work the same as Index Signatures for other object types: tsclass MyClass { [s: string]: boolean  ((s: string) = boolean); check(s: string) { return this[s] as boolean; }}Try Because the index signature type needs to also capture the types of methods, its not easy to usefully use these types. Generally its better to store indexed data in another place instead of on the class instance itself. Class Heritage Like other languages with object-oriented features, classes in JavaScript can inherit from base classes. implements Clauses You can use an implements clause to check that a class satisfies a particular interface. An error will be issued if a class fails to correctly implement it: tsinterface Pingable { ping(): void;} class Sonar implements Pingable { ping() { console.log(\"ping!\"); }} class Ball implements Pingable {Class 'Ball' incorrectly implements interface 'Pingable'. Property 'ping' is missing in type 'Ball' but required in type 'Pingable'.2420Class 'Ball' incorrectly implements interface 'Pingable'. Property 'ping' is missing in type 'Ball' but required in type 'Pingable'. pong() { console.log(\"pong!\"); }}Try Classes may also implement multiple interfaces, e.g. class C implements A, B {. Cautions Its important to understand that an implements clause is only a check that the class can be treated as the interface type. It doesnt change the type of the class or its methods at all. A common source of error is to assume that an implements clause will change the class type - it doesnt! tsinterface Checkable { check(name: string): boolean;} class NameChecker implements Checkable { check(s) {Parameter 's' implicitly has an 'any' type.7006Parameter 's' implicitly has an 'any' type. // Notice no error here return s.toLowerCase() === \"ok\"; any }}Try In this example, we perhaps expected that ss type would be influenced by the name: string parameter of check. It is not - implements clauses dont change how the class body is checked or its type inferred. Similarly, implementing an interface with an optional property doesnt create that property: tsinterface A { x: number; y?: number;}class C implements A { x = 0;}const c = new C();c.y = 10;Property 'y' does not exist on type 'C'.2339Property 'y' does not exist on type 'C'.Try extends Clauses Background Reading: extends keyword (MDN) Classes may extend from a base class. A derived class has all the properties and methods of its base class, and can also define additional members. tsclass Animal { move() { console.log(\"Moving along!\"); }} class Dog extends Animal { woof(times: number) { for (let i = 0; i  times; i++) { console.log(\"woof!\"); } }} const d = new Dog();// Base class methodd.move();// Derived class methodd.woof(3);Try Overriding Methods Background Reading: super keyword (MDN) A derived class can also override a base class field or property. You can use the super. syntax to access base class methods. Note that because JavaScript classes are a simple lookup object, there is no notion of a super field. TypeScript enforces that a derived class is always a subtype of its base class. For example, heres a legal way to override a method: tsclass Base { greet() { console.log(\"Hello, world!\"); }} class Derived extends Base { greet(name?: string) { if (name === undefined) { super.greet(); } else { console.log(Hello, ${name.toUpperCase()}); } }} const d = new Derived();d.greet();d.greet(\"reader\");Try Its important that a derived class follow its base class contract. Remember that its very common (and always legal!) to refer to a derived class instance through a base class reference: ts// Alias the derived instance through a base class referenceconst b: Base = d;// No problemb.greet();Try What if Derived didnt follow Bases contract? tsclass Base { greet() { console.log(\"Hello, world!\"); }} class Derived extends Base { // Make this parameter required greet(name: string) {Property 'greet' in type 'Derived' is not assignable to the same property in base type 'Base'. Type '(name: string) = void' is not assignable to type '() = void'. Target signature provides too few arguments. Expected 1 or more, but got 0.2416Property 'greet' in type 'Derived' is not assignable to the same property in base type 'Base'. Type '(name: string) = void' is not assignable to type '() = void'. Target signature provides too few arguments. Expected 1 or more, but got 0. console.log(Hello, ${name.toUpperCase()}); }}Try If we compiled this code despite the error, this sample would then crash: tsconst b: Base = new Derived();// Crashes because \"name\" will be undefinedb.greet();Try Type-only Field Declarations When target = ES2022 or useDefineForClassFields is true, class fields are initialized after the parent class constructor completes, overwriting any value set by the parent class. This can be a problem when you only want to re-declare a more accurate type for an inherited field. To handle these cases, you can write declare to indicate to TypeScript that there should be no runtime effect for this field declaration. tsinterface Animal { dateOfBirth: any;} interface Dog extends Animal { breed: any;} class AnimalHouse { resident: Animal; constructor(animal: Animal) { this.resident = animal; }} class DogHouse extends AnimalHouse { // Does not emit JavaScript code, // only ensures the types are correct declare resident: Dog; constructor(dog: Dog) { super(dog); }}Try Initialization Order The order that JavaScript classes initialize can be surprising in some cases. Lets consider this code: tsclass Base { name = \"base\"; constructor() { console.log(\"My name is \" + this.name); }} class Derived extends Base { name = \"derived\";} // Prints \"base\", not \"derived\"const d = new Derived();Try What happened here? The order of class initialization, as defined by JavaScript, is: The base class fields are initialized The base class constructor runs The derived class fields are initialized The derived class constructor runs This means that the base class constructor saw its own value for name during its own constructor, because the derived class field initializations hadnt run yet. Inheriting Built-in Types Note: If you dont plan to inherit from built-in types like Array, Error, Map, etc. or your compilation target is explicitly set to ES6/ES2015 or above, you may skip this section In ES2015, constructors which return an object implicitly substitute the value of this for any callers of super(...). It is necessary for generated constructor code to capture any potential return value of super(...) and replace it with this. As a result, subclassing Error, Array, and others may no longer work as expected. This is due to the fact that constructor functions for Error, Array, and the like use ECMAScript 6s new.target to adjust the prototype chain; however, there is no way to ensure a value for new.target when invoking a constructor in ECMAScript 5. Other downlevel compilers generally have the same limitation by default. For a subclass like the following: tsclass MsgError extends Error { constructor(m: string) { super(m); } sayHello() { return \"hello \" + this.message; }}Try you may find that: methods may be undefined on objects returned by constructing these subclasses, so calling sayHello will result in an error. instanceof will be broken between instances of the subclass and their instances, so (new MsgError()) instanceof MsgError will return false. As a recommendation, you can manually adjust the prototype immediately after any super(...) calls. tsclass MsgError extends Error { constructor(m: string) { super(m); // Set the prototype explicitly. Object.setPrototypeOf(this, MsgError.prototype); } sayHello() { return \"hello \" + this.message; }}Try However, any subclass of MsgError will have to manually set the prototype as well. For runtimes that dont support Object.setPrototypeOf, you may instead be able to use __proto__. Unfortunately, these workarounds will not work on Internet Explorer 10 and prior. One can manually copy methods from the prototype onto the instance itself (i.e. MsgError.prototype onto this), but the prototype chain itself cannot be fixed. Member Visibility You can use TypeScript to control whether certain methods or properties are visible to code outside the class. public The default visibility of class members is public. A public member can be accessed anywhere: tsclass Greeter { public greet() { console.log(\"hi!\"); }}const g = new Greeter();g.greet();Try Because public is already the default visibility modifier, you dont ever need to write it on a class member, but might choose to do so for style/readability reasons. protected protected members are only visible to subclasses of the class theyre declared in. tsclass Greeter { public greet() { console.log(\"Hello, \" + this.getName()); } protected getName() { return \"hi\"; }} class SpecialGreeter extends Greeter { public howdy() { // OK to access protected member here console.log(\"Howdy, \" + this.getName()); }}const g = new SpecialGreeter();g.greet(); // OKg.getName();Property 'getName' is protected and only accessible within class 'Greeter' and its subclasses.2445Property 'getName' is protected and only accessible within class 'Greeter' and its subclasses.Try Exposure of protected members Derived classes need to follow their base class contracts, but may choose to expose a subtype of base class with more capabilities. This includes making protected members public: tsclass Base { protected m = 10;}class Derived extends Base { // No modifier, so default is 'public' m = 15;}const d = new Derived();console.log(d.m); // OKTry Note that Derived was already able to freely read and write m, so this doesnt meaningfully alter the security of this situation. The main thing to note here is that in the derived class, we need to be careful to repeat the protected modifier if this exposure isnt intentional. Cross-hierarchy protected access TypeScript doesnt allow accessing protected members of a sibling class in a class hierarchy: tsclass Base { protected x: number = 1;}class Derived1 extends Base { protected x: number = 5;}class Derived2 extends Base { f1(other: Derived2) { other.x = 10; } f2(other: Derived1) { other.x = 10;Property 'x' is protected and only accessible within class 'Derived1' and its subclasses.2445Property 'x' is protected and only accessible within class 'Derived1' and its subclasses. }}Try This is because accessing x in Derived2 should only be legal from Derived2s subclasses, and Derived1 isnt one of them. Moreover, if accessing x through a Derived1 reference is illegal (which it certainly should be!), then accessing it through a base class reference should never improve the situation. See also Why Cant I Access A Protected Member From A Derived Class? which explains more of C#s reasoning on the same topic. private private is like protected, but doesnt allow access to the member even from subclasses: tsclass Base { private x = 0;}const b = new Base();// Can't access from outside the classconsole.log(b.x);Property 'x' is private and only accessible within class 'Base'.2341Property 'x' is private and only accessible within class 'Base'.Try tsclass Derived extends Base { showX() { // Can't access in subclasses console.log(this.x);Property 'x' is private and only accessible within class 'Base'.2341Property 'x' is private and only accessible within class 'Base'. }}Try Because private members arent visible to derived classes, a derived class cant increase their visibility: tsclass Base { private x = 0;}class Derived extends Base {Class 'Derived' incorrectly extends base class 'Base'. Property 'x' is private in type 'Base' but not in type 'Derived'.2415Class 'Derived' incorrectly extends base class 'Base'. Property 'x' is private in type 'Base' but not in type 'Derived'. x = 1;}Try Cross-instance private access Different OOP languages disagree about whether different instances of the same class may access each others private members. While languages like Java, C#, C++, Swift, and PHP allow this, Ruby does not. TypeScript does allow cross-instance private access: tsclass A { private x = 10; public sameAs(other: A) { // No error return other.x === this.x; }}Try Caveats Like other aspects of TypeScripts type system, private and protected are only enforced during type checking. This means that JavaScript runtime constructs like in or simple property lookup can still access a private or protected member: tsclass MySafe { private secretKey = 12345;}Try js// In a JavaScript file...const s = new MySafe();// Will print 12345console.log(s.secretKey); private also allows access using bracket notation during type checking. This makes private-declared fields potentially easier to access for things like unit tests, with the drawback that these fields are soft private and dont strictly enforce privacy. tsclass MySafe { private secretKey = 12345;} const s = new MySafe(); // Not allowed during type checkingconsole.log(s.secretKey);Property 'secretKey' is private and only accessible within class 'MySafe'.2341Property 'secretKey' is private and only accessible within class 'MySafe'. // OKconsole.log(s[\"secretKey\"]);Try Unlike TypeScriptss private, JavaScripts private fields (#) remain private after compilation and do not provide the previously mentioned escape hatches like bracket notation access, making them hard private. tsclass Dog { #barkAmount = 0; personality = \"happy\"; constructor() {}}Try ts\"use strict\";class Dog { #barkAmount = 0; personality = \"happy\"; constructor() { }} Try When compiling to ES2021 or less, TypeScript will use WeakMaps in place of #. ts\"use strict\";var _Dog_barkAmount;class Dog { constructor() { _Dog_barkAmount.set(this, 0); this.personality = \"happy\"; }}_Dog_barkAmount = new WeakMap(); Try If you need to protect values in your class from malicious actors, you should use mechanisms that offer hard runtime privacy, such as closures, WeakMaps, or private fields. Note that these added privacy checks during runtime could affect performance. Static Members Background Reading: Static Members (MDN) Classes may have static members. These members arent associated with a particular instance of the class. They can be accessed through the class constructor object itself: tsclass MyClass { static x = 0; static printX() { console.log(MyClass.x); }}console.log(MyClass.x);MyClass.printX();Try Static members can also use the same public, protected, and private visibility modifiers: tsclass MyClass { private static x = 0;}console.log(MyClass.x);Property 'x' is private and only accessible within class 'MyClass'.2341Property 'x' is private and only accessible within class 'MyClass'.Try Static members are also inherited: tsclass Base { static getGreeting() { return \"Hello world\"; }}class Derived extends Base { myGreeting = Derived.getGreeting();}Try Special Static Names Its generally not safe/possible to overwrite properties from the Function prototype. Because classes are themselves functions that can be invoked with new, certain static names cant be used. Function properties like name, length, and call arent valid to define as static members: tsclass S { static name = \"S!\";Static property 'name' conflicts with built-in property 'Function.name' of constructor function 'S'.2699Static property 'name' conflicts with built-in property 'Function.name' of constructor function 'S'.}Try Why No Static Classes? TypeScript (and JavaScript) dont have a construct called static class the same way as, for example, C# does. Those constructs only exist because those languages force all data and functions to be inside a class; because that restriction doesnt exist in TypeScript, theres no need for them. A class with only a single instance is typically just represented as a normal object in JavaScript/TypeScript. For example, we dont need a static class syntax in TypeScript because a regular object (or even top-level function) will do the job just as well: ts// Unnecessary \"static\" classclass MyStaticClass { static doSomething() {}} // Preferred (alternative 1)function doSomething() {} // Preferred (alternative 2)const MyHelperObject = { dosomething() {},};Try static Blocks in Classes Static blocks allow you to write a sequence of statements with their own scope that can access private fields within the containing class. This means that we can write initialization code with all the capabilities of writing statements, no leakage of variables, and full access to our classs internals. tsclass Foo { static #count = 0; get count() { return Foo.#count; } static { try { const lastInstances = loadLastInstances(); Foo.#count += lastInstances.length; } catch {} }}Try Generic Classes Classes, much like interfaces, can be generic. When a generic class is instantiated with new, its type parameters are inferred the same way as in a function call: tsclass BoxType { contents: Type; constructor(value: Type) { this.contents = value; }} const b = new Box(\"hello!\"); const b: BoxstringTry Classes can use generic constraints and defaults the same way as interfaces. Type Parameters in Static Members This code isnt legal, and it may not be obvious why: tsclass BoxType { static defaultValue: Type;Static members cannot reference class type parameters.2302Static members cannot reference class type parameters.}Try Remember that types are always fully erased! At runtime, theres only one Box.defaultValue property slot. This means that setting Boxstring.defaultValue (if that were possible) would also change Boxnumber.defaultValue - not good. The static members of a generic class can never refer to the classs type parameters. this at Runtime in Classes Background Reading: this keyword (MDN) Its important to remember that TypeScript doesnt change the runtime behavior of JavaScript, and that JavaScript is somewhat famous for having some peculiar runtime behaviors. JavaScripts handling of this is indeed unusual: tsclass MyClass { name = \"MyClass\"; getName() { return this.name; }}const c = new MyClass();const obj = { name: \"obj\", getName: c.getName,}; // Prints \"obj\", not \"MyClass\"console.log(obj.getName());Try Long story short, by default, the value of this inside a function depends on how the function was called. In this example, because the function was called through the obj reference, its value of this was obj rather than the class instance. This is rarely what you want to happen! TypeScript provides some ways to mitigate or prevent this kind of error. Arrow Functions Background Reading: Arrow functions (MDN) If you have a function that will often be called in a way that loses its this context, it can make sense to use an arrow function property instead of a method definition: tsclass MyClass { name = \"MyClass\"; getName = () = { return this.name; };}const c = new MyClass();const g = c.getName;// Prints \"MyClass\" instead of crashingconsole.log(g());Try This has some trade-offs: The this value is guaranteed to be correct at runtime, even for code not checked with TypeScript This will use more memory, because each class instance will have its own copy of each function defined this way You cant use super.getName in a derived class, because theres no entry in the prototype chain to fetch the base class method from this parameters In a method or function definition, an initial parameter named this has special meaning in TypeScript. These parameters are erased during compilation: ts// TypeScript input with 'this' parameterfunction fn(this: SomeType, x: number) { /* ... */}Try js// JavaScript outputfunction fn(x) { /* ... */} TypeScript checks that calling a function with a this parameter is done so with a correct context. Instead of using an arrow function, we can add a this parameter to method definitions to statically enforce that the method is called correctly: tsclass MyClass { name = \"MyClass\"; getName(this: MyClass) { return this.name; }}const c = new MyClass();// OKc.getName(); // Error, would crashconst g = c.getName;console.log(g());The 'this' context of type 'void' is not assignable to method's 'this' of type 'MyClass'.2684The 'this' context of type 'void' is not assignable to method's 'this' of type 'MyClass'.Try This method makes the opposite trade-offs of the arrow function approach: JavaScript callers might still use the class method incorrectly without realizing it Only one function per class definition gets allocated, rather than one per class instance Base method definitions can still be called via super. this Types In classes, a special type called this refers dynamically to the type of the current class. Lets see how this is useful: tsclass Box { contents: string = \"\"; set(value: string) { (method) Box.set(value: string): this this.contents = value; return this; }}Try Here, TypeScript inferred the return type of set to be this, rather than Box. Now lets make a subclass of Box: tsclass ClearableBox extends Box { clear() { this.contents = \"\"; }} const a = new ClearableBox();const b = a.set(\"hello\"); const b: ClearableBoxTry You can also use this in a parameter type annotation: tsclass Box { content: string = \"\"; sameAs(other: this) { return other.content === this.content; }}Try This is different from writing other: Box  if you have a derived class, its sameAs method will now only accept other instances of that same derived class: tsclass Box { content: string = \"\"; sameAs(other: this) { return other.content === this.content; }} class DerivedBox extends Box { otherContent: string = \"?\";} const base = new Box();const derived = new DerivedBox();derived.sameAs(base);Argument of type 'Box' is not assignable to parameter of type 'DerivedBox'. Property 'otherContent' is missing in type 'Box' but required in type 'DerivedBox'.2345Argument of type 'Box' is not assignable to parameter of type 'DerivedBox'. Property 'otherContent' is missing in type 'Box' but required in type 'DerivedBox'.Try this-based type guards You can use this is Type in the return position for methods in classes and interfaces. When mixed with a type narrowing (e.g. if statements) the type of the target object would be narrowed to the specified Type. tsclass FileSystemObject { isFile(): this is FileRep { return this instanceof FileRep; } isDirectory(): this is Directory { return this instanceof Directory; } isNetworked(): this is Networked & this { return this.networked; } constructor(public path: string, private networked: boolean) {}} class FileRep extends FileSystemObject { constructor(path: string, public content: string) { super(path, false); }} class Directory extends FileSystemObject { children: FileSystemObject[];} interface Networked { host: string;} const fso: FileSystemObject = new FileRep(\"foo/bar.txt\", \"foo\"); if (fso.isFile()) { fso.content; const fso: FileRep} else if (fso.isDirectory()) { fso.children; const fso: Directory} else if (fso.isNetworked()) { fso.host; const fso: Networked & FileSystemObject}Try A common use-case for a this-based type guard is to allow for lazy validation of a particular field. For example, this case removes an undefined from the value held inside box when hasValue has been verified to be true: tsclass BoxT { value?: T; hasValue(): this is { value: T } { return this.value !== undefined; }} const box = new Boxstring();box.value = \"Gameboy\"; box.value; (property) Boxstring.value?: string if (box.hasValue()) { box.value; (property) value: string}Try Parameter Properties TypeScript offers special syntax for turning a constructor parameter into a class property with the same name and value. These are called parameter properties and are created by prefixing a constructor argument with one of the visibility modifiers public, private, protected, or readonly. The resulting field gets those modifier(s): tsclass Params { constructor( public readonly x: number, protected y: number, private z: number ) { // No body necessary }}const a = new Params(1, 2, 3);console.log(a.x); (property) Params.x: numberconsole.log(a.z);Property 'z' is private and only accessible within class 'Params'.2341Property 'z' is private and only accessible within class 'Params'.Try Class Expressions Background Reading: Class expressions (MDN) Class expressions are very similar to class declarations. The only real difference is that class expressions dont need a name, though we can refer to them via whatever identifier they ended up bound to: tsconst someClass = classType { content: Type; constructor(value: Type) { this.content = value; }}; const m = new someClass(\"Hello, world\"); const m: someClassstringTry Constructor Signatures JavaScript classes are instantiated with the new operator. Given the type of a class itself, the InstanceType utility type models this operation. tsclass Point { createdAt: number; x: number; y: number constructor(x: number, y: number) { this.createdAt = Date.now() this.x = x; this.y = y; }}type PointInstance = InstanceTypetypeof Point function moveRight(point: PointInstance) { point.x += 5;} const point = new Point(3, 4);moveRight(point);point.x; // = 8Try abstract Classes and Members Classes, methods, and fields in TypeScript may be abstract. An abstract method or abstract field is one that hasnt had an implementation provided. These members must exist inside an abstract class, which cannot be directly instantiated. The role of abstract classes is to serve as a base class for subclasses which do implement all the abstract members. When a class doesnt have any abstract members, it is said to be concrete. Lets look at an example: tsabstract class Base { abstract getName(): string; printName() { console.log(\"Hello, \" + this.getName()); }} const b = new Base();Cannot create an instance of an abstract class.2511Cannot create an instance of an abstract class.Try We cant instantiate Base with new because its abstract. Instead, we need to make a derived class and implement the abstract members: tsclass Derived extends Base { getName() { return \"world\"; }} const d = new Derived();d.printName();Try Notice that if we forget to implement the base classs abstract members, well get an error: tsclass Derived extends Base {Non-abstract class 'Derived' does not implement inherited abstract member getName from class 'Base'.2515Non-abstract class 'Derived' does not implement inherited abstract member getName from class 'Base'. // forgot to do anything}Try Abstract Construct Signatures Sometimes you want to accept some class constructor function that produces an instance of a class which derives from some abstract class. For example, you might want to write this code: tsfunction greet(ctor: typeof Base) { const instance = new ctor();Cannot create an instance of an abstract class.2511Cannot create an instance of an abstract class. instance.printName();}Try TypeScript is correctly telling you that youre trying to instantiate an abstract class. After all, given the definition of greet, its perfectly legal to write this code, which would end up constructing an abstract class: ts// Bad!greet(Base);Try Instead, you want to write a function that accepts something with a construct signature: tsfunction greet(ctor: new () = Base) { const instance = new ctor(); instance.printName();}greet(Derived);greet(Base);Argument of type 'typeof Base' is not assignable to parameter of type 'new () = Base'. Cannot assign an abstract constructor type to a non-abstract constructor type.2345Argument of type 'typeof Base' is not assignable to parameter of type 'new () = Base'. Cannot assign an abstract constructor type to a non-abstract constructor type.Try Now TypeScript correctly tells you about which class constructor functions can be invoked - Derived can because its concrete, but Base cannot. Relationships Between Classes In most cases, classes in TypeScript are compared structurally, the same as other types. For example, these two classes can be used in place of each other because theyre identical: tsclass Point1 { x = 0; y = 0;} class Point2 { x = 0; y = 0;} // OKconst p: Point1 = new Point2();Try Similarly, subtype relationships between classes exist even if theres no explicit inheritance: tsclass Person { name: string; age: number;} class Employee { name: string; age: number; salary: number;} // OKconst p: Person = new Employee();Try This sounds straightforward, but there are a few cases that seem stranger than others. Empty classes have no members. In a structural type system, a type with no members is generally a supertype of anything else. So if you write an empty class (dont!), anything can be used in place of it: tsclass Empty {} function fn(x: Empty) { // can't do anything with 'x', so I won't} // All OK!fn(window);fn({});fn(fn);Try",
    "headings": [
      {
        "level": 2,
        "text": "Class Members",
        "id": "class-members"
      },
      {
        "level": 2,
        "text": "Class Heritage",
        "id": "class-heritage"
      },
      {
        "level": 2,
        "text": "Member Visibility",
        "id": "member-visibility"
      },
      {
        "level": 2,
        "text": "Static Members",
        "id": "static-members"
      },
      {
        "level": 2,
        "text": "static Blocks in Classes",
        "id": "static-blocks-in-classes"
      },
      {
        "level": 2,
        "text": "Generic Classes",
        "id": "generic-classes"
      },
      {
        "level": 2,
        "text": "this at Runtime in Classes",
        "id": "this-at-runtime-in-classes"
      },
      {
        "level": 2,
        "text": "this Types",
        "id": "this-types"
      },
      {
        "level": 2,
        "text": "Parameter Properties",
        "id": "parameter-properties"
      },
      {
        "level": 2,
        "text": "Class Expressions",
        "id": "class-expressions"
      },
      {
        "level": 2,
        "text": "Constructor Signatures",
        "id": "constructor-signatures"
      },
      {
        "level": 2,
        "text": "abstract Classes and Members",
        "id": "abstract-classes-and-members"
      },
      {
        "level": 2,
        "text": "Relationships Between Classes",
        "id": "relationships-between-classes"
      },
      {
        "level": 3,
        "text": "Fields",
        "id": "fields"
      },
      {
        "level": 3,
        "text": "readonly",
        "id": "readonly"
      },
      {
        "level": 3,
        "text": "Constructors",
        "id": "constructors"
      },
      {
        "level": 3,
        "text": "Methods",
        "id": "methods"
      },
      {
        "level": 3,
        "text": "Getters / Setters",
        "id": "getters--setters"
      },
      {
        "level": 3,
        "text": "Index Signatures",
        "id": "index-signatures"
      },
      {
        "level": 3,
        "text": "implements Clauses",
        "id": "implements-clauses"
      },
      {
        "level": 3,
        "text": "extends Clauses",
        "id": "extends-clauses"
      },
      {
        "level": 3,
        "text": "public",
        "id": "public"
      },
      {
        "level": 3,
        "text": "protected",
        "id": "protected"
      },
      {
        "level": 3,
        "text": "private",
        "id": "private"
      },
      {
        "level": 3,
        "text": "Special Static Names",
        "id": "special-static-names"
      },
      {
        "level": 3,
        "text": "Why No Static Classes?",
        "id": "why-no-static-classes"
      },
      {
        "level": 3,
        "text": "Type Parameters in Static Members",
        "id": "type-parameters-in-static-members"
      },
      {
        "level": 3,
        "text": "Arrow Functions",
        "id": "arrow-functions"
      },
      {
        "level": 3,
        "text": "this parameters",
        "id": "this-parameters"
      },
      {
        "level": 3,
        "text": "this-based type guards",
        "id": "this-based-type-guards"
      },
      {
        "level": 3,
        "text": "Abstract Construct Signatures",
        "id": "abstract-construct-signatures"
      },
      {
        "level": 4,
        "text": "--strictPropertyInitialization",
        "id": "--strictpropertyinitialization"
      },
      {
        "level": 4,
        "text": "Super Calls",
        "id": "super-calls"
      },
      {
        "level": 4,
        "text": "Cautions",
        "id": "cautions"
      },
      {
        "level": 4,
        "text": "Overriding Methods",
        "id": "overriding-methods"
      },
      {
        "level": 4,
        "text": "Type-only Field Declarations",
        "id": "type-only-field-declarations"
      },
      {
        "level": 4,
        "text": "Initialization Order",
        "id": "initialization-order"
      },
      {
        "level": 4,
        "text": "Inheriting Built-in Types",
        "id": "inheriting-built-in-types"
      },
      {
        "level": 4,
        "text": "Exposure of protected members",
        "id": "exposure-of-protected-members"
      },
      {
        "level": 4,
        "text": "Cross-hierarchy protected access",
        "id": "cross-hierarchy-protected-access"
      },
      {
        "level": 4,
        "text": "Cross-instance private access",
        "id": "cross-instance-private-access"
      },
      {
        "level": 4,
        "text": "Caveats",
        "id": "caveats"
      }
    ],
    "codeBlocks": [
      {
        "language": "text",
        "code": "tsclass Point {}Try"
      },
      {
        "language": "text",
        "code": "class Point {}"
      },
      {
        "language": "text",
        "code": "tsclass Point {  x: number;  y: number;} const pt = new Point();pt.x = 0;pt.y = 0;Try"
      },
      {
        "language": "text",
        "code": "class Point {  x: number;  y: number;} const pt = new Point();pt.x = 0;pt.y = 0;"
      },
      {
        "language": "text",
        "code": "tsclass Point {  x = 0;  y = 0;} const pt = new Point();// Prints 0, 0console.log(`${pt.x}, ${pt.y}`);Try"
      },
      {
        "language": "text",
        "code": "class Point {  x = 0;  y = 0;} const pt = new Point();// Prints 0, 0console.log(`${pt.x}, ${pt.y}`);"
      },
      {
        "language": "text",
        "code": "tsconst pt = new Point();pt.x = \"0\";Type 'string' is not assignable to type 'number'.2322Type 'string' is not assignable to type 'number'.Try"
      },
      {
        "language": "text",
        "code": "const pt = new Point();pt.x = \"0\";Type 'string' is not assignable to type 'number'.2322Type 'string' is not assignable to type 'number'."
      },
      {
        "language": "text",
        "code": "--strictPropertyInitialization"
      },
      {
        "language": "text",
        "code": "strictPropertyInitialization"
      },
      {
        "language": "text",
        "code": "tsclass BadGreeter {  name: string;Property 'name' has no initializer and is not definitely assigned in the constructor.2564Property 'name' has no initializer and is not definitely assigned in the constructor.}Try"
      },
      {
        "language": "text",
        "code": "class BadGreeter {  name: string;Property 'name' has no initializer and is not definitely assigned in the constructor.2564Property 'name' has no initializer and is not definitely assigned in the constructor.}"
      },
      {
        "language": "text",
        "code": "tsclass GoodGreeter {  name: string;   constructor() {    this.name = \"hello\";  }}Try"
      },
      {
        "language": "text",
        "code": "class GoodGreeter {  name: string;   constructor() {    this.name = \"hello\";  }}"
      },
      {
        "language": "text",
        "code": "tsclass OKGreeter {  // Not initialized, but no error  name!: string;}Try"
      },
      {
        "language": "text",
        "code": "class OKGreeter {  // Not initialized, but no error  name!: string;}"
      },
      {
        "language": "text",
        "code": "tsclass Greeter {  readonly name: string = \"world\";   constructor(otherName?: string) {    if (otherName !== undefined) {      this.name = otherName;    }  }   err() {    this.name = \"not ok\";Cannot assign to 'name' because it is a read-only property.2540Cannot assign to 'name' because it is a read-only property.  }}const g = new Greeter();g.name = \"also not ok\";Cannot assign to 'name' because it is a read-only property.2540Cannot assign to 'name' because it is a read-only property.Try"
      },
      {
        "language": "text",
        "code": "class Greeter {  readonly name: string = \"world\";   constructor(otherName?: string) {    if (otherName !== undefined) {      this.name = otherName;    }  }   err() {    this.name = \"not ok\";Cannot assign to 'name' because it is a read-only property.2540Cannot assign to 'name' because it is a read-only property.  }}const g = new Greeter();g.name = \"also not ok\";Cannot assign to 'name' because it is a read-only property.2540Cannot assign to 'name' because it is a read-only property."
      },
      {
        "language": "text",
        "code": "tsclass Point {  x: number;  y: number;   // Normal signature with defaults  constructor(x = 0, y = 0) {    this.x = x;    this.y = y;  }}Try"
      },
      {
        "language": "text",
        "code": "class Point {  x: number;  y: number;   // Normal signature with defaults  constructor(x = 0, y = 0) {    this.x = x;    this.y = y;  }}"
      },
      {
        "language": "text",
        "code": "tsclass Point {  x: number = 0;  y: number = 0;   // Constructor overloads  constructor(x: number, y: number);  constructor(xy: string);  constructor(x: string | number, y: number = 0) {    // Code logic here  }}Try"
      },
      {
        "language": "text",
        "code": "class Point {  x: number = 0;  y: number = 0;   // Constructor overloads  constructor(x: number, y: number);  constructor(xy: string);  constructor(x: string | number, y: number = 0) {    // Code logic here  }}"
      },
      {
        "language": "text",
        "code": "tsclass Base {  k = 4;} class Derived extends Base {  constructor() {    // Prints a wrong value in ES5; throws exception in ES6    console.log(this.k);'super' must be called before accessing 'this' in the constructor of a derived class.17009'super' must be called before accessing 'this' in the constructor of a derived class.    super();  }}Try"
      },
      {
        "language": "text",
        "code": "class Base {  k = 4;} class Derived extends Base {  constructor() {    // Prints a wrong value in ES5; throws exception in ES6    console.log(this.k);'super' must be called before accessing 'this' in the constructor of a derived class.17009'super' must be called before accessing 'this' in the constructor of a derived class.    super();  }}"
      },
      {
        "language": "text",
        "code": "tsclass Point {  x = 10;  y = 10;   scale(n: number): void {    this.x *= n;    this.y *= n;  }}Try"
      },
      {
        "language": "text",
        "code": "class Point {  x = 10;  y = 10;   scale(n: number): void {    this.x *= n;    this.y *= n;  }}"
      },
      {
        "language": "text",
        "code": "tslet x: number = 0; class C {  x: string = \"hello\";   m() {    // This is trying to modify 'x' from line 1, not the class property    x = \"world\";Type 'string' is not assignable to type 'number'.2322Type 'string' is not assignable to type 'number'.  }}Try"
      },
      {
        "language": "text",
        "code": "let x: number = 0; class C {  x: string = \"hello\";   m() {    // This is trying to modify 'x' from line 1, not the class property    x = \"world\";Type 'string' is not assignable to type 'number'.2322Type 'string' is not assignable to type 'number'.  }}"
      },
      {
        "language": "text",
        "code": "tsclass C {  _length = 0;  get length() {    return this._length;  }  set length(value) {    this._length = value;  }}Try"
      },
      {
        "language": "text",
        "code": "class C {  _length = 0;  get length() {    return this._length;  }  set length(value) {    this._length = value;  }}"
      },
      {
        "language": "text",
        "code": "tsclass Thing {  _size = 0;   get size(): number {    return this._size;  }   set size(value: string | number | boolean) {    let num = Number(value);     // Don't allow NaN, Infinity, etc     if (!Number.isFinite(num)) {      this._size = 0;      return;    }     this._size = num;  }}Try"
      },
      {
        "language": "text",
        "code": "class Thing {  _size = 0;   get size(): number {    return this._size;  }   set size(value: string | number | boolean) {    let num = Number(value);     // Don't allow NaN, Infinity, etc     if (!Number.isFinite(num)) {      this._size = 0;      return;    }     this._size = num;  }}"
      },
      {
        "language": "text",
        "code": "tsclass MyClass {  [s: string]: boolean | ((s: string) => boolean);   check(s: string) {    return this[s] as boolean;  }}Try"
      },
      {
        "language": "text",
        "code": "class MyClass {  [s: string]: boolean | ((s: string) => boolean);   check(s: string) {    return this[s] as boolean;  }}"
      },
      {
        "language": "text",
        "code": "tsinterface Pingable {  ping(): void;} class Sonar implements Pingable {  ping() {    console.log(\"ping!\");  }} class Ball implements Pingable {Class 'Ball' incorrectly implements interface 'Pingable'.\n  Property 'ping' is missing in type 'Ball' but required in type 'Pingable'.2420Class 'Ball' incorrectly implements interface 'Pingable'.\n  Property 'ping' is missing in type 'Ball' but required in type 'Pingable'.  pong() {    console.log(\"pong!\");  }}Try"
      },
      {
        "language": "text",
        "code": "interface Pingable {  ping(): void;} class Sonar implements Pingable {  ping() {    console.log(\"ping!\");  }} class Ball implements Pingable {Class 'Ball' incorrectly implements interface 'Pingable'.\n  Property 'ping' is missing in type 'Ball' but required in type 'Pingable'.2420Class 'Ball' incorrectly implements interface 'Pingable'.\n  Property 'ping' is missing in type 'Ball' but required in type 'Pingable'.  pong() {    console.log(\"pong!\");  }}"
      },
      {
        "language": "text",
        "code": "class C implements A, B {"
      },
      {
        "language": "text",
        "code": "tsinterface Checkable {  check(name: string): boolean;} class NameChecker implements Checkable {  check(s) {Parameter 's' implicitly has an 'any' type.7006Parameter 's' implicitly has an 'any' type.    // Notice no error here    return s.toLowerCase() === \"ok\";                 any  }}Try"
      },
      {
        "language": "text",
        "code": "interface Checkable {  check(name: string): boolean;} class NameChecker implements Checkable {  check(s) {Parameter 's' implicitly has an 'any' type.7006Parameter 's' implicitly has an 'any' type.    // Notice no error here    return s.toLowerCase() === \"ok\";                 any  }}"
      },
      {
        "language": "text",
        "code": "name: string"
      },
      {
        "language": "text",
        "code": "tsinterface A {  x: number;  y?: number;}class C implements A {  x = 0;}const c = new C();c.y = 10;Property 'y' does not exist on type 'C'.2339Property 'y' does not exist on type 'C'.Try"
      },
      {
        "language": "text",
        "code": "interface A {  x: number;  y?: number;}class C implements A {  x = 0;}const c = new C();c.y = 10;Property 'y' does not exist on type 'C'.2339Property 'y' does not exist on type 'C'."
      },
      {
        "language": "text",
        "code": "tsclass Animal {  move() {    console.log(\"Moving along!\");  }} class Dog extends Animal {  woof(times: number) {    for (let i = 0; i < times; i++) {      console.log(\"woof!\");    }  }} const d = new Dog();// Base class methodd.move();// Derived class methodd.woof(3);Try"
      },
      {
        "language": "text",
        "code": "class Animal {  move() {    console.log(\"Moving along!\");  }} class Dog extends Animal {  woof(times: number) {    for (let i = 0; i < times; i++) {      console.log(\"woof!\");    }  }} const d = new Dog();// Base class methodd.move();// Derived class methodd.woof(3);"
      },
      {
        "language": "text",
        "code": "tsclass Base {  greet() {    console.log(\"Hello, world!\");  }} class Derived extends Base {  greet(name?: string) {    if (name === undefined) {      super.greet();    } else {      console.log(`Hello, ${name.toUpperCase()}`);    }  }} const d = new Derived();d.greet();d.greet(\"reader\");Try"
      },
      {
        "language": "text",
        "code": "class Base {  greet() {    console.log(\"Hello, world!\");  }} class Derived extends Base {  greet(name?: string) {    if (name === undefined) {      super.greet();    } else {      console.log(`Hello, ${name.toUpperCase()}`);    }  }} const d = new Derived();d.greet();d.greet(\"reader\");"
      },
      {
        "language": "text",
        "code": "ts// Alias the derived instance through a base class referenceconst b: Base = d;// No problemb.greet();Try"
      },
      {
        "language": "text",
        "code": "// Alias the derived instance through a base class referenceconst b: Base = d;// No problemb.greet();"
      },
      {
        "language": "text",
        "code": "tsclass Base {  greet() {    console.log(\"Hello, world!\");  }} class Derived extends Base {  // Make this parameter required  greet(name: string) {Property 'greet' in type 'Derived' is not assignable to the same property in base type 'Base'.\n  Type '(name: string) => void' is not assignable to type '() => void'.\n    Target signature provides too few arguments. Expected 1 or more, but got 0.2416Property 'greet' in type 'Derived' is not assignable to the same property in base type 'Base'.\n  Type '(name: string) => void' is not assignable to type '() => void'.\n    Target signature provides too few arguments. Expected 1 or more, but got 0.    console.log(`Hello, ${name.toUpperCase()}`);  }}Try"
      },
      {
        "language": "text",
        "code": "class Base {  greet() {    console.log(\"Hello, world!\");  }} class Derived extends Base {  // Make this parameter required  greet(name: string) {Property 'greet' in type 'Derived' is not assignable to the same property in base type 'Base'.\n  Type '(name: string) => void' is not assignable to type '() => void'.\n    Target signature provides too few arguments. Expected 1 or more, but got 0.2416Property 'greet' in type 'Derived' is not assignable to the same property in base type 'Base'.\n  Type '(name: string) => void' is not assignable to type '() => void'.\n    Target signature provides too few arguments. Expected 1 or more, but got 0.    console.log(`Hello, ${name.toUpperCase()}`);  }}"
      },
      {
        "language": "text",
        "code": "tsconst b: Base = new Derived();// Crashes because \"name\" will be undefinedb.greet();Try"
      },
      {
        "language": "text",
        "code": "const b: Base = new Derived();// Crashes because \"name\" will be undefinedb.greet();"
      },
      {
        "language": "text",
        "code": "target >= ES2022"
      },
      {
        "language": "text",
        "code": "useDefineForClassFields"
      },
      {
        "language": "text",
        "code": "tsinterface Animal {  dateOfBirth: any;} interface Dog extends Animal {  breed: any;} class AnimalHouse {  resident: Animal;  constructor(animal: Animal) {    this.resident = animal;  }} class DogHouse extends AnimalHouse {  // Does not emit JavaScript code,  // only ensures the types are correct  declare resident: Dog;  constructor(dog: Dog) {    super(dog);  }}Try"
      },
      {
        "language": "text",
        "code": "interface Animal {  dateOfBirth: any;} interface Dog extends Animal {  breed: any;} class AnimalHouse {  resident: Animal;  constructor(animal: Animal) {    this.resident = animal;  }} class DogHouse extends AnimalHouse {  // Does not emit JavaScript code,  // only ensures the types are correct  declare resident: Dog;  constructor(dog: Dog) {    super(dog);  }}"
      },
      {
        "language": "text",
        "code": "tsclass Base {  name = \"base\";  constructor() {    console.log(\"My name is \" + this.name);  }} class Derived extends Base {  name = \"derived\";} // Prints \"base\", not \"derived\"const d = new Derived();Try"
      },
      {
        "language": "text",
        "code": "class Base {  name = \"base\";  constructor() {    console.log(\"My name is \" + this.name);  }} class Derived extends Base {  name = \"derived\";} // Prints \"base\", not \"derived\"const d = new Derived();"
      },
      {
        "language": "text",
        "code": "tsclass MsgError extends Error {  constructor(m: string) {    super(m);  }  sayHello() {    return \"hello \" + this.message;  }}Try"
      },
      {
        "language": "text",
        "code": "class MsgError extends Error {  constructor(m: string) {    super(m);  }  sayHello() {    return \"hello \" + this.message;  }}"
      },
      {
        "language": "text",
        "code": "(new MsgError()) instanceof MsgError"
      },
      {
        "language": "text",
        "code": "tsclass MsgError extends Error {  constructor(m: string) {    super(m);     // Set the prototype explicitly.    Object.setPrototypeOf(this, MsgError.prototype);  }   sayHello() {    return \"hello \" + this.message;  }}Try"
      },
      {
        "language": "text",
        "code": "class MsgError extends Error {  constructor(m: string) {    super(m);     // Set the prototype explicitly.    Object.setPrototypeOf(this, MsgError.prototype);  }   sayHello() {    return \"hello \" + this.message;  }}"
      },
      {
        "language": "text",
        "code": "Object.setPrototypeOf"
      },
      {
        "language": "text",
        "code": "MsgError.prototype"
      },
      {
        "language": "text",
        "code": "tsclass Greeter {  public greet() {    console.log(\"hi!\");  }}const g = new Greeter();g.greet();Try"
      },
      {
        "language": "text",
        "code": "class Greeter {  public greet() {    console.log(\"hi!\");  }}const g = new Greeter();g.greet();"
      },
      {
        "language": "text",
        "code": "tsclass Greeter {  public greet() {    console.log(\"Hello, \" + this.getName());  }  protected getName() {    return \"hi\";  }} class SpecialGreeter extends Greeter {  public howdy() {    // OK to access protected member here    console.log(\"Howdy, \" + this.getName());  }}const g = new SpecialGreeter();g.greet(); // OKg.getName();Property 'getName' is protected and only accessible within class 'Greeter' and its subclasses.2445Property 'getName' is protected and only accessible within class 'Greeter' and its subclasses.Try"
      },
      {
        "language": "text",
        "code": "class Greeter {  public greet() {    console.log(\"Hello, \" + this.getName());  }  protected getName() {    return \"hi\";  }} class SpecialGreeter extends Greeter {  public howdy() {    // OK to access protected member here    console.log(\"Howdy, \" + this.getName());  }}const g = new SpecialGreeter();g.greet(); // OKg.getName();Property 'getName' is protected and only accessible within class 'Greeter' and its subclasses.2445Property 'getName' is protected and only accessible within class 'Greeter' and its subclasses."
      },
      {
        "language": "text",
        "code": "tsclass Base {  protected m = 10;}class Derived extends Base {  // No modifier, so default is 'public'  m = 15;}const d = new Derived();console.log(d.m); // OKTry"
      },
      {
        "language": "text",
        "code": "class Base {  protected m = 10;}class Derived extends Base {  // No modifier, so default is 'public'  m = 15;}const d = new Derived();console.log(d.m); // OK"
      },
      {
        "language": "text",
        "code": "tsclass Base {  protected x: number = 1;}class Derived1 extends Base {  protected x: number = 5;}class Derived2 extends Base {  f1(other: Derived2) {    other.x = 10;  }  f2(other: Derived1) {    other.x = 10;Property 'x' is protected and only accessible within class 'Derived1' and its subclasses.2445Property 'x' is protected and only accessible within class 'Derived1' and its subclasses.  }}Try"
      },
      {
        "language": "text",
        "code": "class Base {  protected x: number = 1;}class Derived1 extends Base {  protected x: number = 5;}class Derived2 extends Base {  f1(other: Derived2) {    other.x = 10;  }  f2(other: Derived1) {    other.x = 10;Property 'x' is protected and only accessible within class 'Derived1' and its subclasses.2445Property 'x' is protected and only accessible within class 'Derived1' and its subclasses.  }}"
      },
      {
        "language": "text",
        "code": "tsclass Base {  private x = 0;}const b = new Base();// Can't access from outside the classconsole.log(b.x);Property 'x' is private and only accessible within class 'Base'.2341Property 'x' is private and only accessible within class 'Base'.Try"
      },
      {
        "language": "text",
        "code": "class Base {  private x = 0;}const b = new Base();// Can't access from outside the classconsole.log(b.x);Property 'x' is private and only accessible within class 'Base'.2341Property 'x' is private and only accessible within class 'Base'."
      },
      {
        "language": "text",
        "code": "tsclass Derived extends Base {  showX() {    // Can't access in subclasses    console.log(this.x);Property 'x' is private and only accessible within class 'Base'.2341Property 'x' is private and only accessible within class 'Base'.  }}Try"
      },
      {
        "language": "text",
        "code": "class Derived extends Base {  showX() {    // Can't access in subclasses    console.log(this.x);Property 'x' is private and only accessible within class 'Base'.2341Property 'x' is private and only accessible within class 'Base'.  }}"
      },
      {
        "language": "text",
        "code": "tsclass Base {  private x = 0;}class Derived extends Base {Class 'Derived' incorrectly extends base class 'Base'.\n  Property 'x' is private in type 'Base' but not in type 'Derived'.2415Class 'Derived' incorrectly extends base class 'Base'.\n  Property 'x' is private in type 'Base' but not in type 'Derived'.  x = 1;}Try"
      },
      {
        "language": "text",
        "code": "class Base {  private x = 0;}class Derived extends Base {Class 'Derived' incorrectly extends base class 'Base'.\n  Property 'x' is private in type 'Base' but not in type 'Derived'.2415Class 'Derived' incorrectly extends base class 'Base'.\n  Property 'x' is private in type 'Base' but not in type 'Derived'.  x = 1;}"
      },
      {
        "language": "text",
        "code": "tsclass A {  private x = 10;   public sameAs(other: A) {    // No error    return other.x === this.x;  }}Try"
      },
      {
        "language": "text",
        "code": "class A {  private x = 10;   public sameAs(other: A) {    // No error    return other.x === this.x;  }}"
      },
      {
        "language": "text",
        "code": "tsclass MySafe {  private secretKey = 12345;}Try"
      },
      {
        "language": "text",
        "code": "class MySafe {  private secretKey = 12345;}"
      },
      {
        "language": "text",
        "code": "js// In a JavaScript file...const s = new MySafe();// Will print 12345console.log(s.secretKey);"
      },
      {
        "language": "text",
        "code": "// In a JavaScript file...const s = new MySafe();// Will print 12345console.log(s.secretKey);"
      },
      {
        "language": "text",
        "code": "tsclass MySafe {  private secretKey = 12345;} const s = new MySafe(); // Not allowed during type checkingconsole.log(s.secretKey);Property 'secretKey' is private and only accessible within class 'MySafe'.2341Property 'secretKey' is private and only accessible within class 'MySafe'. // OKconsole.log(s[\"secretKey\"]);Try"
      },
      {
        "language": "text",
        "code": "class MySafe {  private secretKey = 12345;} const s = new MySafe(); // Not allowed during type checkingconsole.log(s.secretKey);Property 'secretKey' is private and only accessible within class 'MySafe'.2341Property 'secretKey' is private and only accessible within class 'MySafe'. // OKconsole.log(s[\"secretKey\"]);"
      },
      {
        "language": "text",
        "code": "tsclass Dog {  #barkAmount = 0;  personality = \"happy\";   constructor() {}}Try"
      },
      {
        "language": "text",
        "code": "class Dog {  #barkAmount = 0;  personality = \"happy\";   constructor() {}}"
      },
      {
        "language": "text",
        "code": "ts\"use strict\";class Dog {    #barkAmount = 0;    personality = \"happy\";    constructor() { }} Try"
      },
      {
        "language": "text",
        "code": "\"use strict\";class Dog {    #barkAmount = 0;    personality = \"happy\";    constructor() { }}"
      },
      {
        "language": "text",
        "code": "ts\"use strict\";var _Dog_barkAmount;class Dog {    constructor() {        _Dog_barkAmount.set(this, 0);        this.personality = \"happy\";    }}_Dog_barkAmount = new WeakMap(); Try"
      },
      {
        "language": "text",
        "code": "\"use strict\";var _Dog_barkAmount;class Dog {    constructor() {        _Dog_barkAmount.set(this, 0);        this.personality = \"happy\";    }}_Dog_barkAmount = new WeakMap();"
      },
      {
        "language": "text",
        "code": "tsclass MyClass {  static x = 0;  static printX() {    console.log(MyClass.x);  }}console.log(MyClass.x);MyClass.printX();Try"
      },
      {
        "language": "text",
        "code": "class MyClass {  static x = 0;  static printX() {    console.log(MyClass.x);  }}console.log(MyClass.x);MyClass.printX();"
      },
      {
        "language": "text",
        "code": "tsclass MyClass {  private static x = 0;}console.log(MyClass.x);Property 'x' is private and only accessible within class 'MyClass'.2341Property 'x' is private and only accessible within class 'MyClass'.Try"
      },
      {
        "language": "text",
        "code": "class MyClass {  private static x = 0;}console.log(MyClass.x);Property 'x' is private and only accessible within class 'MyClass'.2341Property 'x' is private and only accessible within class 'MyClass'."
      },
      {
        "language": "text",
        "code": "tsclass Base {  static getGreeting() {    return \"Hello world\";  }}class Derived extends Base {  myGreeting = Derived.getGreeting();}Try"
      },
      {
        "language": "text",
        "code": "class Base {  static getGreeting() {    return \"Hello world\";  }}class Derived extends Base {  myGreeting = Derived.getGreeting();}"
      },
      {
        "language": "text",
        "code": "tsclass S {  static name = \"S!\";Static property 'name' conflicts with built-in property 'Function.name' of constructor function 'S'.2699Static property 'name' conflicts with built-in property 'Function.name' of constructor function 'S'.}Try"
      },
      {
        "language": "text",
        "code": "class S {  static name = \"S!\";Static property 'name' conflicts with built-in property 'Function.name' of constructor function 'S'.2699Static property 'name' conflicts with built-in property 'Function.name' of constructor function 'S'.}"
      },
      {
        "language": "text",
        "code": "static class"
      },
      {
        "language": "text",
        "code": "ts// Unnecessary \"static\" classclass MyStaticClass {  static doSomething() {}} // Preferred (alternative 1)function doSomething() {} // Preferred (alternative 2)const MyHelperObject = {  dosomething() {},};Try"
      },
      {
        "language": "text",
        "code": "// Unnecessary \"static\" classclass MyStaticClass {  static doSomething() {}} // Preferred (alternative 1)function doSomething() {} // Preferred (alternative 2)const MyHelperObject = {  dosomething() {},};"
      },
      {
        "language": "text",
        "code": "tsclass Foo {    static #count = 0;     get count() {        return Foo.#count;    }     static {        try {            const lastInstances = loadLastInstances();            Foo.#count += lastInstances.length;        }        catch {}    }}Try"
      },
      {
        "language": "text",
        "code": "class Foo {    static #count = 0;     get count() {        return Foo.#count;    }     static {        try {            const lastInstances = loadLastInstances();            Foo.#count += lastInstances.length;        }        catch {}    }}"
      },
      {
        "language": "text",
        "code": "tsclass Box<Type> {  contents: Type;  constructor(value: Type) {    this.contents = value;  }} const b = new Box(\"hello!\");     const b: Box<string>Try"
      },
      {
        "language": "text",
        "code": "class Box<Type> {  contents: Type;  constructor(value: Type) {    this.contents = value;  }} const b = new Box(\"hello!\");     const b: Box<string>"
      },
      {
        "language": "text",
        "code": "tsclass Box<Type> {  static defaultValue: Type;Static members cannot reference class type parameters.2302Static members cannot reference class type parameters.}Try"
      },
      {
        "language": "text",
        "code": "class Box<Type> {  static defaultValue: Type;Static members cannot reference class type parameters.2302Static members cannot reference class type parameters.}"
      },
      {
        "language": "text",
        "code": "Box.defaultValue"
      },
      {
        "language": "text",
        "code": "Box<string>.defaultValue"
      },
      {
        "language": "text",
        "code": "Box<number>.defaultValue"
      },
      {
        "language": "text",
        "code": "tsclass MyClass {  name = \"MyClass\";  getName() {    return this.name;  }}const c = new MyClass();const obj = {  name: \"obj\",  getName: c.getName,}; // Prints \"obj\", not \"MyClass\"console.log(obj.getName());Try"
      },
      {
        "language": "text",
        "code": "class MyClass {  name = \"MyClass\";  getName() {    return this.name;  }}const c = new MyClass();const obj = {  name: \"obj\",  getName: c.getName,}; // Prints \"obj\", not \"MyClass\"console.log(obj.getName());"
      },
      {
        "language": "text",
        "code": "tsclass MyClass {  name = \"MyClass\";  getName = () => {    return this.name;  };}const c = new MyClass();const g = c.getName;// Prints \"MyClass\" instead of crashingconsole.log(g());Try"
      },
      {
        "language": "text",
        "code": "class MyClass {  name = \"MyClass\";  getName = () => {    return this.name;  };}const c = new MyClass();const g = c.getName;// Prints \"MyClass\" instead of crashingconsole.log(g());"
      },
      {
        "language": "text",
        "code": "super.getName"
      },
      {
        "language": "text",
        "code": "ts// TypeScript input with 'this' parameterfunction fn(this: SomeType, x: number) {  /* ... */}Try"
      },
      {
        "language": "text",
        "code": "// TypeScript input with 'this' parameterfunction fn(this: SomeType, x: number) {  /* ... */}"
      },
      {
        "language": "text",
        "code": "js// JavaScript outputfunction fn(x) {  /* ... */}"
      },
      {
        "language": "text",
        "code": "// JavaScript outputfunction fn(x) {  /* ... */}"
      },
      {
        "language": "text",
        "code": "tsclass MyClass {  name = \"MyClass\";  getName(this: MyClass) {    return this.name;  }}const c = new MyClass();// OKc.getName(); // Error, would crashconst g = c.getName;console.log(g());The 'this' context of type 'void' is not assignable to method's 'this' of type 'MyClass'.2684The 'this' context of type 'void' is not assignable to method's 'this' of type 'MyClass'.Try"
      },
      {
        "language": "text",
        "code": "class MyClass {  name = \"MyClass\";  getName(this: MyClass) {    return this.name;  }}const c = new MyClass();// OKc.getName(); // Error, would crashconst g = c.getName;console.log(g());The 'this' context of type 'void' is not assignable to method's 'this' of type 'MyClass'.2684The 'this' context of type 'void' is not assignable to method's 'this' of type 'MyClass'."
      },
      {
        "language": "text",
        "code": "tsclass Box {  contents: string = \"\";  set(value: string) {  (method) Box.set(value: string): this    this.contents = value;    return this;  }}Try"
      },
      {
        "language": "text",
        "code": "class Box {  contents: string = \"\";  set(value: string) {  (method) Box.set(value: string): this    this.contents = value;    return this;  }}"
      },
      {
        "language": "text",
        "code": "tsclass ClearableBox extends Box {  clear() {    this.contents = \"\";  }} const a = new ClearableBox();const b = a.set(\"hello\");     const b: ClearableBoxTry"
      },
      {
        "language": "text",
        "code": "class ClearableBox extends Box {  clear() {    this.contents = \"\";  }} const a = new ClearableBox();const b = a.set(\"hello\");     const b: ClearableBox"
      },
      {
        "language": "text",
        "code": "tsclass Box {  content: string = \"\";  sameAs(other: this) {    return other.content === this.content;  }}Try"
      },
      {
        "language": "text",
        "code": "class Box {  content: string = \"\";  sameAs(other: this) {    return other.content === this.content;  }}"
      },
      {
        "language": "text",
        "code": "tsclass Box {  content: string = \"\";  sameAs(other: this) {    return other.content === this.content;  }} class DerivedBox extends Box {  otherContent: string = \"?\";} const base = new Box();const derived = new DerivedBox();derived.sameAs(base);Argument of type 'Box' is not assignable to parameter of type 'DerivedBox'.\n  Property 'otherContent' is missing in type 'Box' but required in type 'DerivedBox'.2345Argument of type 'Box' is not assignable to parameter of type 'DerivedBox'.\n  Property 'otherContent' is missing in type 'Box' but required in type 'DerivedBox'.Try"
      },
      {
        "language": "text",
        "code": "class Box {  content: string = \"\";  sameAs(other: this) {    return other.content === this.content;  }} class DerivedBox extends Box {  otherContent: string = \"?\";} const base = new Box();const derived = new DerivedBox();derived.sameAs(base);Argument of type 'Box' is not assignable to parameter of type 'DerivedBox'.\n  Property 'otherContent' is missing in type 'Box' but required in type 'DerivedBox'.2345Argument of type 'Box' is not assignable to parameter of type 'DerivedBox'.\n  Property 'otherContent' is missing in type 'Box' but required in type 'DerivedBox'."
      },
      {
        "language": "text",
        "code": "this is Type"
      },
      {
        "language": "text",
        "code": "tsclass FileSystemObject {  isFile(): this is FileRep {    return this instanceof FileRep;  }  isDirectory(): this is Directory {    return this instanceof Directory;  }  isNetworked(): this is Networked & this {    return this.networked;  }  constructor(public path: string, private networked: boolean) {}} class FileRep extends FileSystemObject {  constructor(path: string, public content: string) {    super(path, false);  }} class Directory extends FileSystemObject {  children: FileSystemObject[];} interface Networked {  host: string;} const fso: FileSystemObject = new FileRep(\"foo/bar.txt\", \"foo\"); if (fso.isFile()) {  fso.content;  const fso: FileRep} else if (fso.isDirectory()) {  fso.children;  const fso: Directory} else if (fso.isNetworked()) {  fso.host;  const fso: Networked & FileSystemObject}Try"
      },
      {
        "language": "text",
        "code": "class FileSystemObject {  isFile(): this is FileRep {    return this instanceof FileRep;  }  isDirectory(): this is Directory {    return this instanceof Directory;  }  isNetworked(): this is Networked & this {    return this.networked;  }  constructor(public path: string, private networked: boolean) {}} class FileRep extends FileSystemObject {  constructor(path: string, public content: string) {    super(path, false);  }} class Directory extends FileSystemObject {  children: FileSystemObject[];} interface Networked {  host: string;} const fso: FileSystemObject = new FileRep(\"foo/bar.txt\", \"foo\"); if (fso.isFile()) {  fso.content;  const fso: FileRep} else if (fso.isDirectory()) {  fso.children;  const fso: Directory} else if (fso.isNetworked()) {  fso.host;  const fso: Networked & FileSystemObject}"
      },
      {
        "language": "text",
        "code": "tsclass Box<T> {  value?: T;   hasValue(): this is { value: T } {    return this.value !== undefined;  }} const box = new Box<string>();box.value = \"Gameboy\"; box.value;     (property) Box<string>.value?: string if (box.hasValue()) {  box.value;       (property) value: string}Try"
      },
      {
        "language": "text",
        "code": "class Box<T> {  value?: T;   hasValue(): this is { value: T } {    return this.value !== undefined;  }} const box = new Box<string>();box.value = \"Gameboy\"; box.value;     (property) Box<string>.value?: string if (box.hasValue()) {  box.value;       (property) value: string}"
      },
      {
        "language": "text",
        "code": "tsclass Params {  constructor(    public readonly x: number,    protected y: number,    private z: number  ) {    // No body necessary  }}const a = new Params(1, 2, 3);console.log(a.x);             (property) Params.x: numberconsole.log(a.z);Property 'z' is private and only accessible within class 'Params'.2341Property 'z' is private and only accessible within class 'Params'.Try"
      },
      {
        "language": "text",
        "code": "class Params {  constructor(    public readonly x: number,    protected y: number,    private z: number  ) {    // No body necessary  }}const a = new Params(1, 2, 3);console.log(a.x);             (property) Params.x: numberconsole.log(a.z);Property 'z' is private and only accessible within class 'Params'.2341Property 'z' is private and only accessible within class 'Params'."
      },
      {
        "language": "text",
        "code": "tsconst someClass = class<Type> {  content: Type;  constructor(value: Type) {    this.content = value;  }}; const m = new someClass(\"Hello, world\");     const m: someClass<string>Try"
      },
      {
        "language": "text",
        "code": "const someClass = class<Type> {  content: Type;  constructor(value: Type) {    this.content = value;  }}; const m = new someClass(\"Hello, world\");     const m: someClass<string>"
      },
      {
        "language": "text",
        "code": "tsclass Point {  createdAt: number;  x: number;  y: number  constructor(x: number, y: number) {    this.createdAt = Date.now()    this.x = x;    this.y = y;  }}type PointInstance = InstanceType<typeof Point> function moveRight(point: PointInstance) {  point.x += 5;} const point = new Point(3, 4);moveRight(point);point.x; // => 8Try"
      },
      {
        "language": "text",
        "code": "class Point {  createdAt: number;  x: number;  y: number  constructor(x: number, y: number) {    this.createdAt = Date.now()    this.x = x;    this.y = y;  }}type PointInstance = InstanceType<typeof Point> function moveRight(point: PointInstance) {  point.x += 5;} const point = new Point(3, 4);moveRight(point);point.x; // => 8"
      },
      {
        "language": "text",
        "code": "tsabstract class Base {  abstract getName(): string;   printName() {    console.log(\"Hello, \" + this.getName());  }} const b = new Base();Cannot create an instance of an abstract class.2511Cannot create an instance of an abstract class.Try"
      },
      {
        "language": "text",
        "code": "abstract class Base {  abstract getName(): string;   printName() {    console.log(\"Hello, \" + this.getName());  }} const b = new Base();Cannot create an instance of an abstract class.2511Cannot create an instance of an abstract class."
      },
      {
        "language": "text",
        "code": "tsclass Derived extends Base {  getName() {    return \"world\";  }} const d = new Derived();d.printName();Try"
      },
      {
        "language": "text",
        "code": "class Derived extends Base {  getName() {    return \"world\";  }} const d = new Derived();d.printName();"
      },
      {
        "language": "text",
        "code": "tsclass Derived extends Base {Non-abstract class 'Derived' does not implement inherited abstract member getName from class 'Base'.2515Non-abstract class 'Derived' does not implement inherited abstract member getName from class 'Base'.  // forgot to do anything}Try"
      },
      {
        "language": "text",
        "code": "class Derived extends Base {Non-abstract class 'Derived' does not implement inherited abstract member getName from class 'Base'.2515Non-abstract class 'Derived' does not implement inherited abstract member getName from class 'Base'.  // forgot to do anything}"
      },
      {
        "language": "text",
        "code": "tsfunction greet(ctor: typeof Base) {  const instance = new ctor();Cannot create an instance of an abstract class.2511Cannot create an instance of an abstract class.  instance.printName();}Try"
      },
      {
        "language": "text",
        "code": "function greet(ctor: typeof Base) {  const instance = new ctor();Cannot create an instance of an abstract class.2511Cannot create an instance of an abstract class.  instance.printName();}"
      },
      {
        "language": "text",
        "code": "ts// Bad!greet(Base);Try"
      },
      {
        "language": "text",
        "code": "// Bad!greet(Base);"
      },
      {
        "language": "text",
        "code": "tsfunction greet(ctor: new () => Base) {  const instance = new ctor();  instance.printName();}greet(Derived);greet(Base);Argument of type 'typeof Base' is not assignable to parameter of type 'new () => Base'.\n  Cannot assign an abstract constructor type to a non-abstract constructor type.2345Argument of type 'typeof Base' is not assignable to parameter of type 'new () => Base'.\n  Cannot assign an abstract constructor type to a non-abstract constructor type.Try"
      },
      {
        "language": "text",
        "code": "function greet(ctor: new () => Base) {  const instance = new ctor();  instance.printName();}greet(Derived);greet(Base);Argument of type 'typeof Base' is not assignable to parameter of type 'new () => Base'.\n  Cannot assign an abstract constructor type to a non-abstract constructor type.2345Argument of type 'typeof Base' is not assignable to parameter of type 'new () => Base'.\n  Cannot assign an abstract constructor type to a non-abstract constructor type."
      },
      {
        "language": "text",
        "code": "tsclass Point1 {  x = 0;  y = 0;} class Point2 {  x = 0;  y = 0;} // OKconst p: Point1 = new Point2();Try"
      },
      {
        "language": "text",
        "code": "class Point1 {  x = 0;  y = 0;} class Point2 {  x = 0;  y = 0;} // OKconst p: Point1 = new Point2();"
      },
      {
        "language": "text",
        "code": "tsclass Person {  name: string;  age: number;} class Employee {  name: string;  age: number;  salary: number;} // OKconst p: Person = new Employee();Try"
      },
      {
        "language": "text",
        "code": "class Person {  name: string;  age: number;} class Employee {  name: string;  age: number;  salary: number;} // OKconst p: Person = new Employee();"
      },
      {
        "language": "text",
        "code": "tsclass Empty {} function fn(x: Empty) {  // can't do anything with 'x', so I won't} // All OK!fn(window);fn({});fn(fn);Try"
      },
      {
        "language": "text",
        "code": "class Empty {} function fn(x: Empty) {  // can't do anything with 'x', so I won't} // All OK!fn(window);fn({});fn(fn);"
      }
    ],
    "links": [
      {
        "text": "Classes (MDN)",
        "href": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Classes"
      },
      {
        "text": "Try",
        "href": "https://www.typescriptlang.org/play/#code/MYGwhgzhAEAKD2BLAdgF2gbwL5A"
      },
      {
        "text": "Try",
        "href": "https://www.typescriptlang.org/play/#code/PTAEAEGcBcCcEsDG0AKsD2AHApraBPASQDt5p4BDAG3gC8Lz1iAuUAM2smwFgAoRKhUiRQKdPGLRQAbz6hQAD1bEArgFsARrgDcc0PmXqtsXbwC+fPoiYxQmKQF5QxbAHdR4yQAoAlKfsAdAqgTgAM-tAB+CGg4UA"
      },
      {
        "text": "Try",
        "href": "https://www.typescriptlang.org/play/#code/MYGwhgzhAEAKD2BLAdgF2gbwLAChrQA9oBeaABgG5d8BPE8qnAX112HmQnQAd1TkApgHc4SNAAoAlIwD0MuACcUqGGQA05NhwjwQAgHQh4Ac3EADACQZe+gkw1WbNJmelA"
      },
      {
        "text": "Try",
        "href": "https://www.typescriptlang.org/play/#code/PTAEAEFMCdoe2gZwFygEwGY1oLACgBjAGwENFFQAFOASwDsAXUAb31FAA9QBeUABgDcbUAE8e-IXgC++EKAC0iggFcGi+fgJw6iJgAcmvOpADuVWowAUASkkGAdF14AiPs4FA"
      },
      {
        "text": "strictPropertyInitialization",
        "href": "/tsconfig#strictPropertyInitialization"
      },
      {
        "text": "Try",
        "href": "https://www.typescriptlang.org/play/#code/PTAEAEFMCdoe2gZwFygEwFYBsAWAsAFADGANgIaKKgBCZAJgOLSSQAuMoA3oaKAHZkAtpFSJW0AJZ8A5gG5CAXyA"
      },
      {
        "text": "Try",
        "href": "https://www.typescriptlang.org/play/#code/MYGwhgzhAEDiD28AmsBOBTdAXdroG8BYAKGmgDswBbdALmgi1QEtyBzAbhJLOHnMaoArsCzxUACgCUBHmWhYAFswgA6SjWgBeaACJF6ECHi6upaAF8SFoA"
      },
      {
        "text": "Try",
        "href": "https://www.typescriptlang.org/play/#code/MYGwhgzhAEDyDSBxATgU1QF1c6BvAsAFDTQD0p0AcgPYbQCWAdvRvWCPQF6oAmANNABGAVzqNq0bMmrIiJRmAC2qAIQAuaBAzImAcwDcRAL5A"
      },
      {
        "text": "Try",
        "href": "https://www.typescriptlang.org/play/#code/PTAEAEFMCdoe2gZwFygEwFYAsAGd2cBYAKAGMAbAQ0UVAHFpJIAXGUAbxNFEcoBM4AO3IBPUIMoBbSKkTNoAS0EBzUAF5QAIgDuCcn00BuEl1Ckhc6AFdSzBAAo4zABYwAclMgB+WfKXKASg5TbgUAM1BHF3dPUABCNQ0rQT5IMKVIPiDOYm480BcFRAA6CWl1UCdXaA9pY1y8gF9TZuJTGGh7bJCC5yLS2I1NQSdKgGsjFpJW80E5UFUNQUhtekYWGC765QHyocpyRDhxUbgJwyA"
      },
      {
        "text": "Constructor (MDN)",
        "href": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Classes/constructor"
      },
      {
        "text": "Try",
        "href": "https://www.typescriptlang.org/play/#code/MYGwhgzhAEAKD2BLAdgF2gbwLAChrQA8AuaZAVwFsAjAUwCcBuXfATxPOvqZ2egHo+0AHLw6FMCGgREAc2RhUZOjWgB3RKgAW0ACY0AZmDIhUEXsHjIIqOmWCpRACgLQAvNAAMAGmgs3ngEpMXnwtRAgAOhd3Am58UM1wiL93FjjoAF9cDKA"
      },
      {
        "text": "Try",
        "href": "https://www.typescriptlang.org/play/#code/MYGwhgzhAEAKD2BLAdgF2gbwLAChrQA8AuaZAVwFsAjAUwCdoBeaABgG5d8BPE86+pqw45O0APRjoAYXjIIqOmWCp4DeADd6IeGAAmEUcFnzFy1QApipSrToAaaD2v86ASmH4jchUpV1LTiYoAObuhsY+Zv5WQcjB0AA+zrYOTny2giyumKL4EtLwujTQ2sGIwNAAFvQ0ogC+uHVAA"
      },
      {
        "text": "Try",
        "href": "https://www.typescriptlang.org/play/#code/PTAEAEFMCdoe2gZwFygIwHYAMWCcBYAKAGMAbAQ0UVACFLJQBvI0UAa1AF5QAWAbiIBfIkTKVqAERgBLAG6QAJqEgAPAC6QAdgup1EDZoVbE4mxGugBXYmoQAKAJRMWrUCFAAFaNM1rq5UAB3eE0Ac1BZclJLBh9QAFEAZQBWPlA1AAt4QOpVYkgABzVpU1A4pIA2F2NTRDhSSAA6UjhQu0zpREa2BwEjV0RLAphHPtZhQkEgA"
      },
      {
        "text": "Method definitions",
        "href": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Functions/Method_definitions"
      },
      {
        "text": "Try",
        "href": "https://www.typescriptlang.org/play/#code/MYGwhgzhAEAKD2BLAdgF2gbwLAChrQA9oBeaARgAYBuXfATxPOt1ugmDBAFMAKZALmjIArgFsARlwBOASkEA3JABNMrfKgAWiCADoiAKlLIaefNE3adDQ0JP4AvrntA"
      },
      {
        "text": "Try",
        "href": "https://www.typescriptlang.org/play/#code/PTAEAEFMCdoe2gZwFygEwGY1oLACgAbSAF1AA9UA7AVwFsAjGUAXlAAYBuffAYwIENEiUAGFQAb3yhyqRMWgBLSgHMWoAEQALSAQJx1XPFNC0AFAEoJx6SFAAVTQuFPQ8gJ5LVxOCbgATBQAzN1AAcjJQ0ED4WlACJUhQAEYAGlBKOFJibVA+QWEAB3gCmGI3a3I1dQB3BAI-A2MAX3wmoA"
      },
      {
        "text": "Try",
        "href": "https://www.typescriptlang.org/play/#code/MYGwhgzhAEDC0G8CwAoa0D6ICmA7A5gC4AW0AvNAAwDcq6+2h0OBJAFAJSJ3rQBOjAK59c0EgEsIAOix4ixWmmgBfHhEbM57AG5gQg7F2RL0E6bNakKu-dkXpVKZUA"
      },
      {
        "text": "TypeScript 4.3",
        "href": "https://devblogs.microsoft.com/typescript/announcing-typescript-4-3/"
      },
      {
        "text": "Try",
        "href": "https://www.typescriptlang.org/play/#code/MYGwhgzhAEAqAWBLAdgc2gbwLAChrQH0JEAvAU2gF5oAGAbl131TIBdpjyAKASgC5oyAK4BbAEZkATpib5oktkMnJorJBAB0RUmQZ5oAX0b6IbDjq4A3MCCFkBEVpJToAPoNETp7sQHtfIGRgyDwy+viB7MIiVNAAcp5SVjZ2PHqy+AD0mdAAIr7IAOTsNiC+AO7xYHEANNAAksgAZiiIrACedWzAxnLQiE3QXACECeJSGogQAGKtrGRc0Tyh2OFyalNanBTU9BlyCqxKyHp9Rjj7G5ra5LHRp4a4BkA"
      },
      {
        "text": "Index Signatures for other object types",
        "href": "/docs/handbook/2/objects.html#index-signatures"
      },
      {
        "text": "Try",
        "href": "https://www.typescriptlang.org/play/#code/MYGwhgzhAECyCeBhcVoG8CwAoa0DaEAXNBAC4BOAlgHYDmAusQEYD2LIApmNdAD7QAKAURIUatAJTQAvAD5ordl2oSA3Nmy5gACw7AA1sOJkqdKZhy5o5DqQCu5HqW2UIBetEgK2nbussAvtgBQA"
      },
      {
        "text": "Try",
        "href": "https://www.typescriptlang.org/play/#code/PTAEAEFMCdoe2gZwFygEwBY0AYCwAoASwDsAXGAMwEMBjSUABRIHMqAjAG3oG8DRQADiwAUASlQA3OIQAmAbgIBfAgRocqiRKADKcYlWihCAWwFdjkMlqbFWnHn0EjRoXvn78aexHC4A6DjhmYQAiIVsAQhDRBXdQZXwE1XVNUAAhKg4OI1NzS1JrFnYuV0cBPWCXNw9QL2Iff0DgsIqomMcExSA"
      },
      {
        "text": "Try",
        "href": "https://www.typescriptlang.org/play/#code/PTAEAEFMCdoe2gZwFygOwAYMDYCwAoASwDsAXGAMwEMBjSUAYQAtIaBrKgIwBt6BvAqFA0W7ABTEqAW0ipEpaCQDmASlSc4cXlWIBuAgF8CBGtyqJEoAHLTIzVmxihCUgA68ZZS-fZdeoAXwhEQcxRBUAwSFQEGs4UkI6UGI4UBh4aFAWaEgooRzSAFdoYlBEADpSOAAZOAB3GAZzSDEIgF4O0AAiODYu-SDo2OiR0AA9AH4oo3wDIA"
      },
      {
        "text": "Try",
        "href": "https://www.typescriptlang.org/play/#code/PTAEAEFMCdoe2gZwFygEwGYME4CwAoASwDsAXGAMwEMBjSUAQVAG8DRQAPVYgVwFsARjADcbUAE8A-N35Doo-AF8CNADZVEiUAGFQhPgAdVkPpDJamrfOw6gAvKAAMC5fhpxiiUqBr3QxSAB3HQAKAEoFGgA6cT8ARmcgA"
      },
      {
        "text": "extends keyword (MDN)",
        "href": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Classes/extends"
      },
      {
        "text": "Try",
        "href": "https://www.typescriptlang.org/play/#code/MYGwhgzhAECCB2BLAtmE0DeBYAUNayA9gG4CmAFAJSa777CHwSEikB0IhA5uQEQCyJRPC7Q0jLgEJelANy1oAX1zKcuUJBgARbtFIAPAC6l4AExgIUaGnmgB3QoQBm5QylIQAXNHgBXZABGpABO1Ni2+E6EwdDkrIbQiNAAvNAADLKJ0AA80G7IHpmIANTFYQp00AxMLOycPLwOztJyFUoKqqrqjBAJpik+pHbQOjytOAD0E9AAQpCkVeBQBKSGABaEprimbERkVPKT01ohiGT9GssF65vbbE0uAMxyQA"
      },
      {
        "text": "super keyword (MDN)",
        "href": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/super"
      },
      {
        "text": "Try",
        "href": "https://www.typescriptlang.org/play/#code/MYGwhgzhAEBCkFNoG8CwAoa0DmAnBCALgBQCUKGWWwA9gHYQ0gIB0IN2xARABIIjsANNADuNXCAAmAQi6kA3JWgBfDKvQZQkGABEEuAJYA3BJOgIAHoQR1JMeBCRpMOfEWJ0wAWwQB+AFzQEISGdNjkzlTQBgBm0B7eSAC8KdAArrYIMQZ0phFKURBpAA76LHgEJAoFKuYgjhQuUbQMTKzsnAAGfAI0wgAkyJ4+LIQ0AKrFpbgAwohkyp3VTSpK6uqa9MHQZknQuSLQeoYmkmSK6JLlblUXVxXuXPhgkvpy8kA"
      },
      {
        "text": "Try",
        "href": "https://www.typescriptlang.org/play/#code/MYGwhgzhAEBCkFNoG8CwAoa0DmAnBCALgBQCUKGWWwA9gHYQ0gIB0IN2xARABIIjsANNADuNXCAAmAQi6kA3JWgBfDKvShIMACIJcASwBuCSdAQAPQgjqSY8CEmTraDQtFMBeaHQQjoug2NJMkV0AHow6ABaGOAAV0IYqIwI6ABBEH1IaEIACyRJPSMTaH1XMDpgJDzcGjjsXOgwaAAjRGhNKGh8ADM9ayqMFwg3FoAuOHavSVDUgDkaaAAHWpbmAFsMFpY8AhIFIA"
      },
      {
        "text": "Try",
        "href": "https://www.typescriptlang.org/play/#code/PTAEAEFMCdoe2gZwFygEwBYCMA2AsAFADGANgIaKKgBCFkoA3oaKAObSSQAuAFAJSNmLUETgA7RHBKQAdCTiseAIgASkEvIA0oAO4ISAEwCESvgG4hAX0LWChUhSoARGAEsAbpAOhIADy6QYgZUtIj0TAQsIKAAsmQA1vRcABauVAAOZNBkALbcMKAcAI4Arq4cBkLsnLxiuZCoiFzQrmKsAhHCIuKS0nIKPAAGahpw2gAkDHV5MlxwAKrp6TAAwnT8loPmVjZAA"
      },
      {
        "text": "Try",
        "href": "https://www.typescriptlang.org/play/#code/CYUwxgNghgTiAEkoGdnwEIoQbwLACh54BzOEAFwAoBKALngDcB7AS2AG4CBfA0JORNFTwAIiBgsGIYPBAAPciAB2wNJmQ4e+APTb4AWkNgAruUP6CYJkuTl4AI3rqEAXnhKQAd1HjJ0mpw6egDCMCgAFiBo9uBQxhrwAERKUAC2IInwniwQEA4IxiogAGYsHsAE9gB0pCAUAUA"
      },
      {
        "text": "useDefineForClassFields",
        "href": "/tsconfig#useDefineForClassFields"
      },
      {
        "text": "Try",
        "href": "https://www.typescriptlang.org/play/#code/JYOwLgpgTgZghgYwgAgIImAWzgG2QbwFgAoZZAEzkgHkYAhYKMACwC5k4QBPAbhIF8SJUJFiIUAEQD2Ac2QQAHpBDkAzmgzY8RUsgBGUCBHLtOvAUOIIccVevRZcACSkBXVSh1lDq4OQjg7A5afLoIUiCqYFCuCGBSUAAUnI44QZq4AJQEJGRkLMCqAHQ+fgFgyAC8HBk4oWSCxI0k1rbq0jIu7iiKymoaqV0eOboA9KPI0hDqIFIVEJjAFQBScABucADKCFDAAA4V4f4ANLnI48gROFzyka4+yCwoYFx70xyGyOFQhnFn-q1PqV-IFJrJ6l8IlEYnEEolyLJ2B1sl48qpXG8kgiZJkIY1+EA"
      },
      {
        "text": "Try",
        "href": "https://www.typescriptlang.org/play/#code/MYGwhgzhAEBCkFNoG8CwAoa0B2YC2SAvNAEQBGiJA3BlsAPbYQAuATgK7DP2sAUAlClpZoDJvRAIAdCHoBzXiQCyATxz4kASxgloAamjMAFtqm4C-GpmgBfDHfQZQkGABEErTQDcEAE2gIAB7MCNi+MPAQSGjW5kSkvh7eftT2GBgA9BnQAAqe2Mw6FFEkADQ49MwJST6+JE6MLND+xNgIAO7Q7p61AlRAA"
      },
      {
        "text": "Try",
        "href": "https://www.typescriptlang.org/play/#code/MYGwhgzhAECyEHMCiAnFB7F0CmAPALtgHYAmMqGWA3gLABQ00w6RE+KArsPpgBQC2ALmhsUASyIIAlNFoNGIjgAdsKAVIDc9RgF9tIsAE8AEthAh0vGXIXQU2fBxRFoAIgAWZi2+gBqaPjuYhAAdPzYUGAI2FryenQ6QA"
      },
      {
        "text": "Try",
        "href": "https://www.typescriptlang.org/play/#code/MYGwhgzhAECyEHMCiAnFB7F0CmAPALtgHYAmMqGWA3gLABQ00w6RE+KArsPpgBQC2ALmhsUASyIIAlNFoNGIjgAdsKAVIDc9egugB6PdADK2fNHwALbNCUYe+AJ4qcuJSDHAx+EA4B0OhQB5ACMAK2xuXwhTAAU7dEcVQIAzXksxCAAaOEQKTF9bBISnbE0AgF9teQgwBwAJbBAQdF4ZOV0UUw4UImgAIism9H7oAGpzCwzffmwoMARsLXlKunKgA"
      },
      {
        "text": "Object.setPrototypeOf",
        "href": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/setPrototypeOf"
      },
      {
        "text": "__proto__",
        "href": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/proto"
      },
      {
        "text": "these workarounds will not work on Internet Explorer 10 and prior",
        "href": "https://msdn.microsoft.com/en-us/library/s4esdbwz(v=vs.94).aspx"
      },
      {
        "text": "Try",
        "href": "https://www.typescriptlang.org/play/#code/MYGwhgzhAEDiBOBTRAXR9oG8CwAoa0ADgK4BGIAlsNAOZKoAUAlFngQcAPYB2EnIiAHQhONBgCIAFhQCE4pgG420AL541uLrxS1oAXmjdEAdzj008Zktw1BdZCitA"
      },
      {
        "text": "Try",
        "href": "https://www.typescriptlang.org/play/#code/PTAEAEFMCdoe2gZwFygEwBYMFYCwAoAYwBsBDRRUAcWkkgBcZQBvA0UABwFcAjYgS0KgA5rQYAKAJQs27UITgA7RHGKQAdMTjDxAIgASkYloA0oXaADUoegAt+idcIYA5UgFtIUyQG5ZAX1kOeEZCRgATEVcPL2lWfDlQWnouaEVze10-BNBA-DyCEnJKAGUOSEJ+UmIaOkZoUEgAD0ZFcMpahiZ49m4+QVBbOAB3cIBPKRkc9hBQAHkAaRs4UFJCQkgKThCKiNBPdx4mWxhIWXYFZVUNLR0DEfGzC2s7Bydoz29sxNnEv-+AXIAHog0FgsEBAh5S6IegiUAAXlAikgw1AZQqVRqYnqUmywicOLxoFmiwIBOc9Dcn18QA"
      },
      {
        "text": "Try",
        "href": "https://www.typescriptlang.org/play/#code/MYGwhgzhAEBCkFNoG8CwAoa0AOAnA9gC4LDEAm0AttALzQCMADANwYC+GokMAIgrgEsAbggoIAHsQB2ZGPAhI0maAHoV0AHL4q+MgIBmA-gBpoEbWQT6wAVxCFoAmAHJsNgEYgBwZxizU6egBWVnQOdGB8KQgHCjopBAB3aD5BETIACgBKUMjo-BAEADoQfABzDLIiyhzVdQB5AGkgA"
      },
      {
        "text": "Try",
        "href": "https://www.typescriptlang.org/play/#code/PTAEAEFMCdoe2gZwFygEwBYMDYCwAoAYwBsBDRRUAIXMlAG8DRQAHeAF0kM4BNQAPVADsArgFsARjFABeUAEYA3AQC+BEuUoARGAEsAbpB7zQkfpyE9KNRHUb5mbOJ25GBw8VOizQAVmX4akRkFKA60AZGaKbmkJbWtAxMoABm8gAUzgAWMKjhkTxoAJRJDsyg2TAAdPw+8gAMAcxBzClomew50Hl6hsYl9uUVndW1cg1NoEEqQA"
      },
      {
        "text": "Why Can’t I Access A Protected Member From A Derived Class?",
        "href": "https://blogs.msdn.microsoft.com/ericlippert/2005/11/09/why-cant-i-access-a-protected-member-from-a-derived-class/"
      },
      {
        "text": "Try",
        "href": "https://www.typescriptlang.org/play/#code/PTAEAEFMCdoe2gZwFygEwGYAsBGAsAFADGANgIaKKgBCFkoA3oaKAA7QCWAbmQC70APUAF5QABgDchAL6EicAHaJeoAEYjQCyAHcadABQBKKQRCgAwmQUByFWSJFIlUADN4AW1BwArr0QcAE3peAAt6UgpEOUVEOBJIADoSOABzfVUEgWMgA"
      },
      {
        "text": "Try",
        "href": "https://www.typescriptlang.org/play/#code/PTAEAEFMCdoe2gZwFygEwGYAsBGAsAFADGANgIaKKgBCFkoA3oaKAA7QCWAbmQC70APUAF5QABgDchAL6EQoALRKiAV15KFhUhSoARGN0gATUJAH8Adkaq1E9JgRaIAFnADuADQAUASkbMWUHkAYTILAHJeUDIiIkhKUA4LUEQVACNtSniAliI4C0Q4EkgAOhI4AHMvXmcORBKBHylHUFkCaSA"
      },
      {
        "text": "Try",
        "href": "https://www.typescriptlang.org/play/#code/PTAEAEFMCdoe2gZwFygEwBYCMBWAsAFADGANgIaKKgBCFkoA3oaKAA7QCWAbmQC70APUAF5QABgDchAL6FSFKgBEY3SABNQkAfwB2aqrUT0mBFkNFYpBaUA"
      },
      {
        "text": "Try",
        "href": "https://www.typescriptlang.org/play/#code/MYGwhgzhAECC0G8CwAoa0AOAnAlgNzABcBTaAD2gF5oBGABgG5VV0MBXAIxB2GgjAC2xWBAAUAe0IALYlgBccAJSIW6aAHp10AHLjosrOKyr0WYoTZYAdtEkysAOgqUX0aTghOmaaAF9UvkA"
      },
      {
        "text": "are only enforced during type checking",
        "href": "https://www.typescriptlang.org/play?removeComments=true&target=99&ts=4.3.4#code/PTAEGMBsEMGddAEQPYHNQBMCmVoCcsEAHPASwDdoAXLUAM1K0gwQFdZSA7dAKWkoDK4MkSoByBAGJQJLAwAeAWABQIUH0HDSoiTLKUaoUggAW+DHorUsAOlABJcQlhUy4KpACeoLJzrI8cCwMGxU1ABVPIiwhESpMZEJQTmR4lxFQaQxWMm4IZABbIlIYKlJkTlDlXHgkNFAAbxVQTIAjfABrAEEC5FZOeIBeUAAGAG5mmSw8WAroSFIqb2GAIjMiIk8VieVJ8Ar01ncAgAoASkaAXxVr3dUwGoQAYWpMHBgCYn1rekZmNg4eUi0Vi2icoBWJCsNBWoA6WE8AHcAiEwmBgTEtDovtDaMZQLM6PEoQZbA5wSk0q5SO4vD4-AEghZoJwLGYEIRwNBoqAzFRwCZCFUIlFMXECdSiAhId8YZgclx0PsiiVqOVOAAaUAFLAsxWgKiC35MFigfC0FKgSAVVDTSyk+W5dB4fplHVVR6gF7xJrKFotEk-HXIRE9PoDUDDcaTAPTWaceaLZYQlmoPBbHYx-KcQ7HPDnK43FQqfY5+IMDDISPJLCIuqoc47UsuUCofAME3Vzi1r3URvF5QV5A2STtPDdXqunZDgDaYlHnTDrrEAF0dm28B3mDZg6HJwN1+2-hg57ulwNV2NQGoZbjYfNrYiENBwEFaojFiZQK08C-4fFKTVCozWfTgfFgLkeT5AUqiAA"
      },
      {
        "text": "Try",
        "href": "https://www.typescriptlang.org/play/#code/MYGwhgzhAECyCeBlMAzAptA3gWAFDWgAcAnASwDcwAXDCNYYtKgaTXmgF5oBGAJgGYALAFYA3HgC+QA"
      },
      {
        "text": "Try",
        "href": "https://www.typescriptlang.org/play/#code/PTAEAEFMCdoe2gZwFygEwGYAsBGAsAFADGANgIaKKgCyAngMpkBmkoA3oaKAA7QCWANzIAXVokhFokYQGlItUAF5QOTFgCsAbkIBfQoSJwAdomGgqyo5ADuNBs0gAKAJTaChEKABycM2RIkcNaQACagIQCu-EYA5qDCtNysRAAWEgDWfLEGxohwJJAAdIExjoiF4pLScrSu+gSeAPIyOSb5RSVlANoARJVSsvI9ALquQA"
      },
      {
        "text": "private fields",
        "href": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Classes/Private_class_fields"
      },
      {
        "text": "Try",
        "href": "https://www.typescriptlang.org/play/#code/MYGwhgzhAEAiD2BzaBvAsAKGtAxAIzACcBrAQQFt4BXAOwBdoBeaABgG5NsAHAU0Ing0wIAJZ0Ank2gAiABZguXcdI4ZO0YIIh1CVYHXiEAFAEpUAX0zmgA"
      },
      {
        "text": "Try",
        "href": "https://www.typescriptlang.org/play/#code/PTAEAEBcEMCcHMCmkBcpEGcB2iAekBYAKBAgwAsB7AdwFEBbAS0KIGMAbaDDUAEUvigA3sVCgAxACM4AawCC9SgFcskUAF5QABgDco0AAdEsDJSzR2zAJ4bQAInLQDBq3b1F9rMxkiwlrSEpYAAoASmEAX2IIoA"
      },
      {
        "text": "Try",
        "href": "https://www.typescriptlang.org/play/#code/PTAEAEBcEMCcHMCmkBcpEGcBMAGAjAKwCwAUCBBgBYD2A7gKIC2AlpKQMYA20GGoAItXigA3qVCgAxACM4AawCCjagFcAdpFABeUDgDc40AAdEsDNTXROrAJ7bQAIkrQjRmw4MlD7CxkiwVdkhqWAAKAEpRAF9SKKA"
      },
      {
        "text": "Static Members (MDN)",
        "href": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Classes/static"
      },
      {
        "text": "Try",
        "href": "https://www.typescriptlang.org/play/#code/MYGwhgzhAECyCeBhcVoG8CwAoa0IBcx8BLYaAD2gF5oAGAbm1wKNOgAcAnYgO3wA0AFAEp0TXNGAB7HhCkgApgDoQUgOaCEySBCXlhjHNAC+2U1mmz5y1Rq0pd+w-Z1KuvASPpA"
      },
      {
        "text": "Try",
        "href": "https://www.typescriptlang.org/play/#code/PTAEAEFMCdoe2gZwFygEwGYAsBGAsAFADGANgIaKKgCyAngMLmWgDehooADtAJYBuZAC6RQiQUJ5FQAD1ABeUAAYA3IQC+hInAB2iOCUgA6EnADmACjqMKiQ9ICUyoA"
      },
      {
        "text": "Try",
        "href": "https://www.typescriptlang.org/play/#code/MYGwhgzhAEBCkFNoG8CwAoa0IBcw4EthoBzBHAcQCcFyCA7EgCgEoUMssacBXK+6ACIAEghAgA9tADuEqiAAmggNwdoAXwyb0oSDAAiCKgQBuCBdAQAPHAnoKY8CEjSZoAWwCe1WoUbQAXmhDYzMFADoySho6RlZVdHUgA"
      },
      {
        "text": "Try",
        "href": "https://www.typescriptlang.org/play/#code/PTAEAEFMCdoe2gZwFygEwDYCcWCwAoAYwBsBDRRUAZVAG8DRREAXU5gS0NADtSBbSKAC8oAERUAhKIDcBAL5A"
      },
      {
        "text": "Try",
        "href": "https://www.typescriptlang.org/play/#code/PTAEFUDtIUwYxgZ0QQwE4E9QCJEBcU8BLObUOAGxWQFgAoS6xUAWQwGUDi4BhK5UAG96oUPkIlQAEwD27GQFsYeABZFIAcwAUASiEBfeobr0QoAApoYAMxhorU0FpQU8dyBIBuMUAEYd9NYArpBwxDKQ0nKKymqaugb0pmCWNnYOTi5uaB7E3qAATAEMEfisGAASMBQADnYA8gBGAFbweKAAvEIiUYgxquraeoL6ADRGANxAA"
      },
      {
        "text": "Try",
        "href": "https://www.typescriptlang.org/play/#code/CYUwxgNghgTiAEAzArgOzAFwJYHtXwhymABkoBnDASVUqnRHIAoBKALnnoE8BtAXQCwAKAD0I+AFopYZBikThkCuXgAxHDngBvYfD3w62MPADEYHGgzwAvPAAMAbmG79AcxBXzl1tpf79cBjIMPjqOAB0ZhaoGE5C-gC+zvH6hljGOin+ehgwXL5Z2f7mtFbQlDR0DCq2hMRkFaX0YIyscUVFYZFeMfAA1LUU1E3V4RAgqK4YABbtHUmFxVAYYNPaC4nCCUA"
      },
      {
        "text": "Try",
        "href": "https://www.typescriptlang.org/play/#code/MYGwhgzhAEBCD2APAPAFQJ4AcCmA+aA3gLABQ00w8AdgC7a0QBc0GOA3KeZVRDQE4BXYDXh8AFADcwIAdmatsASkKdy0GgAsAlhAB03Og2gBeaFJnYOZaAF9SdkqW69oAIxPQq2AO5wkYgCINbBAQeABCAMUrAHoYtWgAPQB+IA"
      },
      {
        "text": "Try",
        "href": "https://www.typescriptlang.org/play/#code/PTAEAEFMCdoe2gZwFygEwGYAMaCwAoAYwBsBDRRUAITgA8AeAFQE8AHSAPlAG8DRREAF1KCAloVAATSADNSAV2KCAaqWLzIqFuwDcBAL5A"
      },
      {
        "text": "this keyword (MDN)",
        "href": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/this"
      },
      {
        "text": "Try",
        "href": "https://www.typescriptlang.org/play/#code/MYGwhgzhAECyCeBhcVoG8CwAoa0B2YAtgKbQC80ARAspBJQNza4DmxALgHJHEAUAlOma5oAJw4BXUXmjsAFgEsIAOgIkmOaAF9sOrMAD2eCO2jBy+YgHc4SFBAEbDx0wYBGAKwuZNa4gC4qdw9KABphNi4eQOBlSO4ScKwtDWwAejToAAVRBTx2GEpgsPwDU2o7OkpsZwgDEGJlEAMWXmC4jgS+fn4GIA"
      },
      {
        "text": "Arrow functions (MDN)",
        "href": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Functions/Arrow_functions"
      },
      {
        "text": "Try",
        "href": "https://www.typescriptlang.org/play/#code/MYGwhgzhAECyCeBhcVoG8CwAoa0B2YAtgKbQC80ARAspBJQNza4DmxALgHJGkUAUASnIA+dM1zQAThwCukvNHYALAJYQAdARJMc0AL4692YAHs8EdtGDl8xAO5wkKCIJ2nzlljeDq2XHjoA9IHQAAqSKnjsMNROdJTQkRbEYAAm0CYAZlaSkKp4LMZmECYgxOogJix81QICDEA"
      },
      {
        "text": "Try",
        "href": "https://www.typescriptlang.org/play/#code/C4TwDgpgBAyg9gWwgFXNAvFAhgOxAbgFgAoAelKgFpqBjAV2GspPKlUhhoCcBLMYKDxxgGUAO49gACygByaTwDOsqGCxcsSYBC4kAZnRw1gPODih6cACgWKAXLEQo0AGigAPBzjoIARjoBKKABvEigoUgAqKAA6OKhI0hIAXyA"
      },
      {
        "text": "Try",
        "href": "https://www.typescriptlang.org/play/#code/PTAEAEFMCdoe2gZwFygEwDYAcAWAsAFADGANgIaKKgCyAngMLmWgDehooAdmQLaSgBeUACI6jComEBudqADmkAC4A5XpAAUigBYBLFDQZNEASlayO0JQFdonUNr0A6bnxkEOAX0JficTokVQIkEuSAB3A3FKdWM3EFAAeQBpQiJHBRU1GLdCeIBRWAQAGlAwuCsSABMg6AotVL8A+RC0jNVXBv84EkhHEjg5dUHjWKA"
      },
      {
        "text": "Try",
        "href": "https://www.typescriptlang.org/play/#code/MYGwhgzhAEBCD2APaBvAsAKGtY8B2ALgKaEQBc0EBATgJZ4Dm0AvNAERsDcm2ERBACgBuYEAFciFKnUYBKVJgD0i7AD0A-D2zQCAC1oQAdLkIkCMViPFFuWbdX5jqeHfoi3sAX0yegA"
      },
      {
        "text": "Try",
        "href": "https://www.typescriptlang.org/play/#code/MYGwhgzhAEBCD2APaBvAsAKGtY8B2ALgKaEQBc0EBATgJZ4Dm0AvNAERsDcm2ERBACgBuYEAFciFKnUYBKVD2zQCAC1oQAdLkIkCMViPFFuWJdX5jqeZWognsAX0xOMAelfQAtN+BiC3z0xQSBgAYRAiMGowACMIhGQiRGI8ABMYBIVTUEjqAXl0U2xVdS18FL0Wdi5FFxcg-CpoMCq8IgB3aHDc2PikfJNtJpiqsA0+QTYVIhAQeDZZE3claAA9AH4gA"
      },
      {
        "text": "Try",
        "href": "https://www.typescriptlang.org/play/#code/MYGwhgzhAEBCD2APaBvAsAKGtY8B2ALgKaEBc0EBATgJZ4Dm0AvNAESsDcm2EYAtkQCCEABTwCACyJVykmhACUqbtmhUiBAK5U80cVKoA6XIRIFmTFnIjH8xQlyzQAvpmdA"
      },
      {
        "text": "Try",
        "href": "https://www.typescriptlang.org/play/#code/PTAEAEFMCdoe2gZwFygEwGYAsBWAsAFADGANgIaKKgBCcAHqAN6GihFwB2ALpN6ol2gBLDgHNQAXlAAiaQG4WoRGQC2kAIKIAFHC4ALGKn1DEASiaLW0SFwCu0DqF0HoAOnbdeXSRKnHE7pw83AoErAC+hJEEhKQUVAAiMEIAbpAAJrQMkHTB6VRZFmFO+jAAwkFe-IIi4lLSAPzyUYSxnAKgAEYUkJKgHJAA7jT0WqahHh3pyWnpfQPDScKzWWOh08sZrspqmlrdiJDjQA"
      },
      {
        "text": "Try",
        "href": "https://www.typescriptlang.org/play/#code/PTAEAEGcBcCcEsDG0AKsD2AHApraBPASQDt5p4BDAG3gC8Lz1iAuUAM2smwFgAoRKhUiRQAMXhVsAZXwxsAWwDyAIwBW2ZKADefUKHiRxkgBQBKVtAAWB-SKPYAStkzbde0LGzQArrGKgrG3hiGApiRGx0NjEJR2cAbjcAXzcDABF4T2R0WHwzC2sRGwys6Bz8V153Dy9ff0CikOgwiKjQEo0y3MSq0BTegwA5LwB3HIBrbAATfIDC21Bh6DHYSanQADI5mx1evU8fP23IADpiUYnpnr1+vUQmGFhvbNhjTG9lGkRQTAZLVkewQA5gAaH4IABuDGwoHOy0uU1YynQ6EkYVM2n6-T4AiEdliThc2AAHtBsMQpvjJDI5Eo1J1KncHnBnl03n8AXBgWD3p8kKB7sQyULOQhiECMbtqpBvDhXr8rGCOFQuKZrn0+Nj+IJhO1Mp1yqAScLKTFqbIyXT1JopQLrFQpp4WGbpBaFCprdAANoAXR6WuCZNgHAiiwuq2mjNAlnQMFFwP9fBxzPYkHQrHsNMtHoZAF5YdgRi7CcYAERsFHAZQUWAnaCk0tg8so0tqpO8eDRYxsNMnAz2MyStw99AnQXC6A9ECgAB6AH5NUaVTDO6Bu730vqXnlTEPeiOx-bHeSp2B54vsMv9F2D0Nw2tB1GDzGYKfZwveEkgA"
      },
      {
        "text": "Try",
        "href": "https://www.typescriptlang.org/play/#code/MYGwhgzhAEBCD2APAPAFQHzQN4FgBQ00AbmCAK4CmA-AFzSoDc++hAFpAGqmUAUAlHQAurAJYwx2Ytwp1U0AL7YWhaACcKgsqoB20YWIB0JchWgBCALwXoZbQBMKAMxHaKdpgQX55zPMHjaEILQAEZI0NauAO5wSMhBqi4A5uj8HmGIRtIR0ABEAOJgALYUYQCeuR74GVkmHgD09YQAelS+Io7QPDXsEFwm-HxKnjXGlB6EjS1tePJAA"
      },
      {
        "text": "Try",
        "href": "https://www.typescriptlang.org/play/#code/PTAEAEFMCdoe2gZwFygEwGYAsBGAsAFADGANgIaKKgAKZ0ZAtlQN6GihFwB2iALtAFcivBAAo27UAAcBAIxIBLIqGiQyAE24kAnqAAeqLgIayYAGgnsp8XpGGR1obYeOnoFgpOnQFANzK2oABeLiYwEgCUoKyekiCgAHJwoLJw6rpcdpCUdNoSAL6EhcTcfKBkoAC8oJkA7jR0jIiiOGbobRgRANyEnDxwJJAAdCRwAOaiZEN63YTxXgvsAHoA-L2lA8OjE1NB3UA"
      },
      {
        "text": "Class expressions (MDN)",
        "href": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/class"
      },
      {
        "text": "Try",
        "href": "https://www.typescriptlang.org/play/#code/MYewdgzgLgBBIFsCmBhANgQwhGBeGwm2APACoCeADkgHwwDeAsAFAwHhRJhQBcMF1ANws2oSFABOAV2BQQEgBQA3DGilI+ApAEoGItjCgALAJYQAdGM7c8MFWqTDWMAL4sXTlmOgwEtsEgA7nCIqEQQCgBEABJIaGggADQwgfJoACaR2k4A9DkGMAB6APxAA"
      },
      {
        "text": "InstanceType",
        "href": "/docs/handbook/utility-types.html#instancetypetype"
      },
      {
        "text": "Try",
        "href": "https://www.typescriptlang.org/play/#code/MYGwhgzhAEAKD2BLAdgF2gbwLAChrWACcBTMVYgEwEFUAuaZAVwFsAjYwgbl3wA96mbDtzzQAngJbtCPAvGQRUhRsFTxCACn4MpHADTjJQwgEpMs-KgAWiCADoipctXQBeaABEyxO8ngB3DRMLaGtbO15od14RfEsbezEo8VjoAF9cDJxUMQAHYjgkNABJBVQwZGAC91LFCqqAFTziAB4c-PgAM0KUVAA+XFxOxkrURHloZngAN2IAJUQAcytUDVyiuh6SsvriM2xRdd6I6ABqdwBWESzcYHlFaCO0ZORify3VgGYDABYTESmswWy1WT1Q-1wYIinGgAHpYVE+tAABxAA"
      },
      {
        "text": "Try",
        "href": "https://www.typescriptlang.org/play/#code/PTAEAEFMCdoe2gZwFygEwFYCMWCwAoAQwCNEAXaQgYzNCoBtDFFQAhJyUAbwNFBPKUaoAOaQyAOUIBbSAAoAlKkEBLAHYiA3AV6gADtHWSZ8hd118qcNYjj1IAOnpwRcgEQAJSPWcAaUG6gANSgZAAWKogOYsayigra+HwAvgSp+ARWNrTEoAC8oGqQAO5sHIqaQA"
      },
      {
        "text": "Try",
        "href": "https://www.typescriptlang.org/play/#code/IYIwzgLgTsDGEAJYBthjAgQmgpgg3gLABQCCokM8CA5jhAHLAC2OAFAJQBcClAlgDsaAbhJkADlEGMW7DgQC+JJcQD0qhAFptsAK4RtmkijQYAIjikA3HABMEOAB4QcA2xmxg8RUrXpNWTgIxMgQoel0oAQQAIgB3AHsoZFsY0V8VFWMEgUgEewBeBAEcOIQLaztOdNsAOklpALlhIA"
      },
      {
        "text": "Try",
        "href": "https://www.typescriptlang.org/play/#code/PTAEAEFMCdoe2gZwFygEwFYCMGCwAoAQwCNEAXaQgYzNCoBtDFFQAhJyUAbwNFBPKUaoAOaQyAOUIBbSAAoAlKkEBLAHYiA3L1AAHaOskz5C7gF8CF-CFABae1QCuZe7YIMmLACIwVAN0gAE1BIAA8ySDVAlnZETh58PhsAMwQROFoyOFBA7MI1AE8yAAt1EUsgA"
      },
      {
        "text": "Try",
        "href": "https://www.typescriptlang.org/play/#code/PTAEAEFMCdoe2gZwFygEwFYCMWCwAoAQwCNEAXaQgYzNCoBtDFFQAhJyUAbwNFBPKUaoAOaQyAOUIBbSAAoAlKkEBLAHYiA3L1AAHaOskz5C7gF8CF-AyYsAIjBUA3SABNQkAB5lIa1y3ZETh58PjEjWUVuHT5ocQBXaDVQACIU7VDQKysQUABaAqp4sgK8ggAzeLUaFThkkTjxORoEVDIAT11IOHK2DlMQvio68lB1ckJqzgBeUDVIAHc6MgRFDL5xskmqSAA6fUMpSIUMsyA"
      },
      {
        "text": "Try",
        "href": "https://www.typescriptlang.org/play/#code/CYUwxgNghgTiAEYD2A7AzgF3gcziDAXPFCgJ4A08AQlGiESaQNwCwAUAPQfwC0fYAVwx8e7LtSjAAhO1wh8AChp0AlEyA"
      },
      {
        "text": "Try",
        "href": "https://www.typescriptlang.org/play/#code/PTAEAEFMCdoe2gZwFygEwGYAsBWAsAFACGARogC7REDG5o1ANkYoqAELOSgDehoopClVqgA5pHIA5IgFtIACgCUqIQEsAdqIDcfUAAdoGqbIWKeAX0KWCjZqwAiMVQDdIAE1CQAHuUjq3rByIXLwE-OLGcko8uvzQEgCu0OqgAESpOmGg1tYgoAC0hdQJ5IX5hABmCeq0qnApovES8rQIqOqQAO6g0QC8AHzsnGah-NT1FKAaFEQ1XL2gHd2t0EqZ-NPks9SQAHQGRtJRipnWjZDNjoaubieE581BkCdAA"
      },
      {
        "text": "Try",
        "href": "https://www.typescriptlang.org/play/#code/MYGwhgzhAEAKD2BLAdgFwIzQN4FgBQ00AHtALzQAMA3PoQJ5mU14C+++okMCKqATNlrFG1IQ3KjW7PAHoZ0APIBpDvGQRU0AA4AuOEjSZyyAKYB3fbz4AKAJRUgA"
      },
      {
        "text": "Try",
        "href": "https://www.typescriptlang.org/play/#code/PTAEAEGcBcCcEsDG0BcoBmBDANpApgLABQi2mkkoACnrJAPYB2oA3saKI5gLZ5owJGAcwDc7UJiF9OAV24AjWmKIBfYsVLlKAUW4AHbPQCeePK3Fde-OPGHKOk6YzmLY90JByZYRtM4VKxGpExCCgAPIA0hpMMKB6aDR0TKAAvJx4AO6gugbGpgAUAJQiQA"
      },
      {
        "text": "Try",
        "href": "https://www.typescriptlang.org/play/#code/MYGwhgzhAECiC2AHALgT2gbwL4FgBQ+AZgK4B2wyAlgPanSGkAUAHgFxxJoCUm+00AegHRgYUgHJk0ACbVoY1MgAWlUgHNoAd0rLo45uIA00CHICSW2pPy4CeIdACCIENADyAaQCERJttKymlwA3L6M2CFhDCFAA"
      }
    ],
    "meta": {
      "description": "How classes work in TypeScript",
      "keywords": ""
    },
    "summary": "Background Reading:Classes (MDN) TypeScript offers full support for the class keyword introduced in ES2015",
    "tags": [
      "react",
      "javascript",
      "typescript",
      "css",
      "html",
      "classes",
      "members",
      "static",
      "this",
      "class"
    ],
    "id": "typescript-documentation-classeshtml-part-1",
    "quality": 100
  },
  {
    "title": "TypeScript: Documentation",
    "url": "https://www.typescriptlang.org/docs/handbook/2/modules.html",
    "category": "typescript",
    "content": "JavaScript has a long history of different ways to handle modularizing code. Having been around since 2012, TypeScript has implemented support for a lot of these formats, but over time the community and the JavaScript specification has converged on a format called ES Modules (or ES6 modules). You might know it as the import/export syntax. ES Modules was added to the JavaScript spec in 2015, and by 2020 had broad support in most web browsers and JavaScript runtimes. For focus, the handbook will cover both ES Modules and its popular pre-cursor CommonJS module.exports = syntax, and you can find information about the other module patterns in the reference section under Modules. How JavaScript Modules are Defined In TypeScript, just as in ECMAScript 2015, any file containing a top-level import or export is considered a module. Conversely, a file without any top-level import or export declarations is treated as a script whose contents are available in the global scope (and therefore to modules as well). Modules are executed within their own scope, not in the global scope. This means that variables, functions, classes, etc. declared in a module are not visible outside the module unless they are explicitly exported using one of the export forms. Conversely, to consume a variable, function, class, interface, etc. exported from a different module, it has to be imported using one of the import forms. Non-modules Before we start, its important to understand what TypeScript considers a module. The JavaScript specification declares that any JavaScript files without an import declaration, export, or top-level await should be considered a script and not a module. Inside a script file variables and types are declared to be in the shared global scope, and its assumed that youll either use the outFile compiler option to join multiple input files into one output file, or use multiple script tags in your HTML to load these files (in the correct order!). If you have a file that doesnt currently have any imports or exports, but you want to be treated as a module, add the line: tsexport {};Try which will change the file to be a module exporting nothing. This syntax works regardless of your module target. Modules in TypeScript Additional Reading: Impatient JS (Modules) MDN: JavaScript Modules There are three main things to consider when writing module-based code in TypeScript: Syntax: What syntax do I want to use to import and export things? Module Resolution: What is the relationship between module names (or paths) and files on disk? Module Output Target: What should my emitted JavaScript module look like? ES Module Syntax A file can declare a main export via export default: ts// @filename: hello.tsexport default function helloWorld() { console.log(\"Hello, world!\");}Try This is then imported via: tsimport helloWorld from \"./hello.js\";helloWorld();Try In addition to the default export, you can have more than one export of variables and functions via the export by omitting default: ts// @filename: maths.tsexport var pi = 3.14;export let squareTwo = 1.41;export const phi = 1.61; export class RandomNumberGenerator {} export function absolute(num: number) { if (num  0) return num * -1; return num;}Try These can be used in another file via the import syntax: tsimport { pi, phi, absolute } from \"./maths.js\"; console.log(pi);const absPhi = absolute(phi); const absPhi: numberTry Additional Import Syntax An import can be renamed using a format like import {old as new}: tsimport { pi as  } from \"./maths.js\"; console.log(); (alias) var : number import Try You can mix and match the above syntax into a single import: ts// @filename: maths.tsexport const pi = 3.14;export default class RandomNumberGenerator {} // @filename: app.tsimport RandomNumberGenerator, { pi as  } from \"./maths.js\"; RandomNumberGenerator; (alias) class RandomNumberGenerator import RandomNumberGenerator console.log(); (alias) const : 3.14 import Try You can take all of the exported objects and put them into a single namespace using * as name: ts// @filename: app.tsimport * as math from \"./maths.js\"; console.log(math.pi);const positivePhi = math.absolute(math.phi); const positivePhi: numberTry You can import a file and not include any variables into your current module via import \"./file\": ts// @filename: app.tsimport \"./maths.js\"; console.log(\"3.14\");Try In this case, the import does nothing. However, all of the code in maths.ts was evaluated, which could trigger side-effects which affect other objects. TypeScript Specific ES Module Syntax Types can be exported and imported using the same syntax as JavaScript values: ts// @filename: animal.tsexport type Cat = { breed: string; yearOfBirth: number }; export interface Dog { breeds: string[]; yearOfBirth: number;} // @filename: app.tsimport { Cat, Dog } from \"./animal.js\";type Animals = Cat  Dog;Try TypeScript has extended the import syntax with two concepts for declaring an import of a type: import type Which is an import statement which can only import types: ts// @filename: animal.tsexport type Cat = { breed: string; yearOfBirth: number };export type Dog = { breeds: string[]; yearOfBirth: number };export const createCatName = () = \"fluffy\"; // @filename: valid.tsimport type { Cat, Dog } from \"./animal.js\";export type Animals = Cat  Dog; // @filename: app.tsimport type { createCatName } from \"./animal.js\";const name = createCatName();'createCatName' cannot be used as a value because it was imported using 'import type'.1361'createCatName' cannot be used as a value because it was imported using 'import type'.Try Inline type imports TypeScript 4.5 also allows for individual imports to be prefixed with type to indicate that the imported reference is a type: ts// @filename: app.tsimport { createCatName, type Cat, type Dog } from \"./animal.js\"; export type Animals = Cat  Dog;const name = createCatName();Try Together these allow a non-TypeScript transpiler like Babel, swc or esbuild to know what imports can be safely removed. ES Module Syntax with CommonJS Behavior TypeScript has ES Module syntax which directly correlates to a CommonJS and AMD require. Imports using ES Module are for most cases the same as the require from those environments, but this syntax ensures you have a 1 to 1 match in your TypeScript file with the CommonJS output: tsimport fs = require(\"fs\");const code = fs.readFileSync(\"hello.ts\", \"utf8\");Try You can learn more about this syntax in the modules reference page. CommonJS Syntax CommonJS is the format which most modules on npm are delivered in. Even if you are writing using the ES Modules syntax above, having a brief understanding of how CommonJS syntax works will help you debug easier. Exporting Identifiers are exported via setting the exports property on a global called module. tsfunction absolute(num: number) { if (num  0) return num * -1; return num;} module.exports = { pi: 3.14, squareTwo: 1.41, phi: 1.61, absolute,};Try Then these files can be imported via a require statement: tsconst maths = require(\"./maths\");maths.pi; anyTry Or you can simplify a bit using the destructuring feature in JavaScript: tsconst { squareTwo } = require(\"./maths\");squareTwo; const squareTwo: anyTry CommonJS and ES Modules interop There is a mis-match in features between CommonJS and ES Modules regarding the distinction between a default import and a module namespace object import. TypeScript has a compiler flag to reduce the friction between the two different sets of constraints with esModuleInterop. TypeScripts Module Resolution Options Module resolution is the process of taking a string from the import or require statement, and determining what file that string refers to. TypeScript includes two resolution strategies: Classic and Node. Classic, the default when the compiler option module is not commonjs, is included for backwards compatibility. The Node strategy replicates how Node.js works in CommonJS mode, with additional checks for .ts and .d.ts. There are many TSConfig flags which influence the module strategy within TypeScript: moduleResolution, baseUrl, paths, rootDirs. For the full details on how these strategies work, you can consult the Module Resolution reference page. TypeScripts Module Output Options There are two options which affect the emitted JavaScript output: target which determines which JS features are downleveled (converted to run in older JavaScript runtimes) and which are left intact module which determines what code is used for modules to interact with each other Which target you use is determined by the features available in the JavaScript runtime you expect to run the TypeScript code in. That could be: the oldest web browser you support, the lowest version of Node.js you expect to run on or could come from unique constraints from your runtime - like Electron for example. All communication between modules happens via a module loader, the compiler option module determines which one is used. At runtime the module loader is responsible for locating and executing all dependencies of a module before executing it. For example, here is a TypeScript file using ES Modules syntax, showcasing a few different options for module: tsimport { valueOfPi } from \"./constants.js\"; export const twoPi = valueOfPi * 2;Try ES2020 tsimport { valueOfPi } from \"./constants.js\";export const twoPi = valueOfPi * 2; Try CommonJS ts\"use strict\";Object.defineProperty(exports, \"__esModule\", { value: true });exports.twoPi = void 0;const constants_js_1 = require(\"./constants.js\");exports.twoPi = constants_js_1.valueOfPi * 2; Try UMD ts(function (factory) { if (typeof module === \"object\" && typeof module.exports === \"object\") { var v = factory(require, exports); if (v !== undefined) module.exports = v; } else if (typeof define === \"function\" && define.amd) { define([\"require\", \"exports\", \"./constants.js\"], factory); }})(function (require, exports) { \"use strict\"; Object.defineProperty(exports, \"__esModule\", { value: true }); exports.twoPi = void 0; const constants_js_1 = require(\"./constants.js\"); exports.twoPi = constants_js_1.valueOfPi * 2;}); Try Note that ES2020 is effectively the same as the original index.ts. You can see all of the available options and what their emitted JavaScript code looks like in the TSConfig Reference for module. TypeScript namespaces TypeScript has its own module format called namespaces which pre-dates the ES Modules standard. This syntax has a lot of useful features for creating complex definition files, and still sees active use in DefinitelyTyped. While not deprecated, the majority of the features in namespaces exist in ES Modules and we recommend you use that to align with JavaScripts direction. You can learn more about namespaces in the namespaces reference page.",
    "headings": [
      {
        "level": 2,
        "text": "How JavaScript Modules are Defined",
        "id": "how-javascript-modules-are-defined"
      },
      {
        "level": 2,
        "text": "Non-modules",
        "id": "non-modules"
      },
      {
        "level": 2,
        "text": "Modules in TypeScript",
        "id": "modules-in-typescript"
      },
      {
        "level": 2,
        "text": "CommonJS Syntax",
        "id": "commonjs-syntax"
      },
      {
        "level": 2,
        "text": "TypeScript’s Module Resolution Options",
        "id": "typescripts-module-resolution-options"
      },
      {
        "level": 2,
        "text": "TypeScript’s Module Output Options",
        "id": "typescripts-module-output-options"
      },
      {
        "level": 2,
        "text": "TypeScript namespaces",
        "id": "typescript-namespaces"
      },
      {
        "level": 3,
        "text": "ES Module Syntax",
        "id": "es-module-syntax"
      },
      {
        "level": 3,
        "text": "Additional Import Syntax",
        "id": "additional-import-syntax"
      },
      {
        "level": 3,
        "text": "CommonJS and ES Modules interop",
        "id": "commonjs-and-es-modules-interop"
      },
      {
        "level": 4,
        "text": "TypeScript Specific ES Module Syntax",
        "id": "typescript-specific-es-module-syntax"
      },
      {
        "level": 4,
        "text": "ES Module Syntax with CommonJS Behavior",
        "id": "es-module-syntax-with-commonjs-behavior"
      },
      {
        "level": 4,
        "text": "Exporting",
        "id": "exporting"
      },
      {
        "level": 4,
        "text": "ES2020",
        "id": "es2020"
      },
      {
        "level": 4,
        "text": "CommonJS",
        "id": "commonjs"
      },
      {
        "level": 4,
        "text": "UMD",
        "id": "umd"
      },
      {
        "level": 6,
        "text": "import type",
        "id": "import-type"
      },
      {
        "level": 6,
        "text": "Inline type imports",
        "id": "inline-type-imports"
      }
    ],
    "codeBlocks": [
      {
        "language": "text",
        "code": "module.exports ="
      },
      {
        "language": "text",
        "code": "tsexport {};Try"
      },
      {
        "language": "text",
        "code": "export default"
      },
      {
        "language": "text",
        "code": "ts// @filename: hello.tsexport default function helloWorld() {  console.log(\"Hello, world!\");}Try"
      },
      {
        "language": "text",
        "code": "// @filename: hello.tsexport default function helloWorld() {  console.log(\"Hello, world!\");}"
      },
      {
        "language": "text",
        "code": "tsimport helloWorld from \"./hello.js\";helloWorld();Try"
      },
      {
        "language": "text",
        "code": "import helloWorld from \"./hello.js\";helloWorld();"
      },
      {
        "language": "text",
        "code": "ts// @filename: maths.tsexport var pi = 3.14;export let squareTwo = 1.41;export const phi = 1.61; export class RandomNumberGenerator {} export function absolute(num: number) {  if (num < 0) return num * -1;  return num;}Try"
      },
      {
        "language": "text",
        "code": "// @filename: maths.tsexport var pi = 3.14;export let squareTwo = 1.41;export const phi = 1.61; export class RandomNumberGenerator {} export function absolute(num: number) {  if (num < 0) return num * -1;  return num;}"
      },
      {
        "language": "text",
        "code": "tsimport { pi, phi, absolute } from \"./maths.js\"; console.log(pi);const absPhi = absolute(phi);        const absPhi: numberTry"
      },
      {
        "language": "text",
        "code": "import { pi, phi, absolute } from \"./maths.js\"; console.log(pi);const absPhi = absolute(phi);        const absPhi: number"
      },
      {
        "language": "text",
        "code": "import {old as new}"
      },
      {
        "language": "text",
        "code": "tsimport { pi as π } from \"./maths.js\"; console.log(π);           (alias) var π: number\nimport πTry"
      },
      {
        "language": "text",
        "code": "import { pi as π } from \"./maths.js\"; console.log(π);           (alias) var π: number\nimport π"
      },
      {
        "language": "text",
        "code": "ts// @filename: maths.tsexport const pi = 3.14;export default class RandomNumberGenerator {} // @filename: app.tsimport RandomNumberGenerator, { pi as π } from \"./maths.js\"; RandomNumberGenerator;         (alias) class RandomNumberGenerator\nimport RandomNumberGenerator console.log(π);           (alias) const π: 3.14\nimport πTry"
      },
      {
        "language": "text",
        "code": "// @filename: maths.tsexport const pi = 3.14;export default class RandomNumberGenerator {} // @filename: app.tsimport RandomNumberGenerator, { pi as π } from \"./maths.js\"; RandomNumberGenerator;         (alias) class RandomNumberGenerator\nimport RandomNumberGenerator console.log(π);           (alias) const π: 3.14\nimport π"
      },
      {
        "language": "text",
        "code": "ts// @filename: app.tsimport * as math from \"./maths.js\"; console.log(math.pi);const positivePhi = math.absolute(math.phi);          const positivePhi: numberTry"
      },
      {
        "language": "text",
        "code": "// @filename: app.tsimport * as math from \"./maths.js\"; console.log(math.pi);const positivePhi = math.absolute(math.phi);          const positivePhi: number"
      },
      {
        "language": "text",
        "code": "import \"./file\""
      },
      {
        "language": "text",
        "code": "ts// @filename: app.tsimport \"./maths.js\"; console.log(\"3.14\");Try"
      },
      {
        "language": "text",
        "code": "// @filename: app.tsimport \"./maths.js\"; console.log(\"3.14\");"
      },
      {
        "language": "text",
        "code": "ts// @filename: animal.tsexport type Cat = { breed: string; yearOfBirth: number }; export interface Dog {  breeds: string[];  yearOfBirth: number;} // @filename: app.tsimport { Cat, Dog } from \"./animal.js\";type Animals = Cat | Dog;Try"
      },
      {
        "language": "text",
        "code": "// @filename: animal.tsexport type Cat = { breed: string; yearOfBirth: number }; export interface Dog {  breeds: string[];  yearOfBirth: number;} // @filename: app.tsimport { Cat, Dog } from \"./animal.js\";type Animals = Cat | Dog;"
      },
      {
        "language": "text",
        "code": "import type"
      },
      {
        "language": "text",
        "code": "ts// @filename: animal.tsexport type Cat = { breed: string; yearOfBirth: number };export type Dog = { breeds: string[]; yearOfBirth: number };export const createCatName = () => \"fluffy\"; // @filename: valid.tsimport type { Cat, Dog } from \"./animal.js\";export type Animals = Cat | Dog; // @filename: app.tsimport type { createCatName } from \"./animal.js\";const name = createCatName();'createCatName' cannot be used as a value because it was imported using 'import type'.1361'createCatName' cannot be used as a value because it was imported using 'import type'.Try"
      },
      {
        "language": "text",
        "code": "// @filename: animal.tsexport type Cat = { breed: string; yearOfBirth: number };export type Dog = { breeds: string[]; yearOfBirth: number };export const createCatName = () => \"fluffy\"; // @filename: valid.tsimport type { Cat, Dog } from \"./animal.js\";export type Animals = Cat | Dog; // @filename: app.tsimport type { createCatName } from \"./animal.js\";const name = createCatName();'createCatName' cannot be used as a value because it was imported using 'import type'.1361'createCatName' cannot be used as a value because it was imported using 'import type'."
      },
      {
        "language": "text",
        "code": "ts// @filename: app.tsimport { createCatName, type Cat, type Dog } from \"./animal.js\"; export type Animals = Cat | Dog;const name = createCatName();Try"
      },
      {
        "language": "text",
        "code": "// @filename: app.tsimport { createCatName, type Cat, type Dog } from \"./animal.js\"; export type Animals = Cat | Dog;const name = createCatName();"
      },
      {
        "language": "text",
        "code": "tsimport fs = require(\"fs\");const code = fs.readFileSync(\"hello.ts\", \"utf8\");Try"
      },
      {
        "language": "text",
        "code": "import fs = require(\"fs\");const code = fs.readFileSync(\"hello.ts\", \"utf8\");"
      },
      {
        "language": "text",
        "code": "tsfunction absolute(num: number) {  if (num < 0) return num * -1;  return num;} module.exports = {  pi: 3.14,  squareTwo: 1.41,  phi: 1.61,  absolute,};Try"
      },
      {
        "language": "text",
        "code": "function absolute(num: number) {  if (num < 0) return num * -1;  return num;} module.exports = {  pi: 3.14,  squareTwo: 1.41,  phi: 1.61,  absolute,};"
      },
      {
        "language": "text",
        "code": "tsconst maths = require(\"./maths\");maths.pi;      anyTry"
      },
      {
        "language": "text",
        "code": "const maths = require(\"./maths\");maths.pi;      any"
      },
      {
        "language": "text",
        "code": "tsconst { squareTwo } = require(\"./maths\");squareTwo;   const squareTwo: anyTry"
      },
      {
        "language": "text",
        "code": "const { squareTwo } = require(\"./maths\");squareTwo;   const squareTwo: any"
      },
      {
        "language": "text",
        "code": "esModuleInterop"
      },
      {
        "language": "text",
        "code": "moduleResolution"
      },
      {
        "language": "text",
        "code": "tsimport { valueOfPi } from \"./constants.js\"; export const twoPi = valueOfPi * 2;Try"
      },
      {
        "language": "text",
        "code": "import { valueOfPi } from \"./constants.js\"; export const twoPi = valueOfPi * 2;"
      },
      {
        "language": "text",
        "code": "tsimport { valueOfPi } from \"./constants.js\";export const twoPi = valueOfPi * 2; Try"
      },
      {
        "language": "text",
        "code": "import { valueOfPi } from \"./constants.js\";export const twoPi = valueOfPi * 2;"
      },
      {
        "language": "text",
        "code": "ts\"use strict\";Object.defineProperty(exports, \"__esModule\", { value: true });exports.twoPi = void 0;const constants_js_1 = require(\"./constants.js\");exports.twoPi = constants_js_1.valueOfPi * 2; Try"
      },
      {
        "language": "text",
        "code": "\"use strict\";Object.defineProperty(exports, \"__esModule\", { value: true });exports.twoPi = void 0;const constants_js_1 = require(\"./constants.js\");exports.twoPi = constants_js_1.valueOfPi * 2;"
      },
      {
        "language": "text",
        "code": "ts(function (factory) {    if (typeof module === \"object\" && typeof module.exports === \"object\") {        var v = factory(require, exports);        if (v !== undefined) module.exports = v;    }    else if (typeof define === \"function\" && define.amd) {        define([\"require\", \"exports\", \"./constants.js\"], factory);    }})(function (require, exports) {    \"use strict\";    Object.defineProperty(exports, \"__esModule\", { value: true });    exports.twoPi = void 0;    const constants_js_1 = require(\"./constants.js\");    exports.twoPi = constants_js_1.valueOfPi * 2;}); Try"
      },
      {
        "language": "text",
        "code": "(function (factory) {    if (typeof module === \"object\" && typeof module.exports === \"object\") {        var v = factory(require, exports);        if (v !== undefined) module.exports = v;    }    else if (typeof define === \"function\" && define.amd) {        define([\"require\", \"exports\", \"./constants.js\"], factory);    }})(function (require, exports) {    \"use strict\";    Object.defineProperty(exports, \"__esModule\", { value: true });    exports.twoPi = void 0;    const constants_js_1 = require(\"./constants.js\");    exports.twoPi = constants_js_1.valueOfPi * 2;});"
      }
    ],
    "links": [
      {
        "text": "Modules",
        "href": "/docs/handbook/modules.html"
      },
      {
        "text": "outFile",
        "href": "/tsconfig#outFile"
      },
      {
        "text": "Try",
        "href": "https://www.typescriptlang.org/play/#code/KYDwDg9gTgLgBAbwL4G4g"
      },
      {
        "text": "Impatient JS (Modules)",
        "href": "https://exploringjs.com/impatient-js/ch_modules.html#overview-syntax-of-ecmascript-modules"
      },
      {
        "text": "MDN: JavaScript Modules",
        "href": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Guide/Modules"
      },
      {
        "text": "Try",
        "href": "https://www.typescriptlang.org/play/#code/PTAEAEDMEsBsFMB2BDAtvAXKAFvWsB7AOgBcBnAWACh4APABwICcTQATeSZAV1lcm6IAxiWgFEOPIQDqzWGwAUASlABvaqFBDxZAgiKEA5goBEACSkEANKADuctgEITSgNzUAvkA"
      },
      {
        "text": "Try",
        "href": "https://www.typescriptlang.org/play/#code/PTAEAEDMEsBsFMB2BDAtvAXKAFvWsB7AOgBcBnAWACh4APABwICcTQATeSZAV1lcm6IAxiWgFEOPIQDqzWGwAUASlABvaqFBDxZAgiKEA5goBEACSkEANKADuctgEITSgNzUAvtRAQYCFOhY0IgctKSUVD4AtDFC3CQxUdTQqIwskvgEskzyoJBMBKigJkTAuJlEAFZkJu5U5TIOyq5AA"
      },
      {
        "text": "Try",
        "href": "https://www.typescriptlang.org/play/#code/PTAEAEDMEsBsFMB2BDAtvAXKVyAuALAZwDpdCBYAKHgA8AHAewCddQA3ZJ0O6UAXlABmYgEYALAG4qtRi1AJWhAI4BXTvAAqAdwb9QI4mJFTq9ZqwDGDRIVZ18vAQYBsxqtLNyLsZIUKgAJWREABMGVAA5FVQAI3gmAHEkeLxmUABvAF93U1lWSBVEC1xoa1BkGMIGWBVceAAKRGisJtj4gEoMqlBQaEhQRujQAB5QAAZOpnhcFSZEUFbQACpQAFo3Sh6pmbmF6JNMoA"
      },
      {
        "text": "Try",
        "href": "https://www.typescriptlang.org/play/#code/PTAEAEDMEsBsFMB2BDAtvAXKVyAuALAZwDpdCBYAKHgA8AHAewCddQA3ZJ0O6UAXlABmYgEYALAG4qtRi1AJWhAI4BXTvAAqAdwb9QI4mJFTq9ZqwDGDRIVZ18vAQYBsx6WbkXYyQoVAAlZEQAEwZUADkVVAAjeCYAcSQ4vGZQAG8AX3dZVkgVRAtcaGtQZGjCBlgVXHgACkQorAaYuIBKdKpQUGhIUHqo0AAeUAAGdqZ4XBUmRFBm0AAqUABaN0ouiamZuaiTLMoQCBgEFHQsZDo6UgoDsGX7i2r75apoVBz07mgAGm4HX7KFSqNVAGVAkCYYVAACJiMAcAQSAArQjQkxUKw2SrwYiwBgAc1qPFaJkxtlK5QACg49IDKtU6vZoCSqIcuqAAHoAfiAA"
      },
      {
        "text": "Try",
        "href": "https://www.typescriptlang.org/play/#code/PTAEAEDMEsBsFMB2BDAtvAXKVyAuALAZwDpdCBYAKHgA8AHAewCddQA3ZJ0O6UAXlABmYgEYALAG4qICDAQp0WZHTqkKlGQFptAYwCuubZqrRUjFqADe3XskKhAA8CgAvqEhMGqUACJiwHAQkAFaE3lKUVDoMiIQMCMSwDADmABQOAJThMqA5ubkAegD8QA"
      },
      {
        "text": "Try",
        "href": "https://www.typescriptlang.org/play/#code/PTAEAEDMEsBsFMB2BDAtvAXKVyAuALAZwDpdCBYAKHgA8AHAewCddQBjBxQ1u6UAXlABmYgEYALAG4qtRi1AATeJGQBXWKzaxkhQqABKyRAoaoAcqtQAjeEwDiSW3magA3gF8qVEBBgIU6FjIdHSkFJTQqHKshsamFta2DohOuMwANG6gvKA6oIADwKDuoJBMpqAARMTAOAQkAFaEFdKUVLEm5pY29o5MzkwtPgB6APxelBxcDAjEsAwA5gAU+QCUg2Cgm1tbo0A"
      },
      {
        "text": "Try",
        "href": "https://www.typescriptlang.org/play/#code/PTAEAEDMEsBsFMB2BDAtvAXKVyAuALAZwDpdCBYAKHgA8AHAewCddQA3ZJ0O6UAXlABmYgEYALAG4qtRi1AJWhAI4BXTvAAqAdwb9QI4mJFTq9ZqwDGDRIVZ18vAQYBsxqtLNzIKxBdzRrUGQAI0IGWBVceAAKRBVULDjUYPgmAEpQAG8qUFBoSFBY+NAAHlAABgymeFwVJkRQJNAAKlAAWjdKXOra+sb4kwBfKhB2traLSPG2kbAoOCQ0TCC6OlIKSmhUWVZW5EJsPHxQSCYGVFAAImJgHAISACtCS5MqKxtw+GJYBgBzaLu+GIPDSJnetm4DEI0H8bHgAAUHHpAcQQmEIlEAUdgQ5QbNcrkAHoAfiAA"
      },
      {
        "text": "Try",
        "href": "https://www.typescriptlang.org/play/#code/PTAEAEDMEsBsFMB2BDAtvAXKVyAuALAZwDpdCBYAKHgA8AHAewCddQA3ZJ0O6UAXlABmYgEYALAG4qIUAFp5AYwCuuebOlgocJGkyhkdOqQqVoqRi1AAiYsBwESAK0JWplKgoaJCDBMVgMAOYAFFbC4lYAlBJAA"
      },
      {
        "text": "Try",
        "href": "https://www.typescriptlang.org/play/#code/PTAEAEDMEsBsFMB2BDAtvAXKZjqubAHQAuAzgLABQ8AHgA4D2ATsaMQJ53ygDCyrAXlABvUACMm8eABMspYk2iIA5gG5Q7eMiYB5SACFoLABZZEAV1Rj4TUAF9VVKrUYtQS4jcjIAxtwAiDMoiVKDikjKkcgpKygDaALqOlGGa2nqGJmaW1kzJdk6UIBAwCCjoWMh0dCQUlHiurKJ8xAA0oIHBdqCQTAyooABEhMA4eASEAFakg8kcXKAAgrj4sKSgQi2gAD4dQapAA"
      },
      {
        "text": "Try",
        "href": "https://www.typescriptlang.org/play/#code/PTAEAEDMEsBsFMB2BDAtvAXKZjqubAHQAuAzgLABQ8AHgA4D2ATsaMQJ53ygDCyrAXlABvUACMm8eABMspYk2iIA5gG5Q7eMiYB5SACFoLABZZEAV1Rj4TUAF9VVWoxZtO3ACINloIaIlS0qRyCkrKANoAuuqa2nqGJmaW1rYOTvTMrADGDIjyoFmS-PB8xAByaNxCABQAlL4AfKAARJCw5pCQ7M2OlFQgEDAIKOhYAG4E0NIkFJR4LqwcXCK8-AA0oF4+dqCQTAyoLYTAOHgEhABWpD3pC27LAIK4+LCkvqusAD6b3r39YFA4EhKlhkHQ6DN-hAbPsmMFQABGADMADYEVR5pl7txRIUtMQSvwKuh7Lt9odmsdTi9Ltdejk8qwRlUCkUCaVifA6qogA"
      },
      {
        "text": "Try",
        "href": "https://www.typescriptlang.org/play/#code/PTAEAEDMEsBsFMB2BDAtvAXKZjqubAHQAuAzgLABQ8AHgA4D2ATsaMQJ53ygDCyrAXlABvUACMm8eABMspYk2iIA5gG5Q7eMiYB5SACFoLABZZEAV1Rj4TUAF9VVWoxZtO3ACINloIaIlS0qRyCkrKANoAuuqa2nqGJmaW1rYOTvTMrADGDIjyoFmS-PB8xAByaNxCABQAlL4AfKAARJCw5pCQ7M2OlCCgALRDWebEQwNU-VBwSJVYyHR0JBSUeC6sooVaxCX8FegANG5cvPxHHCdePnagkEwMqC2EwDh4BIQAVqQ9VOnrx9wAIK4fCwUi+U6sAA+oCuvRyeVYKHQEK2xVK+3gdVUQA"
      },
      {
        "text": "Try",
        "href": "https://www.typescriptlang.org/play/#code/PQgEB4CcFMDNpgOwMbVAFwJ4AdoGcBeAIkQHsATaI0YAPgFgAoMAAQFsKBXAG2gC5QyUmw6IAVniZgAtLOSd0s6UwCWbbKUjpQsPKAKgYAR04qYACiK6iASgDcTIYjzahlfTrwA6GAENyAGIqvADKmCiWABbQ3NykXuh4RAA0oEQKsAActnZAA"
      },
      {
        "text": "modules reference page",
        "href": "/docs/handbook/modules.html#export--and-import--require"
      },
      {
        "text": "Try",
        "href": "https://www.typescriptlang.org/play/#code/PQgEB4CcFMDNpgOwMbVAFwJ4AdoGcBeAIkQHsATaI0YAPgFgAoMAWjeQFd02WnYOU6AJalEoAIYAjPKQA2XaAApEHALYAuUCtWSEASlABvJqFBDYoZWoigADAZjoOkMdtAAqUCwCMAbhOgjs6uav6MAL5MTKoUHLLQAHTQAB7YpJDoeKAERgHYQpoAzAneACwANAF4AI4c4jAAKgDupJreCaXelYym2AAWBaDtAGxdAVIy8ujQ3eG+QA"
      },
      {
        "text": "Try",
        "href": "https://www.typescriptlang.org/play/#code/PTAEAEFsHsBMFcA2BTAXKAxtSMB2ArAZwFgAoECAMwEsVcBDSNUSegFwAtCA6Nk8igB4ATskrJRuDMlBsAngAdkhALwAiXHGRrQwAHxlK8KW2rRcoegCNC0RPDbIAFLniR0ryFYkBKUAG8yUFBqSlAXN1BBUAAGP1E2eGELT1AAKlAAWgBGAG4g0ASklLd80gBfMjIYBBRuZAAPBWhhPlAVAIKFanQAZm5sgBYAGgLCAEd4elEAFQB3aHRs7kHs0dJghQ4e0GWANjWC61t7R3XysopwGjpGZmpcWEbefgpM94wHd8yyLFxCNgsdhcdqFZCTaiiJxqbjAVicQhqHxleFcbjdS5gYKgAB6AH4gA"
      },
      {
        "text": "Try",
        "href": "https://www.typescriptlang.org/play/#code/PTAEAEFsHsBMFcA2BTAXKAxtSMB2ArAZwFgAoECAMwEsVcBDSNUSegFwAtCA6Nk8igB4ATskrJRuDMlBsAngAdkhALwAiXHGRrQwAHxlK8KW2rRcoegCNC0RPDbIAFLniR0ryFYkBKUAG8yUFBqSlAXN1BBUAAGP1E2eGELT1AAKlAAWgBGAG4g0ASklLd80gBfMjIYBBRuZAAPBWhhPlAVAIKFanQAZm5sgBYAGgLCAEd4elEAFQB3aHRs7kHs0dJghQ4e0GWANjWC61t7R3XysopwGjpGZmpcWEbefgpM94wHd8yyLFxCNgBUATKazBagcrtQrISbUURONTcYCsTiENQ+Mog6bIebQS5gAB6AH4gA"
      },
      {
        "text": "esModuleInterop",
        "href": "/tsconfig#esModuleInterop"
      },
      {
        "text": "module",
        "href": "/tsconfig#module"
      },
      {
        "text": "moduleResolution",
        "href": "/tsconfig#moduleResolution"
      },
      {
        "text": "baseUrl",
        "href": "/tsconfig#baseUrl"
      },
      {
        "text": "paths",
        "href": "/tsconfig#paths"
      },
      {
        "text": "rootDirs",
        "href": "/tsconfig#rootDirs"
      },
      {
        "text": "Module Resolution",
        "href": "/docs/handbook/modules/reference.html#the-moduleresolution-compiler-option"
      },
      {
        "text": "target",
        "href": "/tsconfig#target"
      },
      {
        "text": "module",
        "href": "/tsconfig#module"
      },
      {
        "text": "target",
        "href": "/tsconfig#target"
      },
      {
        "text": "module",
        "href": "/tsconfig#module"
      },
      {
        "text": "module",
        "href": "/tsconfig#module"
      },
      {
        "text": "Try",
        "href": "https://www.typescriptlang.org/play/#code/PTAEAEDMEsBsFMB2BDAtvAXKAxge0QM4AuyiRBAdOQLABQ8AHgA64BORO+xoAbsrAFd4AeUgAFaKAC8oAMwUAjABYATAG46ICDAQp0WaIgAmjKgU1gAtNewCi1y3WioW7UAG9e-IaImgAvqCQrLiooABEFMB4hCRklABWBOEatHSMrhwx3EQA7rh+MnyCIuKSAFSg6kA"
      },
      {
        "text": "Try",
        "href": "https://www.typescriptlang.org/play/#code/PTAEAEGcAsHsHcCiBbAlgFwLACgQWbACYCuANgKYBco5kATAAyM57gB2siATl7F5DlTIADn3SgA3qABuAQ1LFyAeQBmABVSgAvqBW9koAEQA6YAGNYbSOllt0kYwCtIhgNw4c5AB6iu4i1bi6PCwGqAAvDLyiqphAFSgdK5AA"
      },
      {
        "text": "Try",
        "href": "https://www.typescriptlang.org/play/#code/PTAEAEGcAsHsHcCiBbAlgFwLACgQWbACYCuANgKYBcoAxrMgQHYBWkOe4jsiATj7DzbZUyAA4D0oAN6gAbgENSxcgHkAZgAVUoAL6g1-ZKABEAOmB1GkdPMbpIp1sYDcOHOQAe4npMvXQ6PCwWqAAvHKKyuohAFSgAEzOQA"
      },
      {
        "text": "Try",
        "href": "https://www.typescriptlang.org/play/#code/PTAEAEGcAsHsHcCiBbAlgFwLACgQWbACYCuANgKYBcoxyhOe4AdrIgE5uxuQ6rIAOXdKADeoAG4BDUsXIB5AGYAFVKAC+oBZ2SgARADpgAY1hNI6SU3SR9AK0i6A3DhzkAHoLbCTZ4eniwKqAAvBLSsopBAFSgAEyOQA"
      },
      {
        "text": "TSConfig Reference for module",
        "href": "/tsconfig#module"
      },
      {
        "text": "in DefinitelyTyped",
        "href": "https://github.com/DefinitelyTyped/DefinitelyTyped"
      },
      {
        "text": "the namespaces reference page",
        "href": "/docs/handbook/namespaces.html"
      }
    ],
    "meta": {
      "description": "How JavaScript handles communicating across file boundaries.",
      "keywords": ""
    },
    "summary": "JavaScript has a long history of different ways to handle modularizing code",
    "tags": [
      "react",
      "angular",
      "javascript",
      "typescript",
      "html",
      "node",
      "webpack",
      "vite",
      "module",
      "syntax"
    ],
    "id": "typescript-documentation-moduleshtml-part-1",
    "quality": 100
  }
]