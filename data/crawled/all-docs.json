[
  {
    "title": "useState – React",
    "url": "https://react.dev/reference/react/useState",
    "category": "react",
    "content": "API ReferenceHooksuseStateuseState is a React Hook that lets you add a state variable to your component.const [state, setState] = useState(initialState) Reference useState(initialState) set functions, like setSomething(nextState) Usage Adding state to a component Updating state based on the previous state Updating objects and arrays in state Avoiding recreating the initial state Resetting state with a key Storing information from previous renders Troubleshooting Ive updated the state, but logging gives me the old value Ive updated the state, but the screen doesnt update Im getting an error: Too many re-renders My initializer or updater function runs twice Im trying to set state to a function, but it gets called instead Reference useState(initialState) Call useState at the top level of your component to declare a state variable. import { useState } from 'react';function MyComponent() { const [age, setAge] = useState(28); const [name, setName] = useState('Taylor'); const [todos, setTodos] = useState(() = createTodos()); // ... The convention is to name state variables like [something, setSomething] using array destructuring. See more examples below. Parameters initialState: The value you want the state to be initially. It can be a value of any type, but there is a special behavior for functions. This argument is ignored after the initial render. If you pass a function as initialState, it will be treated as an initializer function. It should be pure, should take no arguments, and should return a value of any type. React will call your initializer function when initializing the component, and store its return value as the initial state. See an example below. Returns useState returns an array with exactly two values: The current state. During the first render, it will match the initialState you have passed. The set function that lets you update the state to a different value and trigger a re-render. Caveats useState is a Hook, so you can only call it at the top level of your component or your own Hooks. You cant call it inside loops or conditions. If you need that, extract a new component and move the state into it. In Strict Mode, React will call your initializer function twice in order to help you find accidental impurities. This is development-only behavior and does not affect production. If your initializer function is pure (as it should be), this should not affect the behavior. The result from one of the calls will be ignored. set functions, like setSomething(nextState) The set function returned by useState lets you update the state to a different value and trigger a re-render. You can pass the next state directly, or a function that calculates it from the previous state: const [name, setName] = useState('Edward');function handleClick() { setName('Taylor'); setAge(a = a + 1); // ... Parameters nextState: The value that you want the state to be. It can be a value of any type, but there is a special behavior for functions. If you pass a function as nextState, it will be treated as an updater function. It must be pure, should take the pending state as its only argument, and should return the next state. React will put your updater function in a queue and re-render your component. During the next render, React will calculate the next state by applying all of the queued updaters to the previous state. See an example below. Returns set functions do not have a return value. Caveats The set function only updates the state variable for the next render. If you read the state variable after calling the set function, you will still get the old value that was on the screen before your call. If the new value you provide is identical to the current state, as determined by an Object.is comparison, React will skip re-rendering the component and its children. This is an optimization. Although in some cases React may still need to call your component before skipping the children, it shouldnt affect your code. React batches state updates. It updates the screen after all the event handlers have run and have called their set functions. This prevents multiple re-renders during a single event. In the rare case that you need to force React to update the screen earlier, for example to access the DOM, you can use flushSync. The set function has a stable identity, so you will often see it omitted from Effect dependencies, but including it will not cause the Effect to fire. If the linter lets you omit a dependency without errors, it is safe to do. Learn more about removing Effect dependencies. Calling the set function during rendering is only allowed from within the currently rendering component. React will discard its output and immediately attempt to render it again with the new state. This pattern is rarely needed, but you can use it to store information from the previous renders. See an example below. In Strict Mode, React will call your updater function twice in order to help you find accidental impurities. This is development-only behavior and does not affect production. If your updater function is pure (as it should be), this should not affect the behavior. The result from one of the calls will be ignored. Usage Adding state to a component Call useState at the top level of your component to declare one or more state variables. import { useState } from 'react';function MyComponent() { const [age, setAge] = useState(42); const [name, setName] = useState('Taylor'); // ... The convention is to name state variables like [something, setSomething] using array destructuring. useState returns an array with exactly two items: The current state of this state variable, initially set to the initial state you provided. The set function that lets you change it to any other value in response to interaction. To update whats on the screen, call the set function with some next state: function handleClick() { setName('Robin');} React will store the next state, render your component again with the new values, and update the UI. PitfallCalling the set function does not change the current state in the already executing code:function handleClick() { setName('Robin'); console.log(name); // Still \"Taylor\"!}It only affects what useState will return starting from the next render. Basic useState examples1. Counter (number) 2. Text field (string) 3. Checkbox (boolean) 4. Form (two variables) Example 1 of 4: Counter (number) In this example, the count state variable holds a number. Clicking the button increments it.App.jsApp.js Download ResetForkimport { useState } from 'react'; export default function Counter() { const [count, setCount] = useState(0); function handleClick() { setCount(count + 1); } return ( button onClick={handleClick} You pressed me {count} times /button ); } Next Example Updating state based on the previous state Suppose the age is 42. This handler calls setAge(age + 1) three times: function handleClick() { setAge(age + 1); // setAge(42 + 1) setAge(age + 1); // setAge(42 + 1) setAge(age + 1); // setAge(42 + 1)} However, after one click, age will only be 43 rather than 45! This is because calling the set function does not update the age state variable in the already running code. So each setAge(age + 1) call becomes setAge(43). To solve this problem, you may pass an updater function to setAge instead of the next state: function handleClick() { setAge(a = a + 1); // setAge(42 = 43) setAge(a = a + 1); // setAge(43 = 44) setAge(a = a + 1); // setAge(44 = 45)} Here, a = a + 1 is your updater function. It takes the pending state and calculates the next state from it. React puts your updater functions in a queue. Then, during the next render, it will call them in the same order: a = a + 1 will receive 42 as the pending state and return 43 as the next state. a = a + 1 will receive 43 as the pending state and return 44 as the next state. a = a + 1 will receive 44 as the pending state and return 45 as the next state. There are no other queued updates, so React will store 45 as the current state in the end. By convention, its common to name the pending state argument for the first letter of the state variable name, like a for age. However, you may also call it like prevAge or something else that you find clearer. React may call your updaters twice in development to verify that they are pure. Deep DiveIs using an updater always preferred? Show DetailsYou might hear a recommendation to always write code like setAge(a = a + 1) if the state youre setting is calculated from the previous state. There is no harm in it, but it is also not always necessary.In most cases, there is no difference between these two approaches. React always makes sure that for intentional user actions, like clicks, the age state variable would be updated before the next click. This means there is no risk of a click handler seeing a stale age at the beginning of the event handler.However, if you do multiple updates within the same event, updaters can be helpful. Theyre also helpful if accessing the state variable itself is inconvenient (you might run into this when optimizing re-renders).If you prefer consistency over slightly more verbose syntax, its reasonable to always write an updater if the state youre setting is calculated from the previous state. If its calculated from the previous state of some other state variable, you might want to combine them into one object and use a reducer. The difference between passing an updater and passing the next state directly1. Passing the updater function 2. Passing the next state directly Example 1 of 2: Passing the updater function This example passes the updater function, so the +3 button works.App.jsApp.js Download ResetForkimport { useState } from 'react'; export default function Counter() { const [age, setAge] = useState(42); function increment() { setAge(a = a + 1); } return (  h1Your age: {age}/h1 button onClick={() = { increment(); increment(); increment(); }}+3/button button onClick={() = { increment(); }}+1/button / ); } Show moreNext Example Updating objects and arrays in state You can put objects and arrays into state. In React, state is considered read-only, so you should replace it rather than mutate your existing objects. For example, if you have a form object in state, dont mutate it: //  Don't mutate an object in state like this:form.firstName = 'Taylor'; Instead, replace the whole object by creating a new one: //  Replace state with a new objectsetForm({ ...form, firstName: 'Taylor'}); Read updating objects in state and updating arrays in state to learn more. Examples of objects and arrays in state1. Form (object) 2. Form (nested object) 3. List (array) 4. Writing concise update logic with Immer Example 1 of 4: Form (object) In this example, the form state variable holds an object. Each input has a change handler that calls setForm with the next state of the entire form. The { ...form } spread syntax ensures that the state object is replaced rather than mutated.App.jsApp.js Download ResetForkimport { useState } from 'react'; export default function Form() { const [form, setForm] = useState({ firstName: 'Barbara', lastName: 'Hepworth', email: 'bhepworth@sculpture.com', }); return (  label First name: input value={form.firstName} onChange={e = { setForm({ ...form, firstName: e.target.value }); }} / /label label Last name: input value={form.lastName} onChange={e = { setForm({ ...form, lastName: e.target.value }); }} / /label label Email: input value={form.email} onChange={e = { setForm({ ...form, email: e.target.value }); }} / /label p {form.firstName}{' '} {form.lastName}{' '} ({form.email}) /p / ); } Show moreNext Example Avoiding recreating the initial state React saves the initial state once and ignores it on the next renders. function TodoList() { const [todos, setTodos] = useState(createInitialTodos()); // ... Although the result of createInitialTodos() is only used for the initial render, youre still calling this function on every render. This can be wasteful if its creating large arrays or performing expensive calculations. To solve this, you may pass it as an initializer function to useState instead: function TodoList() { const [todos, setTodos] = useState(createInitialTodos); // ... Notice that youre passing createInitialTodos, which is the function itself, and not createInitialTodos(), which is the result of calling it. If you pass a function to useState, React will only call it during initialization. React may call your initializers twice in development to verify that they are pure. The difference between passing an initializer and passing the initial state directly1. Passing the initializer function 2. Passing the initial state directly Example 1 of 2: Passing the initializer function This example passes the initializer function, so the createInitialTodos function only runs during initialization. It does not run when component re-renders, such as when you type into the input.App.jsApp.js Download ResetForkimport { useState } from 'react'; function createInitialTodos() { const initialTodos = []; for (let i = 0; i  50; i++) { initialTodos.push({ id: i, text: 'Item ' + (i + 1) }); } return initialTodos; } export default function TodoList() { const [todos, setTodos] = useState(createInitialTodos); const [text, setText] = useState(''); return (  input value={text} onChange={e = setText(e.target.value)} / button onClick={() = { setText(''); setTodos([{ id: todos.length, text: text }, ...todos]); }}Add/button ul {todos.map(item = ( li key={item.id} {item.text} /li ))} /ul / ); } Show moreNext Example Resetting state with a key Youll often encounter the key attribute when rendering lists. However, it also serves another purpose. You can reset a components state by passing a different key to a component. In this example, the Reset button changes the version state variable, which we pass as a key to the Form. When the key changes, React re-creates the Form component (and all of its children) from scratch, so its state gets reset. Read preserving and resetting state to learn more. App.jsApp.js Download ResetForkimport { useState } from 'react'; export default function App() { const [version, setVersion] = useState(0); function handleReset() { setVersion(version + 1); } return (  button onClick={handleReset}Reset/button Form key={version} / / ); } function Form() { const [name, setName] = useState('Taylor'); return (  input value={name} onChange={e = setName(e.target.value)} / pHello, {name}./p / ); } Show more Storing information from previous renders Usually, you will update state in event handlers. However, in rare cases you might want to adjust state in response to rendering  for example, you might want to change a state variable when a prop changes. In most cases, you dont need this: If the value you need can be computed entirely from the current props or other state, remove that redundant state altogether. If youre worried about recomputing too often, the useMemo Hook can help. If you want to reset the entire component trees state, pass a different key to your component. If you can, update all the relevant state in the event handlers. In the rare case that none of these apply, there is a pattern you can use to update state based on the values that have been rendered so far, by calling a set function while your component is rendering. Heres an example. This CountLabel component displays the count prop passed to it: export default function CountLabel({ count }) { return h1{count}/h1} Say you want to show whether the counter has increased or decreased since the last change. The count prop doesnt tell you this  you need to keep track of its previous value. Add the prevCount state variable to track it. Add another state variable called trend to hold whether the count has increased or decreased. Compare prevCount with count, and if theyre not equal, update both prevCount and trend. Now you can show both the current count prop and how it has changed since the last render. App.jsCountLabel.jsCountLabel.js ResetForkimport { useState } from 'react'; export default function CountLabel({ count }) { const [prevCount, setPrevCount] = useState(count); const [trend, setTrend] = useState(null); if (prevCount !== count) { setPrevCount(count); setTrend(count  prevCount ? 'increasing' : 'decreasing'); } return (  h1{count}/h1 {trend && pThe count is {trend}/p} / ); } Show more Note that if you call a set function while rendering, it must be inside a condition like prevCount !== count, and there must be a call like setPrevCount(count) inside of the condition. Otherwise, your component would re-render in a loop until it crashes. Also, you can only update the state of the currently rendering component like this. Calling the set function of another component during rendering is an error. Finally, your set call should still update state without mutation  this doesnt mean you can break other rules of pure functions. This pattern can be hard to understand and is usually best avoided. However, its better than updating state in an effect. When you call the set function during render, React will re-render that component immediately after your component exits with a return statement, and before rendering the children. This way, children dont need to render twice. The rest of your component function will still execute (and the result will be thrown away). If your condition is below all the Hook calls, you may add an early return; to restart rendering earlier. Troubleshooting Ive updated the state, but logging gives me the old value Calling the set function does not change state in the running code: function handleClick() { console.log(count); // 0 setCount(count + 1); // Request a re-render with 1 console.log(count); // Still 0! setTimeout(() = { console.log(count); // Also 0! }, 5000);} This is because states behaves like a snapshot. Updating state requests another render with the new state value, but does not affect the count JavaScript variable in your already-running event handler. If you need to use the next state, you can save it in a variable before passing it to the set function: const nextCount = count + 1;setCount(nextCount);console.log(count); // 0console.log(nextCount); // 1 Ive updated the state, but the screen doesnt update React will ignore your update if the next state is equal to the previous state, as determined by an Object.is comparison. This usually happens when you change an object or an array in state directly: obj.x = 10; //  Wrong: mutating existing objectsetObj(obj); //  Doesn't do anything You mutated an existing obj object and passed it back to setObj, so React ignored the update. To fix this, you need to ensure that youre always replacing objects and arrays in state instead of mutating them: //  Correct: creating a new objectsetObj({ ...obj, x: 10}); Im getting an error: Too many re-renders You might get an error that says: Too many re-renders. React limits the number of renders to prevent an infinite loop. Typically, this means that youre unconditionally setting state during render, so your component enters a loop: render, set state (which causes a render), render, set state (which causes a render), and so on. Very often, this is caused by a mistake in specifying an event handler: //  Wrong: calls the handler during renderreturn button onClick={handleClick()}Click me/button//  Correct: passes down the event handlerreturn button onClick={handleClick}Click me/button//  Correct: passes down an inline functionreturn button onClick={(e) = handleClick(e)}Click me/button If you cant find the cause of this error, click on the arrow next to the error in the console and look through the JavaScript stack to find the specific set function call responsible for the error. My initializer or updater function runs twice In Strict Mode, React will call some of your functions twice instead of once: function TodoList() { // This component function will run twice for every render. const [todos, setTodos] = useState(() = { // This initializer function will run twice during initialization. return createTodos(); }); function handleClick() { setTodos(prevTodos = { // This updater function will run twice for every click. return [...prevTodos, createTodo()]; }); } // ... This is expected and shouldnt break your code. This development-only behavior helps you keep components pure. React uses the result of one of the calls, and ignores the result of the other call. As long as your component, initializer, and updater functions are pure, this shouldnt affect your logic. However, if they are accidentally impure, this helps you notice the mistakes. For example, this impure updater function mutates an array in state: setTodos(prevTodos = { //  Mistake: mutating state prevTodos.push(createTodo());}); Because React calls your updater function twice, youll see the todo was added twice, so youll know that there is a mistake. In this example, you can fix the mistake by replacing the array instead of mutating it: setTodos(prevTodos = { //  Correct: replacing with new state return [...prevTodos, createTodo()];}); Now that this updater function is pure, calling it an extra time doesnt make a difference in behavior. This is why React calling it twice helps you find mistakes. Only component, initializer, and updater functions need to be pure. Event handlers dont need to be pure, so React will never call your event handlers twice. Read keeping components pure to learn more. Im trying to set state to a function, but it gets called instead You cant put a function into state like this: const [fn, setFn] = useState(someFunction);function handleClick() { setFn(someOtherFunction);} Because youre passing a function, React assumes that someFunction is an initializer function, and that someOtherFunction is an updater function, so it tries to call them and store the result. To actually store a function, you have to put () = before them in both cases. Then React will store the functions you pass. const [fn, setFn] = useState(() = someFunction);function handleClick() { setFn(() = someOtherFunction);}PrevioususeRefNextuseSyncExternalStore",
    "headings": [
      {
        "level": 1,
        "text": "useState",
        "id": ""
      },
      {
        "level": 2,
        "text": "Reference",
        "id": "reference"
      },
      {
        "level": 2,
        "text": "Usage",
        "id": "usage"
      },
      {
        "level": 2,
        "text": "Troubleshooting",
        "id": "troubleshooting"
      },
      {
        "level": 3,
        "text": "useState(initialState)",
        "id": "usestate"
      },
      {
        "level": 3,
        "text": "set functions, like setSomething(nextState)",
        "id": "setstate"
      },
      {
        "level": 3,
        "text": "Adding state to a component",
        "id": "adding-state-to-a-component"
      },
      {
        "level": 3,
        "text": "Pitfall",
        "id": ""
      },
      {
        "level": 3,
        "text": "Updating state based on the previous state",
        "id": "updating-state-based-on-the-previous-state"
      },
      {
        "level": 3,
        "text": "Updating objects and arrays in state",
        "id": "updating-objects-and-arrays-in-state"
      },
      {
        "level": 3,
        "text": "Avoiding recreating the initial state",
        "id": "avoiding-recreating-the-initial-state"
      },
      {
        "level": 3,
        "text": "Resetting state with a key",
        "id": "resetting-state-with-a-key"
      },
      {
        "level": 3,
        "text": "Storing information from previous renders",
        "id": "storing-information-from-previous-renders"
      },
      {
        "level": 3,
        "text": "I’ve updated the state, but logging gives me the old value",
        "id": "ive-updated-the-state-but-logging-gives-me-the-old-value"
      },
      {
        "level": 3,
        "text": "I’ve updated the state, but the screen doesn’t update",
        "id": "ive-updated-the-state-but-the-screen-doesnt-update"
      },
      {
        "level": 3,
        "text": "I’m getting an error: “Too many re-renders”",
        "id": "im-getting-an-error-too-many-re-renders"
      },
      {
        "level": 3,
        "text": "My initializer or updater function runs twice",
        "id": "my-initializer-or-updater-function-runs-twice"
      },
      {
        "level": 3,
        "text": "I’m trying to set state to a function, but it gets called instead",
        "id": "im-trying-to-set-state-to-a-function-but-it-gets-called-instead"
      },
      {
        "level": 4,
        "text": "Parameters",
        "id": "parameters"
      },
      {
        "level": 4,
        "text": "Returns",
        "id": "returns"
      },
      {
        "level": 4,
        "text": "Caveats",
        "id": "caveats"
      },
      {
        "level": 4,
        "text": "Parameters",
        "id": "setstate-parameters"
      },
      {
        "level": 4,
        "text": "Returns",
        "id": "setstate-returns"
      },
      {
        "level": 4,
        "text": "Caveats",
        "id": "setstate-caveats"
      },
      {
        "level": 4,
        "text": "Basic useState examples",
        "id": "examples-basic"
      },
      {
        "level": 4,
        "text": "Example 1 of 4: Counter (number)",
        "id": "counter-number"
      },
      {
        "level": 4,
        "text": "Is using an updater always preferred?",
        "id": "is-using-an-updater-always-preferred"
      },
      {
        "level": 4,
        "text": "The difference between passing an updater and passing the next state directly",
        "id": "examples-updater"
      },
      {
        "level": 4,
        "text": "Example 1 of 2: Passing the updater function",
        "id": "passing-the-updater-function"
      },
      {
        "level": 4,
        "text": "Examples of objects and arrays in state",
        "id": "examples-objects"
      },
      {
        "level": 4,
        "text": "Example 1 of 4: Form (object)",
        "id": "form-object"
      },
      {
        "level": 4,
        "text": "The difference between passing an initializer and passing the initial state directly",
        "id": "examples-initializer"
      },
      {
        "level": 4,
        "text": "Example 1 of 2: Passing the initializer function",
        "id": "passing-the-initializer-function"
      },
      {
        "level": 5,
        "text": "Deep Dive",
        "id": ""
      }
    ],
    "codeBlocks": [
      {
        "language": "text",
        "code": "const [state, setState] = useState(initialState)"
      },
      {
        "language": "text",
        "code": "const [state, setState] = useState(initialState)"
      },
      {
        "language": "text",
        "code": "useState(initialState)"
      },
      {
        "language": "text",
        "code": "setSomething(nextState)"
      },
      {
        "language": "text",
        "code": "useState(initialState)"
      },
      {
        "language": "text",
        "code": "import { useState } from 'react';function MyComponent() {  const [age, setAge] = useState(28);  const [name, setName] = useState('Taylor');  const [todos, setTodos] = useState(() => createTodos());  // ..."
      },
      {
        "language": "text",
        "code": "import { useState } from 'react';function MyComponent() {  const [age, setAge] = useState(28);  const [name, setName] = useState('Taylor');  const [todos, setTodos] = useState(() => createTodos());  // ..."
      },
      {
        "language": "text",
        "code": "[something, setSomething]"
      },
      {
        "language": "text",
        "code": "initialState"
      },
      {
        "language": "text",
        "code": "initialState"
      },
      {
        "language": "text",
        "code": "initialState"
      },
      {
        "language": "text",
        "code": "setSomething(nextState)"
      },
      {
        "language": "text",
        "code": "const [name, setName] = useState('Edward');function handleClick() {  setName('Taylor');  setAge(a => a + 1);  // ..."
      },
      {
        "language": "text",
        "code": "const [name, setName] = useState('Edward');function handleClick() {  setName('Taylor');  setAge(a => a + 1);  // ..."
      },
      {
        "language": "text",
        "code": "import { useState } from 'react';function MyComponent() {  const [age, setAge] = useState(42);  const [name, setName] = useState('Taylor');  // ..."
      },
      {
        "language": "text",
        "code": "import { useState } from 'react';function MyComponent() {  const [age, setAge] = useState(42);  const [name, setName] = useState('Taylor');  // ..."
      },
      {
        "language": "text",
        "code": "[something, setSomething]"
      },
      {
        "language": "text",
        "code": "function handleClick() {  setName('Robin');}"
      },
      {
        "language": "text",
        "code": "function handleClick() {  setName('Robin');}"
      },
      {
        "language": "text",
        "code": "function handleClick() {  setName('Robin');  console.log(name); // Still \"Taylor\"!}"
      },
      {
        "language": "text",
        "code": "function handleClick() {  setName('Robin');  console.log(name); // Still \"Taylor\"!}"
      },
      {
        "language": "text",
        "code": "import { useState } from 'react';\n\nexport default function Counter() {\n  const [count, setCount] = useState(0);\n\n  function handleClick() {\n    setCount(count + 1);\n  }\n\n  return (\n    <button onClick={handleClick}>\n      You pressed me {count} times\n    </button>\n  );\n}"
      },
      {
        "language": "text",
        "code": "setAge(age + 1)"
      },
      {
        "language": "text",
        "code": "function handleClick() {  setAge(age + 1); // setAge(42 + 1)  setAge(age + 1); // setAge(42 + 1)  setAge(age + 1); // setAge(42 + 1)}"
      },
      {
        "language": "text",
        "code": "function handleClick() {  setAge(age + 1); // setAge(42 + 1)  setAge(age + 1); // setAge(42 + 1)  setAge(age + 1); // setAge(42 + 1)}"
      },
      {
        "language": "text",
        "code": "setAge(age + 1)"
      },
      {
        "language": "text",
        "code": "function handleClick() {  setAge(a => a + 1); // setAge(42 => 43)  setAge(a => a + 1); // setAge(43 => 44)  setAge(a => a + 1); // setAge(44 => 45)}"
      },
      {
        "language": "text",
        "code": "function handleClick() {  setAge(a => a + 1); // setAge(42 => 43)  setAge(a => a + 1); // setAge(43 => 44)  setAge(a => a + 1); // setAge(44 => 45)}"
      },
      {
        "language": "text",
        "code": "setAge(a => a + 1)"
      },
      {
        "language": "text",
        "code": "import { useState } from 'react';\n\nexport default function Counter() {\n  const [age, setAge] = useState(42);\n\n  function increment() {\n    setAge(a => a + 1);\n  }\n\n  return (\n    <>\n      <h1>Your age: {age}</h1>\n      <button onClick={() => {\n        increment();\n        increment();\n        increment();\n      }}>+3</button>\n      <button onClick={() => {\n        increment();\n      }}>+1</button>\n    </>\n  );\n}"
      },
      {
        "language": "text",
        "code": "// 🚩 Don't mutate an object in state like this:form.firstName = 'Taylor';"
      },
      {
        "language": "text",
        "code": "// 🚩 Don't mutate an object in state like this:form.firstName = 'Taylor';"
      },
      {
        "language": "text",
        "code": "// ✅ Replace state with a new objectsetForm({  ...form,  firstName: 'Taylor'});"
      },
      {
        "language": "text",
        "code": "// ✅ Replace state with a new objectsetForm({  ...form,  firstName: 'Taylor'});"
      },
      {
        "language": "text",
        "code": "{ ...form }"
      },
      {
        "language": "text",
        "code": "import { useState } from 'react';\n\nexport default function Form() {\n  const [form, setForm] = useState({\n    firstName: 'Barbara',\n    lastName: 'Hepworth',\n    email: 'bhepworth@sculpture.com',\n  });\n\n  return (\n    <>\n      <label>\n        First name:\n        <input\n          value={form.firstName}\n          onChange={e => {\n            setForm({\n              ...form,\n              firstName: e.target.value\n            });\n          }}\n        />\n      </label>\n      <label>\n        Last name:\n        <input\n          value={form.lastName}\n          onChange={e => {\n            setForm({\n              ...form,\n              lastName: e.target.value\n            });\n          }}\n        />\n      </label>\n      <label>\n        Email:\n        <input\n          value={form.email}\n          onChange={e => {\n            setForm({\n              ...form,\n              email: e.target.value\n            });\n          }}\n        />\n      </label>\n      <p>\n        {form.firstName}{' '}\n        {form.lastName}{' '}\n        ({form.email})\n      </p>\n    </>\n  );\n}"
      },
      {
        "language": "text",
        "code": "function TodoList() {  const [todos, setTodos] = useState(createInitialTodos());  // ..."
      },
      {
        "language": "text",
        "code": "function TodoList() {  const [todos, setTodos] = useState(createInitialTodos());  // ..."
      },
      {
        "language": "text",
        "code": "createInitialTodos()"
      },
      {
        "language": "text",
        "code": "function TodoList() {  const [todos, setTodos] = useState(createInitialTodos);  // ..."
      },
      {
        "language": "text",
        "code": "function TodoList() {  const [todos, setTodos] = useState(createInitialTodos);  // ..."
      },
      {
        "language": "text",
        "code": "createInitialTodos"
      },
      {
        "language": "text",
        "code": "createInitialTodos()"
      },
      {
        "language": "text",
        "code": "createInitialTodos"
      },
      {
        "language": "text",
        "code": "import { useState } from 'react';\n\nfunction createInitialTodos() {\n  const initialTodos = [];\n  for (let i = 0; i < 50; i++) {\n    initialTodos.push({\n      id: i,\n      text: 'Item ' + (i + 1)\n    });\n  }\n  return initialTodos;\n}\n\nexport default function TodoList() {\n  const [todos, setTodos] = useState(createInitialTodos);\n  const [text, setText] = useState('');\n\n  return (\n    <>\n      <input\n        value={text}\n        onChange={e => setText(e.target.value)}\n      />\n      <button onClick={() => {\n        setText('');\n        setTodos([{\n          id: todos.length,\n          text: text\n        }, ...todos]);\n      }}>Add</button>\n      <ul>\n        {todos.map(item => (\n          <li key={item.id}>\n            {item.text}\n          </li>\n        ))}\n      </ul>\n    </>\n  );\n}"
      },
      {
        "language": "text",
        "code": "import { useState } from 'react';\n\nexport default function App() {\n  const [version, setVersion] = useState(0);\n\n  function handleReset() {\n    setVersion(version + 1);\n  }\n\n  return (\n    <>\n      <button onClick={handleReset}>Reset</button>\n      <Form key={version} />\n    </>\n  );\n}\n\nfunction Form() {\n  const [name, setName] = useState('Taylor');\n\n  return (\n    <>\n      <input\n        value={name}\n        onChange={e => setName(e.target.value)}\n      />\n      <p>Hello, {name}.</p>\n    </>\n  );\n}"
      },
      {
        "language": "text",
        "code": "export default function CountLabel({ count }) {  return <h1>{count}</h1>}"
      },
      {
        "language": "text",
        "code": "export default function CountLabel({ count }) {  return <h1>{count}</h1>}"
      },
      {
        "language": "text",
        "code": "import { useState } from 'react';\n\nexport default function CountLabel({ count }) {\n  const [prevCount, setPrevCount] = useState(count);\n  const [trend, setTrend] = useState(null);\n  if (prevCount !== count) {\n    setPrevCount(count);\n    setTrend(count > prevCount ? 'increasing' : 'decreasing');\n  }\n  return (\n    <>\n      <h1>{count}</h1>\n      {trend && <p>The count is {trend}</p>}\n    </>\n  );\n}"
      },
      {
        "language": "text",
        "code": "prevCount !== count"
      },
      {
        "language": "text",
        "code": "setPrevCount(count)"
      },
      {
        "language": "text",
        "code": "function handleClick() {  console.log(count);  // 0  setCount(count + 1); // Request a re-render with 1  console.log(count);  // Still 0!  setTimeout(() => {    console.log(count); // Also 0!  }, 5000);}"
      },
      {
        "language": "text",
        "code": "function handleClick() {  console.log(count);  // 0  setCount(count + 1); // Request a re-render with 1  console.log(count);  // Still 0!  setTimeout(() => {    console.log(count); // Also 0!  }, 5000);}"
      },
      {
        "language": "text",
        "code": "const nextCount = count + 1;setCount(nextCount);console.log(count);     // 0console.log(nextCount); // 1"
      },
      {
        "language": "text",
        "code": "const nextCount = count + 1;setCount(nextCount);console.log(count);     // 0console.log(nextCount); // 1"
      },
      {
        "language": "text",
        "code": "obj.x = 10;  // 🚩 Wrong: mutating existing objectsetObj(obj); // 🚩 Doesn't do anything"
      },
      {
        "language": "text",
        "code": "obj.x = 10;  // 🚩 Wrong: mutating existing objectsetObj(obj); // 🚩 Doesn't do anything"
      },
      {
        "language": "text",
        "code": "// ✅ Correct: creating a new objectsetObj({  ...obj,  x: 10});"
      },
      {
        "language": "text",
        "code": "// ✅ Correct: creating a new objectsetObj({  ...obj,  x: 10});"
      },
      {
        "language": "text",
        "code": "Too many re-renders. React limits the number of renders to prevent an infinite loop."
      },
      {
        "language": "text",
        "code": "// 🚩 Wrong: calls the handler during renderreturn <button onClick={handleClick()}>Click me</button>// ✅ Correct: passes down the event handlerreturn <button onClick={handleClick}>Click me</button>// ✅ Correct: passes down an inline functionreturn <button onClick={(e) => handleClick(e)}>Click me</button>"
      },
      {
        "language": "text",
        "code": "// 🚩 Wrong: calls the handler during renderreturn <button onClick={handleClick()}>Click me</button>// ✅ Correct: passes down the event handlerreturn <button onClick={handleClick}>Click me</button>// ✅ Correct: passes down an inline functionreturn <button onClick={(e) => handleClick(e)}>Click me</button>"
      },
      {
        "language": "text",
        "code": "function TodoList() {  // This component function will run twice for every render.  const [todos, setTodos] = useState(() => {    // This initializer function will run twice during initialization.    return createTodos();  });  function handleClick() {    setTodos(prevTodos => {      // This updater function will run twice for every click.      return [...prevTodos, createTodo()];    });  }  // ..."
      },
      {
        "language": "text",
        "code": "function TodoList() {  // This component function will run twice for every render.  const [todos, setTodos] = useState(() => {    // This initializer function will run twice during initialization.    return createTodos();  });  function handleClick() {    setTodos(prevTodos => {      // This updater function will run twice for every click.      return [...prevTodos, createTodo()];    });  }  // ..."
      },
      {
        "language": "text",
        "code": "setTodos(prevTodos => {  // 🚩 Mistake: mutating state  prevTodos.push(createTodo());});"
      },
      {
        "language": "text",
        "code": "setTodos(prevTodos => {  // 🚩 Mistake: mutating state  prevTodos.push(createTodo());});"
      },
      {
        "language": "text",
        "code": "setTodos(prevTodos => {  // ✅ Correct: replacing with new state  return [...prevTodos, createTodo()];});"
      },
      {
        "language": "text",
        "code": "setTodos(prevTodos => {  // ✅ Correct: replacing with new state  return [...prevTodos, createTodo()];});"
      },
      {
        "language": "text",
        "code": "const [fn, setFn] = useState(someFunction);function handleClick() {  setFn(someOtherFunction);}"
      },
      {
        "language": "text",
        "code": "const [fn, setFn] = useState(someFunction);function handleClick() {  setFn(someOtherFunction);}"
      },
      {
        "language": "text",
        "code": "someFunction"
      },
      {
        "language": "text",
        "code": "someOtherFunction"
      },
      {
        "language": "text",
        "code": "const [fn, setFn] = useState(() => someFunction);function handleClick() {  setFn(() => someOtherFunction);}"
      },
      {
        "language": "text",
        "code": "const [fn, setFn] = useState(() => someFunction);function handleClick() {  setFn(() => someOtherFunction);}"
      }
    ],
    "links": [
      {
        "text": "API Reference",
        "href": "/reference/react"
      },
      {
        "text": "Hooks",
        "href": "/reference/react/hooks"
      },
      {
        "text": "state variable",
        "href": "/learn/state-a-components-memory"
      },
      {
        "text": "state variable.",
        "href": "/learn/state-a-components-memory"
      },
      {
        "text": "array destructuring.",
        "href": "https://javascript.info/destructuring-assignment"
      },
      {
        "text": "Object.is",
        "href": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/is"
      },
      {
        "text": "batches state updates.",
        "href": "/learn/queueing-a-series-of-state-updates"
      },
      {
        "text": "flushSync.",
        "href": "/reference/react-dom/flushSync"
      },
      {
        "text": "Learn more about removing Effect dependencies.",
        "href": "/learn/removing-effect-dependencies#move-dynamic-objects-and-functions-inside-your-effect"
      },
      {
        "text": "state variables.",
        "href": "/learn/state-a-components-memory"
      },
      {
        "text": "array destructuring.",
        "href": "https://javascript.info/destructuring-assignment"
      },
      {
        "text": "does not update",
        "href": "/learn/state-as-a-snapshot"
      },
      {
        "text": "queue.",
        "href": "/learn/queueing-a-series-of-state-updates"
      },
      {
        "text": "pure.",
        "href": "/learn/keeping-components-pure"
      },
      {
        "text": "use a reducer.",
        "href": "/learn/extracting-state-logic-into-a-reducer"
      },
      {
        "text": "updating objects in state",
        "href": "/learn/updating-objects-in-state"
      },
      {
        "text": "updating arrays in state",
        "href": "/learn/updating-arrays-in-state"
      },
      {
        "text": "pure.",
        "href": "/learn/keeping-components-pure"
      },
      {
        "text": "rendering lists.",
        "href": "/learn/rendering-lists"
      },
      {
        "text": "preserving and resetting state",
        "href": "/learn/preserving-and-resetting-state"
      },
      {
        "text": "remove that redundant state altogether.",
        "href": "/learn/choosing-the-state-structure#avoid-redundant-state"
      },
      {
        "text": "useMemo Hook",
        "href": "/reference/react/useMemo"
      },
      {
        "text": "pure functions.",
        "href": "/learn/keeping-components-pure"
      },
      {
        "text": "states behaves like a snapshot.",
        "href": "/learn/state-as-a-snapshot"
      },
      {
        "text": "Object.is",
        "href": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/is"
      },
      {
        "text": "Strict Mode",
        "href": "/reference/react/StrictMode"
      },
      {
        "text": "keep components pure.",
        "href": "/learn/keeping-components-pure"
      },
      {
        "text": "keeping components pure",
        "href": "/learn/keeping-components-pure"
      },
      {
        "text": "PrevioususeRef",
        "href": "/reference/react/useRef"
      },
      {
        "text": "NextuseSyncExternalStore",
        "href": "/reference/react/useSyncExternalStore"
      }
    ],
    "meta": {
      "description": "",
      "keywords": ""
    },
    "summary": "API ReferenceHooksuseStateuseState is a React Hook that lets you add a state variable to your component",
    "tags": [
      "react",
      "angular",
      "javascript",
      "typescript",
      "html",
      "vite",
      "state",
      "passing",
      "usestate",
      "example"
    ],
    "id": "usestate-react-useState-part-1",
    "quality": 100
  },
  {
    "title": "useEffect – React",
    "url": "https://react.dev/reference/react/useEffect",
    "category": "react",
    "content": "API ReferenceHooksuseEffectuseEffect is a React Hook that lets you synchronize a component with an external system.useEffect(setup, dependencies?) Reference useEffect(setup, dependencies?) Usage Connecting to an external system Wrapping Effects in custom Hooks Controlling a non-React widget Fetching data with Effects Specifying reactive dependencies Updating state based on previous state from an Effect Removing unnecessary object dependencies Removing unnecessary function dependencies Reading the latest props and state from an Effect Displaying different content on the server and the client Troubleshooting My Effect runs twice when the component mounts My Effect runs after every re-render My Effect keeps re-running in an infinite cycle My cleanup logic runs even though my component didnt unmount My Effect does something visual, and I see a flicker before it runs Reference useEffect(setup, dependencies?) Call useEffect at the top level of your component to declare an Effect: import { useState, useEffect } from 'react';import { createConnection } from './chat.js';function ChatRoom({ roomId }) { const [serverUrl, setServerUrl] = useState('https://localhost:1234'); useEffect(() = { const connection = createConnection(serverUrl, roomId); connection.connect(); return () = { connection.disconnect(); }; }, [serverUrl, roomId]); // ...} See more examples below. Parameters setup: The function with your Effects logic. Your setup function may also optionally return a cleanup function. When your component is added to the DOM, React will run your setup function. After every re-render with changed dependencies, React will first run the cleanup function (if you provided it) with the old values, and then run your setup function with the new values. After your component is removed from the DOM, React will run your cleanup function. optional dependencies: The list of all reactive values referenced inside of the setup code. Reactive values include props, state, and all the variables and functions declared directly inside your component body. If your linter is configured for React, it will verify that every reactive value is correctly specified as a dependency. The list of dependencies must have a constant number of items and be written inline like [dep1, dep2, dep3]. React will compare each dependency with its previous value using the Object.is comparison. If you omit this argument, your Effect will re-run after every re-render of the component. See the difference between passing an array of dependencies, an empty array, and no dependencies at all. Returns useEffect returns undefined. Caveats useEffect is a Hook, so you can only call it at the top level of your component or your own Hooks. You cant call it inside loops or conditions. If you need that, extract a new component and move the state into it. If youre not trying to synchronize with some external system, you probably dont need an Effect. When Strict Mode is on, React will run one extra development-only setup+cleanup cycle before the first real setup. This is a stress-test that ensures that your cleanup logic mirrors your setup logic and that it stops or undoes whatever the setup is doing. If this causes a problem, implement the cleanup function. If some of your dependencies are objects or functions defined inside the component, there is a risk that they will cause the Effect to re-run more often than needed. To fix this, remove unnecessary object and function dependencies. You can also extract state updates and non-reactive logic outside of your Effect. If your Effect wasnt caused by an interaction (like a click), React will generally let the browser paint the updated screen first before running your Effect. If your Effect is doing something visual (for example, positioning a tooltip), and the delay is noticeable (for example, it flickers), replace useEffect with useLayoutEffect. If your Effect is caused by an interaction (like a click), React may run your Effect before the browser paints the updated screen. This ensures that the result of the Effect can be observed by the event system. Usually, this works as expected. However, if you must defer the work until after paint, such as an alert(), you can use setTimeout. See reactwg/react-18/128 for more information. Even if your Effect was caused by an interaction (like a click), React may allow the browser to repaint the screen before processing the state updates inside your Effect. Usually, this works as expected. However, if you must block the browser from repainting the screen, you need to replace useEffect with useLayoutEffect. Effects only run on the client. They dont run during server rendering. Usage Connecting to an external system Some components need to stay connected to the network, some browser API, or a third-party library, while they are displayed on the page. These systems arent controlled by React, so they are called external. To connect your component to some external system, call useEffect at the top level of your component: import { useState, useEffect } from 'react';import { createConnection } from './chat.js';function ChatRoom({ roomId }) { const [serverUrl, setServerUrl] = useState('https://localhost:1234'); useEffect(() = { const connection = createConnection(serverUrl, roomId); connection.connect(); return () = { connection.disconnect(); }; }, [serverUrl, roomId]); // ...} You need to pass two arguments to useEffect: A setup function with setup code that connects to that system. It should return a cleanup function with cleanup code that disconnects from that system. A list of dependencies including every value from your component used inside of those functions. React calls your setup and cleanup functions whenever its necessary, which may happen multiple times: Your setup code runs when your component is added to the page (mounts). After every re-render of your component where the dependencies have changed: First, your cleanup code runs with the old props and state. Then, your setup code runs with the new props and state. Your cleanup code runs one final time after your component is removed from the page (unmounts). Lets illustrate this sequence for the example above. When the ChatRoom component above gets added to the page, it will connect to the chat room with the initial serverUrl and roomId. If either serverUrl or roomId change as a result of a re-render (say, if the user picks a different chat room in a dropdown), your Effect will disconnect from the previous room, and connect to the next one. When the ChatRoom component is removed from the page, your Effect will disconnect one last time. To help you find bugs, in development React runs setup and cleanup one extra time before the setup. This is a stress-test that verifies your Effects logic is implemented correctly. If this causes visible issues, your cleanup function is missing some logic. The cleanup function should stop or undo whatever the setup function was doing. The rule of thumb is that the user shouldnt be able to distinguish between the setup being called once (as in production) and a setup  cleanup  setup sequence (as in development). See common solutions. Try to write every Effect as an independent process and think about a single setup/cleanup cycle at a time. It shouldnt matter whether your component is mounting, updating, or unmounting. When your cleanup logic correctly mirrors the setup logic, your Effect is resilient to running setup and cleanup as often as needed. NoteAn Effect lets you keep your component synchronized with some external system (like a chat service). Here, external system means any piece of code thats not controlled by React, such as: A timer managed with setInterval() and clearInterval(). An event subscription using window.addEventListener() and window.removeEventListener(). A third-party animation library with an API like animation.start() and animation.reset(). If youre not connecting to any external system, you probably dont need an Effect. Examples of connecting to an external system1. Connecting to a chat server 2. Listening to a global browser event 3. Triggering an animation 4. Controlling a modal dialog 5. Tracking element visibility Example 1 of 5: Connecting to a chat server In this example, the ChatRoom component uses an Effect to stay connected to an external system defined in chat.js. Press Open chat to make the ChatRoom component appear. This sandbox runs in development mode, so there is an extra connect-and-disconnect cycle, as explained here. Try changing the roomId and serverUrl using the dropdown and the input, and see how the Effect re-connects to the chat. Press Close chat to see the Effect disconnect one last time.App.jschat.jsApp.js ResetForkimport { useState, useEffect } from 'react'; import { createConnection } from './chat.js'; function ChatRoom({ roomId }) { const [serverUrl, setServerUrl] = useState('https://localhost:1234'); useEffect(() = { const connection = createConnection(serverUrl, roomId); connection.connect(); return () = { connection.disconnect(); }; }, [roomId, serverUrl]); return (  label Server URL:{' '} input value={serverUrl} onChange={e = setServerUrl(e.target.value)} / /label h1Welcome to the {roomId} room!/h1 / ); } export default function App() { const [roomId, setRoomId] = useState('general'); const [show, setShow] = useState(false); return (  label Choose the chat room:{' '} select value={roomId} onChange={e = setRoomId(e.target.value)}  option value=\"general\"general/option option value=\"travel\"travel/option option value=\"music\"music/option /select /label button onClick={() = setShow(!show)} {show ? 'Close chat' : 'Open chat'} /button {show && hr /} {show && ChatRoom roomId={roomId} /} / ); } Show moreNext Example Wrapping Effects in custom Hooks Effects are an escape hatch: you use them when you need to step outside React and when there is no better built-in solution for your use case. If you find yourself often needing to manually write Effects, its usually a sign that you need to extract some custom Hooks for common behaviors your components rely on. For example, this useChatRoom custom Hook hides the logic of your Effect behind a more declarative API: function useChatRoom({ serverUrl, roomId }) { useEffect(() = { const options = { serverUrl: serverUrl, roomId: roomId }; const connection = createConnection(options); connection.connect(); return () = connection.disconnect(); }, [roomId, serverUrl]);} Then you can use it from any component like this: function ChatRoom({ roomId }) { const [serverUrl, setServerUrl] = useState('https://localhost:1234'); useChatRoom({ roomId: roomId, serverUrl: serverUrl }); // ... There are also many excellent custom Hooks for every purpose available in the React ecosystem. Learn more about wrapping Effects in custom Hooks. Examples of wrapping Effects in custom Hooks1. Custom useChatRoom Hook 2. Custom useWindowListener Hook 3. Custom useIntersectionObserver Hook Example 1 of 3: Custom useChatRoom Hook This example is identical to one of the earlier examples, but the logic is extracted to a custom Hook.App.jsuseChatRoom.jschat.jsApp.js ResetForkimport { useState } from 'react'; import { useChatRoom } from './useChatRoom.js'; function ChatRoom({ roomId }) { const [serverUrl, setServerUrl] = useState('https://localhost:1234'); useChatRoom({ roomId: roomId, serverUrl: serverUrl }); return (  label Server URL:{' '} input value={serverUrl} onChange={e = setServerUrl(e.target.value)} / /label h1Welcome to the {roomId} room!/h1 / ); } export default function App() { const [roomId, setRoomId] = useState('general'); const [show, setShow] = useState(false); return (  label Choose the chat room:{' '} select value={roomId} onChange={e = setRoomId(e.target.value)}  option value=\"general\"general/option option value=\"travel\"travel/option option value=\"music\"music/option /select /label button onClick={() = setShow(!show)} {show ? 'Close chat' : 'Open chat'} /button {show && hr /} {show && ChatRoom roomId={roomId} /} / ); } Show moreNext Example Controlling a non-React widget Sometimes, you want to keep an external system synchronized to some prop or state of your component. For example, if you have a third-party map widget or a video player component written without React, you can use an Effect to call methods on it that make its state match the current state of your React component. This Effect creates an instance of a MapWidget class defined in map-widget.js. When you change the zoomLevel prop of the Map component, the Effect calls the setZoom() on the class instance to keep it synchronized: App.jsMap.jsmap-widget.jsMap.js ResetForkimport { useRef, useEffect } from 'react'; import { MapWidget } from './map-widget.js'; export default function Map({ zoomLevel }) { const containerRef = useRef(null); const mapRef = useRef(null); useEffect(() = { if (mapRef.current === null) { mapRef.current = new MapWidget(containerRef.current); } const map = mapRef.current; map.setZoom(zoomLevel); }, [zoomLevel]); return ( div style={{ width: 200, height: 200 }} ref={containerRef} / ); } Show more In this example, a cleanup function is not needed because the MapWidget class manages only the DOM node that was passed to it. After the Map React component is removed from the tree, both the DOM node and the MapWidget class instance will be automatically garbage-collected by the browser JavaScript engine. Fetching data with Effects You can use an Effect to fetch data for your component. Note that if you use a framework, using your frameworks data fetching mechanism will be a lot more efficient than writing Effects manually. If you want to fetch data from an Effect manually, your code might look like this: import { useState, useEffect } from 'react';import { fetchBio } from './api.js';export default function Page() { const [person, setPerson] = useState('Alice'); const [bio, setBio] = useState(null); useEffect(() = { let ignore = false; setBio(null); fetchBio(person).then(result = { if (!ignore) { setBio(result); } }); return () = { ignore = true; }; }, [person]); // ... Note the ignore variable which is initialized to false, and is set to true during cleanup. This ensures your code doesnt suffer from race conditions: network responses may arrive in a different order than you sent them. App.jsApp.js ResetForkimport { useState, useEffect } from 'react'; import { fetchBio } from './api.js'; export default function Page() { const [person, setPerson] = useState('Alice'); const [bio, setBio] = useState(null); useEffect(() = { let ignore = false; setBio(null); fetchBio(person).then(result = { if (!ignore) { setBio(result); } }); return () = { ignore = true; } }, [person]); return (  select value={person} onChange={e = { setPerson(e.target.value); }} option value=\"Alice\"Alice/option option value=\"Bob\"Bob/option option value=\"Taylor\"Taylor/option /select hr / pi{bio ?? 'Loading...'}/i/p / ); } Show more You can also rewrite using the async / await syntax, but you still need to provide a cleanup function: App.jsApp.js ResetForkimport { useState, useEffect } from 'react'; import { fetchBio } from './api.js'; export default function Page() { const [person, setPerson] = useState('Alice'); const [bio, setBio] = useState(null); useEffect(() = { async function startFetching() { setBio(null); const result = await fetchBio(person); if (!ignore) { setBio(result); } } let ignore = false; startFetching(); return () = { ignore = true; } }, [person]); return (  select value={person} onChange={e = { setPerson(e.target.value); }} option value=\"Alice\"Alice/option option value=\"Bob\"Bob/option option value=\"Taylor\"Taylor/option /select hr / pi{bio ?? 'Loading...'}/i/p / ); } Show more Writing data fetching directly in Effects gets repetitive and makes it difficult to add optimizations like caching and server rendering later. Its easier to use a custom Hookeither your own or maintained by the community. Deep DiveWhat are good alternatives to data fetching in Effects? Show DetailsWriting fetch calls inside Effects is a popular way to fetch data, especially in fully client-side apps. This is, however, a very manual approach and it has significant downsides: Effects dont run on the server. This means that the initial server-rendered HTML will only include a loading state with no data. The client computer will have to download all JavaScript and render your app only to discover that now it needs to load the data. This is not very efficient. Fetching directly in Effects makes it easy to create network waterfalls. You render the parent component, it fetches some data, renders the child components, and then they start fetching their data. If the network is not very fast, this is significantly slower than fetching all data in parallel. Fetching directly in Effects usually means you dont preload or cache data. For example, if the component unmounts and then mounts again, it would have to fetch the data again. Its not very ergonomic. Theres quite a bit of boilerplate code involved when writing fetch calls in a way that doesnt suffer from bugs like race conditions. This list of downsides is not specific to React. It applies to fetching data on mount with any library. Like with routing, data fetching is not trivial to do well, so we recommend the following approaches: If you use a framework, use its built-in data fetching mechanism. Modern React frameworks have integrated data fetching mechanisms that are efficient and dont suffer from the above pitfalls. Otherwise, consider using or building a client-side cache. Popular open source solutions include React Query, useSWR, and React Router 6.4+. You can build your own solution too, in which case you would use Effects under the hood but also add logic for deduplicating requests, caching responses, and avoiding network waterfalls (by preloading data or hoisting data requirements to routes). You can continue fetching data directly in Effects if neither of these approaches suit you. Specifying reactive dependencies Notice that you cant choose the dependencies of your Effect. Every reactive value used by your Effects code must be declared as a dependency. Your Effects dependency list is determined by the surrounding code: function ChatRoom({ roomId }) { // This is a reactive value const [serverUrl, setServerUrl] = useState('https://localhost:1234'); // This is a reactive value too useEffect(() = { const connection = createConnection(serverUrl, roomId); // This Effect reads these reactive values connection.connect(); return () = connection.disconnect(); }, [serverUrl, roomId]); //  So you must specify them as dependencies of your Effect // ...} If either serverUrl or roomId change, your Effect will reconnect to the chat using the new values. Reactive values include props and all variables and functions declared directly inside of your component. Since roomId and serverUrl are reactive values, you cant remove them from the dependencies. If you try to omit them and your linter is correctly configured for React, the linter will flag this as a mistake you need to fix: function ChatRoom({ roomId }) { const [serverUrl, setServerUrl] = useState('https://localhost:1234'); useEffect(() = { const connection = createConnection(serverUrl, roomId); connection.connect(); return () = connection.disconnect(); }, []); //  React Hook useEffect has missing dependencies: 'roomId' and 'serverUrl' // ...} To remove a dependency, you need to prove to the linter that it doesnt need to be a dependency. For example, you can move serverUrl out of your component to prove that its not reactive and wont change on re-renders: const serverUrl = 'https://localhost:1234'; // Not a reactive value anymorefunction ChatRoom({ roomId }) { useEffect(() = { const connection = createConnection(serverUrl, roomId); connection.connect(); return () = connection.disconnect(); }, [roomId]); //  All dependencies declared // ...} Now that serverUrl is not a reactive value (and cant change on a re-render), it doesnt need to be a dependency. If your Effects code doesnt use any reactive values, its dependency list should be empty ([]): const serverUrl = 'https://localhost:1234'; // Not a reactive value anymoreconst roomId = 'music'; // Not a reactive value anymorefunction ChatRoom() { useEffect(() = { const connection = createConnection(serverUrl, roomId); connection.connect(); return () = connection.disconnect(); }, []); //  All dependencies declared // ...} An Effect with empty dependencies doesnt re-run when any of your components props or state change. PitfallIf you have an existing codebase, you might have some Effects that suppress the linter like this:useEffect(() = { // ... //  Avoid suppressing the linter like this: // eslint-ignore-next-line react-hooks/exhaustive-deps}, []);When dependencies dont match the code, there is a high risk of introducing bugs. By suppressing the linter, you lie to React about the values your Effect depends on. Instead, prove theyre unnecessary. Examples of passing reactive dependencies1. Passing a dependency array 2. Passing an empty dependency array 3. Passing no dependency array at all Example 1 of 3: Passing a dependency array If you specify the dependencies, your Effect runs after the initial render and after re-renders with changed dependencies.useEffect(() = { // ...}, [a, b]); // Runs again if a or b are differentIn the below example, serverUrl and roomId are reactive values, so they both must be specified as dependencies. As a result, selecting a different room in the dropdown or editing the server URL input causes the chat to re-connect. However, since message isnt used in the Effect (and so it isnt a dependency), editing the message doesnt re-connect to the chat.App.jschat.jsApp.js ResetForkimport { useState, useEffect } from 'react'; import { createConnection } from './chat.js'; function ChatRoom({ roomId }) { const [serverUrl, setServerUrl] = useState('https://localhost:1234'); const [message, setMessage] = useState(''); useEffect(() = { const connection = createConnection(serverUrl, roomId); connection.connect(); return () = { connection.disconnect(); }; }, [serverUrl, roomId]); return (  label Server URL:{' '} input value={serverUrl} onChange={e = setServerUrl(e.target.value)} / /label h1Welcome to the {roomId} room!/h1 label Your message:{' '} input value={message} onChange={e = setMessage(e.target.value)} / /label / ); } export default function App() { const [show, setShow] = useState(false); const [roomId, setRoomId] = useState('general'); return (  label Choose the chat room:{' '} select value={roomId} onChange={e = setRoomId(e.target.value)}  option value=\"general\"general/option option value=\"travel\"travel/option option value=\"music\"music/option /select button onClick={() = setShow(!show)} {show ? 'Close chat' : 'Open chat'} /button /label {show && hr /} {show && ChatRoom roomId={roomId}/} / ); } Show moreNext Example Updating state based on previous state from an Effect When you want to update state based on previous state from an Effect, you might run into a problem: function Counter() { const [count, setCount] = useState(0); useEffect(() = { const intervalId = setInterval(() = { setCount(count + 1); // You want to increment the counter every second... }, 1000) return () = clearInterval(intervalId); }, [count]); //  ... but specifying count as a dependency always resets the interval. // ...} Since count is a reactive value, it must be specified in the list of dependencies. However, that causes the Effect to cleanup and setup again every time the count changes. This is not ideal. To fix this, pass the c = c + 1 state updater to setCount: App.jsApp.js Download ResetForkimport { useState, useEffect } from 'react'; export default function Counter() { const [count, setCount] = useState(0); useEffect(() = { const intervalId = setInterval(() = { setCount(c = c + 1); //  Pass a state updater }, 1000); return () = clearInterval(intervalId); }, []); //  Now count is not a dependency return h1{count}/h1; } Now that youre passing c = c + 1 instead of count + 1, your Effect no longer needs to depend on count. As a result of this fix, it wont need to cleanup and setup the interval again every time the count changes. Removing unnecessary object dependencies If your Effect depends on an object or a function created during rendering, it might run too often. For example, this Effect re-connects after every render because the options object is different for every render: const serverUrl = 'https://localhost:1234';function ChatRoom({ roomId }) { const [message, setMessage] = useState(''); const options = { //  This object is created from scratch on every re-render serverUrl: serverUrl, roomId: roomId }; useEffect(() = { const connection = createConnection(options); // It's used inside the Effect connection.connect(); return () = connection.disconnect(); }, [options]); //  As a result, these dependencies are always different on a re-render // ... Avoid using an object created during rendering as a dependency. Instead, create the object inside the Effect: App.jschat.jsApp.js ResetForkimport { useState, useEffect } from 'react'; import { createConnection } from './chat.js'; const serverUrl = 'https://localhost:1234'; function ChatRoom({ roomId }) { const [message, setMessage] = useState(''); useEffect(() = { const options = { serverUrl: serverUrl, roomId: roomId }; const connection = createConnection(options); connection.connect(); return () = connection.disconnect(); }, [roomId]); return (  h1Welcome to the {roomId} room!/h1 input value={message} onChange={e = setMessage(e.target.value)} / / ); } export default function App() { const [roomId, setRoomId] = useState('general'); return (  label Choose the chat room:{' '} select value={roomId} onChange={e = setRoomId(e.target.value)}  option value=\"general\"general/option option value=\"travel\"travel/option option value=\"music\"music/option /select /label hr / ChatRoom roomId={roomId} / / ); } Show more Now that you create the options object inside the Effect, the Effect itself only depends on the roomId string. With this fix, typing into the input doesnt reconnect the chat. Unlike an object which gets re-created, a string like roomId doesnt change unless you set it to another value. Read more about removing dependencies. Removing unnecessary function dependencies If your Effect depends on an object or a function created during rendering, it might run too often. For example, this Effect re-connects after every render because the createOptions function is different for every render: function ChatRoom({ roomId }) { const [message, setMessage] = useState(''); function createOptions() { //  This function is created from scratch on every re-render return { serverUrl: serverUrl, roomId: roomId }; } useEffect(() = { const options = createOptions(); // It's used inside the Effect const connection = createConnection(); connection.connect(); return () = connection.disconnect(); }, [createOptions]); //  As a result, these dependencies are always different on a re-render // ... By itself, creating a function from scratch on every re-render is not a problem. You dont need to optimize that. However, if you use it as a dependency of your Effect, it will cause your Effect to re-run after every re-render. Avoid using a function created during rendering as a dependency. Instead, declare it inside the Effect: App.jschat.jsApp.js ResetForkimport { useState, useEffect } from 'react'; import { createConnection } from './chat.js'; const serverUrl = 'https://localhost:1234'; function ChatRoom({ roomId }) { const [message, setMessage] = useState(''); useEffect(() = { function createOptions() { return { serverUrl: serverUrl, roomId: roomId }; } const options = createOptions(); const connection = createConnection(options); connection.connect(); return () = connection.disconnect(); }, [roomId]); return (  h1Welcome to the {roomId} room!/h1 input value={message} onChange={e = setMessage(e.target.value)} / / ); } export default function App() { const [roomId, setRoomId] = useState('general'); return (  label Choose the chat room:{' '} select value={roomId} onChange={e = setRoomId(e.target.value)}  option value=\"general\"general/option option value=\"travel\"travel/option option value=\"music\"music/option /select /label hr / ChatRoom roomId={roomId} / / ); } Show more Now that you define the createOptions function inside the Effect, the Effect itself only depends on the roomId string. With this fix, typing into the input doesnt reconnect the chat. Unlike a function which gets re-created, a string like roomId doesnt change unless you set it to another value. Read more about removing dependencies. Reading the latest props and state from an Effect Under ConstructionThis section describes an experimental API that has not yet been released in a stable version of React. By default, when you read a reactive value from an Effect, you have to add it as a dependency. This ensures that your Effect reacts to every change of that value. For most dependencies, thats the behavior you want. However, sometimes youll want to read the latest props and state from an Effect without reacting to them. For example, imagine you want to log the number of the items in the shopping cart for every page visit: function Page({ url, shoppingCart }) { useEffect(() = { logVisit(url, shoppingCart.length); }, [url, shoppingCart]); //  All dependencies declared // ...} What if you want to log a new page visit after every url change, but not if only the shoppingCart changes? You cant exclude shoppingCart from dependencies without breaking the reactivity rules. However, you can express that you dont want a piece of code to react to changes even though it is called from inside an Effect. Declare an Effect Event with the useEffectEvent Hook, and move the code reading shoppingCart inside of it: function Page({ url, shoppingCart }) { const onVisit = useEffectEvent(visitedUrl = { logVisit(visitedUrl, shoppingCart.length) }); useEffect(() = { onVisit(url); }, [url]); //  All dependencies declared // ...} Effect Events are not reactive and must always be omitted from dependencies of your Effect. This is what lets you put non-reactive code (where you can read the latest value of some props and state) inside of them. By reading shoppingCart inside of onVisit, you ensure that shoppingCart wont re-run your Effect. Read more about how Effect Events let you separate reactive and non-reactive code. Displaying different content on the server and the client If your app uses server rendering (either directly or via a framework), your component will render in two different environments. On the server, it will render to produce the initial HTML. On the client, React will run the rendering code again so that it can attach your event handlers to that HTML. This is why, for hydration to work, your initial render output must be identical on the client and the server. In rare cases, you might need to display different content on the client. For example, if your app reads some data from localStorage, it cant possibly do that on the server. Here is how you could implement this: function MyComponent() { const [didMount, setDidMount] = useState(false); useEffect(() = { setDidMount(true); }, []); if (didMount) { // ... return client-only JSX ... } else { // ... return initial JSX ... }} While the app is loading, the user will see the initial render output. Then, when its loaded and hydrated, your Effect will run and set didMount to true, triggering a re-render. This will switch to the client-only render output. Effects dont run on the server, so this is why didMount was false during the initial server render. Use this pattern sparingly. Keep in mind that users with a slow connection will see the initial content for quite a bit of timepotentially, many secondsso you dont want to make jarring changes to your components appearance. In many cases, you can avoid the need for this by conditionally showing different things with CSS. Troubleshooting My Effect runs twice when the component mounts When Strict Mode is on, in development, React runs setup and cleanup one extra time before the actual setup. This is a stress-test that verifies your Effects logic is implemented correctly. If this causes visible issues, your cleanup function is missing some logic. The cleanup function should stop or undo whatever the setup function was doing. The rule of thumb is that the user shouldnt be able to distinguish between the setup being called once (as in production) and a setup  cleanup  setup sequence (as in development). Read more about how this helps find bugs and how to fix your logic. My Effect runs after every re-render First, check that you havent forgotten to specify the dependency array: useEffect(() = { // ...}); //  No dependency array: re-runs after every render! If youve specified the dependency array but your Effect still re-runs in a loop, its because one of your dependencies is different on every re-render. You can debug this problem by manually logging your dependencies to the console: useEffect(() = { // .. }, [serverUrl, roomId]); console.log([serverUrl, roomId]); You can then right-click on the arrays from different re-renders in the console and select Store as a global variable for both of them. Assuming the first one got saved as temp1 and the second one got saved as temp2, you can then use the browser console to check whether each dependency in both arrays is the same: Object.is(temp1[0], temp2[0]); // Is the first dependency the same between the arrays?Object.is(temp1[1], temp2[1]); // Is the second dependency the same between the arrays?Object.is(temp1[2], temp2[2]); // ... and so on for every dependency ... When you find the dependency that is different on every re-render, you can usually fix it in one of these ways: Updating state based on previous state from an Effect Removing unnecessary object dependencies Removing unnecessary function dependencies Reading the latest props and state from an Effect As a last resort (if these methods didnt help), wrap its creation with useMemo or useCallback (for functions). My Effect keeps re-running in an infinite cycle If your Effect runs in an infinite cycle, these two things must be true: Your Effect is updating some state. That state leads to a re-render, which causes the Effects dependencies to change. Before you start fixing the problem, ask yourself whether your Effect is connecting to some external system (like DOM, network, a third-party widget, and so on). Why does your Effect need to set state? Does it synchronize with that external system? Or are you trying to manage your applications data flow with it? If there is no external system, consider whether removing the Effect altogether would simplify your logic. If youre genuinely synchronizing with some external system, think about why and under what conditions your Effect should update the state. Has something changed that affects your components visual output? If you need to keep track of some data that isnt used by rendering, a ref (which doesnt trigger re-renders) might be more appropriate. Verify your Effect doesnt update the state (and trigger re-renders) more than needed. Finally, if your Effect is updating the state at the right time, but there is still a loop, its because that state update leads to one of the Effects dependencies changing. Read how to debug dependency changes. My cleanup logic runs even though my component didnt unmount The cleanup function runs not only during unmount, but before every re-render with changed dependencies. Additionally, in development, React runs setup+cleanup one extra time immediately after component mounts. If you have cleanup code without corresponding setup code, its usually a code smell: useEffect(() = { //  Avoid: Cleanup logic without corresponding setup logic return () = { doSomething(); };}, []); Your cleanup logic should be symmetrical to the setup logic, and should stop or undo whatever setup did: useEffect(() = { const connection = createConnection(serverUrl, roomId); connection.connect(); return () = { connection.disconnect(); }; }, [serverUrl, roomId]); Learn how the Effect lifecycle is different from the components lifecycle. My Effect does something visual, and I see a flicker before it runs If your Effect must block the browser from painting the screen, replace useEffect with useLayoutEffect. Note that this shouldnt be needed for the vast majority of Effects. Youll only need this if its crucial to run your Effect before the browser paint: for example, to measure and position a tooltip before the user sees it.PrevioususeDeferredValueNextuseId",
    "headings": [
      {
        "level": 1,
        "text": "useEffect",
        "id": ""
      },
      {
        "level": 2,
        "text": "Reference",
        "id": "reference"
      },
      {
        "level": 2,
        "text": "Usage",
        "id": "usage"
      },
      {
        "level": 2,
        "text": "Troubleshooting",
        "id": "troubleshooting"
      },
      {
        "level": 3,
        "text": "useEffect(setup, dependencies?)",
        "id": "useeffect"
      },
      {
        "level": 3,
        "text": "Connecting to an external system",
        "id": "connecting-to-an-external-system"
      },
      {
        "level": 3,
        "text": "Note",
        "id": ""
      },
      {
        "level": 3,
        "text": "Wrapping Effects in custom Hooks",
        "id": "wrapping-effects-in-custom-hooks"
      },
      {
        "level": 3,
        "text": "Controlling a non-React widget",
        "id": "controlling-a-non-react-widget"
      },
      {
        "level": 3,
        "text": "Fetching data with Effects",
        "id": "fetching-data-with-effects"
      },
      {
        "level": 3,
        "text": "Specifying reactive dependencies",
        "id": "specifying-reactive-dependencies"
      },
      {
        "level": 3,
        "text": "Pitfall",
        "id": ""
      },
      {
        "level": 3,
        "text": "Updating state based on previous state from an Effect",
        "id": "updating-state-based-on-previous-state-from-an-effect"
      },
      {
        "level": 3,
        "text": "Removing unnecessary object dependencies",
        "id": "removing-unnecessary-object-dependencies"
      },
      {
        "level": 3,
        "text": "Removing unnecessary function dependencies",
        "id": "removing-unnecessary-function-dependencies"
      },
      {
        "level": 3,
        "text": "Reading the latest props and state from an Effect",
        "id": "reading-the-latest-props-and-state-from-an-effect"
      },
      {
        "level": 3,
        "text": "Under Construction",
        "id": ""
      },
      {
        "level": 3,
        "text": "Displaying different content on the server and the client",
        "id": "displaying-different-content-on-the-server-and-the-client"
      },
      {
        "level": 3,
        "text": "My Effect runs twice when the component mounts",
        "id": "my-effect-runs-twice-when-the-component-mounts"
      },
      {
        "level": 3,
        "text": "My Effect runs after every re-render",
        "id": "my-effect-runs-after-every-re-render"
      },
      {
        "level": 3,
        "text": "My Effect keeps re-running in an infinite cycle",
        "id": "my-effect-keeps-re-running-in-an-infinite-cycle"
      },
      {
        "level": 3,
        "text": "My cleanup logic runs even though my component didn’t unmount",
        "id": "my-cleanup-logic-runs-even-though-my-component-didnt-unmount"
      },
      {
        "level": 3,
        "text": "My Effect does something visual, and I see a flicker before it runs",
        "id": "my-effect-does-something-visual-and-i-see-a-flicker-before-it-runs"
      },
      {
        "level": 4,
        "text": "Parameters",
        "id": "parameters"
      },
      {
        "level": 4,
        "text": "Returns",
        "id": "returns"
      },
      {
        "level": 4,
        "text": "Caveats",
        "id": "caveats"
      },
      {
        "level": 4,
        "text": "Examples of connecting to an external system",
        "id": "examples-connecting"
      },
      {
        "level": 4,
        "text": "Example 1 of 5: Connecting to a chat server",
        "id": "connecting-to-a-chat-server"
      },
      {
        "level": 4,
        "text": "Examples of wrapping Effects in custom Hooks",
        "id": "examples-custom-hooks"
      },
      {
        "level": 4,
        "text": "Example 1 of 3: Custom useChatRoom Hook",
        "id": "custom-usechatroom-hook"
      },
      {
        "level": 4,
        "text": "What are good alternatives to data fetching in Effects?",
        "id": "what-are-good-alternatives-to-data-fetching-in-effects"
      },
      {
        "level": 4,
        "text": "Examples of passing reactive dependencies",
        "id": "examples-dependencies"
      },
      {
        "level": 4,
        "text": "Example 1 of 3: Passing a dependency array",
        "id": "passing-a-dependency-array"
      },
      {
        "level": 5,
        "text": "Deep Dive",
        "id": ""
      }
    ],
    "codeBlocks": [
      {
        "language": "text",
        "code": "useEffect(setup, dependencies?)"
      },
      {
        "language": "text",
        "code": "useEffect(setup, dependencies?)"
      },
      {
        "language": "text",
        "code": "useEffect(setup, dependencies?)"
      },
      {
        "language": "text",
        "code": "useEffect(setup, dependencies?)"
      },
      {
        "language": "text",
        "code": "import { useState, useEffect } from 'react';import { createConnection } from './chat.js';function ChatRoom({ roomId }) {  const [serverUrl, setServerUrl] = useState('https://localhost:1234');  useEffect(() => {    const connection = createConnection(serverUrl, roomId);    connection.connect();    return () => {      connection.disconnect();    };  }, [serverUrl, roomId]);  // ...}"
      },
      {
        "language": "text",
        "code": "import { useState, useEffect } from 'react';import { createConnection } from './chat.js';function ChatRoom({ roomId }) {  const [serverUrl, setServerUrl] = useState('https://localhost:1234');  useEffect(() => {    const connection = createConnection(serverUrl, roomId);    connection.connect();    return () => {      connection.disconnect();    };  }, [serverUrl, roomId]);  // ...}"
      },
      {
        "language": "text",
        "code": "dependencies"
      },
      {
        "language": "text",
        "code": "[dep1, dep2, dep3]"
      },
      {
        "language": "text",
        "code": "useLayoutEffect"
      },
      {
        "language": "text",
        "code": "useLayoutEffect"
      },
      {
        "language": "text",
        "code": "import { useState, useEffect } from 'react';import { createConnection } from './chat.js';function ChatRoom({ roomId }) {  const [serverUrl, setServerUrl] = useState('https://localhost:1234');  useEffect(() => {  \tconst connection = createConnection(serverUrl, roomId);    connection.connect();  \treturn () => {      connection.disconnect();  \t};  }, [serverUrl, roomId]);  // ...}"
      },
      {
        "language": "text",
        "code": "import { useState, useEffect } from 'react';import { createConnection } from './chat.js';function ChatRoom({ roomId }) {  const [serverUrl, setServerUrl] = useState('https://localhost:1234');  useEffect(() => {  \tconst connection = createConnection(serverUrl, roomId);    connection.connect();  \treturn () => {      connection.disconnect();  \t};  }, [serverUrl, roomId]);  // ...}"
      },
      {
        "language": "text",
        "code": "setInterval()"
      },
      {
        "language": "text",
        "code": "clearInterval()"
      },
      {
        "language": "text",
        "code": "window.addEventListener()"
      },
      {
        "language": "text",
        "code": "window.removeEventListener()"
      },
      {
        "language": "text",
        "code": "animation.start()"
      },
      {
        "language": "text",
        "code": "animation.reset()"
      },
      {
        "language": "text",
        "code": "import { useState, useEffect } from 'react';\nimport { createConnection } from './chat.js';\n\nfunction ChatRoom({ roomId }) {\n  const [serverUrl, setServerUrl] = useState('https://localhost:1234');\n\n  useEffect(() => {\n    const connection = createConnection(serverUrl, roomId);\n    connection.connect();\n    return () => {\n      connection.disconnect();\n    };\n  }, [roomId, serverUrl]);\n\n  return (\n    <>\n      <label>\n        Server URL:{' '}\n        <input\n          value={serverUrl}\n          onChange={e => setServerUrl(e.target.value)}\n        />\n      </label>\n      <h1>Welcome to the {roomId} room!</h1>\n    </>\n  );\n}\n\nexport default function App() {\n  const [roomId, setRoomId] = useState('general');\n  const [show, setShow] = useState(false);\n  return (\n    <>\n      <label>\n        Choose the chat room:{' '}\n        <select\n          value={roomId}\n          onChange={e => setRoomId(e.target.value)}\n        >\n          <option value=\"general\">general</option>\n          <option value=\"travel\">travel</option>\n          <option value=\"music\">music</option>\n        </select>\n      </label>\n      <button onClick={() => setShow(!show)}>\n        {show ? 'Close chat' : 'Open chat'}\n      </button>\n      {show && <hr />}\n      {show && <ChatRoom roomId={roomId} />}\n    </>\n  );\n}"
      },
      {
        "language": "text",
        "code": "useChatRoom"
      },
      {
        "language": "text",
        "code": "function useChatRoom({ serverUrl, roomId }) {  useEffect(() => {    const options = {      serverUrl: serverUrl,      roomId: roomId    };    const connection = createConnection(options);    connection.connect();    return () => connection.disconnect();  }, [roomId, serverUrl]);}"
      },
      {
        "language": "text",
        "code": "function useChatRoom({ serverUrl, roomId }) {  useEffect(() => {    const options = {      serverUrl: serverUrl,      roomId: roomId    };    const connection = createConnection(options);    connection.connect();    return () => connection.disconnect();  }, [roomId, serverUrl]);}"
      },
      {
        "language": "text",
        "code": "function ChatRoom({ roomId }) {  const [serverUrl, setServerUrl] = useState('https://localhost:1234');  useChatRoom({    roomId: roomId,    serverUrl: serverUrl  });  // ..."
      },
      {
        "language": "text",
        "code": "function ChatRoom({ roomId }) {  const [serverUrl, setServerUrl] = useState('https://localhost:1234');  useChatRoom({    roomId: roomId,    serverUrl: serverUrl  });  // ..."
      },
      {
        "language": "text",
        "code": "useChatRoom"
      },
      {
        "language": "text",
        "code": "useWindowListener"
      },
      {
        "language": "text",
        "code": "useIntersectionObserver"
      },
      {
        "language": "text",
        "code": "useChatRoom"
      },
      {
        "language": "text",
        "code": "import { useState } from 'react';\nimport { useChatRoom } from './useChatRoom.js';\n\nfunction ChatRoom({ roomId }) {\n  const [serverUrl, setServerUrl] = useState('https://localhost:1234');\n\n  useChatRoom({\n    roomId: roomId,\n    serverUrl: serverUrl\n  });\n\n  return (\n    <>\n      <label>\n        Server URL:{' '}\n        <input\n          value={serverUrl}\n          onChange={e => setServerUrl(e.target.value)}\n        />\n      </label>\n      <h1>Welcome to the {roomId} room!</h1>\n    </>\n  );\n}\n\nexport default function App() {\n  const [roomId, setRoomId] = useState('general');\n  const [show, setShow] = useState(false);\n  return (\n    <>\n      <label>\n        Choose the chat room:{' '}\n        <select\n          value={roomId}\n          onChange={e => setRoomId(e.target.value)}\n        >\n          <option value=\"general\">general</option>\n          <option value=\"travel\">travel</option>\n          <option value=\"music\">music</option>\n        </select>\n      </label>\n      <button onClick={() => setShow(!show)}>\n        {show ? 'Close chat' : 'Open chat'}\n      </button>\n      {show && <hr />}\n      {show && <ChatRoom roomId={roomId} />}\n    </>\n  );\n}"
      },
      {
        "language": "text",
        "code": "map-widget.js"
      },
      {
        "language": "text",
        "code": "import { useRef, useEffect } from 'react';\nimport { MapWidget } from './map-widget.js';\n\nexport default function Map({ zoomLevel }) {\n  const containerRef = useRef(null);\n  const mapRef = useRef(null);\n\n  useEffect(() => {\n    if (mapRef.current === null) {\n      mapRef.current = new MapWidget(containerRef.current);\n    }\n\n    const map = mapRef.current;\n    map.setZoom(zoomLevel);\n  }, [zoomLevel]);\n\n  return (\n    <div\n      style={{ width: 200, height: 200 }}\n      ref={containerRef}\n    />\n  );\n}"
      },
      {
        "language": "text",
        "code": "import { useState, useEffect } from 'react';import { fetchBio } from './api.js';export default function Page() {  const [person, setPerson] = useState('Alice');  const [bio, setBio] = useState(null);  useEffect(() => {    let ignore = false;    setBio(null);    fetchBio(person).then(result => {      if (!ignore) {        setBio(result);      }    });    return () => {      ignore = true;    };  }, [person]);  // ..."
      },
      {
        "language": "text",
        "code": "import { useState, useEffect } from 'react';import { fetchBio } from './api.js';export default function Page() {  const [person, setPerson] = useState('Alice');  const [bio, setBio] = useState(null);  useEffect(() => {    let ignore = false;    setBio(null);    fetchBio(person).then(result => {      if (!ignore) {        setBio(result);      }    });    return () => {      ignore = true;    };  }, [person]);  // ..."
      },
      {
        "language": "text",
        "code": "import { useState, useEffect } from 'react';\nimport { fetchBio } from './api.js';\n\nexport default function Page() {\n  const [person, setPerson] = useState('Alice');\n  const [bio, setBio] = useState(null);\n  useEffect(() => {\n    let ignore = false;\n    setBio(null);\n    fetchBio(person).then(result => {\n      if (!ignore) {\n        setBio(result);\n      }\n    });\n    return () => {\n      ignore = true;\n    }\n  }, [person]);\n\n  return (\n    <>\n      <select value={person} onChange={e => {\n        setPerson(e.target.value);\n      }}>\n        <option value=\"Alice\">Alice</option>\n        <option value=\"Bob\">Bob</option>\n        <option value=\"Taylor\">Taylor</option>\n      </select>\n      <hr />\n      <p><i>{bio ?? 'Loading...'}</i></p>\n    </>\n  );\n}"
      },
      {
        "language": "text",
        "code": "import { useState, useEffect } from 'react';\nimport { fetchBio } from './api.js';\n\nexport default function Page() {\n  const [person, setPerson] = useState('Alice');\n  const [bio, setBio] = useState(null);\n  useEffect(() => {\n    async function startFetching() {\n      setBio(null);\n      const result = await fetchBio(person);\n      if (!ignore) {\n        setBio(result);\n      }\n    }\n\n    let ignore = false;\n    startFetching();\n    return () => {\n      ignore = true;\n    }\n  }, [person]);\n\n  return (\n    <>\n      <select value={person} onChange={e => {\n        setPerson(e.target.value);\n      }}>\n        <option value=\"Alice\">Alice</option>\n        <option value=\"Bob\">Bob</option>\n        <option value=\"Taylor\">Taylor</option>\n      </select>\n      <hr />\n      <p><i>{bio ?? 'Loading...'}</i></p>\n    </>\n  );\n}"
      },
      {
        "language": "text",
        "code": "function ChatRoom({ roomId }) { // This is a reactive value  const [serverUrl, setServerUrl] = useState('https://localhost:1234'); // This is a reactive value too  useEffect(() => {    const connection = createConnection(serverUrl, roomId); // This Effect reads these reactive values    connection.connect();    return () => connection.disconnect();  }, [serverUrl, roomId]); // ✅ So you must specify them as dependencies of your Effect  // ...}"
      },
      {
        "language": "text",
        "code": "function ChatRoom({ roomId }) { // This is a reactive value  const [serverUrl, setServerUrl] = useState('https://localhost:1234'); // This is a reactive value too  useEffect(() => {    const connection = createConnection(serverUrl, roomId); // This Effect reads these reactive values    connection.connect();    return () => connection.disconnect();  }, [serverUrl, roomId]); // ✅ So you must specify them as dependencies of your Effect  // ...}"
      },
      {
        "language": "text",
        "code": "function ChatRoom({ roomId }) {  const [serverUrl, setServerUrl] = useState('https://localhost:1234');    useEffect(() => {    const connection = createConnection(serverUrl, roomId);    connection.connect();    return () => connection.disconnect();  }, []); // 🔴 React Hook useEffect has missing dependencies: 'roomId' and 'serverUrl'  // ...}"
      },
      {
        "language": "text",
        "code": "function ChatRoom({ roomId }) {  const [serverUrl, setServerUrl] = useState('https://localhost:1234');    useEffect(() => {    const connection = createConnection(serverUrl, roomId);    connection.connect();    return () => connection.disconnect();  }, []); // 🔴 React Hook useEffect has missing dependencies: 'roomId' and 'serverUrl'  // ...}"
      },
      {
        "language": "text",
        "code": "const serverUrl = 'https://localhost:1234'; // Not a reactive value anymorefunction ChatRoom({ roomId }) {  useEffect(() => {    const connection = createConnection(serverUrl, roomId);    connection.connect();    return () => connection.disconnect();  }, [roomId]); // ✅ All dependencies declared  // ...}"
      },
      {
        "language": "text",
        "code": "const serverUrl = 'https://localhost:1234'; // Not a reactive value anymorefunction ChatRoom({ roomId }) {  useEffect(() => {    const connection = createConnection(serverUrl, roomId);    connection.connect();    return () => connection.disconnect();  }, [roomId]); // ✅ All dependencies declared  // ...}"
      },
      {
        "language": "text",
        "code": "const serverUrl = 'https://localhost:1234'; // Not a reactive value anymoreconst roomId = 'music'; // Not a reactive value anymorefunction ChatRoom() {  useEffect(() => {    const connection = createConnection(serverUrl, roomId);    connection.connect();    return () => connection.disconnect();  }, []); // ✅ All dependencies declared  // ...}"
      },
      {
        "language": "text",
        "code": "const serverUrl = 'https://localhost:1234'; // Not a reactive value anymoreconst roomId = 'music'; // Not a reactive value anymorefunction ChatRoom() {  useEffect(() => {    const connection = createConnection(serverUrl, roomId);    connection.connect();    return () => connection.disconnect();  }, []); // ✅ All dependencies declared  // ...}"
      },
      {
        "language": "text",
        "code": "useEffect(() => {  // ...  // 🔴 Avoid suppressing the linter like this:  // eslint-ignore-next-line react-hooks/exhaustive-deps}, []);"
      },
      {
        "language": "text",
        "code": "useEffect(() => {  // ...  // 🔴 Avoid suppressing the linter like this:  // eslint-ignore-next-line react-hooks/exhaustive-deps}, []);"
      },
      {
        "language": "text",
        "code": "useEffect(() => {  // ...}, [a, b]); // Runs again if a or b are different"
      },
      {
        "language": "text",
        "code": "useEffect(() => {  // ...}, [a, b]); // Runs again if a or b are different"
      },
      {
        "language": "text",
        "code": "import { useState, useEffect } from 'react';\nimport { createConnection } from './chat.js';\n\nfunction ChatRoom({ roomId }) {\n  const [serverUrl, setServerUrl] = useState('https://localhost:1234');\n  const [message, setMessage] = useState('');\n\n  useEffect(() => {\n    const connection = createConnection(serverUrl, roomId);\n    connection.connect();\n    return () => {\n      connection.disconnect();\n    };\n  }, [serverUrl, roomId]);\n\n  return (\n    <>\n      <label>\n        Server URL:{' '}\n        <input\n          value={serverUrl}\n          onChange={e => setServerUrl(e.target.value)}\n        />\n      </label>\n      <h1>Welcome to the {roomId} room!</h1>\n      <label>\n        Your message:{' '}\n        <input value={message} onChange={e => setMessage(e.target.value)} />\n      </label>\n    </>\n  );\n}\n\nexport default function App() {\n  const [show, setShow] = useState(false);\n  const [roomId, setRoomId] = useState('general');\n  return (\n    <>\n      <label>\n        Choose the chat room:{' '}\n        <select\n          value={roomId}\n          onChange={e => setRoomId(e.target.value)}\n        >\n          <option value=\"general\">general</option>\n          <option value=\"travel\">travel</option>\n          <option value=\"music\">music</option>\n        </select>\n        <button onClick={() => setShow(!show)}>\n          {show ? 'Close chat' : 'Open chat'}\n        </button>\n      </label>\n      {show && <hr />}\n      {show && <ChatRoom roomId={roomId}/>}\n    </>\n  );\n}"
      },
      {
        "language": "text",
        "code": "function Counter() {  const [count, setCount] = useState(0);  useEffect(() => {    const intervalId = setInterval(() => {      setCount(count + 1); // You want to increment the counter every second...    }, 1000)    return () => clearInterval(intervalId);  }, [count]); // 🚩 ... but specifying `count` as a dependency always resets the interval.  // ...}"
      },
      {
        "language": "text",
        "code": "function Counter() {  const [count, setCount] = useState(0);  useEffect(() => {    const intervalId = setInterval(() => {      setCount(count + 1); // You want to increment the counter every second...    }, 1000)    return () => clearInterval(intervalId);  }, [count]); // 🚩 ... but specifying `count` as a dependency always resets the interval.  // ...}"
      },
      {
        "language": "text",
        "code": "import { useState, useEffect } from 'react';\n\nexport default function Counter() {\n  const [count, setCount] = useState(0);\n\n  useEffect(() => {\n    const intervalId = setInterval(() => {\n      setCount(c => c + 1); // ✅ Pass a state updater\n    }, 1000);\n    return () => clearInterval(intervalId);\n  }, []); // ✅ Now count is not a dependency\n\n  return <h1>{count}</h1>;\n}"
      },
      {
        "language": "text",
        "code": "const serverUrl = 'https://localhost:1234';function ChatRoom({ roomId }) {  const [message, setMessage] = useState('');  const options = { // 🚩 This object is created from scratch on every re-render    serverUrl: serverUrl,    roomId: roomId  };  useEffect(() => {    const connection = createConnection(options); // It's used inside the Effect    connection.connect();    return () => connection.disconnect();  }, [options]); // 🚩 As a result, these dependencies are always different on a re-render  // ..."
      },
      {
        "language": "text",
        "code": "const serverUrl = 'https://localhost:1234';function ChatRoom({ roomId }) {  const [message, setMessage] = useState('');  const options = { // 🚩 This object is created from scratch on every re-render    serverUrl: serverUrl,    roomId: roomId  };  useEffect(() => {    const connection = createConnection(options); // It's used inside the Effect    connection.connect();    return () => connection.disconnect();  }, [options]); // 🚩 As a result, these dependencies are always different on a re-render  // ..."
      },
      {
        "language": "text",
        "code": "import { useState, useEffect } from 'react';\nimport { createConnection } from './chat.js';\n\nconst serverUrl = 'https://localhost:1234';\n\nfunction ChatRoom({ roomId }) {\n  const [message, setMessage] = useState('');\n\n  useEffect(() => {\n    const options = {\n      serverUrl: serverUrl,\n      roomId: roomId\n    };\n    const connection = createConnection(options);\n    connection.connect();\n    return () => connection.disconnect();\n  }, [roomId]);\n\n  return (\n    <>\n      <h1>Welcome to the {roomId} room!</h1>\n      <input value={message} onChange={e => setMessage(e.target.value)} />\n    </>\n  );\n}\n\nexport default function App() {\n  const [roomId, setRoomId] = useState('general');\n  return (\n    <>\n      <label>\n        Choose the chat room:{' '}\n        <select\n          value={roomId}\n          onChange={e => setRoomId(e.target.value)}\n        >\n          <option value=\"general\">general</option>\n          <option value=\"travel\">travel</option>\n          <option value=\"music\">music</option>\n        </select>\n      </label>\n      <hr />\n      <ChatRoom roomId={roomId} />\n    </>\n  );\n}"
      },
      {
        "language": "text",
        "code": "createOptions"
      },
      {
        "language": "text",
        "code": "function ChatRoom({ roomId }) {  const [message, setMessage] = useState('');  function createOptions() { // 🚩 This function is created from scratch on every re-render    return {      serverUrl: serverUrl,      roomId: roomId    };  }  useEffect(() => {    const options = createOptions(); // It's used inside the Effect    const connection = createConnection();    connection.connect();    return () => connection.disconnect();  }, [createOptions]); // 🚩 As a result, these dependencies are always different on a re-render  // ..."
      },
      {
        "language": "text",
        "code": "function ChatRoom({ roomId }) {  const [message, setMessage] = useState('');  function createOptions() { // 🚩 This function is created from scratch on every re-render    return {      serverUrl: serverUrl,      roomId: roomId    };  }  useEffect(() => {    const options = createOptions(); // It's used inside the Effect    const connection = createConnection();    connection.connect();    return () => connection.disconnect();  }, [createOptions]); // 🚩 As a result, these dependencies are always different on a re-render  // ..."
      },
      {
        "language": "text",
        "code": "import { useState, useEffect } from 'react';\nimport { createConnection } from './chat.js';\n\nconst serverUrl = 'https://localhost:1234';\n\nfunction ChatRoom({ roomId }) {\n  const [message, setMessage] = useState('');\n\n  useEffect(() => {\n    function createOptions() {\n      return {\n        serverUrl: serverUrl,\n        roomId: roomId\n      };\n    }\n\n    const options = createOptions();\n    const connection = createConnection(options);\n    connection.connect();\n    return () => connection.disconnect();\n  }, [roomId]);\n\n  return (\n    <>\n      <h1>Welcome to the {roomId} room!</h1>\n      <input value={message} onChange={e => setMessage(e.target.value)} />\n    </>\n  );\n}\n\nexport default function App() {\n  const [roomId, setRoomId] = useState('general');\n  return (\n    <>\n      <label>\n        Choose the chat room:{' '}\n        <select\n          value={roomId}\n          onChange={e => setRoomId(e.target.value)}\n        >\n          <option value=\"general\">general</option>\n          <option value=\"travel\">travel</option>\n          <option value=\"music\">music</option>\n        </select>\n      </label>\n      <hr />\n      <ChatRoom roomId={roomId} />\n    </>\n  );\n}"
      },
      {
        "language": "text",
        "code": "createOptions"
      },
      {
        "language": "text",
        "code": "function Page({ url, shoppingCart }) {  useEffect(() => {    logVisit(url, shoppingCart.length);  }, [url, shoppingCart]); // ✅ All dependencies declared  // ...}"
      },
      {
        "language": "text",
        "code": "function Page({ url, shoppingCart }) {  useEffect(() => {    logVisit(url, shoppingCart.length);  }, [url, shoppingCart]); // ✅ All dependencies declared  // ...}"
      },
      {
        "language": "text",
        "code": "shoppingCart"
      },
      {
        "language": "text",
        "code": "shoppingCart"
      },
      {
        "language": "text",
        "code": "useEffectEvent"
      },
      {
        "language": "text",
        "code": "shoppingCart"
      },
      {
        "language": "text",
        "code": "function Page({ url, shoppingCart }) {  const onVisit = useEffectEvent(visitedUrl => {    logVisit(visitedUrl, shoppingCart.length)  });  useEffect(() => {    onVisit(url);  }, [url]); // ✅ All dependencies declared  // ...}"
      },
      {
        "language": "text",
        "code": "function Page({ url, shoppingCart }) {  const onVisit = useEffectEvent(visitedUrl => {    logVisit(visitedUrl, shoppingCart.length)  });  useEffect(() => {    onVisit(url);  }, [url]); // ✅ All dependencies declared  // ...}"
      },
      {
        "language": "text",
        "code": "shoppingCart"
      },
      {
        "language": "text",
        "code": "shoppingCart"
      },
      {
        "language": "text",
        "code": "localStorage"
      },
      {
        "language": "text",
        "code": "function MyComponent() {  const [didMount, setDidMount] = useState(false);  useEffect(() => {    setDidMount(true);  }, []);  if (didMount) {    // ... return client-only JSX ...  }  else {    // ... return initial JSX ...  }}"
      },
      {
        "language": "text",
        "code": "function MyComponent() {  const [didMount, setDidMount] = useState(false);  useEffect(() => {    setDidMount(true);  }, []);  if (didMount) {    // ... return client-only JSX ...  }  else {    // ... return initial JSX ...  }}"
      },
      {
        "language": "text",
        "code": "useEffect(() => {  // ...}); // 🚩 No dependency array: re-runs after every render!"
      },
      {
        "language": "text",
        "code": "useEffect(() => {  // ...}); // 🚩 No dependency array: re-runs after every render!"
      },
      {
        "language": "text",
        "code": "useEffect(() => {    // ..  }, [serverUrl, roomId]);  console.log([serverUrl, roomId]);"
      },
      {
        "language": "text",
        "code": "useEffect(() => {    // ..  }, [serverUrl, roomId]);  console.log([serverUrl, roomId]);"
      },
      {
        "language": "text",
        "code": "Object.is(temp1[0], temp2[0]); // Is the first dependency the same between the arrays?Object.is(temp1[1], temp2[1]); // Is the second dependency the same between the arrays?Object.is(temp1[2], temp2[2]); // ... and so on for every dependency ..."
      },
      {
        "language": "text",
        "code": "Object.is(temp1[0], temp2[0]); // Is the first dependency the same between the arrays?Object.is(temp1[1], temp2[1]); // Is the second dependency the same between the arrays?Object.is(temp1[2], temp2[2]); // ... and so on for every dependency ..."
      },
      {
        "language": "text",
        "code": "useCallback"
      },
      {
        "language": "text",
        "code": "useEffect(() => {  // 🔴 Avoid: Cleanup logic without corresponding setup logic  return () => {    doSomething();  };}, []);"
      },
      {
        "language": "text",
        "code": "useEffect(() => {  // 🔴 Avoid: Cleanup logic without corresponding setup logic  return () => {    doSomething();  };}, []);"
      },
      {
        "language": "text",
        "code": "useEffect(() => {    const connection = createConnection(serverUrl, roomId);    connection.connect();    return () => {      connection.disconnect();    };  }, [serverUrl, roomId]);"
      },
      {
        "language": "text",
        "code": "useEffect(() => {    const connection = createConnection(serverUrl, roomId);    connection.connect();    return () => {      connection.disconnect();    };  }, [serverUrl, roomId]);"
      },
      {
        "language": "text",
        "code": "useLayoutEffect"
      }
    ],
    "links": [
      {
        "text": "API Reference",
        "href": "/reference/react"
      },
      {
        "text": "Hooks",
        "href": "/reference/react/hooks"
      },
      {
        "text": "synchronize a component with an external system.",
        "href": "/learn/synchronizing-with-effects"
      },
      {
        "text": "configured for React",
        "href": "/learn/editor-setup#linting"
      },
      {
        "text": "Object.is",
        "href": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/is"
      },
      {
        "text": "you probably don’t need an Effect.",
        "href": "/learn/you-might-not-need-an-effect"
      },
      {
        "text": "implement the cleanup function.",
        "href": "/learn/synchronizing-with-effects#how-to-handle-the-effect-firing-twice-in-development"
      },
      {
        "text": "useLayoutEffect.",
        "href": "/reference/react/useLayoutEffect"
      },
      {
        "text": "reactwg/react-18/128",
        "href": "https://github.com/reactwg/react-18/discussions/128"
      },
      {
        "text": "useLayoutEffect.",
        "href": "/reference/react/useLayoutEffect"
      },
      {
        "text": "connect your component to some external system,",
        "href": "/learn/synchronizing-with-effects"
      },
      {
        "text": "help you find bugs,",
        "href": "/learn/synchronizing-with-effects#step-3-add-cleanup-if-needed"
      },
      {
        "text": "See common solutions.",
        "href": "/learn/synchronizing-with-effects#how-to-handle-the-effect-firing-twice-in-development"
      },
      {
        "text": "write every Effect as an independent process",
        "href": "/learn/lifecycle-of-reactive-effects#each-effect-represents-a-separate-synchronization-process"
      },
      {
        "text": "think about a single setup/cleanup cycle at a time.",
        "href": "/learn/lifecycle-of-reactive-effects#thinking-from-the-effects-perspective"
      },
      {
        "text": "keep your component synchronized",
        "href": "/learn/synchronizing-with-effects"
      },
      {
        "text": "setInterval()",
        "href": "https://developer.mozilla.org/en-US/docs/Web/API/setInterval"
      },
      {
        "text": "clearInterval()",
        "href": "https://developer.mozilla.org/en-US/docs/Web/API/clearInterval"
      },
      {
        "text": "window.addEventListener()",
        "href": "https://developer.mozilla.org/en-US/docs/Web/API/EventTarget/addEventListener"
      },
      {
        "text": "window.removeEventListener()",
        "href": "https://developer.mozilla.org/en-US/docs/Web/API/EventTarget/removeEventListener"
      },
      {
        "text": "you probably don’t need an Effect.",
        "href": "/learn/you-might-not-need-an-effect"
      },
      {
        "text": "explained here.",
        "href": "/learn/synchronizing-with-effects#step-3-add-cleanup-if-needed"
      },
      {
        "text": "“escape hatch”:",
        "href": "/learn/escape-hatches"
      },
      {
        "text": "custom Hooks",
        "href": "/learn/reusing-logic-with-custom-hooks"
      },
      {
        "text": "Learn more about wrapping Effects in custom Hooks.",
        "href": "/learn/reusing-logic-with-custom-hooks"
      },
      {
        "text": "if you use a framework,",
        "href": "/learn/start-a-new-react-project#full-stack-frameworks"
      },
      {
        "text": "your code doesn’t suffer from “race conditions”:",
        "href": "https://maxrozen.com/race-conditions-fetching-data-react-with-useeffect"
      },
      {
        "text": "async / await",
        "href": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Statements/async_function"
      },
      {
        "text": "It’s easier to use a custom Hook—either your own or maintained by the community.",
        "href": "/learn/reusing-logic-with-custom-hooks#when-to-use-custom-hooks"
      },
      {
        "text": "popular way to fetch data",
        "href": "https://www.robinwieruch.de/react-hooks-fetch-data/"
      },
      {
        "text": "race conditions.",
        "href": "https://maxrozen.com/race-conditions-fetching-data-react-with-useeffect"
      },
      {
        "text": "framework",
        "href": "/learn/start-a-new-react-project#full-stack-frameworks"
      },
      {
        "text": "React Query",
        "href": "https://tanstack.com/query/latest/"
      },
      {
        "text": "useSWR",
        "href": "https://swr.vercel.app/"
      },
      {
        "text": "React Router 6.4+.",
        "href": "https://beta.reactrouter.com/en/main/start/overview"
      },
      {
        "text": "Reactive values",
        "href": "/learn/lifecycle-of-reactive-effects#effects-react-to-reactive-values"
      },
      {
        "text": "your linter is correctly configured for React,",
        "href": "/learn/editor-setup#linting"
      },
      {
        "text": "“prove” to the linter that it doesn’t need to be a dependency.",
        "href": "/learn/removing-effect-dependencies#removing-unnecessary-dependencies"
      },
      {
        "text": "An Effect with empty dependencies",
        "href": "/learn/lifecycle-of-reactive-effects#what-an-effect-with-empty-dependencies-means"
      },
      {
        "text": "Instead, prove they’re unnecessary.",
        "href": "/learn/removing-effect-dependencies#removing-unnecessary-dependencies"
      },
      {
        "text": "reactive values,",
        "href": "/learn/lifecycle-of-reactive-effects#effects-react-to-reactive-values"
      },
      {
        "text": "pass the c => c + 1 state updater",
        "href": "/reference/react/useState#updating-state-based-on-the-previous-state"
      },
      {
        "text": "your Effect no longer needs to depend on count.",
        "href": "/learn/removing-effect-dependencies#are-you-reading-some-state-to-calculate-the-next-state"
      },
      {
        "text": "different for every render:",
        "href": "/learn/removing-effect-dependencies#does-some-reactive-value-change-unintentionally"
      },
      {
        "text": "Read more about removing dependencies.",
        "href": "/learn/removing-effect-dependencies"
      },
      {
        "text": "different for every render:",
        "href": "/learn/removing-effect-dependencies#does-some-reactive-value-change-unintentionally"
      },
      {
        "text": "Read more about removing dependencies.",
        "href": "/learn/removing-effect-dependencies"
      },
      {
        "text": "Declare an Effect Event",
        "href": "/learn/separating-events-from-effects#declaring-an-effect-event"
      },
      {
        "text": "useEffectEvent",
        "href": "/reference/react/experimental_useEffectEvent"
      },
      {
        "text": "Read more about how Effect Events let you separate reactive and non-reactive code.",
        "href": "/learn/separating-events-from-effects#reading-latest-props-and-state-with-effect-events"
      },
      {
        "text": "directly",
        "href": "/reference/react-dom/server"
      },
      {
        "text": "framework",
        "href": "/learn/start-a-new-react-project#full-stack-frameworks"
      },
      {
        "text": "hydration",
        "href": "/reference/react-dom/client/hydrateRoot#hydrating-server-rendered-html"
      },
      {
        "text": "localStorage",
        "href": "https://developer.mozilla.org/en-US/docs/Web/API/Window/localStorage"
      },
      {
        "text": "how this helps find bugs",
        "href": "/learn/synchronizing-with-effects#step-3-add-cleanup-if-needed"
      },
      {
        "text": "how to fix your logic.",
        "href": "/learn/synchronizing-with-effects#how-to-handle-the-effect-firing-twice-in-development"
      },
      {
        "text": "useMemo",
        "href": "/reference/react/useMemo#memoizing-a-dependency-of-another-hook"
      },
      {
        "text": "useCallback",
        "href": "/reference/react/useCallback#preventing-an-effect-from-firing-too-often"
      },
      {
        "text": "removing the Effect altogether",
        "href": "/learn/you-might-not-need-an-effect"
      },
      {
        "text": "ref",
        "href": "/reference/react/useRef#referencing-a-value-with-a-ref"
      },
      {
        "text": "Read how to debug dependency changes.",
        "href": "/reference/react/useEffect#my-effect-runs-after-every-re-render"
      },
      {
        "text": "Learn how the Effect lifecycle is different from the component’s lifecycle.",
        "href": "/learn/lifecycle-of-reactive-effects#the-lifecycle-of-an-effect"
      },
      {
        "text": "painting the screen,",
        "href": "/learn/render-and-commit#epilogue-browser-paint"
      },
      {
        "text": "useLayoutEffect",
        "href": "/reference/react/useLayoutEffect"
      },
      {
        "text": "PrevioususeDeferredValue",
        "href": "/reference/react/useDeferredValue"
      },
      {
        "text": "NextuseId",
        "href": "/reference/react/useId"
      }
    ],
    "meta": {
      "description": "",
      "keywords": ""
    },
    "summary": "API ReferenceHooksuseEffectuseEffect is a React Hook that lets you synchronize a component with an external system. useEffect(setup, dependencies. ) Reference useEffect(setup, dependencies",
    "tags": [
      "react",
      "vue",
      "angular",
      "javascript",
      "typescript",
      "css",
      "html",
      "node",
      "vite",
      "effect"
    ],
    "id": "useeffect-react-useEffect-part-1",
    "quality": 100
  },
  {
    "title": "useContext – React",
    "url": "https://react.dev/reference/react/useContext",
    "category": "react",
    "content": "API ReferenceHooksuseContextuseContext is a React Hook that lets you read and subscribe to context from your component.const value = useContext(SomeContext) Reference useContext(SomeContext) Usage Passing data deeply into the tree Updating data passed via context Specifying a fallback default value Overriding context for a part of the tree Optimizing re-renders when passing objects and functions Troubleshooting My component doesnt see the value from my provider I am always getting undefined from my context although the default value is different Reference useContext(SomeContext) Call useContext at the top level of your component to read and subscribe to context. import { useContext } from 'react';function MyComponent() { const theme = useContext(ThemeContext); // ... See more examples below. Parameters SomeContext: The context that youve previously created with createContext. The context itself does not hold the information, it only represents the kind of information you can provide or read from components. Returns useContext returns the context value for the calling component. It is determined as the value passed to the closest SomeContext above the calling component in the tree. If there is no such provider, then the returned value will be the defaultValue you have passed to createContext for that context. The returned value is always up-to-date. React automatically re-renders components that read some context if it changes. Caveats useContext() call in a component is not affected by providers returned from the same component. The corresponding Context needs to be above the component doing the useContext() call. React automatically re-renders all the children that use a particular context starting from the provider that receives a different value. The previous and the next values are compared with the Object.is comparison. Skipping re-renders with memo does not prevent the children receiving fresh context values. If your build system produces duplicates modules in the output (which can happen with symlinks), this can break context. Passing something via context only works if SomeContext that you use to provide context and SomeContext that you use to read it are exactly the same object, as determined by a === comparison. Usage Passing data deeply into the tree Call useContext at the top level of your component to read and subscribe to context. import { useContext } from 'react';function Button() { const theme = useContext(ThemeContext); // ... useContext returns the context value for the context you passed. To determine the context value, React searches the component tree and finds the closest context provider above for that particular context. To pass context to a Button, wrap it or one of its parent components into the corresponding context provider: function MyPage() { return ( ThemeContext value=\"dark\" Form / /ThemeContext );}function Form() { // ... renders buttons inside ...} It doesnt matter how many layers of components there are between the provider and the Button. When a Button anywhere inside of Form calls useContext(ThemeContext), it will receive \"dark\" as the value. PitfalluseContext() always looks for the closest provider above the component that calls it. It searches upwards and does not consider providers in the component from which youre calling useContext(). App.jsApp.js Download ResetForkimport { createContext, useContext } from 'react'; const ThemeContext = createContext(null); export default function MyApp() { return ( ThemeContext value=\"dark\" Form / /ThemeContext ) } function Form() { return ( Panel title=\"Welcome\" ButtonSign up/Button ButtonLog in/Button /Panel ); } function Panel({ title, children }) { const theme = useContext(ThemeContext); const className = 'panel-' + theme; return ( section className={className} h1{title}/h1 {children} /section ) } function Button({ children }) { const theme = useContext(ThemeContext); const className = 'button-' + theme; return ( button className={className} {children} /button ); } Show more Updating data passed via context Often, youll want the context to change over time. To update context, combine it with state. Declare a state variable in the parent component, and pass the current state down as the context value to the provider. function MyPage() { const [theme, setTheme] = useState('dark'); return ( ThemeContext value={theme} Form / Button onClick={() = { setTheme('light'); }} Switch to light theme /Button /ThemeContext );} Now any Button inside of the provider will receive the current theme value. If you call setTheme to update the theme value that you pass to the provider, all Button components will re-render with the new 'light' value. Examples of updating context1. Updating a value via context 2. Updating an object via context 3. Multiple contexts 4. Extracting providers to a component 5. Scaling up with context and a reducer Example 1 of 5: Updating a value via context In this example, the MyApp component holds a state variable which is then passed to the ThemeContext provider. Checking the Dark mode checkbox updates the state. Changing the provided value re-renders all the components using that context.App.jsApp.js Download ResetForkimport { createContext, useContext, useState } from 'react'; const ThemeContext = createContext(null); export default function MyApp() { const [theme, setTheme] = useState('light'); return ( ThemeContext value={theme} Form / label input type=\"checkbox\" checked={theme === 'dark'} onChange={(e) = { setTheme(e.target.checked ? 'dark' : 'light') }} / Use dark mode /label /ThemeContext ) } function Form({ children }) { return ( Panel title=\"Welcome\" ButtonSign up/Button ButtonLog in/Button /Panel ); } function Panel({ title, children }) { const theme = useContext(ThemeContext); const className = 'panel-' + theme; return ( section className={className} h1{title}/h1 {children} /section ) } function Button({ children }) { const theme = useContext(ThemeContext); const className = 'button-' + theme; return ( button className={className} {children} /button ); } Show moreNote that value=\"dark\" passes the \"dark\" string, but value={theme} passes the value of the JavaScript theme variable with JSX curly braces. Curly braces also let you pass context values that arent strings.Next Example Specifying a fallback default value If React cant find any providers of that particular context in the parent tree, the context value returned by useContext() will be equal to the default value that you specified when you created that context: const ThemeContext = createContext(null); The default value never changes. If you want to update context, use it with state as described above. Often, instead of null, there is some more meaningful value you can use as a default, for example: const ThemeContext = createContext('light'); This way, if you accidentally render some component without a corresponding provider, it wont break. This also helps your components work well in a test environment without setting up a lot of providers in the tests. In the example below, the Toggle theme button is always light because its outside any theme context provider and the default context theme value is 'light'. Try editing the default theme to be 'dark'. App.jsApp.js Download ResetForkimport { createContext, useContext, useState } from 'react'; const ThemeContext = createContext('light'); export default function MyApp() { const [theme, setTheme] = useState('light'); return (  ThemeContext value={theme} Form / /ThemeContext Button onClick={() = { setTheme(theme === 'dark' ? 'light' : 'dark'); }} Toggle theme /Button / ) } function Form({ children }) { return ( Panel title=\"Welcome\" ButtonSign up/Button ButtonLog in/Button /Panel ); } function Panel({ title, children }) { const theme = useContext(ThemeContext); const className = 'panel-' + theme; return ( section className={className} h1{title}/h1 {children} /section ) } function Button({ children, onClick }) { const theme = useContext(ThemeContext); const className = 'button-' + theme; return ( button className={className} onClick={onClick} {children} /button ); } Show more Overriding context for a part of the tree You can override the context for a part of the tree by wrapping that part in a provider with a different value. ThemeContext value=\"dark\" ... ThemeContext value=\"light\" Footer / /ThemeContext .../ThemeContext You can nest and override providers as many times as you need. Examples of overriding context1. Overriding a theme 2. Automatically nested headings Example 1 of 2: Overriding a theme Here, the button inside the Footer receives a different context value (\"light\") than the buttons outside (\"dark\").App.jsApp.js Download ResetForkimport { createContext, useContext } from 'react'; const ThemeContext = createContext(null); export default function MyApp() { return ( ThemeContext value=\"dark\" Form / /ThemeContext ) } function Form() { return ( Panel title=\"Welcome\" ButtonSign up/Button ButtonLog in/Button ThemeContext value=\"light\" Footer / /ThemeContext /Panel ); } function Footer() { return ( footer ButtonSettings/Button /footer ); } function Panel({ title, children }) { const theme = useContext(ThemeContext); const className = 'panel-' + theme; return ( section className={className} {title && h1{title}/h1} {children} /section ) } function Button({ children }) { const theme = useContext(ThemeContext); const className = 'button-' + theme; return ( button className={className} {children} /button ); } Show moreNext Example Optimizing re-renders when passing objects and functions You can pass any values via context, including objects and functions. function MyApp() { const [currentUser, setCurrentUser] = useState(null); function login(response) { storeCredentials(response.credentials); setCurrentUser(response.user); } return ( AuthContext value={{ currentUser, login }} Page / /AuthContext );} Here, the context value is a JavaScript object with two properties, one of which is a function. Whenever MyApp re-renders (for example, on a route update), this will be a different object pointing at a different function, so React will also have to re-render all components deep in the tree that call useContext(AuthContext). In smaller apps, this is not a problem. However, there is no need to re-render them if the underlying data, like currentUser, has not changed. To help React take advantage of that fact, you may wrap the login function with useCallback and wrap the object creation into useMemo. This is a performance optimization: import { useCallback, useMemo } from 'react';function MyApp() { const [currentUser, setCurrentUser] = useState(null); const login = useCallback((response) = { storeCredentials(response.credentials); setCurrentUser(response.user); }, []); const contextValue = useMemo(() = ({ currentUser, login }), [currentUser, login]); return ( AuthContext value={contextValue} Page / /AuthContext );} As a result of this change, even if MyApp needs to re-render, the components calling useContext(AuthContext) wont need to re-render unless currentUser has changed. Read more about useMemo and useCallback. Troubleshooting My component doesnt see the value from my provider There are a few common ways that this can happen: Youre rendering SomeContext in the same component (or below) as where youre calling useContext(). Move SomeContext above and outside the component calling useContext(). You may have forgotten to wrap your component with SomeContext, or you might have put it in a different part of the tree than you thought. Check whether the hierarchy is right using React DevTools. You might be running into some build issue with your tooling that causes SomeContext as seen from the providing component and SomeContext as seen by the reading component to be two different objects. This can happen if you use symlinks, for example. You can verify this by assigning them to globals like window.SomeContext1 and window.SomeContext2 and then checking whether window.SomeContext1 === window.SomeContext2 in the console. If theyre not the same, fix that issue on the build tool level. I am always getting undefined from my context although the default value is different You might have a provider without a value in the tree: //  Doesn't work: no value propThemeContext Button //ThemeContext If you forget to specify value, its like passing value={undefined}. You may have also mistakingly used a different prop name by mistake: //  Doesn't work: prop should be called \"value\"ThemeContext theme={theme} Button //ThemeContext In both of these cases you should see a warning from React in the console. To fix them, call the prop value: //  Passing the value propThemeContext value={theme} Button //ThemeContext Note that the default value from your createContext(defaultValue) call is only used if there is no matching provider above at all. If there is a SomeContext value={undefined} component somewhere in the parent tree, the component calling useContext(SomeContext) will receive undefined as the context value.PrevioususeCallbackNextuseDebugValue",
    "headings": [
      {
        "level": 1,
        "text": "useContext",
        "id": ""
      },
      {
        "level": 2,
        "text": "Reference",
        "id": "reference"
      },
      {
        "level": 2,
        "text": "Usage",
        "id": "usage"
      },
      {
        "level": 2,
        "text": "Troubleshooting",
        "id": "troubleshooting"
      },
      {
        "level": 3,
        "text": "useContext(SomeContext)",
        "id": "usecontext"
      },
      {
        "level": 3,
        "text": "Passing data deeply into the tree",
        "id": "passing-data-deeply-into-the-tree"
      },
      {
        "level": 3,
        "text": "Pitfall",
        "id": ""
      },
      {
        "level": 3,
        "text": "Updating data passed via context",
        "id": "updating-data-passed-via-context"
      },
      {
        "level": 3,
        "text": "Specifying a fallback default value",
        "id": "specifying-a-fallback-default-value"
      },
      {
        "level": 3,
        "text": "Overriding context for a part of the tree",
        "id": "overriding-context-for-a-part-of-the-tree"
      },
      {
        "level": 3,
        "text": "Optimizing re-renders when passing objects and functions",
        "id": "optimizing-re-renders-when-passing-objects-and-functions"
      },
      {
        "level": 3,
        "text": "My component doesn’t see the value from my provider",
        "id": "my-component-doesnt-see-the-value-from-my-provider"
      },
      {
        "level": 3,
        "text": "I am always getting undefined from my context although the default value is different",
        "id": "i-am-always-getting-undefined-from-my-context-although-the-default-value-is-different"
      },
      {
        "level": 4,
        "text": "Parameters",
        "id": "parameters"
      },
      {
        "level": 4,
        "text": "Returns",
        "id": "returns"
      },
      {
        "level": 4,
        "text": "Caveats",
        "id": "caveats"
      },
      {
        "level": 4,
        "text": "Examples of updating context",
        "id": "examples-basic"
      },
      {
        "level": 4,
        "text": "Example 1 of 5: Updating a value via context",
        "id": "updating-a-value-via-context"
      },
      {
        "level": 4,
        "text": "Examples of overriding context",
        "id": "examples"
      },
      {
        "level": 4,
        "text": "Example 1 of 2: Overriding a theme",
        "id": "overriding-a-theme"
      }
    ],
    "codeBlocks": [
      {
        "language": "text",
        "code": "const value = useContext(SomeContext)"
      },
      {
        "language": "text",
        "code": "const value = useContext(SomeContext)"
      },
      {
        "language": "text",
        "code": "useContext(SomeContext)"
      },
      {
        "language": "text",
        "code": "useContext(SomeContext)"
      },
      {
        "language": "text",
        "code": "import { useContext } from 'react';function MyComponent() {  const theme = useContext(ThemeContext);  // ..."
      },
      {
        "language": "text",
        "code": "import { useContext } from 'react';function MyComponent() {  const theme = useContext(ThemeContext);  // ..."
      },
      {
        "language": "text",
        "code": "SomeContext"
      },
      {
        "language": "text",
        "code": "createContext"
      },
      {
        "language": "text",
        "code": "SomeContext"
      },
      {
        "language": "text",
        "code": "defaultValue"
      },
      {
        "language": "text",
        "code": "createContext"
      },
      {
        "language": "text",
        "code": "useContext()"
      },
      {
        "language": "text",
        "code": "useContext()"
      },
      {
        "language": "text",
        "code": "SomeContext"
      },
      {
        "language": "text",
        "code": "SomeContext"
      },
      {
        "language": "text",
        "code": "import { useContext } from 'react';function Button() {  const theme = useContext(ThemeContext);  // ..."
      },
      {
        "language": "text",
        "code": "import { useContext } from 'react';function Button() {  const theme = useContext(ThemeContext);  // ..."
      },
      {
        "language": "text",
        "code": "function MyPage() {  return (    <ThemeContext value=\"dark\">      <Form />    </ThemeContext>  );}function Form() {  // ... renders buttons inside ...}"
      },
      {
        "language": "text",
        "code": "function MyPage() {  return (    <ThemeContext value=\"dark\">      <Form />    </ThemeContext>  );}function Form() {  // ... renders buttons inside ...}"
      },
      {
        "language": "text",
        "code": "useContext(ThemeContext)"
      },
      {
        "language": "text",
        "code": "useContext()"
      },
      {
        "language": "text",
        "code": "useContext()"
      },
      {
        "language": "text",
        "code": "import { createContext, useContext } from 'react';\n\nconst ThemeContext = createContext(null);\n\nexport default function MyApp() {\n  return (\n    <ThemeContext value=\"dark\">\n      <Form />\n    </ThemeContext>\n  )\n}\n\nfunction Form() {\n  return (\n    <Panel title=\"Welcome\">\n      <Button>Sign up</Button>\n      <Button>Log in</Button>\n    </Panel>\n  );\n}\n\nfunction Panel({ title, children }) {\n  const theme = useContext(ThemeContext);\n  const className = 'panel-' + theme;\n  return (\n    <section className={className}>\n      <h1>{title}</h1>\n      {children}\n    </section>\n  )\n}\n\nfunction Button({ children }) {\n  const theme = useContext(ThemeContext);\n  const className = 'button-' + theme;\n  return (\n    <button className={className}>\n      {children}\n    </button>\n  );\n}"
      },
      {
        "language": "text",
        "code": "function MyPage() {  const [theme, setTheme] = useState('dark');  return (    <ThemeContext value={theme}>      <Form />      <Button onClick={() => {        setTheme('light');      }}>        Switch to light theme      </Button>    </ThemeContext>  );}"
      },
      {
        "language": "text",
        "code": "function MyPage() {  const [theme, setTheme] = useState('dark');  return (    <ThemeContext value={theme}>      <Form />      <Button onClick={() => {        setTheme('light');      }}>        Switch to light theme      </Button>    </ThemeContext>  );}"
      },
      {
        "language": "text",
        "code": "ThemeContext"
      },
      {
        "language": "text",
        "code": "import { createContext, useContext, useState } from 'react';\n\nconst ThemeContext = createContext(null);\n\nexport default function MyApp() {\n  const [theme, setTheme] = useState('light');\n  return (\n    <ThemeContext value={theme}>\n      <Form />\n      <label>\n        <input\n          type=\"checkbox\"\n          checked={theme === 'dark'}\n          onChange={(e) => {\n            setTheme(e.target.checked ? 'dark' : 'light')\n          }}\n        />\n        Use dark mode\n      </label>\n    </ThemeContext>\n  )\n}\n\nfunction Form({ children }) {\n  return (\n    <Panel title=\"Welcome\">\n      <Button>Sign up</Button>\n      <Button>Log in</Button>\n    </Panel>\n  );\n}\n\nfunction Panel({ title, children }) {\n  const theme = useContext(ThemeContext);\n  const className = 'panel-' + theme;\n  return (\n    <section className={className}>\n      <h1>{title}</h1>\n      {children}\n    </section>\n  )\n}\n\nfunction Button({ children }) {\n  const theme = useContext(ThemeContext);\n  const className = 'button-' + theme;\n  return (\n    <button className={className}>\n      {children}\n    </button>\n  );\n}"
      },
      {
        "language": "text",
        "code": "value=\"dark\""
      },
      {
        "language": "text",
        "code": "value={theme}"
      },
      {
        "language": "text",
        "code": "useContext()"
      },
      {
        "language": "text",
        "code": "const ThemeContext = createContext(null);"
      },
      {
        "language": "text",
        "code": "const ThemeContext = createContext(null);"
      },
      {
        "language": "text",
        "code": "const ThemeContext = createContext('light');"
      },
      {
        "language": "text",
        "code": "const ThemeContext = createContext('light');"
      },
      {
        "language": "text",
        "code": "import { createContext, useContext, useState } from 'react';\n\nconst ThemeContext = createContext('light');\n\nexport default function MyApp() {\n  const [theme, setTheme] = useState('light');\n  return (\n    <>\n      <ThemeContext value={theme}>\n        <Form />\n      </ThemeContext>\n      <Button onClick={() => {\n        setTheme(theme === 'dark' ? 'light' : 'dark');\n      }}>\n        Toggle theme\n      </Button>\n    </>\n  )\n}\n\nfunction Form({ children }) {\n  return (\n    <Panel title=\"Welcome\">\n      <Button>Sign up</Button>\n      <Button>Log in</Button>\n    </Panel>\n  );\n}\n\nfunction Panel({ title, children }) {\n  const theme = useContext(ThemeContext);\n  const className = 'panel-' + theme;\n  return (\n    <section className={className}>\n      <h1>{title}</h1>\n      {children}\n    </section>\n  )\n}\n\nfunction Button({ children, onClick }) {\n  const theme = useContext(ThemeContext);\n  const className = 'button-' + theme;\n  return (\n    <button className={className} onClick={onClick}>\n      {children}\n    </button>\n  );\n}"
      },
      {
        "language": "text",
        "code": "<ThemeContext value=\"dark\">  ...  <ThemeContext value=\"light\">    <Footer />  </ThemeContext>  ...</ThemeContext>"
      },
      {
        "language": "text",
        "code": "<ThemeContext value=\"dark\">  ...  <ThemeContext value=\"light\">    <Footer />  </ThemeContext>  ...</ThemeContext>"
      },
      {
        "language": "text",
        "code": "import { createContext, useContext } from 'react';\n\nconst ThemeContext = createContext(null);\n\nexport default function MyApp() {\n  return (\n    <ThemeContext value=\"dark\">\n      <Form />\n    </ThemeContext>\n  )\n}\n\nfunction Form() {\n  return (\n    <Panel title=\"Welcome\">\n      <Button>Sign up</Button>\n      <Button>Log in</Button>\n      <ThemeContext value=\"light\">\n        <Footer />\n      </ThemeContext>\n    </Panel>\n  );\n}\n\nfunction Footer() {\n  return (\n    <footer>\n      <Button>Settings</Button>\n    </footer>\n  );\n}\n\nfunction Panel({ title, children }) {\n  const theme = useContext(ThemeContext);\n  const className = 'panel-' + theme;\n  return (\n    <section className={className}>\n      {title && <h1>{title}</h1>}\n      {children}\n    </section>\n  )\n}\n\nfunction Button({ children }) {\n  const theme = useContext(ThemeContext);\n  const className = 'button-' + theme;\n  return (\n    <button className={className}>\n      {children}\n    </button>\n  );\n}"
      },
      {
        "language": "text",
        "code": "function MyApp() {  const [currentUser, setCurrentUser] = useState(null);  function login(response) {    storeCredentials(response.credentials);    setCurrentUser(response.user);  }  return (    <AuthContext value={{ currentUser, login }}>      <Page />    </AuthContext>  );}"
      },
      {
        "language": "text",
        "code": "function MyApp() {  const [currentUser, setCurrentUser] = useState(null);  function login(response) {    storeCredentials(response.credentials);    setCurrentUser(response.user);  }  return (    <AuthContext value={{ currentUser, login }}>      <Page />    </AuthContext>  );}"
      },
      {
        "language": "text",
        "code": "useContext(AuthContext)"
      },
      {
        "language": "text",
        "code": "currentUser"
      },
      {
        "language": "text",
        "code": "useCallback"
      },
      {
        "language": "text",
        "code": "import { useCallback, useMemo } from 'react';function MyApp() {  const [currentUser, setCurrentUser] = useState(null);  const login = useCallback((response) => {    storeCredentials(response.credentials);    setCurrentUser(response.user);  }, []);  const contextValue = useMemo(() => ({    currentUser,    login  }), [currentUser, login]);  return (    <AuthContext value={contextValue}>      <Page />    </AuthContext>  );}"
      },
      {
        "language": "text",
        "code": "import { useCallback, useMemo } from 'react';function MyApp() {  const [currentUser, setCurrentUser] = useState(null);  const login = useCallback((response) => {    storeCredentials(response.credentials);    setCurrentUser(response.user);  }, []);  const contextValue = useMemo(() => ({    currentUser,    login  }), [currentUser, login]);  return (    <AuthContext value={contextValue}>      <Page />    </AuthContext>  );}"
      },
      {
        "language": "text",
        "code": "useContext(AuthContext)"
      },
      {
        "language": "text",
        "code": "currentUser"
      },
      {
        "language": "text",
        "code": "useCallback"
      },
      {
        "language": "text",
        "code": "<SomeContext>"
      },
      {
        "language": "text",
        "code": "useContext()"
      },
      {
        "language": "text",
        "code": "<SomeContext>"
      },
      {
        "language": "text",
        "code": "useContext()"
      },
      {
        "language": "text",
        "code": "<SomeContext>"
      },
      {
        "language": "text",
        "code": "SomeContext"
      },
      {
        "language": "text",
        "code": "SomeContext"
      },
      {
        "language": "text",
        "code": "window.SomeContext1"
      },
      {
        "language": "text",
        "code": "window.SomeContext2"
      },
      {
        "language": "text",
        "code": "window.SomeContext1 === window.SomeContext2"
      },
      {
        "language": "text",
        "code": "// 🚩 Doesn't work: no value prop<ThemeContext>   <Button /></ThemeContext>"
      },
      {
        "language": "text",
        "code": "// 🚩 Doesn't work: no value prop<ThemeContext>   <Button /></ThemeContext>"
      },
      {
        "language": "text",
        "code": "value={undefined}"
      },
      {
        "language": "text",
        "code": "// 🚩 Doesn't work: prop should be called \"value\"<ThemeContext theme={theme}>   <Button /></ThemeContext>"
      },
      {
        "language": "text",
        "code": "// 🚩 Doesn't work: prop should be called \"value\"<ThemeContext theme={theme}>   <Button /></ThemeContext>"
      },
      {
        "language": "text",
        "code": "// ✅ Passing the value prop<ThemeContext value={theme}>   <Button /></ThemeContext>"
      },
      {
        "language": "text",
        "code": "// ✅ Passing the value prop<ThemeContext value={theme}>   <Button /></ThemeContext>"
      },
      {
        "language": "text",
        "code": "createContext(defaultValue)"
      },
      {
        "language": "text",
        "code": "<SomeContext value={undefined}>"
      },
      {
        "language": "text",
        "code": "useContext(SomeContext)"
      }
    ],
    "links": [
      {
        "text": "API Reference",
        "href": "/reference/react"
      },
      {
        "text": "Hooks",
        "href": "/reference/react/hooks"
      },
      {
        "text": "context",
        "href": "/learn/passing-data-deeply-with-context"
      },
      {
        "text": "context.",
        "href": "/learn/passing-data-deeply-with-context"
      },
      {
        "text": "createContext",
        "href": "/reference/react/createContext"
      },
      {
        "text": "createContext",
        "href": "/reference/react/createContext"
      },
      {
        "text": "Object.is",
        "href": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/is"
      },
      {
        "text": "memo",
        "href": "/reference/react/memo"
      },
      {
        "text": "context.",
        "href": "/learn/passing-data-deeply-with-context"
      },
      {
        "text": "state.",
        "href": "/reference/react/useState"
      },
      {
        "text": "JSX curly braces.",
        "href": "/learn/javascript-in-jsx-with-curly-braces"
      },
      {
        "text": "created that context",
        "href": "/reference/react/createContext"
      },
      {
        "text": "useCallback",
        "href": "/reference/react/useCallback"
      },
      {
        "text": "useMemo",
        "href": "/reference/react/useMemo"
      },
      {
        "text": "useMemo",
        "href": "/reference/react/useMemo#skipping-re-rendering-of-components"
      },
      {
        "text": "useCallback.",
        "href": "/reference/react/useCallback#skipping-re-rendering-of-components"
      },
      {
        "text": "React DevTools.",
        "href": "/learn/react-developer-tools"
      },
      {
        "text": "PrevioususeCallback",
        "href": "/reference/react/useCallback"
      },
      {
        "text": "NextuseDebugValue",
        "href": "/reference/react/useDebugValue"
      }
    ],
    "meta": {
      "description": "",
      "keywords": ""
    },
    "summary": "API ReferenceHooksuseContextuseContext is a React Hook that lets you read and subscribe to context from your component",
    "tags": [
      "react",
      "angular",
      "javascript",
      "typescript",
      "html",
      "node",
      "vite",
      "context",
      "value",
      "usecontext"
    ],
    "id": "usecontext-react-useContext-part-1",
    "quality": 100
  },
  {
    "title": "useReducer – React",
    "url": "https://react.dev/reference/react/useReducer",
    "category": "react",
    "content": "API ReferenceHooksuseReduceruseReducer is a React Hook that lets you add a reducer to your component.const [state, dispatch] = useReducer(reducer, initialArg, init?) Reference useReducer(reducer, initialArg, init?) dispatch function Usage Adding a reducer to a component Writing the reducer function Avoiding recreating the initial state Troubleshooting Ive dispatched an action, but logging gives me the old state value Ive dispatched an action, but the screen doesnt update A part of my reducer state becomes undefined after dispatching My entire reducer state becomes undefined after dispatching Im getting an error: Too many re-renders My reducer or initializer function runs twice Reference useReducer(reducer, initialArg, init?) Call useReducer at the top level of your component to manage its state with a reducer. import { useReducer } from 'react';function reducer(state, action) { // ...}function MyComponent() { const [state, dispatch] = useReducer(reducer, { age: 42 }); // ... See more examples below. Parameters reducer: The reducer function that specifies how the state gets updated. It must be pure, should take the state and action as arguments, and should return the next state. State and action can be of any types. initialArg: The value from which the initial state is calculated. It can be a value of any type. How the initial state is calculated from it depends on the next init argument. optional init: The initializer function that should return the initial state. If its not specified, the initial state is set to initialArg. Otherwise, the initial state is set to the result of calling init(initialArg). Returns useReducer returns an array with exactly two values: The current state. During the first render, its set to init(initialArg) or initialArg (if theres no init). The dispatch function that lets you update the state to a different value and trigger a re-render. Caveats useReducer is a Hook, so you can only call it at the top level of your component or your own Hooks. You cant call it inside loops or conditions. If you need that, extract a new component and move the state into it. The dispatch function has a stable identity, so you will often see it omitted from Effect dependencies, but including it will not cause the Effect to fire. If the linter lets you omit a dependency without errors, it is safe to do. Learn more about removing Effect dependencies. In Strict Mode, React will call your reducer and initializer twice in order to help you find accidental impurities. This is development-only behavior and does not affect production. If your reducer and initializer are pure (as they should be), this should not affect your logic. The result from one of the calls is ignored. dispatch function The dispatch function returned by useReducer lets you update the state to a different value and trigger a re-render. You need to pass the action as the only argument to the dispatch function: const [state, dispatch] = useReducer(reducer, { age: 42 });function handleClick() { dispatch({ type: 'incremented_age' }); // ... React will set the next state to the result of calling the reducer function youve provided with the current state and the action youve passed to dispatch. Parameters action: The action performed by the user. It can be a value of any type. By convention, an action is usually an object with a type property identifying it and, optionally, other properties with additional information. Returns dispatch functions do not have a return value. Caveats The dispatch function only updates the state variable for the next render. If you read the state variable after calling the dispatch function, you will still get the old value that was on the screen before your call. If the new value you provide is identical to the current state, as determined by an Object.is comparison, React will skip re-rendering the component and its children. This is an optimization. React may still need to call your component before ignoring the result, but it shouldnt affect your code. React batches state updates. It updates the screen after all the event handlers have run and have called their set functions. This prevents multiple re-renders during a single event. In the rare case that you need to force React to update the screen earlier, for example to access the DOM, you can use flushSync. Usage Adding a reducer to a component Call useReducer at the top level of your component to manage state with a reducer. import { useReducer } from 'react';function reducer(state, action) { // ...}function MyComponent() { const [state, dispatch] = useReducer(reducer, { age: 42 }); // ... useReducer returns an array with exactly two items: The current state of this state variable, initially set to the initial state you provided. The dispatch function that lets you change it in response to interaction. To update whats on the screen, call dispatch with an object representing what the user did, called an action: function handleClick() { dispatch({ type: 'incremented_age' });} React will pass the current state and the action to your reducer function. Your reducer will calculate and return the next state. React will store that next state, render your component with it, and update the UI. App.jsApp.js Download ResetForkimport { useReducer } from 'react'; function reducer(state, action) { if (action.type === 'incremented_age') { return { age: state.age + 1 }; } throw Error('Unknown action.'); } export default function Counter() { const [state, dispatch] = useReducer(reducer, { age: 42 }); return (  button onClick={() = { dispatch({ type: 'incremented_age' }) }} Increment age /button pHello! You are {state.age}./p / ); } Show more useReducer is very similar to useState, but it lets you move the state update logic from event handlers into a single function outside of your component. Read more about choosing between useState and useReducer. Writing the reducer function A reducer function is declared like this: function reducer(state, action) { // ...} Then you need to fill in the code that will calculate and return the next state. By convention, it is common to write it as a switch statement. For each case in the switch, calculate and return some next state. function reducer(state, action) { switch (action.type) { case 'incremented_age': { return { name: state.name, age: state.age + 1 }; } case 'changed_name': { return { name: action.nextName, age: state.age }; } } throw Error('Unknown action: ' + action.type);} Actions can have any shape. By convention, its common to pass objects with a type property identifying the action. It should include the minimal necessary information that the reducer needs to compute the next state. function Form() { const [state, dispatch] = useReducer(reducer, { name: 'Taylor', age: 42 }); function handleButtonClick() { dispatch({ type: 'incremented_age' }); } function handleInputChange(e) { dispatch({ type: 'changed_name', nextName: e.target.value }); } // ... The action type names are local to your component. Each action describes a single interaction, even if that leads to multiple changes in data. The shape of the state is arbitrary, but usually itll be an object or an array. Read extracting state logic into a reducer to learn more. PitfallState is read-only. Dont modify any objects or arrays in state:function reducer(state, action) { switch (action.type) { case 'incremented_age': { //  Don't mutate an object in state like this: state.age = state.age + 1; return state; }Instead, always return new objects from your reducer:function reducer(state, action) { switch (action.type) { case 'incremented_age': { //  Instead, return a new object return { ...state, age: state.age + 1 }; }Read updating objects in state and updating arrays in state to learn more. Basic useReducer examples1. Form (object) 2. Todo list (array) 3. Writing concise update logic with Immer Example 1 of 3: Form (object) In this example, the reducer manages a state object with two fields: name and age.App.jsApp.js Download ResetForkimport { useReducer } from 'react'; function reducer(state, action) { switch (action.type) { case 'incremented_age': { return { name: state.name, age: state.age + 1 }; } case 'changed_name': { return { name: action.nextName, age: state.age }; } } throw Error('Unknown action: ' + action.type); } const initialState = { name: 'Taylor', age: 42 }; export default function Form() { const [state, dispatch] = useReducer(reducer, initialState); function handleButtonClick() { dispatch({ type: 'incremented_age' }); } function handleInputChange(e) { dispatch({ type: 'changed_name', nextName: e.target.value }); } return (  input value={state.name} onChange={handleInputChange} / button onClick={handleButtonClick} Increment age /button pHello, {state.name}. You are {state.age}./p / ); } Show moreNext Example Avoiding recreating the initial state React saves the initial state once and ignores it on the next renders. function createInitialState(username) { // ...}function TodoList({ username }) { const [state, dispatch] = useReducer(reducer, createInitialState(username)); // ... Although the result of createInitialState(username) is only used for the initial render, youre still calling this function on every render. This can be wasteful if its creating large arrays or performing expensive calculations. To solve this, you may pass it as an initializer function to useReducer as the third argument instead: function createInitialState(username) { // ...}function TodoList({ username }) { const [state, dispatch] = useReducer(reducer, username, createInitialState); // ... Notice that youre passing createInitialState, which is the function itself, and not createInitialState(), which is the result of calling it. This way, the initial state does not get re-created after initialization. In the above example, createInitialState takes a username argument. If your initializer doesnt need any information to compute the initial state, you may pass null as the second argument to useReducer. The difference between passing an initializer and passing the initial state directly1. Passing the initializer function 2. Passing the initial state directly Example 1 of 2: Passing the initializer function This example passes the initializer function, so the createInitialState function only runs during initialization. It does not run when component re-renders, such as when you type into the input.TodoList.jsTodoList.js ResetForkimport { useReducer } from 'react'; function createInitialState(username) { const initialTodos = []; for (let i = 0; i  50; i++) { initialTodos.push({ id: i, text: username + \"'s task #\" + (i + 1) }); } return { draft: '', todos: initialTodos, }; } function reducer(state, action) { switch (action.type) { case 'changed_draft': { return { draft: action.nextDraft, todos: state.todos, }; }; case 'added_todo': { return { draft: '', todos: [{ id: state.todos.length, text: state.draft }, ...state.todos] } } } throw Error('Unknown action: ' + action.type); } export default function TodoList({ username }) { const [state, dispatch] = useReducer( reducer, username, createInitialState ); return (  input value={state.draft} onChange={e = { dispatch({ type: 'changed_draft', nextDraft: e.target.value }) }} / button onClick={() = { dispatch({ type: 'added_todo' }); }}Add/button ul {state.todos.map(item = ( li key={item.id} {item.text} /li ))} /ul / ); } Show moreNext Example Troubleshooting Ive dispatched an action, but logging gives me the old state value Calling the dispatch function does not change state in the running code: function handleClick() { console.log(state.age); // 42 dispatch({ type: 'incremented_age' }); // Request a re-render with 43 console.log(state.age); // Still 42! setTimeout(() = { console.log(state.age); // Also 42! }, 5000);} This is because states behaves like a snapshot. Updating state requests another render with the new state value, but does not affect the state JavaScript variable in your already-running event handler. If you need to guess the next state value, you can calculate it manually by calling the reducer yourself: const action = { type: 'incremented_age' };dispatch(action);const nextState = reducer(state, action);console.log(state); // { age: 42 }console.log(nextState); // { age: 43 } Ive dispatched an action, but the screen doesnt update React will ignore your update if the next state is equal to the previous state, as determined by an Object.is comparison. This usually happens when you change an object or an array in state directly: function reducer(state, action) { switch (action.type) { case 'incremented_age': { //  Wrong: mutating existing object state.age++; return state; } case 'changed_name': { //  Wrong: mutating existing object state.name = action.nextName; return state; } // ... }} You mutated an existing state object and returned it, so React ignored the update. To fix this, you need to ensure that youre always updating objects in state and updating arrays in state instead of mutating them: function reducer(state, action) { switch (action.type) { case 'incremented_age': { //  Correct: creating a new object return { ...state, age: state.age + 1 }; } case 'changed_name': { //  Correct: creating a new object return { ...state, name: action.nextName }; } // ... }} A part of my reducer state becomes undefined after dispatching Make sure that every case branch copies all of the existing fields when returning the new state: function reducer(state, action) { switch (action.type) { case 'incremented_age': { return { ...state, // Don't forget this! age: state.age + 1 }; } // ... Without ...state above, the returned next state would only contain the age field and nothing else. My entire reducer state becomes undefined after dispatching If your state unexpectedly becomes undefined, youre likely forgetting to return state in one of the cases, or your action type doesnt match any of the case statements. To find why, throw an error outside the switch: function reducer(state, action) { switch (action.type) { case 'incremented_age': { // ... } case 'edited_name': { // ... } } throw Error('Unknown action: ' + action.type);} You can also use a static type checker like TypeScript to catch such mistakes. Im getting an error: Too many re-renders You might get an error that says: Too many re-renders. React limits the number of renders to prevent an infinite loop. Typically, this means that youre unconditionally dispatching an action during render, so your component enters a loop: render, dispatch (which causes a render), render, dispatch (which causes a render), and so on. Very often, this is caused by a mistake in specifying an event handler: //  Wrong: calls the handler during renderreturn button onClick={handleClick()}Click me/button//  Correct: passes down the event handlerreturn button onClick={handleClick}Click me/button//  Correct: passes down an inline functionreturn button onClick={(e) = handleClick(e)}Click me/button If you cant find the cause of this error, click on the arrow next to the error in the console and look through the JavaScript stack to find the specific dispatch function call responsible for the error. My reducer or initializer function runs twice In Strict Mode, React will call your reducer and initializer functions twice. This shouldnt break your code. This development-only behavior helps you keep components pure. React uses the result of one of the calls, and ignores the result of the other call. As long as your component, initializer, and reducer functions are pure, this shouldnt affect your logic. However, if they are accidentally impure, this helps you notice the mistakes. For example, this impure reducer function mutates an array in state: function reducer(state, action) { switch (action.type) { case 'added_todo': { //  Mistake: mutating state state.todos.push({ id: nextId++, text: action.text }); return state; } // ... }} Because React calls your reducer function twice, youll see the todo was added twice, so youll know that there is a mistake. In this example, you can fix the mistake by replacing the array instead of mutating it: function reducer(state, action) { switch (action.type) { case 'added_todo': { //  Correct: replacing with new state return { ...state, todos: [ ...state.todos, { id: nextId++, text: action.text } ] }; } // ... }} Now that this reducer function is pure, calling it an extra time doesnt make a difference in behavior. This is why React calling it twice helps you find mistakes. Only component, initializer, and reducer functions need to be pure. Event handlers dont need to be pure, so React will never call your event handlers twice. Read keeping components pure to learn more.PrevioususeOptimisticNextuseRef",
    "headings": [
      {
        "level": 1,
        "text": "useReducer",
        "id": ""
      },
      {
        "level": 2,
        "text": "Reference",
        "id": "reference"
      },
      {
        "level": 2,
        "text": "Usage",
        "id": "usage"
      },
      {
        "level": 2,
        "text": "Troubleshooting",
        "id": "troubleshooting"
      },
      {
        "level": 3,
        "text": "useReducer(reducer, initialArg, init?)",
        "id": "usereducer"
      },
      {
        "level": 3,
        "text": "dispatch function",
        "id": "dispatch"
      },
      {
        "level": 3,
        "text": "Adding a reducer to a component",
        "id": "adding-a-reducer-to-a-component"
      },
      {
        "level": 3,
        "text": "Writing the reducer function",
        "id": "writing-the-reducer-function"
      },
      {
        "level": 3,
        "text": "Pitfall",
        "id": ""
      },
      {
        "level": 3,
        "text": "Avoiding recreating the initial state",
        "id": "avoiding-recreating-the-initial-state"
      },
      {
        "level": 3,
        "text": "I’ve dispatched an action, but logging gives me the old state value",
        "id": "ive-dispatched-an-action-but-logging-gives-me-the-old-state-value"
      },
      {
        "level": 3,
        "text": "I’ve dispatched an action, but the screen doesn’t update",
        "id": "ive-dispatched-an-action-but-the-screen-doesnt-update"
      },
      {
        "level": 3,
        "text": "A part of my reducer state becomes undefined after dispatching",
        "id": "a-part-of-my-reducer-state-becomes-undefined-after-dispatching"
      },
      {
        "level": 3,
        "text": "My entire reducer state becomes undefined after dispatching",
        "id": "my-entire-reducer-state-becomes-undefined-after-dispatching"
      },
      {
        "level": 3,
        "text": "I’m getting an error: “Too many re-renders”",
        "id": "im-getting-an-error-too-many-re-renders"
      },
      {
        "level": 3,
        "text": "My reducer or initializer function runs twice",
        "id": "my-reducer-or-initializer-function-runs-twice"
      },
      {
        "level": 4,
        "text": "Parameters",
        "id": "parameters"
      },
      {
        "level": 4,
        "text": "Returns",
        "id": "returns"
      },
      {
        "level": 4,
        "text": "Caveats",
        "id": "caveats"
      },
      {
        "level": 4,
        "text": "Parameters",
        "id": "dispatch-parameters"
      },
      {
        "level": 4,
        "text": "Returns",
        "id": "dispatch-returns"
      },
      {
        "level": 4,
        "text": "Caveats",
        "id": "setstate-caveats"
      },
      {
        "level": 4,
        "text": "Basic useReducer examples",
        "id": "examples-basic"
      },
      {
        "level": 4,
        "text": "Example 1 of 3: Form (object)",
        "id": "form-object"
      },
      {
        "level": 4,
        "text": "The difference between passing an initializer and passing the initial state directly",
        "id": "examples-initializer"
      },
      {
        "level": 4,
        "text": "Example 1 of 2: Passing the initializer function",
        "id": "passing-the-initializer-function"
      }
    ],
    "codeBlocks": [
      {
        "language": "text",
        "code": "const [state, dispatch] = useReducer(reducer, initialArg, init?)"
      },
      {
        "language": "text",
        "code": "const [state, dispatch] = useReducer(reducer, initialArg, init?)"
      },
      {
        "language": "text",
        "code": "useReducer(reducer, initialArg, init?)"
      },
      {
        "language": "text",
        "code": "useReducer(reducer, initialArg, init?)"
      },
      {
        "language": "text",
        "code": "import { useReducer } from 'react';function reducer(state, action) {  // ...}function MyComponent() {  const [state, dispatch] = useReducer(reducer, { age: 42 });  // ..."
      },
      {
        "language": "text",
        "code": "import { useReducer } from 'react';function reducer(state, action) {  // ...}function MyComponent() {  const [state, dispatch] = useReducer(reducer, { age: 42 });  // ..."
      },
      {
        "language": "text",
        "code": "init(initialArg)"
      },
      {
        "language": "text",
        "code": "init(initialArg)"
      },
      {
        "language": "text",
        "code": "const [state, dispatch] = useReducer(reducer, { age: 42 });function handleClick() {  dispatch({ type: 'incremented_age' });  // ..."
      },
      {
        "language": "text",
        "code": "const [state, dispatch] = useReducer(reducer, { age: 42 });function handleClick() {  dispatch({ type: 'incremented_age' });  // ..."
      },
      {
        "language": "text",
        "code": "import { useReducer } from 'react';function reducer(state, action) {  // ...}function MyComponent() {  const [state, dispatch] = useReducer(reducer, { age: 42 });  // ..."
      },
      {
        "language": "text",
        "code": "import { useReducer } from 'react';function reducer(state, action) {  // ...}function MyComponent() {  const [state, dispatch] = useReducer(reducer, { age: 42 });  // ..."
      },
      {
        "language": "text",
        "code": "function handleClick() {  dispatch({ type: 'incremented_age' });}"
      },
      {
        "language": "text",
        "code": "function handleClick() {  dispatch({ type: 'incremented_age' });}"
      },
      {
        "language": "text",
        "code": "import { useReducer } from 'react';\n\nfunction reducer(state, action) {\n  if (action.type === 'incremented_age') {\n    return {\n      age: state.age + 1\n    };\n  }\n  throw Error('Unknown action.');\n}\n\nexport default function Counter() {\n  const [state, dispatch] = useReducer(reducer, { age: 42 });\n\n  return (\n    <>\n      <button onClick={() => {\n        dispatch({ type: 'incremented_age' })\n      }}>\n        Increment age\n      </button>\n      <p>Hello! You are {state.age}.</p>\n    </>\n  );\n}"
      },
      {
        "language": "text",
        "code": "function reducer(state, action) {  // ...}"
      },
      {
        "language": "text",
        "code": "function reducer(state, action) {  // ...}"
      },
      {
        "language": "text",
        "code": "function reducer(state, action) {  switch (action.type) {    case 'incremented_age': {      return {        name: state.name,        age: state.age + 1      };    }    case 'changed_name': {      return {        name: action.nextName,        age: state.age      };    }  }  throw Error('Unknown action: ' + action.type);}"
      },
      {
        "language": "text",
        "code": "function reducer(state, action) {  switch (action.type) {    case 'incremented_age': {      return {        name: state.name,        age: state.age + 1      };    }    case 'changed_name': {      return {        name: action.nextName,        age: state.age      };    }  }  throw Error('Unknown action: ' + action.type);}"
      },
      {
        "language": "text",
        "code": "function Form() {  const [state, dispatch] = useReducer(reducer, { name: 'Taylor', age: 42 });    function handleButtonClick() {    dispatch({ type: 'incremented_age' });  }  function handleInputChange(e) {    dispatch({      type: 'changed_name',      nextName: e.target.value    });  }  // ..."
      },
      {
        "language": "text",
        "code": "function Form() {  const [state, dispatch] = useReducer(reducer, { name: 'Taylor', age: 42 });    function handleButtonClick() {    dispatch({ type: 'incremented_age' });  }  function handleInputChange(e) {    dispatch({      type: 'changed_name',      nextName: e.target.value    });  }  // ..."
      },
      {
        "language": "text",
        "code": "function reducer(state, action) {  switch (action.type) {    case 'incremented_age': {      // 🚩 Don't mutate an object in state like this:      state.age = state.age + 1;      return state;    }"
      },
      {
        "language": "text",
        "code": "function reducer(state, action) {  switch (action.type) {    case 'incremented_age': {      // 🚩 Don't mutate an object in state like this:      state.age = state.age + 1;      return state;    }"
      },
      {
        "language": "text",
        "code": "function reducer(state, action) {  switch (action.type) {    case 'incremented_age': {      // ✅ Instead, return a new object      return {        ...state,        age: state.age + 1      };    }"
      },
      {
        "language": "text",
        "code": "function reducer(state, action) {  switch (action.type) {    case 'incremented_age': {      // ✅ Instead, return a new object      return {        ...state,        age: state.age + 1      };    }"
      },
      {
        "language": "text",
        "code": "import { useReducer } from 'react';\n\nfunction reducer(state, action) {\n  switch (action.type) {\n    case 'incremented_age': {\n      return {\n        name: state.name,\n        age: state.age + 1\n      };\n    }\n    case 'changed_name': {\n      return {\n        name: action.nextName,\n        age: state.age\n      };\n    }\n  }\n  throw Error('Unknown action: ' + action.type);\n}\n\nconst initialState = { name: 'Taylor', age: 42 };\n\nexport default function Form() {\n  const [state, dispatch] = useReducer(reducer, initialState);\n\n  function handleButtonClick() {\n    dispatch({ type: 'incremented_age' });\n  }\n\n  function handleInputChange(e) {\n    dispatch({\n      type: 'changed_name',\n      nextName: e.target.value\n    }); \n  }\n\n  return (\n    <>\n      <input\n        value={state.name}\n        onChange={handleInputChange}\n      />\n      <button onClick={handleButtonClick}>\n        Increment age\n      </button>\n      <p>Hello, {state.name}. You are {state.age}.</p>\n    </>\n  );\n}"
      },
      {
        "language": "text",
        "code": "function createInitialState(username) {  // ...}function TodoList({ username }) {  const [state, dispatch] = useReducer(reducer, createInitialState(username));  // ..."
      },
      {
        "language": "text",
        "code": "function createInitialState(username) {  // ...}function TodoList({ username }) {  const [state, dispatch] = useReducer(reducer, createInitialState(username));  // ..."
      },
      {
        "language": "text",
        "code": "createInitialState(username)"
      },
      {
        "language": "text",
        "code": "function createInitialState(username) {  // ...}function TodoList({ username }) {  const [state, dispatch] = useReducer(reducer, username, createInitialState);  // ..."
      },
      {
        "language": "text",
        "code": "function createInitialState(username) {  // ...}function TodoList({ username }) {  const [state, dispatch] = useReducer(reducer, username, createInitialState);  // ..."
      },
      {
        "language": "text",
        "code": "createInitialState"
      },
      {
        "language": "text",
        "code": "createInitialState()"
      },
      {
        "language": "text",
        "code": "createInitialState"
      },
      {
        "language": "text",
        "code": "createInitialState"
      },
      {
        "language": "text",
        "code": "import { useReducer } from 'react';\n\nfunction createInitialState(username) {\n  const initialTodos = [];\n  for (let i = 0; i < 50; i++) {\n    initialTodos.push({\n      id: i,\n      text: username + \"'s task #\" + (i + 1)\n    });\n  }\n  return {\n    draft: '',\n    todos: initialTodos,\n  };\n}\n\nfunction reducer(state, action) {\n  switch (action.type) {\n    case 'changed_draft': {\n      return {\n        draft: action.nextDraft,\n        todos: state.todos,\n      };\n    };\n    case 'added_todo': {\n      return {\n        draft: '',\n        todos: [{\n          id: state.todos.length,\n          text: state.draft\n        }, ...state.todos]\n      }\n    }\n  }\n  throw Error('Unknown action: ' + action.type);\n}\n\nexport default function TodoList({ username }) {\n  const [state, dispatch] = useReducer(\n    reducer,\n    username,\n    createInitialState\n  );\n  return (\n    <>\n      <input\n        value={state.draft}\n        onChange={e => {\n          dispatch({\n            type: 'changed_draft',\n            nextDraft: e.target.value\n          })\n        }}\n      />\n      <button onClick={() => {\n        dispatch({ type: 'added_todo' });\n      }}>Add</button>\n      <ul>\n        {state.todos.map(item => (\n          <li key={item.id}>\n            {item.text}\n          </li>\n        ))}\n      </ul>\n    </>\n  );\n}"
      },
      {
        "language": "text",
        "code": "function handleClick() {  console.log(state.age);  // 42  dispatch({ type: 'incremented_age' }); // Request a re-render with 43  console.log(state.age);  // Still 42!  setTimeout(() => {    console.log(state.age); // Also 42!  }, 5000);}"
      },
      {
        "language": "text",
        "code": "function handleClick() {  console.log(state.age);  // 42  dispatch({ type: 'incremented_age' }); // Request a re-render with 43  console.log(state.age);  // Still 42!  setTimeout(() => {    console.log(state.age); // Also 42!  }, 5000);}"
      },
      {
        "language": "text",
        "code": "const action = { type: 'incremented_age' };dispatch(action);const nextState = reducer(state, action);console.log(state);     // { age: 42 }console.log(nextState); // { age: 43 }"
      },
      {
        "language": "text",
        "code": "const action = { type: 'incremented_age' };dispatch(action);const nextState = reducer(state, action);console.log(state);     // { age: 42 }console.log(nextState); // { age: 43 }"
      },
      {
        "language": "text",
        "code": "function reducer(state, action) {  switch (action.type) {    case 'incremented_age': {      // 🚩 Wrong: mutating existing object      state.age++;      return state;    }    case 'changed_name': {      // 🚩 Wrong: mutating existing object      state.name = action.nextName;      return state;    }    // ...  }}"
      },
      {
        "language": "text",
        "code": "function reducer(state, action) {  switch (action.type) {    case 'incremented_age': {      // 🚩 Wrong: mutating existing object      state.age++;      return state;    }    case 'changed_name': {      // 🚩 Wrong: mutating existing object      state.name = action.nextName;      return state;    }    // ...  }}"
      },
      {
        "language": "text",
        "code": "function reducer(state, action) {  switch (action.type) {    case 'incremented_age': {      // ✅ Correct: creating a new object      return {        ...state,        age: state.age + 1      };    }    case 'changed_name': {      // ✅ Correct: creating a new object      return {        ...state,        name: action.nextName      };    }    // ...  }}"
      },
      {
        "language": "text",
        "code": "function reducer(state, action) {  switch (action.type) {    case 'incremented_age': {      // ✅ Correct: creating a new object      return {        ...state,        age: state.age + 1      };    }    case 'changed_name': {      // ✅ Correct: creating a new object      return {        ...state,        name: action.nextName      };    }    // ...  }}"
      },
      {
        "language": "text",
        "code": "function reducer(state, action) {  switch (action.type) {    case 'incremented_age': {      return {        ...state, // Don't forget this!        age: state.age + 1      };    }    // ..."
      },
      {
        "language": "text",
        "code": "function reducer(state, action) {  switch (action.type) {    case 'incremented_age': {      return {        ...state, // Don't forget this!        age: state.age + 1      };    }    // ..."
      },
      {
        "language": "text",
        "code": "function reducer(state, action) {  switch (action.type) {    case 'incremented_age': {      // ...    }    case 'edited_name': {      // ...    }  }  throw Error('Unknown action: ' + action.type);}"
      },
      {
        "language": "text",
        "code": "function reducer(state, action) {  switch (action.type) {    case 'incremented_age': {      // ...    }    case 'edited_name': {      // ...    }  }  throw Error('Unknown action: ' + action.type);}"
      },
      {
        "language": "text",
        "code": "Too many re-renders. React limits the number of renders to prevent an infinite loop."
      },
      {
        "language": "text",
        "code": "// 🚩 Wrong: calls the handler during renderreturn <button onClick={handleClick()}>Click me</button>// ✅ Correct: passes down the event handlerreturn <button onClick={handleClick}>Click me</button>// ✅ Correct: passes down an inline functionreturn <button onClick={(e) => handleClick(e)}>Click me</button>"
      },
      {
        "language": "text",
        "code": "// 🚩 Wrong: calls the handler during renderreturn <button onClick={handleClick()}>Click me</button>// ✅ Correct: passes down the event handlerreturn <button onClick={handleClick}>Click me</button>// ✅ Correct: passes down an inline functionreturn <button onClick={(e) => handleClick(e)}>Click me</button>"
      },
      {
        "language": "text",
        "code": "function reducer(state, action) {  switch (action.type) {    case 'added_todo': {      // 🚩 Mistake: mutating state      state.todos.push({ id: nextId++, text: action.text });      return state;    }    // ...  }}"
      },
      {
        "language": "text",
        "code": "function reducer(state, action) {  switch (action.type) {    case 'added_todo': {      // 🚩 Mistake: mutating state      state.todos.push({ id: nextId++, text: action.text });      return state;    }    // ...  }}"
      },
      {
        "language": "text",
        "code": "function reducer(state, action) {  switch (action.type) {    case 'added_todo': {      // ✅ Correct: replacing with new state      return {        ...state,        todos: [          ...state.todos,          { id: nextId++, text: action.text }        ]      };    }    // ...  }}"
      },
      {
        "language": "text",
        "code": "function reducer(state, action) {  switch (action.type) {    case 'added_todo': {      // ✅ Correct: replacing with new state      return {        ...state,        todos: [          ...state.todos,          { id: nextId++, text: action.text }        ]      };    }    // ...  }}"
      }
    ],
    "links": [
      {
        "text": "API Reference",
        "href": "/reference/react"
      },
      {
        "text": "Hooks",
        "href": "/reference/react/hooks"
      },
      {
        "text": "reducer",
        "href": "/learn/extracting-state-logic-into-a-reducer"
      },
      {
        "text": "reducer.",
        "href": "/learn/extracting-state-logic-into-a-reducer"
      },
      {
        "text": "Learn more about removing Effect dependencies.",
        "href": "/learn/removing-effect-dependencies#move-dynamic-objects-and-functions-inside-your-effect"
      },
      {
        "text": "Object.is",
        "href": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/is"
      },
      {
        "text": "batches state updates.",
        "href": "/learn/queueing-a-series-of-state-updates"
      },
      {
        "text": "flushSync.",
        "href": "/reference/react-dom/flushSync"
      },
      {
        "text": "reducer.",
        "href": "/learn/extracting-state-logic-into-a-reducer"
      },
      {
        "text": "useState",
        "href": "/reference/react/useState"
      },
      {
        "text": "choosing between useState and useReducer.",
        "href": "/learn/extracting-state-logic-into-a-reducer#comparing-usestate-and-usereducer"
      },
      {
        "text": "switch statement.",
        "href": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Statements/switch"
      },
      {
        "text": "Each action describes a single interaction, even if that leads to multiple changes in data.",
        "href": "/learn/extracting-state-logic-into-a-reducer#writing-reducers-well"
      },
      {
        "text": "extracting state logic into a reducer",
        "href": "/learn/extracting-state-logic-into-a-reducer"
      },
      {
        "text": "updating objects in state",
        "href": "/learn/updating-objects-in-state"
      },
      {
        "text": "updating arrays in state",
        "href": "/learn/updating-arrays-in-state"
      },
      {
        "text": "states behaves like a snapshot.",
        "href": "/learn/state-as-a-snapshot"
      },
      {
        "text": "Object.is",
        "href": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/is"
      },
      {
        "text": "updating objects in state",
        "href": "/learn/updating-objects-in-state"
      },
      {
        "text": "updating arrays in state",
        "href": "/learn/updating-arrays-in-state"
      },
      {
        "text": "Strict Mode",
        "href": "/reference/react/StrictMode"
      },
      {
        "text": "keep components pure.",
        "href": "/learn/keeping-components-pure"
      },
      {
        "text": "replacing the array instead of mutating it",
        "href": "/learn/updating-arrays-in-state#adding-to-an-array"
      },
      {
        "text": "keeping components pure",
        "href": "/learn/keeping-components-pure"
      },
      {
        "text": "PrevioususeOptimistic",
        "href": "/reference/react/useOptimistic"
      },
      {
        "text": "NextuseRef",
        "href": "/reference/react/useRef"
      }
    ],
    "meta": {
      "description": "",
      "keywords": ""
    },
    "summary": "API ReferenceHooksuseReduceruseReducer is a React Hook that lets you add a reducer to your component. const [state, dispatch] = useReducer(reducer, initialArg, init",
    "tags": [
      "react",
      "angular",
      "javascript",
      "typescript",
      "html",
      "vite",
      "reducer",
      "state",
      "usereducer",
      "function"
    ],
    "id": "usereducer-react-useReducer-part-1",
    "quality": 100
  },
  {
    "title": "useMemo – React",
    "url": "https://react.dev/reference/react/useMemo",
    "category": "react",
    "content": "API ReferenceHooksuseMemouseMemo is a React Hook that lets you cache the result of a calculation between re-renders.const cachedValue = useMemo(calculateValue, dependencies) NoteReact Compiler automatically memoizes values and functions, reducing the need for manual useMemo calls. You can use the compiler to handle memoization automatically. Reference useMemo(calculateValue, dependencies) Usage Skipping expensive recalculations Skipping re-rendering of components Preventing an Effect from firing too often Memoizing a dependency of another Hook Memoizing a function Troubleshooting My calculation runs twice on every re-render My useMemo call is supposed to return an object, but returns undefined Every time my component renders, the calculation in useMemo re-runs I need to call useMemo for each list item in a loop, but its not allowed Reference useMemo(calculateValue, dependencies) Call useMemo at the top level of your component to cache a calculation between re-renders: import { useMemo } from 'react';function TodoList({ todos, tab }) { const visibleTodos = useMemo( () = filterTodos(todos, tab), [todos, tab] ); // ...} See more examples below. Parameters calculateValue: The function calculating the value that you want to cache. It should be pure, should take no arguments, and should return a value of any type. React will call your function during the initial render. On next renders, React will return the same value again if the dependencies have not changed since the last render. Otherwise, it will call calculateValue, return its result, and store it so it can be reused later. dependencies: The list of all reactive values referenced inside of the calculateValue code. Reactive values include props, state, and all the variables and functions declared directly inside your component body. If your linter is configured for React, it will verify that every reactive value is correctly specified as a dependency. The list of dependencies must have a constant number of items and be written inline like [dep1, dep2, dep3]. React will compare each dependency with its previous value using the Object.is comparison. Returns On the initial render, useMemo returns the result of calling calculateValue with no arguments. During next renders, it will either return an already stored value from the last render (if the dependencies havent changed), or call calculateValue again, and return the result that calculateValue has returned. Caveats useMemo is a Hook, so you can only call it at the top level of your component or your own Hooks. You cant call it inside loops or conditions. If you need that, extract a new component and move the state into it. In Strict Mode, React will call your calculation function twice in order to help you find accidental impurities. This is development-only behavior and does not affect production. If your calculation function is pure (as it should be), this should not affect your logic. The result from one of the calls will be ignored. React will not throw away the cached value unless there is a specific reason to do that. For example, in development, React throws away the cache when you edit the file of your component. Both in development and in production, React will throw away the cache if your component suspends during the initial mount. In the future, React may add more features that take advantage of throwing away the cachefor example, if React adds built-in support for virtualized lists in the future, it would make sense to throw away the cache for items that scroll out of the virtualized table viewport. This should be fine if you rely on useMemo solely as a performance optimization. Otherwise, a state variable or a ref may be more appropriate. NoteCaching return values like this is also known as memoization, which is why this Hook is called useMemo. Usage Skipping expensive recalculations To cache a calculation between re-renders, wrap it in a useMemo call at the top level of your component: import { useMemo } from 'react';function TodoList({ todos, tab, theme }) { const visibleTodos = useMemo(() = filterTodos(todos, tab), [todos, tab]); // ...} You need to pass two things to useMemo: A calculation function that takes no arguments, like () =, and returns what you wanted to calculate. A list of dependencies including every value within your component thats used inside your calculation. On the initial render, the value youll get from useMemo will be the result of calling your calculation. On every subsequent render, React will compare the dependencies with the dependencies you passed during the last render. If none of the dependencies have changed (compared with Object.is), useMemo will return the value you already calculated before. Otherwise, React will re-run your calculation and return the new value. In other words, useMemo caches a calculation result between re-renders until its dependencies change. Lets walk through an example to see when this is useful. By default, React will re-run the entire body of your component every time that it re-renders. For example, if this TodoList updates its state or receives new props from its parent, the filterTodos function will re-run: function TodoList({ todos, tab, theme }) { const visibleTodos = filterTodos(todos, tab); // ...} Usually, this isnt a problem because most calculations are very fast. However, if youre filtering or transforming a large array, or doing some expensive computation, you might want to skip doing it again if data hasnt changed. If both todos and tab are the same as they were during the last render, wrapping the calculation in useMemo like earlier lets you reuse visibleTodos youve already calculated before. This type of caching is called memoization. NoteYou should only rely on useMemo as a performance optimization. If your code doesnt work without it, find the underlying problem and fix it first. Then you may add useMemo to improve performance. Deep DiveHow to tell if a calculation is expensive? Show DetailsIn general, unless youre creating or looping over thousands of objects, its probably not expensive. If you want to get more confidence, you can add a console log to measure the time spent in a piece of code:console.time('filter array');const visibleTodos = filterTodos(todos, tab);console.timeEnd('filter array');Perform the interaction youre measuring (for example, typing into the input). You will then see logs like filter array: 0.15ms in your console. If the overall logged time adds up to a significant amount (say, 1ms or more), it might make sense to memoize that calculation. As an experiment, you can then wrap the calculation in useMemo to verify whether the total logged time has decreased for that interaction or not:console.time('filter array');const visibleTodos = useMemo(() = { return filterTodos(todos, tab); // Skipped if todos and tab haven't changed}, [todos, tab]);console.timeEnd('filter array');useMemo wont make the first render faster. It only helps you skip unnecessary work on updates.Keep in mind that your machine is probably faster than your users so its a good idea to test the performance with an artificial slowdown. For example, Chrome offers a CPU Throttling option for this.Also note that measuring performance in development will not give you the most accurate results. (For example, when Strict Mode is on, you will see each component render twice rather than once.) To get the most accurate timings, build your app for production and test it on a device like your users have. Deep DiveShould you add useMemo everywhere? Show DetailsIf your app is like this site, and most interactions are coarse (like replacing a page or an entire section), memoization is usually unnecessary. On the other hand, if your app is more like a drawing editor, and most interactions are granular (like moving shapes), then you might find memoization very helpful.Optimizing with useMemo is only valuable in a few cases: The calculation youre putting in useMemo is noticeably slow, and its dependencies rarely change. You pass it as a prop to a component wrapped in memo. You want to skip re-rendering if the value hasnt changed. Memoization lets your component re-render only when dependencies arent the same. The value youre passing is later used as a dependency of some Hook. For example, maybe another useMemo calculation value depends on it. Or maybe you are depending on this value from useEffect. There is no benefit to wrapping a calculation in useMemo in other cases. There is no significant harm to doing that either, so some teams choose to not think about individual cases, and memoize as much as possible. The downside of this approach is that code becomes less readable. Also, not all memoization is effective: a single value thats always new is enough to break memoization for an entire component.In practice, you can make a lot of memoization unnecessary by following a few principles: When a component visually wraps other components, let it accept JSX as children. This way, when the wrapper component updates its own state, React knows that its children dont need to re-render. Prefer local state and dont lift state up any further than necessary. For example, dont keep transient state like forms and whether an item is hovered at the top of your tree or in a global state library. Keep your rendering logic pure. If re-rendering a component causes a problem or produces some noticeable visual artifact, its a bug in your component! Fix the bug instead of adding memoization. Avoid unnecessary Effects that update state. Most performance problems in React apps are caused by chains of updates originating from Effects that cause your components to render over and over. Try to remove unnecessary dependencies from your Effects. For example, instead of memoization, its often simpler to move some object or a function inside an Effect or outside the component. If a specific interaction still feels laggy, use the React Developer Tools profiler to see which components would benefit the most from memoization, and add memoization where needed. These principles make your components easier to debug and understand, so its good to follow them in any case. In the long term, were researching doing granular memoization automatically to solve this once and for all. The difference between useMemo and calculating a value directly1. Skipping recalculation with useMemo 2. Always recalculating a value Example 1 of 2: Skipping recalculation with useMemo In this example, the filterTodos implementation is artificially slowed down so that you can see what happens when some JavaScript function youre calling during rendering is genuinely slow. Try switching the tabs and toggling the theme.Switching the tabs feels slow because it forces the slowed down filterTodos to re-execute. Thats expected because the tab has changed, and so the entire calculation needs to re-run. (If youre curious why it runs twice, its explained here.)Toggle the theme. Thanks to useMemo, its fast despite the artificial slowdown! The slow filterTodos call was skipped because both todos and tab (which you pass as dependencies to useMemo) havent changed since the last render.App.jsTodoList.jsutils.jsTodoList.js ResetForkimport { useMemo } from 'react'; import { filterTodos } from './utils.js' export default function TodoList({ todos, theme, tab }) { const visibleTodos = useMemo( () = filterTodos(todos, tab), [todos, tab] ); return ( div className={theme} pbNote: codefilterTodos/code is artificially slowed down!/b/p ul {visibleTodos.map(todo = ( li key={todo.id} {todo.completed ? s{todo.text}/s : todo.text } /li ))} /ul /div ); } Show moreNext Example Skipping re-rendering of components In some cases, useMemo can also help you optimize performance of re-rendering child components. To illustrate this, lets say this TodoList component passes the visibleTodos as a prop to the child List component: export default function TodoList({ todos, tab, theme }) { // ... return ( div className={theme} List items={visibleTodos} / /div );} Youve noticed that toggling the theme prop freezes the app for a moment, but if you remove List / from your JSX, it feels fast. This tells you that its worth trying to optimize the List component. By default, when a component re-renders, React re-renders all of its children recursively. This is why, when TodoList re-renders with a different theme, the List component also re-renders. This is fine for components that dont require much calculation to re-render. But if youve verified that a re-render is slow, you can tell List to skip re-rendering when its props are the same as on last render by wrapping it in memo: import { memo } from 'react';const List = memo(function List({ items }) { // ...}); With this change, List will skip re-rendering if all of its props are the same as on the last render. This is where caching the calculation becomes important! Imagine that you calculated visibleTodos without useMemo: export default function TodoList({ todos, tab, theme }) { // Every time the theme changes, this will be a different array... const visibleTodos = filterTodos(todos, tab); return ( div className={theme} {/* ... so List's props will never be the same, and it will re-render every time */} List items={visibleTodos} / /div );} In the above example, the filterTodos function always creates a different array, similar to how the {} object literal always creates a new object. Normally, this wouldnt be a problem, but it means that List props will never be the same, and your memo optimization wont work. This is where useMemo comes in handy: export default function TodoList({ todos, tab, theme }) { // Tell React to cache your calculation between re-renders... const visibleTodos = useMemo( () = filterTodos(todos, tab), [todos, tab] // ...so as long as these dependencies don't change... ); return ( div className={theme} {/* ...List will receive the same props and can skip re-rendering */} List items={visibleTodos} / /div );} By wrapping the visibleTodos calculation in useMemo, you ensure that it has the same value between the re-renders (until dependencies change). You dont have to wrap a calculation in useMemo unless you do it for some specific reason. In this example, the reason is that you pass it to a component wrapped in memo, and this lets it skip re-rendering. There are a few other reasons to add useMemo which are described further on this page. Deep DiveMemoizing individual JSX nodes Show DetailsInstead of wrapping List in memo, you could wrap the List / JSX node itself in useMemo:export default function TodoList({ todos, tab, theme }) { const visibleTodos = useMemo(() = filterTodos(todos, tab), [todos, tab]); const children = useMemo(() = List items={visibleTodos} /, [visibleTodos]); return ( div className={theme} {children} /div );}The behavior would be the same. If the visibleTodos havent changed, List wont be re-rendered.A JSX node like List items={visibleTodos} / is an object like { type: List, props: { items: visibleTodos } }. Creating this object is very cheap, but React doesnt know whether its contents is the same as last time or not. This is why by default, React will re-render the List component.However, if React sees the same exact JSX as during the previous render, it wont try to re-render your component. This is because JSX nodes are immutable. A JSX node object could not have changed over time, so React knows its safe to skip a re-render. However, for this to work, the node has to actually be the same object, not merely look the same in code. This is what useMemo does in this example.Manually wrapping JSX nodes into useMemo is not convenient. For example, you cant do this conditionally. This is usually why you would wrap components with memo instead of wrapping JSX nodes. The difference between skipping re-renders and always re-rendering1. Skipping re-rendering with useMemo and memo 2. Always re-rendering a component Example 1 of 2: Skipping re-rendering with useMemo and memo In this example, the List component is artificially slowed down so that you can see what happens when a React component youre rendering is genuinely slow. Try switching the tabs and toggling the theme.Switching the tabs feels slow because it forces the slowed down List to re-render. Thats expected because the tab has changed, and so you need to reflect the users new choice on the screen.Next, try toggling the theme. Thanks to useMemo together with memo, its fast despite the artificial slowdown! The List skipped re-rendering because the visibleTodos array has not changed since the last render. The visibleTodos array has not changed because both todos and tab (which you pass as dependencies to useMemo) havent changed since the last render.App.jsTodoList.jsList.jsutils.jsTodoList.js ResetForkimport { useMemo } from 'react'; import List from './List.js'; import { filterTodos } from './utils.js' export default function TodoList({ todos, theme, tab }) { const visibleTodos = useMemo( () = filterTodos(todos, tab), [todos, tab] ); return ( div className={theme} pbNote: codeList/code is artificially slowed down!/b/p List items={visibleTodos} / /div ); } Show moreNext Example Preventing an Effect from firing too often Sometimes, you might want to use a value inside an Effect: function ChatRoom({ roomId }) { const [message, setMessage] = useState(''); const options = { serverUrl: 'https://localhost:1234', roomId: roomId } useEffect(() = { const connection = createConnection(options); connection.connect(); // ... This creates a problem. Every reactive value must be declared as a dependency of your Effect. However, if you declare options as a dependency, it will cause your Effect to constantly reconnect to the chat room: useEffect(() = { const connection = createConnection(options); connection.connect(); return () = connection.disconnect(); }, [options]); //  Problem: This dependency changes on every render // ... To solve this, you can wrap the object you need to call from an Effect in useMemo: function ChatRoom({ roomId }) { const [message, setMessage] = useState(''); const options = useMemo(() = { return { serverUrl: 'https://localhost:1234', roomId: roomId }; }, [roomId]); //  Only changes when roomId changes useEffect(() = { const connection = createConnection(options); connection.connect(); return () = connection.disconnect(); }, [options]); //  Only changes when options changes // ... This ensures that the options object is the same between re-renders if useMemo returns the cached object. However, since useMemo is performance optimization, not a semantic guarantee, React may throw away the cached value if there is a specific reason to do that. This will also cause the effect to re-fire, so its even better to remove the need for a function dependency by moving your object inside the Effect: function ChatRoom({ roomId }) { const [message, setMessage] = useState(''); useEffect(() = { const options = { //  No need for useMemo or object dependencies! serverUrl: 'https://localhost:1234', roomId: roomId } const connection = createConnection(options); connection.connect(); return () = connection.disconnect(); }, [roomId]); //  Only changes when roomId changes // ... Now your code is simpler and doesnt need useMemo. Learn more about removing Effect dependencies. Memoizing a dependency of another Hook Suppose you have a calculation that depends on an object created directly in the component body: function Dropdown({ allItems, text }) { const searchOptions = { matchMode: 'whole-word', text }; const visibleItems = useMemo(() = { return searchItems(allItems, searchOptions); }, [allItems, searchOptions]); //  Caution: Dependency on an object created in the component body // ... Depending on an object like this defeats the point of memoization. When a component re-renders, all of the code directly inside the component body runs again. The lines of code creating the searchOptions object will also run on every re-render. Since searchOptions is a dependency of your useMemo call, and its different every time, React knows the dependencies are different, and recalculate searchItems every time. To fix this, you could memoize the searchOptions object itself before passing it as a dependency: function Dropdown({ allItems, text }) { const searchOptions = useMemo(() = { return { matchMode: 'whole-word', text }; }, [text]); //  Only changes when text changes const visibleItems = useMemo(() = { return searchItems(allItems, searchOptions); }, [allItems, searchOptions]); //  Only changes when allItems or searchOptions changes // ... In the example above, if the text did not change, the searchOptions object also wont change. However, an even better fix is to move the searchOptions object declaration inside of the useMemo calculation function: function Dropdown({ allItems, text }) { const visibleItems = useMemo(() = { const searchOptions = { matchMode: 'whole-word', text }; return searchItems(allItems, searchOptions); }, [allItems, text]); //  Only changes when allItems or text changes // ... Now your calculation depends on text directly (which is a string and cant accidentally become different). Memoizing a function Suppose the Form component is wrapped in memo. You want to pass a function to it as a prop: export default function ProductPage({ productId, referrer }) { function handleSubmit(orderDetails) { post('/product/' + productId + '/buy', { referrer, orderDetails }); } return Form onSubmit={handleSubmit} /;} Just as {} creates a different object, function declarations like function() {} and expressions like () = {} produce a different function on every re-render. By itself, creating a new function is not a problem. This is not something to avoid! However, if the Form component is memoized, presumably you want to skip re-rendering it when no props have changed. A prop that is always different would defeat the point of memoization. To memoize a function with useMemo, your calculation function would have to return another function: export default function Page({ productId, referrer }) { const handleSubmit = useMemo(() = { return (orderDetails) = { post('/product/' + productId + '/buy', { referrer, orderDetails }); }; }, [productId, referrer]); return Form onSubmit={handleSubmit} /;} This looks clunky! Memoizing functions is common enough that React has a built-in Hook specifically for that. Wrap your functions into useCallback instead of useMemo to avoid having to write an extra nested function: export default function Page({ productId, referrer }) { const handleSubmit = useCallback((orderDetails) = { post('/product/' + productId + '/buy', { referrer, orderDetails }); }, [productId, referrer]); return Form onSubmit={handleSubmit} /;} The two examples above are completely equivalent. The only benefit to useCallback is that it lets you avoid writing an extra nested function inside. It doesnt do anything else. Read more about useCallback. Troubleshooting My calculation runs twice on every re-render In Strict Mode, React will call some of your functions twice instead of once: function TodoList({ todos, tab }) { // This component function will run twice for every render. const visibleTodos = useMemo(() = { // This calculation will run twice if any of the dependencies change. return filterTodos(todos, tab); }, [todos, tab]); // ... This is expected and shouldnt break your code. This development-only behavior helps you keep components pure. React uses the result of one of the calls, and ignores the result of the other call. As long as your component and calculation functions are pure, this shouldnt affect your logic. However, if they are accidentally impure, this helps you notice and fix the mistake. For example, this impure calculation function mutates an array you received as a prop: const visibleTodos = useMemo(() = { //  Mistake: mutating a prop todos.push({ id: 'last', text: 'Go for a walk!' }); const filtered = filterTodos(todos, tab); return filtered; }, [todos, tab]); React calls your function twice, so youd notice the todo is added twice. Your calculation shouldnt change any existing objects, but its okay to change any new objects you created during the calculation. For example, if the filterTodos function always returns a different array, you can mutate that array instead: const visibleTodos = useMemo(() = { const filtered = filterTodos(todos, tab); //  Correct: mutating an object you created during the calculation filtered.push({ id: 'last', text: 'Go for a walk!' }); return filtered; }, [todos, tab]); Read keeping components pure to learn more about purity. Also, check out the guides on updating objects and updating arrays without mutation. My useMemo call is supposed to return an object, but returns undefined This code doesnt work: //  You can't return an object from an arrow function with () = { const searchOptions = useMemo(() = { matchMode: 'whole-word', text: text }, [text]); In JavaScript, () = { starts the arrow function body, so the { brace is not a part of your object. This is why it doesnt return an object, and leads to mistakes. You could fix it by adding parentheses like ({ and }): // This works, but is easy for someone to break again const searchOptions = useMemo(() = ({ matchMode: 'whole-word', text: text }), [text]); However, this is still confusing and too easy for someone to break by removing the parentheses. To avoid this mistake, write a return statement explicitly: //  This works and is explicit const searchOptions = useMemo(() = { return { matchMode: 'whole-word', text: text }; }, [text]); Every time my component renders, the calculation in useMemo re-runs Make sure youve specified the dependency array as a second argument! If you forget the dependency array, useMemo will re-run the calculation every time: function TodoList({ todos, tab }) { //  Recalculates every time: no dependency array const visibleTodos = useMemo(() = filterTodos(todos, tab)); // ... This is the corrected version passing the dependency array as a second argument: function TodoList({ todos, tab }) { //  Does not recalculate unnecessarily const visibleTodos = useMemo(() = filterTodos(todos, tab), [todos, tab]); // ... If this doesnt help, then the problem is that at least one of your dependencies is different from the previous render. You can debug this problem by manually logging your dependencies to the console: const visibleTodos = useMemo(() = filterTodos(todos, tab), [todos, tab]); console.log([todos, tab]); You can then right-click on the arrays from different re-renders in the console and select Store as a global variable for both of them. Assuming the first one got saved as temp1 and the second one got saved as temp2, you can then use the browser console to check whether each dependency in both arrays is the same: Object.is(temp1[0], temp2[0]); // Is the first dependency the same between the arrays?Object.is(temp1[1], temp2[1]); // Is the second dependency the same between the arrays?Object.is(temp1[2], temp2[2]); // ... and so on for every dependency ... When you find which dependency breaks memoization, either find a way to remove it, or memoize it as well. I need to call useMemo for each list item in a loop, but its not allowed Suppose the Chart component is wrapped in memo. You want to skip re-rendering every Chart in the list when the ReportList component re-renders. However, you cant call useMemo in a loop: function ReportList({ items }) { return ( article {items.map(item = { //  You can't call useMemo in a loop like this: const data = useMemo(() = calculateReport(item), [item]); return ( figure key={item.id} Chart data={data} / /figure ); })} /article );} Instead, extract a component for each item and memoize data for individual items: function ReportList({ items }) { return ( article {items.map(item = Report key={item.id} item={item} / )} /article );}function Report({ item }) { //  Call useMemo at the top level: const data = useMemo(() = calculateReport(item), [item]); return ( figure Chart data={data} / /figure );} Alternatively, you could remove useMemo and instead wrap Report itself in memo. If the item prop does not change, Report will skip re-rendering, so Chart will skip re-rendering too: function ReportList({ items }) { // ...}const Report = memo(function Report({ item }) { const data = calculateReport(item); return ( figure Chart data={data} / /figure );});PrevioususeLayoutEffectNextuseOptimistic",
    "headings": [
      {
        "level": 1,
        "text": "useMemo",
        "id": ""
      },
      {
        "level": 2,
        "text": "Reference",
        "id": "reference"
      },
      {
        "level": 2,
        "text": "Usage",
        "id": "usage"
      },
      {
        "level": 2,
        "text": "Troubleshooting",
        "id": "troubleshooting"
      },
      {
        "level": 3,
        "text": "Note",
        "id": ""
      },
      {
        "level": 3,
        "text": "useMemo(calculateValue, dependencies)",
        "id": "usememo"
      },
      {
        "level": 3,
        "text": "Note",
        "id": ""
      },
      {
        "level": 3,
        "text": "Skipping expensive recalculations",
        "id": "skipping-expensive-recalculations"
      },
      {
        "level": 3,
        "text": "Note",
        "id": ""
      },
      {
        "level": 3,
        "text": "Skipping re-rendering of components",
        "id": "skipping-re-rendering-of-components"
      },
      {
        "level": 3,
        "text": "Preventing an Effect from firing too often",
        "id": "preventing-an-effect-from-firing-too-often"
      },
      {
        "level": 3,
        "text": "Memoizing a dependency of another Hook",
        "id": "memoizing-a-dependency-of-another-hook"
      },
      {
        "level": 3,
        "text": "Memoizing a function",
        "id": "memoizing-a-function"
      },
      {
        "level": 3,
        "text": "My calculation runs twice on every re-render",
        "id": "my-calculation-runs-twice-on-every-re-render"
      },
      {
        "level": 3,
        "text": "My useMemo call is supposed to return an object, but returns undefined",
        "id": "my-usememo-call-is-supposed-to-return-an-object-but-returns-undefined"
      },
      {
        "level": 3,
        "text": "Every time my component renders, the calculation in useMemo re-runs",
        "id": "every-time-my-component-renders-the-calculation-in-usememo-re-runs"
      },
      {
        "level": 3,
        "text": "I need to call useMemo for each list item in a loop, but it’s not allowed",
        "id": "i-need-to-call-usememo-for-each-list-item-in-a-loop-but-its-not-allowed"
      },
      {
        "level": 4,
        "text": "Parameters",
        "id": "parameters"
      },
      {
        "level": 4,
        "text": "Returns",
        "id": "returns"
      },
      {
        "level": 4,
        "text": "Caveats",
        "id": "caveats"
      },
      {
        "level": 4,
        "text": "How to tell if a calculation is expensive?",
        "id": "how-to-tell-if-a-calculation-is-expensive"
      },
      {
        "level": 4,
        "text": "Should you add useMemo everywhere?",
        "id": "should-you-add-usememo-everywhere"
      },
      {
        "level": 4,
        "text": "The difference between useMemo and calculating a value directly",
        "id": "examples-recalculation"
      },
      {
        "level": 4,
        "text": "Example 1 of 2: Skipping recalculation with useMemo",
        "id": "skipping-recalculation-with-usememo"
      },
      {
        "level": 4,
        "text": "Memoizing individual JSX nodes",
        "id": "memoizing-individual-jsx-nodes"
      },
      {
        "level": 4,
        "text": "The difference between skipping re-renders and always re-rendering",
        "id": "examples-rerendering"
      },
      {
        "level": 4,
        "text": "Example 1 of 2: Skipping re-rendering with useMemo and memo",
        "id": "skipping-re-rendering-with-usememo-and-memo"
      },
      {
        "level": 5,
        "text": "Deep Dive",
        "id": ""
      },
      {
        "level": 5,
        "text": "Deep Dive",
        "id": ""
      },
      {
        "level": 5,
        "text": "Deep Dive",
        "id": ""
      }
    ],
    "codeBlocks": [
      {
        "language": "text",
        "code": "const cachedValue = useMemo(calculateValue, dependencies)"
      },
      {
        "language": "text",
        "code": "const cachedValue = useMemo(calculateValue, dependencies)"
      },
      {
        "language": "text",
        "code": "useMemo(calculateValue, dependencies)"
      },
      {
        "language": "text",
        "code": "useMemo(calculateValue, dependencies)"
      },
      {
        "language": "text",
        "code": "import { useMemo } from 'react';function TodoList({ todos, tab }) {  const visibleTodos = useMemo(    () => filterTodos(todos, tab),    [todos, tab]  );  // ...}"
      },
      {
        "language": "text",
        "code": "import { useMemo } from 'react';function TodoList({ todos, tab }) {  const visibleTodos = useMemo(    () => filterTodos(todos, tab),    [todos, tab]  );  // ...}"
      },
      {
        "language": "text",
        "code": "calculateValue"
      },
      {
        "language": "text",
        "code": "dependencies"
      },
      {
        "language": "text",
        "code": "calculateValue"
      },
      {
        "language": "text",
        "code": "dependencies"
      },
      {
        "language": "text",
        "code": "calculateValue"
      },
      {
        "language": "text",
        "code": "[dep1, dep2, dep3]"
      },
      {
        "language": "text",
        "code": "calculateValue"
      },
      {
        "language": "text",
        "code": "calculateValue"
      },
      {
        "language": "text",
        "code": "calculateValue"
      },
      {
        "language": "text",
        "code": "import { useMemo } from 'react';function TodoList({ todos, tab, theme }) {  const visibleTodos = useMemo(() => filterTodos(todos, tab), [todos, tab]);  // ...}"
      },
      {
        "language": "text",
        "code": "import { useMemo } from 'react';function TodoList({ todos, tab, theme }) {  const visibleTodos = useMemo(() => filterTodos(todos, tab), [todos, tab]);  // ...}"
      },
      {
        "language": "text",
        "code": "filterTodos"
      },
      {
        "language": "text",
        "code": "function TodoList({ todos, tab, theme }) {  const visibleTodos = filterTodos(todos, tab);  // ...}"
      },
      {
        "language": "text",
        "code": "function TodoList({ todos, tab, theme }) {  const visibleTodos = filterTodos(todos, tab);  // ...}"
      },
      {
        "language": "text",
        "code": "visibleTodos"
      },
      {
        "language": "text",
        "code": "console.time('filter array');const visibleTodos = filterTodos(todos, tab);console.timeEnd('filter array');"
      },
      {
        "language": "text",
        "code": "console.time('filter array');const visibleTodos = filterTodos(todos, tab);console.timeEnd('filter array');"
      },
      {
        "language": "text",
        "code": "filter array: 0.15ms"
      },
      {
        "language": "text",
        "code": "console.time('filter array');const visibleTodos = useMemo(() => {  return filterTodos(todos, tab); // Skipped if todos and tab haven't changed}, [todos, tab]);console.timeEnd('filter array');"
      },
      {
        "language": "text",
        "code": "console.time('filter array');const visibleTodos = useMemo(() => {  return filterTodos(todos, tab); // Skipped if todos and tab haven't changed}, [todos, tab]);console.timeEnd('filter array');"
      },
      {
        "language": "text",
        "code": "filterTodos"
      },
      {
        "language": "text",
        "code": "filterTodos"
      },
      {
        "language": "text",
        "code": "filterTodos"
      },
      {
        "language": "text",
        "code": "import { useMemo } from 'react';\nimport { filterTodos } from './utils.js'\n\nexport default function TodoList({ todos, theme, tab }) {\n  const visibleTodos = useMemo(\n    () => filterTodos(todos, tab),\n    [todos, tab]\n  );\n  return (\n    <div className={theme}>\n      <p><b>Note: <code>filterTodos</code> is artificially slowed down!</b></p>\n      <ul>\n        {visibleTodos.map(todo => (\n          <li key={todo.id}>\n            {todo.completed ?\n              <s>{todo.text}</s> :\n              todo.text\n            }\n          </li>\n        ))}\n      </ul>\n    </div>\n  );\n}"
      },
      {
        "language": "text",
        "code": "visibleTodos"
      },
      {
        "language": "text",
        "code": "export default function TodoList({ todos, tab, theme }) {  // ...  return (    <div className={theme}>      <List items={visibleTodos} />    </div>  );}"
      },
      {
        "language": "text",
        "code": "export default function TodoList({ todos, tab, theme }) {  // ...  return (    <div className={theme}>      <List items={visibleTodos} />    </div>  );}"
      },
      {
        "language": "text",
        "code": "import { memo } from 'react';const List = memo(function List({ items }) {  // ...});"
      },
      {
        "language": "text",
        "code": "import { memo } from 'react';const List = memo(function List({ items }) {  // ...});"
      },
      {
        "language": "text",
        "code": "visibleTodos"
      },
      {
        "language": "text",
        "code": "export default function TodoList({ todos, tab, theme }) {  // Every time the theme changes, this will be a different array...  const visibleTodos = filterTodos(todos, tab);  return (    <div className={theme}>      {/* ... so List's props will never be the same, and it will re-render every time */}      <List items={visibleTodos} />    </div>  );}"
      },
      {
        "language": "text",
        "code": "export default function TodoList({ todos, tab, theme }) {  // Every time the theme changes, this will be a different array...  const visibleTodos = filterTodos(todos, tab);  return (    <div className={theme}>      {/* ... so List's props will never be the same, and it will re-render every time */}      <List items={visibleTodos} />    </div>  );}"
      },
      {
        "language": "text",
        "code": "filterTodos"
      },
      {
        "language": "text",
        "code": "export default function TodoList({ todos, tab, theme }) {  // Tell React to cache your calculation between re-renders...  const visibleTodos = useMemo(    () => filterTodos(todos, tab),    [todos, tab] // ...so as long as these dependencies don't change...  );  return (    <div className={theme}>      {/* ...List will receive the same props and can skip re-rendering */}      <List items={visibleTodos} />    </div>  );}"
      },
      {
        "language": "text",
        "code": "export default function TodoList({ todos, tab, theme }) {  // Tell React to cache your calculation between re-renders...  const visibleTodos = useMemo(    () => filterTodos(todos, tab),    [todos, tab] // ...so as long as these dependencies don't change...  );  return (    <div className={theme}>      {/* ...List will receive the same props and can skip re-rendering */}      <List items={visibleTodos} />    </div>  );}"
      },
      {
        "language": "text",
        "code": "visibleTodos"
      },
      {
        "language": "text",
        "code": "export default function TodoList({ todos, tab, theme }) {  const visibleTodos = useMemo(() => filterTodos(todos, tab), [todos, tab]);  const children = useMemo(() => <List items={visibleTodos} />, [visibleTodos]);  return (    <div className={theme}>      {children}    </div>  );}"
      },
      {
        "language": "text",
        "code": "export default function TodoList({ todos, tab, theme }) {  const visibleTodos = useMemo(() => filterTodos(todos, tab), [todos, tab]);  const children = useMemo(() => <List items={visibleTodos} />, [visibleTodos]);  return (    <div className={theme}>      {children}    </div>  );}"
      },
      {
        "language": "text",
        "code": "visibleTodos"
      },
      {
        "language": "text",
        "code": "<List items={visibleTodos} />"
      },
      {
        "language": "text",
        "code": "{ type: List, props: { items: visibleTodos } }"
      },
      {
        "language": "text",
        "code": "visibleTodos"
      },
      {
        "language": "text",
        "code": "visibleTodos"
      },
      {
        "language": "text",
        "code": "import { useMemo } from 'react';\nimport List from './List.js';\nimport { filterTodos } from './utils.js'\n\nexport default function TodoList({ todos, theme, tab }) {\n  const visibleTodos = useMemo(\n    () => filterTodos(todos, tab),\n    [todos, tab]\n  );\n  return (\n    <div className={theme}>\n      <p><b>Note: <code>List</code> is artificially slowed down!</b></p>\n      <List items={visibleTodos} />\n    </div>\n  );\n}"
      },
      {
        "language": "text",
        "code": "function ChatRoom({ roomId }) {  const [message, setMessage] = useState('');  const options = {    serverUrl: 'https://localhost:1234',    roomId: roomId  }  useEffect(() => {    const connection = createConnection(options);    connection.connect();    // ..."
      },
      {
        "language": "text",
        "code": "function ChatRoom({ roomId }) {  const [message, setMessage] = useState('');  const options = {    serverUrl: 'https://localhost:1234',    roomId: roomId  }  useEffect(() => {    const connection = createConnection(options);    connection.connect();    // ..."
      },
      {
        "language": "text",
        "code": "useEffect(() => {    const connection = createConnection(options);    connection.connect();    return () => connection.disconnect();  }, [options]); // 🔴 Problem: This dependency changes on every render  // ..."
      },
      {
        "language": "text",
        "code": "useEffect(() => {    const connection = createConnection(options);    connection.connect();    return () => connection.disconnect();  }, [options]); // 🔴 Problem: This dependency changes on every render  // ..."
      },
      {
        "language": "text",
        "code": "function ChatRoom({ roomId }) {  const [message, setMessage] = useState('');  const options = useMemo(() => {    return {      serverUrl: 'https://localhost:1234',      roomId: roomId    };  }, [roomId]); // ✅ Only changes when roomId changes  useEffect(() => {    const connection = createConnection(options);    connection.connect();    return () => connection.disconnect();  }, [options]); // ✅ Only changes when options changes  // ..."
      },
      {
        "language": "text",
        "code": "function ChatRoom({ roomId }) {  const [message, setMessage] = useState('');  const options = useMemo(() => {    return {      serverUrl: 'https://localhost:1234',      roomId: roomId    };  }, [roomId]); // ✅ Only changes when roomId changes  useEffect(() => {    const connection = createConnection(options);    connection.connect();    return () => connection.disconnect();  }, [options]); // ✅ Only changes when options changes  // ..."
      },
      {
        "language": "text",
        "code": "function ChatRoom({ roomId }) {  const [message, setMessage] = useState('');  useEffect(() => {    const options = { // ✅ No need for useMemo or object dependencies!      serverUrl: 'https://localhost:1234',      roomId: roomId    }        const connection = createConnection(options);    connection.connect();    return () => connection.disconnect();  }, [roomId]); // ✅ Only changes when roomId changes  // ..."
      },
      {
        "language": "text",
        "code": "function ChatRoom({ roomId }) {  const [message, setMessage] = useState('');  useEffect(() => {    const options = { // ✅ No need for useMemo or object dependencies!      serverUrl: 'https://localhost:1234',      roomId: roomId    }        const connection = createConnection(options);    connection.connect();    return () => connection.disconnect();  }, [roomId]); // ✅ Only changes when roomId changes  // ..."
      },
      {
        "language": "text",
        "code": "function Dropdown({ allItems, text }) {  const searchOptions = { matchMode: 'whole-word', text };  const visibleItems = useMemo(() => {    return searchItems(allItems, searchOptions);  }, [allItems, searchOptions]); // 🚩 Caution: Dependency on an object created in the component body  // ..."
      },
      {
        "language": "text",
        "code": "function Dropdown({ allItems, text }) {  const searchOptions = { matchMode: 'whole-word', text };  const visibleItems = useMemo(() => {    return searchItems(allItems, searchOptions);  }, [allItems, searchOptions]); // 🚩 Caution: Dependency on an object created in the component body  // ..."
      },
      {
        "language": "text",
        "code": "searchOptions"
      },
      {
        "language": "text",
        "code": "searchOptions"
      },
      {
        "language": "text",
        "code": "searchItems"
      },
      {
        "language": "text",
        "code": "searchOptions"
      },
      {
        "language": "text",
        "code": "function Dropdown({ allItems, text }) {  const searchOptions = useMemo(() => {    return { matchMode: 'whole-word', text };  }, [text]); // ✅ Only changes when text changes  const visibleItems = useMemo(() => {    return searchItems(allItems, searchOptions);  }, [allItems, searchOptions]); // ✅ Only changes when allItems or searchOptions changes  // ..."
      },
      {
        "language": "text",
        "code": "function Dropdown({ allItems, text }) {  const searchOptions = useMemo(() => {    return { matchMode: 'whole-word', text };  }, [text]); // ✅ Only changes when text changes  const visibleItems = useMemo(() => {    return searchItems(allItems, searchOptions);  }, [allItems, searchOptions]); // ✅ Only changes when allItems or searchOptions changes  // ..."
      },
      {
        "language": "text",
        "code": "searchOptions"
      },
      {
        "language": "text",
        "code": "searchOptions"
      },
      {
        "language": "text",
        "code": "function Dropdown({ allItems, text }) {  const visibleItems = useMemo(() => {    const searchOptions = { matchMode: 'whole-word', text };    return searchItems(allItems, searchOptions);  }, [allItems, text]); // ✅ Only changes when allItems or text changes  // ..."
      },
      {
        "language": "text",
        "code": "function Dropdown({ allItems, text }) {  const visibleItems = useMemo(() => {    const searchOptions = { matchMode: 'whole-word', text };    return searchItems(allItems, searchOptions);  }, [allItems, text]); // ✅ Only changes when allItems or text changes  // ..."
      },
      {
        "language": "text",
        "code": "export default function ProductPage({ productId, referrer }) {  function handleSubmit(orderDetails) {    post('/product/' + productId + '/buy', {      referrer,      orderDetails    });  }  return <Form onSubmit={handleSubmit} />;}"
      },
      {
        "language": "text",
        "code": "export default function ProductPage({ productId, referrer }) {  function handleSubmit(orderDetails) {    post('/product/' + productId + '/buy', {      referrer,      orderDetails    });  }  return <Form onSubmit={handleSubmit} />;}"
      },
      {
        "language": "text",
        "code": "function() {}"
      },
      {
        "language": "text",
        "code": "export default function Page({ productId, referrer }) {  const handleSubmit = useMemo(() => {    return (orderDetails) => {      post('/product/' + productId + '/buy', {        referrer,        orderDetails      });    };  }, [productId, referrer]);  return <Form onSubmit={handleSubmit} />;}"
      },
      {
        "language": "text",
        "code": "export default function Page({ productId, referrer }) {  const handleSubmit = useMemo(() => {    return (orderDetails) => {      post('/product/' + productId + '/buy', {        referrer,        orderDetails      });    };  }, [productId, referrer]);  return <Form onSubmit={handleSubmit} />;}"
      },
      {
        "language": "text",
        "code": "useCallback"
      },
      {
        "language": "text",
        "code": "export default function Page({ productId, referrer }) {  const handleSubmit = useCallback((orderDetails) => {    post('/product/' + productId + '/buy', {      referrer,      orderDetails    });  }, [productId, referrer]);  return <Form onSubmit={handleSubmit} />;}"
      },
      {
        "language": "text",
        "code": "export default function Page({ productId, referrer }) {  const handleSubmit = useCallback((orderDetails) => {    post('/product/' + productId + '/buy', {      referrer,      orderDetails    });  }, [productId, referrer]);  return <Form onSubmit={handleSubmit} />;}"
      },
      {
        "language": "text",
        "code": "useCallback"
      },
      {
        "language": "text",
        "code": "useCallback"
      },
      {
        "language": "text",
        "code": "function TodoList({ todos, tab }) {  // This component function will run twice for every render.  const visibleTodos = useMemo(() => {    // This calculation will run twice if any of the dependencies change.    return filterTodos(todos, tab);  }, [todos, tab]);  // ..."
      },
      {
        "language": "text",
        "code": "function TodoList({ todos, tab }) {  // This component function will run twice for every render.  const visibleTodos = useMemo(() => {    // This calculation will run twice if any of the dependencies change.    return filterTodos(todos, tab);  }, [todos, tab]);  // ..."
      },
      {
        "language": "text",
        "code": "const visibleTodos = useMemo(() => {    // 🚩 Mistake: mutating a prop    todos.push({ id: 'last', text: 'Go for a walk!' });    const filtered = filterTodos(todos, tab);    return filtered;  }, [todos, tab]);"
      },
      {
        "language": "text",
        "code": "const visibleTodos = useMemo(() => {    // 🚩 Mistake: mutating a prop    todos.push({ id: 'last', text: 'Go for a walk!' });    const filtered = filterTodos(todos, tab);    return filtered;  }, [todos, tab]);"
      },
      {
        "language": "text",
        "code": "filterTodos"
      },
      {
        "language": "text",
        "code": "const visibleTodos = useMemo(() => {    const filtered = filterTodos(todos, tab);    // ✅ Correct: mutating an object you created during the calculation    filtered.push({ id: 'last', text: 'Go for a walk!' });    return filtered;  }, [todos, tab]);"
      },
      {
        "language": "text",
        "code": "const visibleTodos = useMemo(() => {    const filtered = filterTodos(todos, tab);    // ✅ Correct: mutating an object you created during the calculation    filtered.push({ id: 'last', text: 'Go for a walk!' });    return filtered;  }, [todos, tab]);"
      },
      {
        "language": "text",
        "code": "// 🔴 You can't return an object from an arrow function with () => {  const searchOptions = useMemo(() => {    matchMode: 'whole-word',    text: text  }, [text]);"
      },
      {
        "language": "text",
        "code": "// 🔴 You can't return an object from an arrow function with () => {  const searchOptions = useMemo(() => {    matchMode: 'whole-word',    text: text  }, [text]);"
      },
      {
        "language": "text",
        "code": "// This works, but is easy for someone to break again  const searchOptions = useMemo(() => ({    matchMode: 'whole-word',    text: text  }), [text]);"
      },
      {
        "language": "text",
        "code": "// This works, but is easy for someone to break again  const searchOptions = useMemo(() => ({    matchMode: 'whole-word',    text: text  }), [text]);"
      },
      {
        "language": "text",
        "code": "// ✅ This works and is explicit  const searchOptions = useMemo(() => {    return {      matchMode: 'whole-word',      text: text    };  }, [text]);"
      },
      {
        "language": "text",
        "code": "// ✅ This works and is explicit  const searchOptions = useMemo(() => {    return {      matchMode: 'whole-word',      text: text    };  }, [text]);"
      },
      {
        "language": "text",
        "code": "function TodoList({ todos, tab }) {  // 🔴 Recalculates every time: no dependency array  const visibleTodos = useMemo(() => filterTodos(todos, tab));  // ..."
      },
      {
        "language": "text",
        "code": "function TodoList({ todos, tab }) {  // 🔴 Recalculates every time: no dependency array  const visibleTodos = useMemo(() => filterTodos(todos, tab));  // ..."
      },
      {
        "language": "text",
        "code": "function TodoList({ todos, tab }) {  // ✅ Does not recalculate unnecessarily  const visibleTodos = useMemo(() => filterTodos(todos, tab), [todos, tab]);  // ..."
      },
      {
        "language": "text",
        "code": "function TodoList({ todos, tab }) {  // ✅ Does not recalculate unnecessarily  const visibleTodos = useMemo(() => filterTodos(todos, tab), [todos, tab]);  // ..."
      },
      {
        "language": "text",
        "code": "const visibleTodos = useMemo(() => filterTodos(todos, tab), [todos, tab]);  console.log([todos, tab]);"
      },
      {
        "language": "text",
        "code": "const visibleTodos = useMemo(() => filterTodos(todos, tab), [todos, tab]);  console.log([todos, tab]);"
      },
      {
        "language": "text",
        "code": "Object.is(temp1[0], temp2[0]); // Is the first dependency the same between the arrays?Object.is(temp1[1], temp2[1]); // Is the second dependency the same between the arrays?Object.is(temp1[2], temp2[2]); // ... and so on for every dependency ..."
      },
      {
        "language": "text",
        "code": "Object.is(temp1[0], temp2[0]); // Is the first dependency the same between the arrays?Object.is(temp1[1], temp2[1]); // Is the second dependency the same between the arrays?Object.is(temp1[2], temp2[2]); // ... and so on for every dependency ..."
      },
      {
        "language": "text",
        "code": "function ReportList({ items }) {  return (    <article>      {items.map(item => {        // 🔴 You can't call useMemo in a loop like this:        const data = useMemo(() => calculateReport(item), [item]);        return (          <figure key={item.id}>            <Chart data={data} />          </figure>        );      })}    </article>  );}"
      },
      {
        "language": "text",
        "code": "function ReportList({ items }) {  return (    <article>      {items.map(item => {        // 🔴 You can't call useMemo in a loop like this:        const data = useMemo(() => calculateReport(item), [item]);        return (          <figure key={item.id}>            <Chart data={data} />          </figure>        );      })}    </article>  );}"
      },
      {
        "language": "text",
        "code": "function ReportList({ items }) {  return (    <article>      {items.map(item =>        <Report key={item.id} item={item} />      )}    </article>  );}function Report({ item }) {  // ✅ Call useMemo at the top level:  const data = useMemo(() => calculateReport(item), [item]);  return (    <figure>      <Chart data={data} />    </figure>  );}"
      },
      {
        "language": "text",
        "code": "function ReportList({ items }) {  return (    <article>      {items.map(item =>        <Report key={item.id} item={item} />      )}    </article>  );}function Report({ item }) {  // ✅ Call useMemo at the top level:  const data = useMemo(() => calculateReport(item), [item]);  return (    <figure>      <Chart data={data} />    </figure>  );}"
      },
      {
        "language": "text",
        "code": "function ReportList({ items }) {  // ...}const Report = memo(function Report({ item }) {  const data = calculateReport(item);  return (    <figure>      <Chart data={data} />    </figure>  );});"
      },
      {
        "language": "text",
        "code": "function ReportList({ items }) {  // ...}const Report = memo(function Report({ item }) {  const data = calculateReport(item);  return (    <figure>      <Chart data={data} />    </figure>  );});"
      }
    ],
    "links": [
      {
        "text": "API Reference",
        "href": "/reference/react"
      },
      {
        "text": "Hooks",
        "href": "/reference/react/hooks"
      },
      {
        "text": "React Compiler",
        "href": "/learn/react-compiler"
      },
      {
        "text": "configured for React",
        "href": "/learn/editor-setup#linting"
      },
      {
        "text": "Object.is",
        "href": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/is"
      },
      {
        "text": "state variable",
        "href": "/reference/react/useState#avoiding-recreating-the-initial-state"
      },
      {
        "text": "ref",
        "href": "/reference/react/useRef#avoiding-recreating-the-ref-contents"
      },
      {
        "text": "memoization,",
        "href": "https://en.wikipedia.org/wiki/Memoization"
      },
      {
        "text": "Object.is",
        "href": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/is"
      },
      {
        "text": "memoization.",
        "href": "https://en.wikipedia.org/wiki/Memoization"
      },
      {
        "text": "CPU Throttling",
        "href": "https://developer.chrome.com/blog/new-in-devtools-61/#throttling"
      },
      {
        "text": "Strict Mode",
        "href": "/reference/react/StrictMode"
      },
      {
        "text": "memo.",
        "href": "/reference/react/memo"
      },
      {
        "text": "useEffect.",
        "href": "/reference/react/useEffect"
      },
      {
        "text": "accept JSX as children.",
        "href": "/learn/passing-props-to-a-component#passing-jsx-as-children"
      },
      {
        "text": "lift state up",
        "href": "/learn/sharing-state-between-components"
      },
      {
        "text": "rendering logic pure.",
        "href": "/learn/keeping-components-pure"
      },
      {
        "text": "unnecessary Effects that update state.",
        "href": "/learn/you-might-not-need-an-effect"
      },
      {
        "text": "remove unnecessary dependencies from your Effects.",
        "href": "/learn/removing-effect-dependencies"
      },
      {
        "text": "use the React Developer Tools profiler",
        "href": "https://legacy.reactjs.org/blog/2018/09/10/introducing-the-react-profiler.html"
      },
      {
        "text": "doing granular memoization automatically",
        "href": "https://www.youtube.com/watch?v=lGEMwh32soc"
      },
      {
        "text": "Fork",
        "href": "https://codesandbox.io/api/v1/sandboxes/define?undefined&environment=create-react-app"
      },
      {
        "text": "memo:",
        "href": "/reference/react/memo"
      },
      {
        "text": "memo",
        "href": "/reference/react/memo"
      },
      {
        "text": "memo,",
        "href": "/reference/react/memo"
      },
      {
        "text": "memo",
        "href": "/reference/react/memo"
      },
      {
        "text": "immutable.",
        "href": "https://en.wikipedia.org/wiki/Immutable_object"
      },
      {
        "text": "memo",
        "href": "/reference/react/memo"
      },
      {
        "text": "memo",
        "href": "/reference/react/memo"
      },
      {
        "text": "Fork",
        "href": "https://codesandbox.io/api/v1/sandboxes/define?undefined&environment=create-react-app"
      },
      {
        "text": "Effect:",
        "href": "/learn/synchronizing-with-effects"
      },
      {
        "text": "Every reactive value must be declared as a dependency of your Effect.",
        "href": "/learn/lifecycle-of-reactive-effects#react-verifies-that-you-specified-every-reactive-value-as-a-dependency"
      },
      {
        "text": "Learn more about removing Effect dependencies.",
        "href": "/learn/removing-effect-dependencies#move-dynamic-objects-and-functions-inside-your-effect"
      },
      {
        "text": "memo.",
        "href": "/reference/react/memo"
      },
      {
        "text": "useCallback",
        "href": "/reference/react/useCallback"
      },
      {
        "text": "Read more about useCallback.",
        "href": "/reference/react/useCallback"
      },
      {
        "text": "Strict Mode",
        "href": "/reference/react/StrictMode"
      },
      {
        "text": "keep components pure.",
        "href": "/learn/keeping-components-pure"
      },
      {
        "text": "keeping components pure",
        "href": "/learn/keeping-components-pure"
      },
      {
        "text": "updating objects",
        "href": "/learn/updating-objects-in-state"
      },
      {
        "text": "updating arrays",
        "href": "/learn/updating-arrays-in-state"
      },
      {
        "text": "memo",
        "href": "/reference/react/memo"
      },
      {
        "text": "memo.",
        "href": "/reference/react/memo"
      },
      {
        "text": "PrevioususeLayoutEffect",
        "href": "/reference/react/useLayoutEffect"
      },
      {
        "text": "NextuseOptimistic",
        "href": "/reference/react/useOptimistic"
      }
    ],
    "meta": {
      "description": "",
      "keywords": ""
    },
    "summary": "API ReferenceHooksuseMemouseMemo is a React Hook that lets you cache the result of a calculation between re-renders",
    "tags": [
      "react",
      "vue",
      "angular",
      "javascript",
      "typescript",
      "html",
      "node",
      "vite",
      "usememo",
      "skipping"
    ],
    "id": "usememo-react-useMemo-part-1",
    "quality": 100
  },
  {
    "title": "useCallback – React",
    "url": "https://react.dev/reference/react/useCallback",
    "category": "react",
    "content": "API ReferenceHooksuseCallbackuseCallback is a React Hook that lets you cache a function definition between re-renders.const cachedFn = useCallback(fn, dependencies) NoteReact Compiler automatically memoizes values and functions, reducing the need for manual useCallback calls. You can use the compiler to handle memoization automatically. Reference useCallback(fn, dependencies) Usage Skipping re-rendering of components Updating state from a memoized callback Preventing an Effect from firing too often Optimizing a custom Hook Troubleshooting Every time my component renders, useCallback returns a different function I need to call useCallback for each list item in a loop, but its not allowed Reference useCallback(fn, dependencies) Call useCallback at the top level of your component to cache a function definition between re-renders: import { useCallback } from 'react';export default function ProductPage({ productId, referrer, theme }) { const handleSubmit = useCallback((orderDetails) = { post('/product/' + productId + '/buy', { referrer, orderDetails, }); }, [productId, referrer]); See more examples below. Parameters fn: The function value that you want to cache. It can take any arguments and return any values. React will return (not call!) your function back to you during the initial render. On next renders, React will give you the same function again if the dependencies have not changed since the last render. Otherwise, it will give you the function that you have passed during the current render, and store it in case it can be reused later. React will not call your function. The function is returned to you so you can decide when and whether to call it. dependencies: The list of all reactive values referenced inside of the fn code. Reactive values include props, state, and all the variables and functions declared directly inside your component body. If your linter is configured for React, it will verify that every reactive value is correctly specified as a dependency. The list of dependencies must have a constant number of items and be written inline like [dep1, dep2, dep3]. React will compare each dependency with its previous value using the Object.is comparison algorithm. Returns On the initial render, useCallback returns the fn function you have passed. During subsequent renders, it will either return an already stored fn function from the last render (if the dependencies havent changed), or return the fn function you have passed during this render. Caveats useCallback is a Hook, so you can only call it at the top level of your component or your own Hooks. You cant call it inside loops or conditions. If you need that, extract a new component and move the state into it. React will not throw away the cached function unless there is a specific reason to do that. For example, in development, React throws away the cache when you edit the file of your component. Both in development and in production, React will throw away the cache if your component suspends during the initial mount. In the future, React may add more features that take advantage of throwing away the cachefor example, if React adds built-in support for virtualized lists in the future, it would make sense to throw away the cache for items that scroll out of the virtualized table viewport. This should match your expectations if you rely on useCallback as a performance optimization. Otherwise, a state variable or a ref may be more appropriate. Usage Skipping re-rendering of components When you optimize rendering performance, you will sometimes need to cache the functions that you pass to child components. Lets first look at the syntax for how to do this, and then see in which cases its useful. To cache a function between re-renders of your component, wrap its definition into the useCallback Hook: import { useCallback } from 'react';function ProductPage({ productId, referrer, theme }) { const handleSubmit = useCallback((orderDetails) = { post('/product/' + productId + '/buy', { referrer, orderDetails, }); }, [productId, referrer]); // ... You need to pass two things to useCallback: A function definition that you want to cache between re-renders. A list of dependencies including every value within your component thats used inside your function. On the initial render, the returned function youll get from useCallback will be the function you passed. On the following renders, React will compare the dependencies with the dependencies you passed during the previous render. If none of the dependencies have changed (compared with Object.is), useCallback will return the same function as before. Otherwise, useCallback will return the function you passed on this render. In other words, useCallback caches a function between re-renders until its dependencies change. Lets walk through an example to see when this is useful. Say youre passing a handleSubmit function down from the ProductPage to the ShippingForm component: function ProductPage({ productId, referrer, theme }) { // ... return ( div className={theme} ShippingForm onSubmit={handleSubmit} / /div ); Youve noticed that toggling the theme prop freezes the app for a moment, but if you remove ShippingForm / from your JSX, it feels fast. This tells you that its worth trying to optimize the ShippingForm component. By default, when a component re-renders, React re-renders all of its children recursively. This is why, when ProductPage re-renders with a different theme, the ShippingForm component also re-renders. This is fine for components that dont require much calculation to re-render. But if you verified a re-render is slow, you can tell ShippingForm to skip re-rendering when its props are the same as on last render by wrapping it in memo: import { memo } from 'react';const ShippingForm = memo(function ShippingForm({ onSubmit }) { // ...}); With this change, ShippingForm will skip re-rendering if all of its props are the same as on the last render. This is when caching a function becomes important! Lets say you defined handleSubmit without useCallback: function ProductPage({ productId, referrer, theme }) { // Every time the theme changes, this will be a different function... function handleSubmit(orderDetails) { post('/product/' + productId + '/buy', { referrer, orderDetails, }); } return ( div className={theme} {/* ... so ShippingForm's props will never be the same, and it will re-render every time */} ShippingForm onSubmit={handleSubmit} / /div );} In JavaScript, a function () {} or () = {} always creates a different function, similar to how the {} object literal always creates a new object. Normally, this wouldnt be a problem, but it means that ShippingForm props will never be the same, and your memo optimization wont work. This is where useCallback comes in handy: function ProductPage({ productId, referrer, theme }) { // Tell React to cache your function between re-renders... const handleSubmit = useCallback((orderDetails) = { post('/product/' + productId + '/buy', { referrer, orderDetails, }); }, [productId, referrer]); // ...so as long as these dependencies don't change... return ( div className={theme} {/* ...ShippingForm will receive the same props and can skip re-rendering */} ShippingForm onSubmit={handleSubmit} / /div );} By wrapping handleSubmit in useCallback, you ensure that its the same function between the re-renders (until dependencies change). You dont have to wrap a function in useCallback unless you do it for some specific reason. In this example, the reason is that you pass it to a component wrapped in memo, and this lets it skip re-rendering. There are other reasons you might need useCallback which are described further on this page. NoteYou should only rely on useCallback as a performance optimization. If your code doesnt work without it, find the underlying problem and fix it first. Then you may add useCallback back. Deep DiveHow is useCallback related to useMemo? Show DetailsYou will often see useMemo alongside useCallback. They are both useful when youre trying to optimize a child component. They let you memoize (or, in other words, cache) something youre passing down:import { useMemo, useCallback } from 'react';function ProductPage({ productId, referrer }) { const product = useData('/product/' + productId); const requirements = useMemo(() = { // Calls your function and caches its result return computeRequirements(product); }, [product]); const handleSubmit = useCallback((orderDetails) = { // Caches your function itself post('/product/' + productId + '/buy', { referrer, orderDetails, }); }, [productId, referrer]); return ( div className={theme} ShippingForm requirements={requirements} onSubmit={handleSubmit} / /div );}The difference is in what theyre letting you cache: useMemo caches the result of calling your function. In this example, it caches the result of calling computeRequirements(product) so that it doesnt change unless product has changed. This lets you pass the requirements object down without unnecessarily re-rendering ShippingForm. When necessary, React will call the function youve passed during rendering to calculate the result. useCallback caches the function itself. Unlike useMemo, it does not call the function you provide. Instead, it caches the function you provided so that handleSubmit itself doesnt change unless productId or referrer has changed. This lets you pass the handleSubmit function down without unnecessarily re-rendering ShippingForm. Your code wont run until the user submits the form. If youre already familiar with useMemo, you might find it helpful to think of useCallback as this:// Simplified implementation (inside React)function useCallback(fn, dependencies) { return useMemo(() = fn, dependencies);}Read more about the difference between useMemo and useCallback. Deep DiveShould you add useCallback everywhere? Show DetailsIf your app is like this site, and most interactions are coarse (like replacing a page or an entire section), memoization is usually unnecessary. On the other hand, if your app is more like a drawing editor, and most interactions are granular (like moving shapes), then you might find memoization very helpful.Caching a function with useCallback is only valuable in a few cases: You pass it as a prop to a component wrapped in memo. You want to skip re-rendering if the value hasnt changed. Memoization lets your component re-render only if dependencies changed. The function youre passing is later used as a dependency of some Hook. For example, another function wrapped in useCallback depends on it, or you depend on this function from useEffect. There is no benefit to wrapping a function in useCallback in other cases. There is no significant harm to doing that either, so some teams choose to not think about individual cases, and memoize as much as possible. The downside is that code becomes less readable. Also, not all memoization is effective: a single value thats always new is enough to break memoization for an entire component.Note that useCallback does not prevent creating the function. Youre always creating a function (and thats fine!), but React ignores it and gives you back a cached function if nothing changed.In practice, you can make a lot of memoization unnecessary by following a few principles: When a component visually wraps other components, let it accept JSX as children. Then, if the wrapper component updates its own state, React knows that its children dont need to re-render. Prefer local state and dont lift state up any further than necessary. Dont keep transient state like forms and whether an item is hovered at the top of your tree or in a global state library. Keep your rendering logic pure. If re-rendering a component causes a problem or produces some noticeable visual artifact, its a bug in your component! Fix the bug instead of adding memoization. Avoid unnecessary Effects that update state. Most performance problems in React apps are caused by chains of updates originating from Effects that cause your components to render over and over. Try to remove unnecessary dependencies from your Effects. For example, instead of memoization, its often simpler to move some object or a function inside an Effect or outside the component. If a specific interaction still feels laggy, use the React Developer Tools profiler to see which components benefit the most from memoization, and add memoization where needed. These principles make your components easier to debug and understand, so its good to follow them in any case. In long term, were researching doing memoization automatically to solve this once and for all. The difference between useCallback and declaring a function directly1. Skipping re-rendering with useCallback and memo 2. Always re-rendering a component Example 1 of 2: Skipping re-rendering with useCallback and memo In this example, the ShippingForm component is artificially slowed down so that you can see what happens when a React component youre rendering is genuinely slow. Try incrementing the counter and toggling the theme.Incrementing the counter feels slow because it forces the slowed down ShippingForm to re-render. Thats expected because the counter has changed, and so you need to reflect the users new choice on the screen.Next, try toggling the theme. Thanks to useCallback together with memo, its fast despite the artificial slowdown! ShippingForm skipped re-rendering because the handleSubmit function has not changed. The handleSubmit function has not changed because both productId and referrer (your useCallback dependencies) havent changed since last render.App.jsProductPage.jsShippingForm.jsProductPage.js ResetForkimport { useCallback } from 'react'; import ShippingForm from './ShippingForm.js'; export default function ProductPage({ productId, referrer, theme }) { const handleSubmit = useCallback((orderDetails) = { post('/product/' + productId + '/buy', { referrer, orderDetails, }); }, [productId, referrer]); return ( div className={theme} ShippingForm onSubmit={handleSubmit} / /div ); } function post(url, data) { // Imagine this sends a request... console.log('POST /' + url); console.log(data); } Show moreNext Example Updating state from a memoized callback Sometimes, you might need to update state based on previous state from a memoized callback. This handleAddTodo function specifies todos as a dependency because it computes the next todos from it: function TodoList() { const [todos, setTodos] = useState([]); const handleAddTodo = useCallback((text) = { const newTodo = { id: nextId++, text }; setTodos([...todos, newTodo]); }, [todos]); // ... Youll usually want memoized functions to have as few dependencies as possible. When you read some state only to calculate the next state, you can remove that dependency by passing an updater function instead: function TodoList() { const [todos, setTodos] = useState([]); const handleAddTodo = useCallback((text) = { const newTodo = { id: nextId++, text }; setTodos(todos = [...todos, newTodo]); }, []); //  No need for the todos dependency // ... Here, instead of making todos a dependency and reading it inside, you pass an instruction about how to update the state (todos = [...todos, newTodo]) to React. Read more about updater functions. Preventing an Effect from firing too often Sometimes, you might want to call a function from inside an Effect: function ChatRoom({ roomId }) { const [message, setMessage] = useState(''); function createOptions() { return { serverUrl: 'https://localhost:1234', roomId: roomId }; } useEffect(() = { const options = createOptions(); const connection = createConnection(options); connection.connect(); // ... This creates a problem. Every reactive value must be declared as a dependency of your Effect. However, if you declare createOptions as a dependency, it will cause your Effect to constantly reconnect to the chat room: useEffect(() = { const options = createOptions(); const connection = createConnection(options); connection.connect(); return () = connection.disconnect(); }, [createOptions]); //  Problem: This dependency changes on every render // ... To solve this, you can wrap the function you need to call from an Effect into useCallback: function ChatRoom({ roomId }) { const [message, setMessage] = useState(''); const createOptions = useCallback(() = { return { serverUrl: 'https://localhost:1234', roomId: roomId }; }, [roomId]); //  Only changes when roomId changes useEffect(() = { const options = createOptions(); const connection = createConnection(options); connection.connect(); return () = connection.disconnect(); }, [createOptions]); //  Only changes when createOptions changes // ... This ensures that the createOptions function is the same between re-renders if the roomId is the same. However, its even better to remove the need for a function dependency. Move your function inside the Effect: function ChatRoom({ roomId }) { const [message, setMessage] = useState(''); useEffect(() = { function createOptions() { //  No need for useCallback or function dependencies! return { serverUrl: 'https://localhost:1234', roomId: roomId }; } const options = createOptions(); const connection = createConnection(options); connection.connect(); return () = connection.disconnect(); }, [roomId]); //  Only changes when roomId changes // ... Now your code is simpler and doesnt need useCallback. Learn more about removing Effect dependencies. Optimizing a custom Hook If youre writing a custom Hook, its recommended to wrap any functions that it returns into useCallback: function useRouter() { const { dispatch } = useContext(RouterStateContext); const navigate = useCallback((url) = { dispatch({ type: 'navigate', url }); }, [dispatch]); const goBack = useCallback(() = { dispatch({ type: 'back' }); }, [dispatch]); return { navigate, goBack, };} This ensures that the consumers of your Hook can optimize their own code when needed. Troubleshooting Every time my component renders, useCallback returns a different function Make sure youve specified the dependency array as a second argument! If you forget the dependency array, useCallback will return a new function every time: function ProductPage({ productId, referrer }) { const handleSubmit = useCallback((orderDetails) = { post('/product/' + productId + '/buy', { referrer, orderDetails, }); }); //  Returns a new function every time: no dependency array // ... This is the corrected version passing the dependency array as a second argument: function ProductPage({ productId, referrer }) { const handleSubmit = useCallback((orderDetails) = { post('/product/' + productId + '/buy', { referrer, orderDetails, }); }, [productId, referrer]); //  Does not return a new function unnecessarily // ... If this doesnt help, then the problem is that at least one of your dependencies is different from the previous render. You can debug this problem by manually logging your dependencies to the console: const handleSubmit = useCallback((orderDetails) = { // .. }, [productId, referrer]); console.log([productId, referrer]); You can then right-click on the arrays from different re-renders in the console and select Store as a global variable for both of them. Assuming the first one got saved as temp1 and the second one got saved as temp2, you can then use the browser console to check whether each dependency in both arrays is the same: Object.is(temp1[0], temp2[0]); // Is the first dependency the same between the arrays?Object.is(temp1[1], temp2[1]); // Is the second dependency the same between the arrays?Object.is(temp1[2], temp2[2]); // ... and so on for every dependency ... When you find which dependency is breaking memoization, either find a way to remove it, or memoize it as well. I need to call useCallback for each list item in a loop, but its not allowed Suppose the Chart component is wrapped in memo. You want to skip re-rendering every Chart in the list when the ReportList component re-renders. However, you cant call useCallback in a loop: function ReportList({ items }) { return ( article {items.map(item = { //  You can't call useCallback in a loop like this: const handleClick = useCallback(() = { sendReport(item) }, [item]); return ( figure key={item.id} Chart onClick={handleClick} / /figure ); })} /article );} Instead, extract a component for an individual item, and put useCallback there: function ReportList({ items }) { return ( article {items.map(item = Report key={item.id} item={item} / )} /article );}function Report({ item }) { //  Call useCallback at the top level: const handleClick = useCallback(() = { sendReport(item) }, [item]); return ( figure Chart onClick={handleClick} / /figure );} Alternatively, you could remove useCallback in the last snippet and instead wrap Report itself in memo. If the item prop does not change, Report will skip re-rendering, so Chart will skip re-rendering too: function ReportList({ items }) { // ...}const Report = memo(function Report({ item }) { function handleClick() { sendReport(item); } return ( figure Chart onClick={handleClick} / /figure );});PrevioususeActionStateNextuseContext",
    "headings": [
      {
        "level": 1,
        "text": "useCallback",
        "id": ""
      },
      {
        "level": 2,
        "text": "Reference",
        "id": "reference"
      },
      {
        "level": 2,
        "text": "Usage",
        "id": "usage"
      },
      {
        "level": 2,
        "text": "Troubleshooting",
        "id": "troubleshooting"
      },
      {
        "level": 3,
        "text": "Note",
        "id": ""
      },
      {
        "level": 3,
        "text": "useCallback(fn, dependencies)",
        "id": "usecallback"
      },
      {
        "level": 3,
        "text": "Skipping re-rendering of components",
        "id": "skipping-re-rendering-of-components"
      },
      {
        "level": 3,
        "text": "Note",
        "id": ""
      },
      {
        "level": 3,
        "text": "Updating state from a memoized callback",
        "id": "updating-state-from-a-memoized-callback"
      },
      {
        "level": 3,
        "text": "Preventing an Effect from firing too often",
        "id": "preventing-an-effect-from-firing-too-often"
      },
      {
        "level": 3,
        "text": "Optimizing a custom Hook",
        "id": "optimizing-a-custom-hook"
      },
      {
        "level": 3,
        "text": "Every time my component renders, useCallback returns a different function",
        "id": "every-time-my-component-renders-usecallback-returns-a-different-function"
      },
      {
        "level": 3,
        "text": "I need to call useCallback for each list item in a loop, but it’s not allowed",
        "id": "i-need-to-call-usememo-for-each-list-item-in-a-loop-but-its-not-allowed"
      },
      {
        "level": 4,
        "text": "Parameters",
        "id": "parameters"
      },
      {
        "level": 4,
        "text": "Returns",
        "id": "returns"
      },
      {
        "level": 4,
        "text": "Caveats",
        "id": "caveats"
      },
      {
        "level": 4,
        "text": "How is useCallback related to useMemo?",
        "id": "how-is-usecallback-related-to-usememo"
      },
      {
        "level": 4,
        "text": "Should you add useCallback everywhere?",
        "id": "should-you-add-usecallback-everywhere"
      },
      {
        "level": 4,
        "text": "The difference between useCallback and declaring a function directly",
        "id": "examples-rerendering"
      },
      {
        "level": 4,
        "text": "Example 1 of 2: Skipping re-rendering with useCallback and memo",
        "id": "skipping-re-rendering-with-usecallback-and-memo"
      },
      {
        "level": 5,
        "text": "Deep Dive",
        "id": ""
      },
      {
        "level": 5,
        "text": "Deep Dive",
        "id": ""
      }
    ],
    "codeBlocks": [
      {
        "language": "text",
        "code": "useCallback"
      },
      {
        "language": "text",
        "code": "const cachedFn = useCallback(fn, dependencies)"
      },
      {
        "language": "text",
        "code": "const cachedFn = useCallback(fn, dependencies)"
      },
      {
        "language": "text",
        "code": "useCallback"
      },
      {
        "language": "text",
        "code": "useCallback(fn, dependencies)"
      },
      {
        "language": "text",
        "code": "useCallback"
      },
      {
        "language": "text",
        "code": "useCallback"
      },
      {
        "language": "text",
        "code": "useCallback(fn, dependencies)"
      },
      {
        "language": "text",
        "code": "useCallback"
      },
      {
        "language": "text",
        "code": "import { useCallback } from 'react';export default function ProductPage({ productId, referrer, theme }) {  const handleSubmit = useCallback((orderDetails) => {    post('/product/' + productId + '/buy', {      referrer,      orderDetails,    });  }, [productId, referrer]);"
      },
      {
        "language": "text",
        "code": "import { useCallback } from 'react';export default function ProductPage({ productId, referrer, theme }) {  const handleSubmit = useCallback((orderDetails) => {    post('/product/' + productId + '/buy', {      referrer,      orderDetails,    });  }, [productId, referrer]);"
      },
      {
        "language": "text",
        "code": "dependencies"
      },
      {
        "language": "text",
        "code": "dependencies"
      },
      {
        "language": "text",
        "code": "[dep1, dep2, dep3]"
      },
      {
        "language": "text",
        "code": "useCallback"
      },
      {
        "language": "text",
        "code": "useCallback"
      },
      {
        "language": "text",
        "code": "useCallback"
      },
      {
        "language": "text",
        "code": "useCallback"
      },
      {
        "language": "text",
        "code": "import { useCallback } from 'react';function ProductPage({ productId, referrer, theme }) {  const handleSubmit = useCallback((orderDetails) => {    post('/product/' + productId + '/buy', {      referrer,      orderDetails,    });  }, [productId, referrer]);  // ..."
      },
      {
        "language": "text",
        "code": "import { useCallback } from 'react';function ProductPage({ productId, referrer, theme }) {  const handleSubmit = useCallback((orderDetails) => {    post('/product/' + productId + '/buy', {      referrer,      orderDetails,    });  }, [productId, referrer]);  // ..."
      },
      {
        "language": "text",
        "code": "useCallback"
      },
      {
        "language": "text",
        "code": "useCallback"
      },
      {
        "language": "text",
        "code": "useCallback"
      },
      {
        "language": "text",
        "code": "useCallback"
      },
      {
        "language": "text",
        "code": "useCallback"
      },
      {
        "language": "text",
        "code": "handleSubmit"
      },
      {
        "language": "text",
        "code": "ProductPage"
      },
      {
        "language": "text",
        "code": "ShippingForm"
      },
      {
        "language": "text",
        "code": "function ProductPage({ productId, referrer, theme }) {  // ...  return (    <div className={theme}>      <ShippingForm onSubmit={handleSubmit} />    </div>  );"
      },
      {
        "language": "text",
        "code": "function ProductPage({ productId, referrer, theme }) {  // ...  return (    <div className={theme}>      <ShippingForm onSubmit={handleSubmit} />    </div>  );"
      },
      {
        "language": "text",
        "code": "<ShippingForm />"
      },
      {
        "language": "text",
        "code": "ShippingForm"
      },
      {
        "language": "text",
        "code": "ProductPage"
      },
      {
        "language": "text",
        "code": "ShippingForm"
      },
      {
        "language": "text",
        "code": "ShippingForm"
      },
      {
        "language": "text",
        "code": "import { memo } from 'react';const ShippingForm = memo(function ShippingForm({ onSubmit }) {  // ...});"
      },
      {
        "language": "text",
        "code": "import { memo } from 'react';const ShippingForm = memo(function ShippingForm({ onSubmit }) {  // ...});"
      },
      {
        "language": "text",
        "code": "ShippingForm"
      },
      {
        "language": "text",
        "code": "handleSubmit"
      },
      {
        "language": "text",
        "code": "useCallback"
      },
      {
        "language": "text",
        "code": "function ProductPage({ productId, referrer, theme }) {  // Every time the theme changes, this will be a different function...  function handleSubmit(orderDetails) {    post('/product/' + productId + '/buy', {      referrer,      orderDetails,    });  }    return (    <div className={theme}>      {/* ... so ShippingForm's props will never be the same, and it will re-render every time */}      <ShippingForm onSubmit={handleSubmit} />    </div>  );}"
      },
      {
        "language": "text",
        "code": "function ProductPage({ productId, referrer, theme }) {  // Every time the theme changes, this will be a different function...  function handleSubmit(orderDetails) {    post('/product/' + productId + '/buy', {      referrer,      orderDetails,    });  }    return (    <div className={theme}>      {/* ... so ShippingForm's props will never be the same, and it will re-render every time */}      <ShippingForm onSubmit={handleSubmit} />    </div>  );}"
      },
      {
        "language": "text",
        "code": "function () {}"
      },
      {
        "language": "text",
        "code": "ShippingForm"
      },
      {
        "language": "text",
        "code": "useCallback"
      },
      {
        "language": "text",
        "code": "function ProductPage({ productId, referrer, theme }) {  // Tell React to cache your function between re-renders...  const handleSubmit = useCallback((orderDetails) => {    post('/product/' + productId + '/buy', {      referrer,      orderDetails,    });  }, [productId, referrer]); // ...so as long as these dependencies don't change...  return (    <div className={theme}>      {/* ...ShippingForm will receive the same props and can skip re-rendering */}      <ShippingForm onSubmit={handleSubmit} />    </div>  );}"
      },
      {
        "language": "text",
        "code": "function ProductPage({ productId, referrer, theme }) {  // Tell React to cache your function between re-renders...  const handleSubmit = useCallback((orderDetails) => {    post('/product/' + productId + '/buy', {      referrer,      orderDetails,    });  }, [productId, referrer]); // ...so as long as these dependencies don't change...  return (    <div className={theme}>      {/* ...ShippingForm will receive the same props and can skip re-rendering */}      <ShippingForm onSubmit={handleSubmit} />    </div>  );}"
      },
      {
        "language": "text",
        "code": "handleSubmit"
      },
      {
        "language": "text",
        "code": "useCallback"
      },
      {
        "language": "text",
        "code": "useCallback"
      },
      {
        "language": "text",
        "code": "useCallback"
      },
      {
        "language": "text",
        "code": "useCallback"
      },
      {
        "language": "text",
        "code": "useCallback"
      },
      {
        "language": "text",
        "code": "useCallback"
      },
      {
        "language": "text",
        "code": "import { useMemo, useCallback } from 'react';function ProductPage({ productId, referrer }) {  const product = useData('/product/' + productId);  const requirements = useMemo(() => { // Calls your function and caches its result    return computeRequirements(product);  }, [product]);  const handleSubmit = useCallback((orderDetails) => { // Caches your function itself    post('/product/' + productId + '/buy', {      referrer,      orderDetails,    });  }, [productId, referrer]);  return (    <div className={theme}>      <ShippingForm requirements={requirements} onSubmit={handleSubmit} />    </div>  );}"
      },
      {
        "language": "text",
        "code": "import { useMemo, useCallback } from 'react';function ProductPage({ productId, referrer }) {  const product = useData('/product/' + productId);  const requirements = useMemo(() => { // Calls your function and caches its result    return computeRequirements(product);  }, [product]);  const handleSubmit = useCallback((orderDetails) => { // Caches your function itself    post('/product/' + productId + '/buy', {      referrer,      orderDetails,    });  }, [productId, referrer]);  return (    <div className={theme}>      <ShippingForm requirements={requirements} onSubmit={handleSubmit} />    </div>  );}"
      },
      {
        "language": "text",
        "code": "computeRequirements(product)"
      },
      {
        "language": "text",
        "code": "requirements"
      },
      {
        "language": "text",
        "code": "ShippingForm"
      },
      {
        "language": "text",
        "code": "useCallback"
      },
      {
        "language": "text",
        "code": "handleSubmit"
      },
      {
        "language": "text",
        "code": "handleSubmit"
      },
      {
        "language": "text",
        "code": "ShippingForm"
      },
      {
        "language": "text",
        "code": "useCallback"
      },
      {
        "language": "text",
        "code": "// Simplified implementation (inside React)function useCallback(fn, dependencies) {  return useMemo(() => fn, dependencies);}"
      },
      {
        "language": "text",
        "code": "// Simplified implementation (inside React)function useCallback(fn, dependencies) {  return useMemo(() => fn, dependencies);}"
      },
      {
        "language": "text",
        "code": "useCallback"
      },
      {
        "language": "text",
        "code": "useCallback"
      },
      {
        "language": "text",
        "code": "useCallback"
      },
      {
        "language": "text",
        "code": "useCallback"
      },
      {
        "language": "text",
        "code": "useCallback"
      },
      {
        "language": "text",
        "code": "useCallback"
      },
      {
        "language": "text",
        "code": "useCallback"
      },
      {
        "language": "text",
        "code": "ShippingForm"
      },
      {
        "language": "text",
        "code": "ShippingForm"
      },
      {
        "language": "text",
        "code": "useCallback"
      },
      {
        "language": "text",
        "code": "ShippingForm"
      },
      {
        "language": "text",
        "code": "handleSubmit"
      },
      {
        "language": "text",
        "code": "handleSubmit"
      },
      {
        "language": "text",
        "code": "useCallback"
      },
      {
        "language": "text",
        "code": "import { useCallback } from 'react';\nimport ShippingForm from './ShippingForm.js';\n\nexport default function ProductPage({ productId, referrer, theme }) {\n  const handleSubmit = useCallback((orderDetails) => {\n    post('/product/' + productId + '/buy', {\n      referrer,\n      orderDetails,\n    });\n  }, [productId, referrer]);\n\n  return (\n    <div className={theme}>\n      <ShippingForm onSubmit={handleSubmit} />\n    </div>\n  );\n}\n\nfunction post(url, data) {\n  // Imagine this sends a request...\n  console.log('POST /' + url);\n  console.log(data);\n}"
      },
      {
        "language": "text",
        "code": "handleAddTodo"
      },
      {
        "language": "text",
        "code": "function TodoList() {  const [todos, setTodos] = useState([]);  const handleAddTodo = useCallback((text) => {    const newTodo = { id: nextId++, text };    setTodos([...todos, newTodo]);  }, [todos]);  // ..."
      },
      {
        "language": "text",
        "code": "function TodoList() {  const [todos, setTodos] = useState([]);  const handleAddTodo = useCallback((text) => {    const newTodo = { id: nextId++, text };    setTodos([...todos, newTodo]);  }, [todos]);  // ..."
      },
      {
        "language": "text",
        "code": "function TodoList() {  const [todos, setTodos] = useState([]);  const handleAddTodo = useCallback((text) => {    const newTodo = { id: nextId++, text };    setTodos(todos => [...todos, newTodo]);  }, []); // ✅ No need for the todos dependency  // ..."
      },
      {
        "language": "text",
        "code": "function TodoList() {  const [todos, setTodos] = useState([]);  const handleAddTodo = useCallback((text) => {    const newTodo = { id: nextId++, text };    setTodos(todos => [...todos, newTodo]);  }, []); // ✅ No need for the todos dependency  // ..."
      },
      {
        "language": "text",
        "code": "todos => [...todos, newTodo]"
      },
      {
        "language": "text",
        "code": "function ChatRoom({ roomId }) {  const [message, setMessage] = useState('');  function createOptions() {    return {      serverUrl: 'https://localhost:1234',      roomId: roomId    };  }  useEffect(() => {    const options = createOptions();    const connection = createConnection(options);    connection.connect();    // ..."
      },
      {
        "language": "text",
        "code": "function ChatRoom({ roomId }) {  const [message, setMessage] = useState('');  function createOptions() {    return {      serverUrl: 'https://localhost:1234',      roomId: roomId    };  }  useEffect(() => {    const options = createOptions();    const connection = createConnection(options);    connection.connect();    // ..."
      },
      {
        "language": "text",
        "code": "createOptions"
      },
      {
        "language": "text",
        "code": "useEffect(() => {    const options = createOptions();    const connection = createConnection(options);    connection.connect();    return () => connection.disconnect();  }, [createOptions]); // 🔴 Problem: This dependency changes on every render  // ..."
      },
      {
        "language": "text",
        "code": "useEffect(() => {    const options = createOptions();    const connection = createConnection(options);    connection.connect();    return () => connection.disconnect();  }, [createOptions]); // 🔴 Problem: This dependency changes on every render  // ..."
      },
      {
        "language": "text",
        "code": "useCallback"
      },
      {
        "language": "text",
        "code": "function ChatRoom({ roomId }) {  const [message, setMessage] = useState('');  const createOptions = useCallback(() => {    return {      serverUrl: 'https://localhost:1234',      roomId: roomId    };  }, [roomId]); // ✅ Only changes when roomId changes  useEffect(() => {    const options = createOptions();    const connection = createConnection(options);    connection.connect();    return () => connection.disconnect();  }, [createOptions]); // ✅ Only changes when createOptions changes  // ..."
      },
      {
        "language": "text",
        "code": "function ChatRoom({ roomId }) {  const [message, setMessage] = useState('');  const createOptions = useCallback(() => {    return {      serverUrl: 'https://localhost:1234',      roomId: roomId    };  }, [roomId]); // ✅ Only changes when roomId changes  useEffect(() => {    const options = createOptions();    const connection = createConnection(options);    connection.connect();    return () => connection.disconnect();  }, [createOptions]); // ✅ Only changes when createOptions changes  // ..."
      },
      {
        "language": "text",
        "code": "createOptions"
      },
      {
        "language": "text",
        "code": "function ChatRoom({ roomId }) {  const [message, setMessage] = useState('');  useEffect(() => {    function createOptions() { // ✅ No need for useCallback or function dependencies!      return {        serverUrl: 'https://localhost:1234',        roomId: roomId      };    }    const options = createOptions();    const connection = createConnection(options);    connection.connect();    return () => connection.disconnect();  }, [roomId]); // ✅ Only changes when roomId changes  // ..."
      },
      {
        "language": "text",
        "code": "function ChatRoom({ roomId }) {  const [message, setMessage] = useState('');  useEffect(() => {    function createOptions() { // ✅ No need for useCallback or function dependencies!      return {        serverUrl: 'https://localhost:1234',        roomId: roomId      };    }    const options = createOptions();    const connection = createConnection(options);    connection.connect();    return () => connection.disconnect();  }, [roomId]); // ✅ Only changes when roomId changes  // ..."
      },
      {
        "language": "text",
        "code": "useCallback"
      },
      {
        "language": "text",
        "code": "useCallback"
      },
      {
        "language": "text",
        "code": "function useRouter() {  const { dispatch } = useContext(RouterStateContext);  const navigate = useCallback((url) => {    dispatch({ type: 'navigate', url });  }, [dispatch]);  const goBack = useCallback(() => {    dispatch({ type: 'back' });  }, [dispatch]);  return {    navigate,    goBack,  };}"
      },
      {
        "language": "text",
        "code": "function useRouter() {  const { dispatch } = useContext(RouterStateContext);  const navigate = useCallback((url) => {    dispatch({ type: 'navigate', url });  }, [dispatch]);  const goBack = useCallback(() => {    dispatch({ type: 'back' });  }, [dispatch]);  return {    navigate,    goBack,  };}"
      },
      {
        "language": "text",
        "code": "useCallback"
      },
      {
        "language": "text",
        "code": "useCallback"
      },
      {
        "language": "text",
        "code": "function ProductPage({ productId, referrer }) {  const handleSubmit = useCallback((orderDetails) => {    post('/product/' + productId + '/buy', {      referrer,      orderDetails,    });  }); // 🔴 Returns a new function every time: no dependency array  // ..."
      },
      {
        "language": "text",
        "code": "function ProductPage({ productId, referrer }) {  const handleSubmit = useCallback((orderDetails) => {    post('/product/' + productId + '/buy', {      referrer,      orderDetails,    });  }); // 🔴 Returns a new function every time: no dependency array  // ..."
      },
      {
        "language": "text",
        "code": "function ProductPage({ productId, referrer }) {  const handleSubmit = useCallback((orderDetails) => {    post('/product/' + productId + '/buy', {      referrer,      orderDetails,    });  }, [productId, referrer]); // ✅ Does not return a new function unnecessarily  // ..."
      },
      {
        "language": "text",
        "code": "function ProductPage({ productId, referrer }) {  const handleSubmit = useCallback((orderDetails) => {    post('/product/' + productId + '/buy', {      referrer,      orderDetails,    });  }, [productId, referrer]); // ✅ Does not return a new function unnecessarily  // ..."
      },
      {
        "language": "text",
        "code": "const handleSubmit = useCallback((orderDetails) => {    // ..  }, [productId, referrer]);  console.log([productId, referrer]);"
      },
      {
        "language": "text",
        "code": "const handleSubmit = useCallback((orderDetails) => {    // ..  }, [productId, referrer]);  console.log([productId, referrer]);"
      },
      {
        "language": "text",
        "code": "Object.is(temp1[0], temp2[0]); // Is the first dependency the same between the arrays?Object.is(temp1[1], temp2[1]); // Is the second dependency the same between the arrays?Object.is(temp1[2], temp2[2]); // ... and so on for every dependency ..."
      },
      {
        "language": "text",
        "code": "Object.is(temp1[0], temp2[0]); // Is the first dependency the same between the arrays?Object.is(temp1[1], temp2[1]); // Is the second dependency the same between the arrays?Object.is(temp1[2], temp2[2]); // ... and so on for every dependency ..."
      },
      {
        "language": "text",
        "code": "useCallback"
      },
      {
        "language": "text",
        "code": "useCallback"
      },
      {
        "language": "text",
        "code": "function ReportList({ items }) {  return (    <article>      {items.map(item => {        // 🔴 You can't call useCallback in a loop like this:        const handleClick = useCallback(() => {          sendReport(item)        }, [item]);        return (          <figure key={item.id}>            <Chart onClick={handleClick} />          </figure>        );      })}    </article>  );}"
      },
      {
        "language": "text",
        "code": "function ReportList({ items }) {  return (    <article>      {items.map(item => {        // 🔴 You can't call useCallback in a loop like this:        const handleClick = useCallback(() => {          sendReport(item)        }, [item]);        return (          <figure key={item.id}>            <Chart onClick={handleClick} />          </figure>        );      })}    </article>  );}"
      },
      {
        "language": "text",
        "code": "useCallback"
      },
      {
        "language": "text",
        "code": "function ReportList({ items }) {  return (    <article>      {items.map(item =>        <Report key={item.id} item={item} />      )}    </article>  );}function Report({ item }) {  // ✅ Call useCallback at the top level:  const handleClick = useCallback(() => {    sendReport(item)  }, [item]);  return (    <figure>      <Chart onClick={handleClick} />    </figure>  );}"
      },
      {
        "language": "text",
        "code": "function ReportList({ items }) {  return (    <article>      {items.map(item =>        <Report key={item.id} item={item} />      )}    </article>  );}function Report({ item }) {  // ✅ Call useCallback at the top level:  const handleClick = useCallback(() => {    sendReport(item)  }, [item]);  return (    <figure>      <Chart onClick={handleClick} />    </figure>  );}"
      },
      {
        "language": "text",
        "code": "useCallback"
      },
      {
        "language": "text",
        "code": "function ReportList({ items }) {  // ...}const Report = memo(function Report({ item }) {  function handleClick() {    sendReport(item);  }  return (    <figure>      <Chart onClick={handleClick} />    </figure>  );});"
      },
      {
        "language": "text",
        "code": "function ReportList({ items }) {  // ...}const Report = memo(function Report({ item }) {  function handleClick() {    sendReport(item);  }  return (    <figure>      <Chart onClick={handleClick} />    </figure>  );});"
      }
    ],
    "links": [
      {
        "text": "API Reference",
        "href": "/reference/react"
      },
      {
        "text": "Hooks",
        "href": "/reference/react/hooks"
      },
      {
        "text": "React Compiler",
        "href": "/learn/react-compiler"
      },
      {
        "text": "configured for React",
        "href": "/learn/editor-setup#linting"
      },
      {
        "text": "Object.is",
        "href": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/is"
      },
      {
        "text": "state variable",
        "href": "/reference/react/useState#im-trying-to-set-state-to-a-function-but-it-gets-called-instead"
      },
      {
        "text": "ref",
        "href": "/reference/react/useRef#avoiding-recreating-the-ref-contents"
      },
      {
        "text": "Object.is",
        "href": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/is"
      },
      {
        "text": "memo:",
        "href": "/reference/react/memo"
      },
      {
        "text": "memo",
        "href": "/reference/react/memo"
      },
      {
        "text": "memo,",
        "href": "/reference/react/memo"
      },
      {
        "text": "useMemo",
        "href": "/reference/react/useMemo"
      },
      {
        "text": "memoize",
        "href": "https://en.wikipedia.org/wiki/Memoization"
      },
      {
        "text": "useMemo",
        "href": "/reference/react/useMemo"
      },
      {
        "text": "useMemo,",
        "href": "/reference/react/useMemo"
      },
      {
        "text": "Read more about the difference between useMemo and useCallback.",
        "href": "/reference/react/useMemo#memoizing-a-function"
      },
      {
        "text": "memo.",
        "href": "/reference/react/memo"
      },
      {
        "text": "useEffect.",
        "href": "/reference/react/useEffect"
      },
      {
        "text": "accept JSX as children.",
        "href": "/learn/passing-props-to-a-component#passing-jsx-as-children"
      },
      {
        "text": "lift state up",
        "href": "/learn/sharing-state-between-components"
      },
      {
        "text": "rendering logic pure.",
        "href": "/learn/keeping-components-pure"
      },
      {
        "text": "unnecessary Effects that update state.",
        "href": "/learn/you-might-not-need-an-effect"
      },
      {
        "text": "remove unnecessary dependencies from your Effects.",
        "href": "/learn/removing-effect-dependencies"
      },
      {
        "text": "use the React Developer Tools profiler",
        "href": "https://legacy.reactjs.org/blog/2018/09/10/introducing-the-react-profiler.html"
      },
      {
        "text": "doing memoization automatically",
        "href": "https://www.youtube.com/watch?v=lGEMwh32soc"
      },
      {
        "text": "memo",
        "href": "/reference/react/memo"
      },
      {
        "text": "updater function",
        "href": "/reference/react/useState#updating-state-based-on-the-previous-state"
      },
      {
        "text": "Read more about updater functions.",
        "href": "/reference/react/useState#updating-state-based-on-the-previous-state"
      },
      {
        "text": "Effect:",
        "href": "/learn/synchronizing-with-effects"
      },
      {
        "text": "Every reactive value must be declared as a dependency of your Effect.",
        "href": "/learn/lifecycle-of-reactive-effects#react-verifies-that-you-specified-every-reactive-value-as-a-dependency"
      },
      {
        "text": "Learn more about removing Effect dependencies.",
        "href": "/learn/removing-effect-dependencies#move-dynamic-objects-and-functions-inside-your-effect"
      },
      {
        "text": "custom Hook,",
        "href": "/learn/reusing-logic-with-custom-hooks"
      },
      {
        "text": "memoize it as well.",
        "href": "/reference/react/useMemo#memoizing-a-dependency-of-another-hook"
      },
      {
        "text": "memo",
        "href": "/reference/react/memo"
      },
      {
        "text": "memo.",
        "href": "/reference/react/memo"
      },
      {
        "text": "PrevioususeActionState",
        "href": "/reference/react/useActionState"
      },
      {
        "text": "NextuseContext",
        "href": "/reference/react/useContext"
      }
    ],
    "meta": {
      "description": "",
      "keywords": ""
    },
    "summary": "API ReferenceHooksuseCallbackuseCallback is a React Hook that lets you cache a function definition between re-renders",
    "tags": [
      "react",
      "vue",
      "angular",
      "javascript",
      "typescript",
      "html",
      "node",
      "vite",
      "usecallback",
      "note"
    ],
    "id": "usecallback-react-useCallback-part-1",
    "quality": 100
  },
  {
    "title": "useRef – React",
    "url": "https://react.dev/reference/react/useRef",
    "category": "react",
    "content": "API ReferenceHooksuseRefuseRef is a React Hook that lets you reference a value thats not needed for rendering.const ref = useRef(initialValue) Reference useRef(initialValue) Usage Referencing a value with a ref Manipulating the DOM with a ref Avoiding recreating the ref contents Troubleshooting I cant get a ref to a custom component Reference useRef(initialValue) Call useRef at the top level of your component to declare a ref. import { useRef } from 'react';function MyComponent() { const intervalRef = useRef(0); const inputRef = useRef(null); // ... See more examples below. Parameters initialValue: The value you want the ref objects current property to be initially. It can be a value of any type. This argument is ignored after the initial render. Returns useRef returns an object with a single property: current: Initially, its set to the initialValue you have passed. You can later set it to something else. If you pass the ref object to React as a ref attribute to a JSX node, React will set its current property. On the next renders, useRef will return the same object. Caveats You can mutate the ref.current property. Unlike state, it is mutable. However, if it holds an object that is used for rendering (for example, a piece of your state), then you shouldnt mutate that object. When you change the ref.current property, React does not re-render your component. React is not aware of when you change it because a ref is a plain JavaScript object. Do not write or read ref.current during rendering, except for initialization. This makes your components behavior unpredictable. In Strict Mode, React will call your component function twice in order to help you find accidental impurities. This is development-only behavior and does not affect production. Each ref object will be created twice, but one of the versions will be discarded. If your component function is pure (as it should be), this should not affect the behavior. Usage Referencing a value with a ref Call useRef at the top level of your component to declare one or more refs. import { useRef } from 'react';function Stopwatch() { const intervalRef = useRef(0); // ... useRef returns a ref object with a single current property initially set to the initial value you provided. On the next renders, useRef will return the same object. You can change its current property to store information and read it later. This might remind you of state, but there is an important difference. Changing a ref does not trigger a re-render. This means refs are perfect for storing information that doesnt affect the visual output of your component. For example, if you need to store an interval ID and retrieve it later, you can put it in a ref. To update the value inside the ref, you need to manually change its current property: function handleStartClick() { const intervalId = setInterval(() = { // ... }, 1000); intervalRef.current = intervalId;} Later, you can read that interval ID from the ref so that you can call clear that interval: function handleStopClick() { const intervalId = intervalRef.current; clearInterval(intervalId);} By using a ref, you ensure that: You can store information between re-renders (unlike regular variables, which reset on every render). Changing it does not trigger a re-render (unlike state variables, which trigger a re-render). The information is local to each copy of your component (unlike the variables outside, which are shared). Changing a ref does not trigger a re-render, so refs are not appropriate for storing information you want to display on the screen. Use state for that instead. Read more about choosing between useRef and useState. Examples of referencing a value with useRef1. Click counter 2. A stopwatch Example 1 of 2: Click counter This component uses a ref to keep track of how many times the button was clicked. Note that its okay to use a ref instead of state here because the click count is only read and written in an event handler.App.jsApp.js Download ResetForkimport { useRef } from 'react'; export default function Counter() { let ref = useRef(0); function handleClick() { ref.current = ref.current + 1; alert('You clicked ' + ref.current + ' times!'); } return ( button onClick={handleClick} Click me! /button ); } Show moreIf you show {ref.current} in the JSX, the number wont update on click. This is because setting ref.current does not trigger a re-render. Information thats used for rendering should be state instead.Next Example PitfallDo not write or read ref.current during rendering.React expects that the body of your component behaves like a pure function: If the inputs (props, state, and context) are the same, it should return exactly the same JSX. Calling it in a different order or with different arguments should not affect the results of other calls. Reading or writing a ref during rendering breaks these expectations.function MyComponent() { // ... //  Don't write a ref during rendering myRef.current = 123; // ... //  Don't read a ref during rendering return h1{myOtherRef.current}/h1;}You can read or write refs from event handlers or effects instead.function MyComponent() { // ... useEffect(() = { //  You can read or write refs in effects myRef.current = 123; }); // ... function handleClick() { //  You can read or write refs in event handlers doSomething(myOtherRef.current); } // ...}If you have to read or write something during rendering, use state instead.When you break these rules, your component might still work, but most of the newer features were adding to React will rely on these expectations. Read more about keeping your components pure. Manipulating the DOM with a ref Its particularly common to use a ref to manipulate the DOM. React has built-in support for this. First, declare a ref object with an initial value of null: import { useRef } from 'react';function MyComponent() { const inputRef = useRef(null); // ... Then pass your ref object as the ref attribute to the JSX of the DOM node you want to manipulate: // ... return input ref={inputRef} /; After React creates the DOM node and puts it on the screen, React will set the current property of your ref object to that DOM node. Now you can access the inputs DOM node and call methods like focus(): function handleClick() { inputRef.current.focus(); } React will set the current property back to null when the node is removed from the screen. Read more about manipulating the DOM with refs. Examples of manipulating the DOM with useRef1. Focusing a text input 2. Scrolling an image into view 3. Playing and pausing a video 4. Exposing a ref to your own component Example 1 of 4: Focusing a text input In this example, clicking the button will focus the input:App.jsApp.js Download ResetForkimport { useRef } from 'react'; export default function Form() { const inputRef = useRef(null); function handleClick() { inputRef.current.focus(); } return (  input ref={inputRef} / button onClick={handleClick} Focus the input /button / ); } Show moreNext Example Avoiding recreating the ref contents React saves the initial ref value once and ignores it on the next renders. function Video() { const playerRef = useRef(new VideoPlayer()); // ... Although the result of new VideoPlayer() is only used for the initial render, youre still calling this function on every render. This can be wasteful if its creating expensive objects. To solve it, you may initialize the ref like this instead: function Video() { const playerRef = useRef(null); if (playerRef.current === null) { playerRef.current = new VideoPlayer(); } // ... Normally, writing or reading ref.current during render is not allowed. However, its fine in this case because the result is always the same, and the condition only executes during initialization so its fully predictable. Deep DiveHow to avoid null checks when initializing useRef later Show DetailsIf you use a type checker and dont want to always check for null, you can try a pattern like this instead:function Video() { const playerRef = useRef(null); function getPlayer() { if (playerRef.current !== null) { return playerRef.current; } const player = new VideoPlayer(); playerRef.current = player; return player; } // ...Here, the playerRef itself is nullable. However, you should be able to convince your type checker that there is no case in which getPlayer() returns null. Then use getPlayer() in your event handlers. Troubleshooting I cant get a ref to a custom component If you try to pass a ref to your own component like this: const inputRef = useRef(null);return MyInput ref={inputRef} /; You might get an error in the console: ConsoleTypeError: Cannot read properties of null By default, your own components dont expose refs to the DOM nodes inside them. To fix this, find the component that you want to get a ref to: export default function MyInput({ value, onChange }) { return ( input value={value} onChange={onChange} / );} And then add ref to the list of props your component accepts and pass ref as a prop to the relevent child built-in component like this: function MyInput({ value, onChange, ref }) { return ( input value={value} onChange={onChange} ref={ref} / );};export default MyInput; Then the parent component can get a ref to it. Read more about accessing another components DOM nodes.PrevioususeReducerNextuseState",
    "headings": [
      {
        "level": 1,
        "text": "useRef",
        "id": ""
      },
      {
        "level": 2,
        "text": "Reference",
        "id": "reference"
      },
      {
        "level": 2,
        "text": "Usage",
        "id": "usage"
      },
      {
        "level": 2,
        "text": "Troubleshooting",
        "id": "troubleshooting"
      },
      {
        "level": 3,
        "text": "useRef(initialValue)",
        "id": "useref"
      },
      {
        "level": 3,
        "text": "Referencing a value with a ref",
        "id": "referencing-a-value-with-a-ref"
      },
      {
        "level": 3,
        "text": "Pitfall",
        "id": ""
      },
      {
        "level": 3,
        "text": "Manipulating the DOM with a ref",
        "id": "manipulating-the-dom-with-a-ref"
      },
      {
        "level": 3,
        "text": "Avoiding recreating the ref contents",
        "id": "avoiding-recreating-the-ref-contents"
      },
      {
        "level": 3,
        "text": "I can’t get a ref to a custom component",
        "id": "i-cant-get-a-ref-to-a-custom-component"
      },
      {
        "level": 4,
        "text": "Parameters",
        "id": "parameters"
      },
      {
        "level": 4,
        "text": "Returns",
        "id": "returns"
      },
      {
        "level": 4,
        "text": "Caveats",
        "id": "caveats"
      },
      {
        "level": 4,
        "text": "Examples of referencing a value with useRef",
        "id": "examples-value"
      },
      {
        "level": 4,
        "text": "Example 1 of 2: Click counter",
        "id": "click-counter"
      },
      {
        "level": 4,
        "text": "Examples of manipulating the DOM with useRef",
        "id": "examples-dom"
      },
      {
        "level": 4,
        "text": "Example 1 of 4: Focusing a text input",
        "id": "focusing-a-text-input"
      },
      {
        "level": 4,
        "text": "How to avoid null checks when initializing useRef later",
        "id": "how-to-avoid-null-checks-when-initializing-use-ref-later"
      },
      {
        "level": 5,
        "text": "Deep Dive",
        "id": ""
      }
    ],
    "codeBlocks": [
      {
        "language": "text",
        "code": "const ref = useRef(initialValue)"
      },
      {
        "language": "text",
        "code": "const ref = useRef(initialValue)"
      },
      {
        "language": "text",
        "code": "useRef(initialValue)"
      },
      {
        "language": "text",
        "code": "useRef(initialValue)"
      },
      {
        "language": "text",
        "code": "import { useRef } from 'react';function MyComponent() {  const intervalRef = useRef(0);  const inputRef = useRef(null);  // ..."
      },
      {
        "language": "text",
        "code": "import { useRef } from 'react';function MyComponent() {  const intervalRef = useRef(0);  const inputRef = useRef(null);  // ..."
      },
      {
        "language": "text",
        "code": "initialValue"
      },
      {
        "language": "text",
        "code": "initialValue"
      },
      {
        "language": "text",
        "code": "ref.current"
      },
      {
        "language": "text",
        "code": "ref.current"
      },
      {
        "language": "text",
        "code": "ref.current"
      },
      {
        "language": "text",
        "code": "import { useRef } from 'react';function Stopwatch() {  const intervalRef = useRef(0);  // ..."
      },
      {
        "language": "text",
        "code": "import { useRef } from 'react';function Stopwatch() {  const intervalRef = useRef(0);  // ..."
      },
      {
        "language": "text",
        "code": "function handleStartClick() {  const intervalId = setInterval(() => {    // ...  }, 1000);  intervalRef.current = intervalId;}"
      },
      {
        "language": "text",
        "code": "function handleStartClick() {  const intervalId = setInterval(() => {    // ...  }, 1000);  intervalRef.current = intervalId;}"
      },
      {
        "language": "text",
        "code": "function handleStopClick() {  const intervalId = intervalRef.current;  clearInterval(intervalId);}"
      },
      {
        "language": "text",
        "code": "function handleStopClick() {  const intervalId = intervalRef.current;  clearInterval(intervalId);}"
      },
      {
        "language": "text",
        "code": "import { useRef } from 'react';\n\nexport default function Counter() {\n  let ref = useRef(0);\n\n  function handleClick() {\n    ref.current = ref.current + 1;\n    alert('You clicked ' + ref.current + ' times!');\n  }\n\n  return (\n    <button onClick={handleClick}>\n      Click me!\n    </button>\n  );\n}"
      },
      {
        "language": "text",
        "code": "{ref.current}"
      },
      {
        "language": "text",
        "code": "ref.current"
      },
      {
        "language": "text",
        "code": "ref.current"
      },
      {
        "language": "text",
        "code": "function MyComponent() {  // ...  // 🚩 Don't write a ref during rendering  myRef.current = 123;  // ...  // 🚩 Don't read a ref during rendering  return <h1>{myOtherRef.current}</h1>;}"
      },
      {
        "language": "text",
        "code": "function MyComponent() {  // ...  // 🚩 Don't write a ref during rendering  myRef.current = 123;  // ...  // 🚩 Don't read a ref during rendering  return <h1>{myOtherRef.current}</h1>;}"
      },
      {
        "language": "text",
        "code": "function MyComponent() {  // ...  useEffect(() => {    // ✅ You can read or write refs in effects    myRef.current = 123;  });  // ...  function handleClick() {    // ✅ You can read or write refs in event handlers    doSomething(myOtherRef.current);  }  // ...}"
      },
      {
        "language": "text",
        "code": "function MyComponent() {  // ...  useEffect(() => {    // ✅ You can read or write refs in effects    myRef.current = 123;  });  // ...  function handleClick() {    // ✅ You can read or write refs in event handlers    doSomething(myOtherRef.current);  }  // ...}"
      },
      {
        "language": "text",
        "code": "import { useRef } from 'react';function MyComponent() {  const inputRef = useRef(null);  // ..."
      },
      {
        "language": "text",
        "code": "import { useRef } from 'react';function MyComponent() {  const inputRef = useRef(null);  // ..."
      },
      {
        "language": "text",
        "code": "// ...  return <input ref={inputRef} />;"
      },
      {
        "language": "text",
        "code": "// ...  return <input ref={inputRef} />;"
      },
      {
        "language": "text",
        "code": "function handleClick() {    inputRef.current.focus();  }"
      },
      {
        "language": "text",
        "code": "function handleClick() {    inputRef.current.focus();  }"
      },
      {
        "language": "text",
        "code": "import { useRef } from 'react';\n\nexport default function Form() {\n  const inputRef = useRef(null);\n\n  function handleClick() {\n    inputRef.current.focus();\n  }\n\n  return (\n    <>\n      <input ref={inputRef} />\n      <button onClick={handleClick}>\n        Focus the input\n      </button>\n    </>\n  );\n}"
      },
      {
        "language": "text",
        "code": "function Video() {  const playerRef = useRef(new VideoPlayer());  // ..."
      },
      {
        "language": "text",
        "code": "function Video() {  const playerRef = useRef(new VideoPlayer());  // ..."
      },
      {
        "language": "text",
        "code": "new VideoPlayer()"
      },
      {
        "language": "text",
        "code": "function Video() {  const playerRef = useRef(null);  if (playerRef.current === null) {    playerRef.current = new VideoPlayer();  }  // ..."
      },
      {
        "language": "text",
        "code": "function Video() {  const playerRef = useRef(null);  if (playerRef.current === null) {    playerRef.current = new VideoPlayer();  }  // ..."
      },
      {
        "language": "text",
        "code": "ref.current"
      },
      {
        "language": "text",
        "code": "function Video() {  const playerRef = useRef(null);  function getPlayer() {    if (playerRef.current !== null) {      return playerRef.current;    }    const player = new VideoPlayer();    playerRef.current = player;    return player;  }  // ..."
      },
      {
        "language": "text",
        "code": "function Video() {  const playerRef = useRef(null);  function getPlayer() {    if (playerRef.current !== null) {      return playerRef.current;    }    const player = new VideoPlayer();    playerRef.current = player;    return player;  }  // ..."
      },
      {
        "language": "text",
        "code": "getPlayer()"
      },
      {
        "language": "text",
        "code": "getPlayer()"
      },
      {
        "language": "text",
        "code": "const inputRef = useRef(null);return <MyInput ref={inputRef} />;"
      },
      {
        "language": "text",
        "code": "const inputRef = useRef(null);return <MyInput ref={inputRef} />;"
      },
      {
        "language": "text",
        "code": "export default function MyInput({ value, onChange }) {  return (    <input      value={value}      onChange={onChange}    />  );}"
      },
      {
        "language": "text",
        "code": "export default function MyInput({ value, onChange }) {  return (    <input      value={value}      onChange={onChange}    />  );}"
      },
      {
        "language": "text",
        "code": "function MyInput({ value, onChange, ref }) {  return (    <input      value={value}      onChange={onChange}      ref={ref}    />  );};export default MyInput;"
      },
      {
        "language": "text",
        "code": "function MyInput({ value, onChange, ref }) {  return (    <input      value={value}      onChange={onChange}      ref={ref}    />  );};export default MyInput;"
      }
    ],
    "links": [
      {
        "text": "API Reference",
        "href": "/reference/react"
      },
      {
        "text": "Hooks",
        "href": "/reference/react/hooks"
      },
      {
        "text": "ref.",
        "href": "/learn/referencing-values-with-refs"
      },
      {
        "text": "help you find accidental impurities.",
        "href": "/reference/react/useState#my-initializer-or-updater-function-runs-twice"
      },
      {
        "text": "refs.",
        "href": "/learn/referencing-values-with-refs"
      },
      {
        "text": "state",
        "href": "/reference/react/useState"
      },
      {
        "text": "interval ID",
        "href": "https://developer.mozilla.org/en-US/docs/Web/API/setInterval"
      },
      {
        "text": "clear that interval",
        "href": "https://developer.mozilla.org/en-US/docs/Web/API/clearInterval"
      },
      {
        "text": "choosing between useRef and useState.",
        "href": "/learn/referencing-values-with-refs#differences-between-refs-and-state"
      },
      {
        "text": "behaves like a pure function",
        "href": "/learn/keeping-components-pure"
      },
      {
        "text": "props",
        "href": "/learn/passing-props-to-a-component"
      },
      {
        "text": "state",
        "href": "/learn/state-a-components-memory"
      },
      {
        "text": "context",
        "href": "/learn/passing-data-deeply-with-context"
      },
      {
        "text": "or write",
        "href": "/reference/react/useState#storing-information-from-previous-renders"
      },
      {
        "text": "use state",
        "href": "/reference/react/useState"
      },
      {
        "text": "keeping your components pure.",
        "href": "/learn/keeping-components-pure#where-you-_can_-cause-side-effects"
      },
      {
        "text": "DOM.",
        "href": "https://developer.mozilla.org/en-US/docs/Web/API/HTML_DOM_API"
      },
      {
        "text": "focus()",
        "href": "https://developer.mozilla.org/en-US/docs/Web/API/HTMLElement/focus"
      },
      {
        "text": "manipulating the DOM with refs.",
        "href": "/learn/manipulating-the-dom-with-refs"
      },
      {
        "text": "built-in component",
        "href": "/reference/react-dom/components/common"
      },
      {
        "text": "accessing another component’s DOM nodes.",
        "href": "/learn/manipulating-the-dom-with-refs#accessing-another-components-dom-nodes"
      },
      {
        "text": "PrevioususeReducer",
        "href": "/reference/react/useReducer"
      },
      {
        "text": "NextuseState",
        "href": "/reference/react/useState"
      }
    ],
    "meta": {
      "description": "",
      "keywords": ""
    },
    "summary": "API ReferenceHooksuseRefuseRef is a React Hook that lets you reference a value thats not needed for rendering",
    "tags": [
      "react",
      "angular",
      "javascript",
      "typescript",
      "html",
      "node",
      "vite",
      "useref",
      "ref",
      "referencing"
    ],
    "id": "useref-react-useRef-part-1",
    "quality": 100
  },
  {
    "title": "Describing the UI – React",
    "url": "https://react.dev/learn/describing-the-ui",
    "category": "react",
    "content": "Learn ReactDescribing the UIReact is a JavaScript library for rendering user interfaces (UI). UI is built from small units like buttons, text, and images. React lets you combine them into reusable, nestable components. From web sites to phone apps, everything on the screen can be broken down into components. In this chapter, youll learn to create, customize, and conditionally display React components. In this chapter How to write your first React component When and how to create multi-component files How to add markup to JavaScript with JSX How to use curly braces with JSX to access JavaScript functionality from your components How to configure components with props How to conditionally render components How to render multiple components at a time How to avoid confusing bugs by keeping components pure Why understanding your UI as trees is useful Your first component React applications are built from isolated pieces of UI called components. A React component is a JavaScript function that you can sprinkle with markup. Components can be as small as a button, or as large as an entire page. Here is a Gallery component rendering three Profile components: App.jsApp.js Download ResetForkfunction Profile() { return ( img src=\"https://i.imgur.com/MK3eW3As.jpg\" alt=\"Katherine Johnson\" / ); } export default function Gallery() { return ( section h1Amazing scientists/h1 Profile / Profile / Profile / /section ); } Show more Ready to learn this topic?Read Your First Component to learn how to declare and use React components.Read More Importing and exporting components You can declare many components in one file, but large files can get difficult to navigate. To solve this, you can export a component into its own file, and then import that component from another file: Gallery.jsProfile.jsGallery.js ResetForkimport Profile from './Profile.js'; export default function Gallery() { return ( section h1Amazing scientists/h1 Profile / Profile / Profile / /section ); } Ready to learn this topic?Read Importing and Exporting Components to learn how to split components into their own files.Read More Writing markup with JSX Each React component is a JavaScript function that may contain some markup that React renders into the browser. React components use a syntax extension called JSX to represent that markup. JSX looks a lot like HTML, but it is a bit stricter and can display dynamic information. If we paste existing HTML markup into a React component, it wont always work: App.jsApp.js Download ResetForkexport default function TodoList() { return ( // This doesn't quite work! h1Hedy Lamarr's Todos/h1 img src=\"https://i.imgur.com/yXOvdOSs.jpg\" alt=\"Hedy Lamarr\" class=\"photo\"  ul liInvent new traffic lights liRehearse a movie scene liImprove spectrum technology /ul Show more If you have existing HTML like this, you can fix it using a converter: App.jsApp.js Download ResetForkexport default function TodoList() { return (  h1Hedy Lamarr's Todos/h1 img src=\"https://i.imgur.com/yXOvdOSs.jpg\" alt=\"Hedy Lamarr\" className=\"photo\" / ul liInvent new traffic lights/li liRehearse a movie scene/li liImprove spectrum technology/li /ul / ); } Show more Ready to learn this topic?Read Writing Markup with JSX to learn how to write valid JSX.Read More JavaScript in JSX with curly braces JSX lets you write HTML-like markup inside a JavaScript file, keeping rendering logic and content in the same place. Sometimes you will want to add a little JavaScript logic or reference a dynamic property inside that markup. In this situation, you can use curly braces in your JSX to open a window to JavaScript: App.jsApp.js Download ResetForkconst person = { name: 'Gregorio Y. Zara', theme: { backgroundColor: 'black', color: 'pink' } }; export default function TodoList() { return ( div style={person.theme} h1{person.name}'s Todos/h1 img className=\"avatar\" src=\"https://i.imgur.com/7vQD0fPs.jpg\" alt=\"Gregorio Y. Zara\" / ul liImprove the videophone/li liPrepare aeronautics lectures/li liWork on the alcohol-fuelled engine/li /ul /div ); } Show more Ready to learn this topic?Read JavaScript in JSX with Curly Braces to learn how to access JavaScript data from JSX.Read More Passing props to a component React components use props to communicate with each other. Every parent component can pass some information to its child components by giving them props. Props might remind you of HTML attributes, but you can pass any JavaScript value through them, including objects, arrays, functions, and even JSX! App.jsutils.jsApp.js ResetForkimport { getImageUrl } from './utils.js' export default function Profile() { return ( Card Avatar size={100} person={{ name: 'Katsuko Saruhashi', imageId: 'YfeOqp2' }} / /Card ); } function Avatar({ person, size }) { return ( img className=\"avatar\" src={getImageUrl(person)} alt={person.name} width={size} height={size} / ); } function Card({ children }) { return ( div className=\"card\" {children} /div ); } Show more Ready to learn this topic?Read Passing Props to a Component to learn how to pass and read props.Read More Conditional rendering Your components will often need to display different things depending on different conditions. In React, you can conditionally render JSX using JavaScript syntax like if statements, &&, and ? : operators. In this example, the JavaScript && operator is used to conditionally render a checkmark: App.jsApp.js Download ResetForkfunction Item({ name, isPacked }) { return ( li className=\"item\" {name} {isPacked && ''} /li ); } export default function PackingList() { return ( section h1Sally Ride's Packing List/h1 ul Item isPacked={true} name=\"Space suit\" / Item isPacked={true} name=\"Helmet with a golden leaf\" / Item isPacked={false} name=\"Photo of Tam\" / /ul /section ); } Show more Ready to learn this topic?Read Conditional Rendering to learn the different ways to render content conditionally.Read More Rendering lists You will often want to display multiple similar components from a collection of data. You can use JavaScripts filter() and map() with React to filter and transform your array of data into an array of components. For each array item, you will need to specify a key. Usually, you will want to use an ID from the database as a key. Keys let React keep track of each items place in the list even if the list changes. App.jsdata.jsutils.jsApp.js ResetForkimport { people } from './data.js'; import { getImageUrl } from './utils.js'; export default function List() { const listItems = people.map(person = li key={person.id} img src={getImageUrl(person)} alt={person.name} / p b{person.name}:/b {' ' + person.profession + ' '} known for {person.accomplishment} /p /li ); return ( article h1Scientists/h1 ul{listItems}/ul /article ); } Show more Ready to learn this topic?Read Rendering Lists to learn how to render a list of components, and how to choose a key.Read More Keeping components pure Some JavaScript functions are pure. A pure function: Minds its own business. It does not change any objects or variables that existed before it was called. Same inputs, same output. Given the same inputs, a pure function should always return the same result. By strictly only writing your components as pure functions, you can avoid an entire class of baffling bugs and unpredictable behavior as your codebase grows. Here is an example of an impure component: App.jsApp.js Download ResetForklet guest = 0; function Cup() { // Bad: changing a preexisting variable! guest = guest + 1; return h2Tea cup for guest #{guest}/h2; } export default function TeaSet() { return (  Cup / Cup / Cup / / ); } Show more You can make this component pure by passing a prop instead of modifying a preexisting variable: App.jsApp.js Download ResetForkfunction Cup({ guest }) { return h2Tea cup for guest #{guest}/h2; } export default function TeaSet() { return (  Cup guest={1} / Cup guest={2} / Cup guest={3} / / ); } Ready to learn this topic?Read Keeping Components Pure to learn how to write components as pure, predictable functions.Read More Your UI as a tree React uses trees to model the relationships between components and modules. A React render tree is a representation of the parent and child relationship between components. An example React render tree. Components near the top of the tree, near the root component, are considered top-level components. Components with no child components are leaf components. This categorization of components is useful for understanding data flow and rendering performance. Modelling the relationship between JavaScript modules is another useful way to understand your app. We refer to it as a module dependency tree. An example module dependency tree. A dependency tree is often used by build tools to bundle all the relevant JavaScript code for the client to download and render. A large bundle size regresses user experience for React apps. Understanding the module dependency tree is helpful to debug such issues. Ready to learn this topic?Read Your UI as a Tree to learn how to create a render and module dependency trees for a React app and how theyre useful mental models for improving user experience and performance.Read More Whats next? Head over to Your First Component to start reading this chapter page by page! Or, if youre already familiar with these topics, why not read about Adding Interactivity?NextYour First Component",
    "headings": [
      {
        "level": 1,
        "text": "Describing the UI",
        "id": ""
      },
      {
        "level": 2,
        "text": "Your first component",
        "id": "your-first-component"
      },
      {
        "level": 2,
        "text": "Ready to learn this topic?",
        "id": ""
      },
      {
        "level": 2,
        "text": "Importing and exporting components",
        "id": "importing-and-exporting-components"
      },
      {
        "level": 2,
        "text": "Ready to learn this topic?",
        "id": ""
      },
      {
        "level": 2,
        "text": "Writing markup with JSX",
        "id": "writing-markup-with-jsx"
      },
      {
        "level": 2,
        "text": "Ready to learn this topic?",
        "id": ""
      },
      {
        "level": 2,
        "text": "JavaScript in JSX with curly braces",
        "id": "javascript-in-jsx-with-curly-braces"
      },
      {
        "level": 2,
        "text": "Ready to learn this topic?",
        "id": ""
      },
      {
        "level": 2,
        "text": "Passing props to a component",
        "id": "passing-props-to-a-component"
      },
      {
        "level": 2,
        "text": "Ready to learn this topic?",
        "id": ""
      },
      {
        "level": 2,
        "text": "Conditional rendering",
        "id": "conditional-rendering"
      },
      {
        "level": 2,
        "text": "Ready to learn this topic?",
        "id": ""
      },
      {
        "level": 2,
        "text": "Rendering lists",
        "id": "rendering-lists"
      },
      {
        "level": 2,
        "text": "Ready to learn this topic?",
        "id": ""
      },
      {
        "level": 2,
        "text": "Keeping components pure",
        "id": "keeping-components-pure"
      },
      {
        "level": 2,
        "text": "Ready to learn this topic?",
        "id": ""
      },
      {
        "level": 2,
        "text": "Your UI as a tree",
        "id": "your-ui-as-a-tree"
      },
      {
        "level": 2,
        "text": "Ready to learn this topic?",
        "id": ""
      },
      {
        "level": 2,
        "text": "What’s next?",
        "id": "whats-next"
      },
      {
        "level": 3,
        "text": "In this chapter",
        "id": ""
      }
    ],
    "codeBlocks": [
      {
        "language": "text",
        "code": "function Profile() {\n  return (\n    <img\n      src=\"https://i.imgur.com/MK3eW3As.jpg\"\n      alt=\"Katherine Johnson\"\n    />\n  );\n}\n\nexport default function Gallery() {\n  return (\n    <section>\n      <h1>Amazing scientists</h1>\n      <Profile />\n      <Profile />\n      <Profile />\n    </section>\n  );\n}"
      },
      {
        "language": "text",
        "code": "import Profile from './Profile.js';\n\nexport default function Gallery() {\n  return (\n    <section>\n      <h1>Amazing scientists</h1>\n      <Profile />\n      <Profile />\n      <Profile />\n    </section>\n  );\n}"
      },
      {
        "language": "text",
        "code": "export default function TodoList() {\n  return (\n    // This doesn't quite work!\n    <h1>Hedy Lamarr's Todos</h1>\n    <img\n      src=\"https://i.imgur.com/yXOvdOSs.jpg\"\n      alt=\"Hedy Lamarr\"\n      class=\"photo\"\n    >\n    <ul>\n      <li>Invent new traffic lights\n      <li>Rehearse a movie scene\n      <li>Improve spectrum technology\n    </ul>"
      },
      {
        "language": "text",
        "code": "export default function TodoList() {\n  return (\n    <>\n      <h1>Hedy Lamarr's Todos</h1>\n      <img\n        src=\"https://i.imgur.com/yXOvdOSs.jpg\"\n        alt=\"Hedy Lamarr\"\n        className=\"photo\"\n      />\n      <ul>\n        <li>Invent new traffic lights</li>\n        <li>Rehearse a movie scene</li>\n        <li>Improve spectrum technology</li>\n      </ul>\n    </>\n  );\n}"
      },
      {
        "language": "text",
        "code": "const person = {\n  name: 'Gregorio Y. Zara',\n  theme: {\n    backgroundColor: 'black',\n    color: 'pink'\n  }\n};\n\nexport default function TodoList() {\n  return (\n    <div style={person.theme}>\n      <h1>{person.name}'s Todos</h1>\n      <img\n        className=\"avatar\"\n        src=\"https://i.imgur.com/7vQD0fPs.jpg\"\n        alt=\"Gregorio Y. Zara\"\n      />\n      <ul>\n        <li>Improve the videophone</li>\n        <li>Prepare aeronautics lectures</li>\n        <li>Work on the alcohol-fuelled engine</li>\n      </ul>\n    </div>\n  );\n}"
      },
      {
        "language": "text",
        "code": "import { getImageUrl } from './utils.js'\n\nexport default function Profile() {\n  return (\n    <Card>\n      <Avatar\n        size={100}\n        person={{\n          name: 'Katsuko Saruhashi',\n          imageId: 'YfeOqp2'\n        }}\n      />\n    </Card>\n  );\n}\n\nfunction Avatar({ person, size }) {\n  return (\n    <img\n      className=\"avatar\"\n      src={getImageUrl(person)}\n      alt={person.name}\n      width={size}\n      height={size}\n    />\n  );\n}\n\nfunction Card({ children }) {\n  return (\n    <div className=\"card\">\n      {children}\n    </div>\n  );\n}"
      },
      {
        "language": "text",
        "code": "function Item({ name, isPacked }) {\n  return (\n    <li className=\"item\">\n      {name} {isPacked && '✅'}\n    </li>\n  );\n}\n\nexport default function PackingList() {\n  return (\n    <section>\n      <h1>Sally Ride's Packing List</h1>\n      <ul>\n        <Item\n          isPacked={true}\n          name=\"Space suit\"\n        />\n        <Item\n          isPacked={true}\n          name=\"Helmet with a golden leaf\"\n        />\n        <Item\n          isPacked={false}\n          name=\"Photo of Tam\"\n        />\n      </ul>\n    </section>\n  );\n}"
      },
      {
        "language": "text",
        "code": "import { people } from './data.js';\nimport { getImageUrl } from './utils.js';\n\nexport default function List() {\n  const listItems = people.map(person =>\n    <li key={person.id}>\n      <img\n        src={getImageUrl(person)}\n        alt={person.name}\n      />\n      <p>\n        <b>{person.name}:</b>\n        {' ' + person.profession + ' '}\n        known for {person.accomplishment}\n      </p>\n    </li>\n  );\n  return (\n    <article>\n      <h1>Scientists</h1>\n      <ul>{listItems}</ul>\n    </article>\n  );\n}"
      },
      {
        "language": "text",
        "code": "let guest = 0;\n\nfunction Cup() {\n  // Bad: changing a preexisting variable!\n  guest = guest + 1;\n  return <h2>Tea cup for guest #{guest}</h2>;\n}\n\nexport default function TeaSet() {\n  return (\n    <>\n      <Cup />\n      <Cup />\n      <Cup />\n    </>\n  );\n}"
      },
      {
        "language": "text",
        "code": "function Cup({ guest }) {\n  return <h2>Tea cup for guest #{guest}</h2>;\n}\n\nexport default function TeaSet() {\n  return (\n    <>\n      <Cup guest={1} />\n      <Cup guest={2} />\n      <Cup guest={3} />\n    </>\n  );\n}"
      }
    ],
    "links": [
      {
        "text": "Learn React",
        "href": "/learn"
      },
      {
        "text": "How to write your first React component",
        "href": "/learn/your-first-component"
      },
      {
        "text": "When and how to create multi-component files",
        "href": "/learn/importing-and-exporting-components"
      },
      {
        "text": "How to add markup to JavaScript with JSX",
        "href": "/learn/writing-markup-with-jsx"
      },
      {
        "text": "How to use curly braces with JSX to access JavaScript functionality from your components",
        "href": "/learn/javascript-in-jsx-with-curly-braces"
      },
      {
        "text": "How to configure components with props",
        "href": "/learn/passing-props-to-a-component"
      },
      {
        "text": "How to conditionally render components",
        "href": "/learn/conditional-rendering"
      },
      {
        "text": "How to render multiple components at a time",
        "href": "/learn/rendering-lists"
      },
      {
        "text": "How to avoid confusing bugs by keeping components pure",
        "href": "/learn/keeping-components-pure"
      },
      {
        "text": "Why understanding your UI as trees is useful",
        "href": "/learn/understanding-your-ui-as-a-tree"
      },
      {
        "text": "Your First Component",
        "href": "/learn/your-first-component"
      },
      {
        "text": "Read More",
        "href": "/learn/your-first-component"
      },
      {
        "text": "Importing and Exporting Components",
        "href": "/learn/importing-and-exporting-components"
      },
      {
        "text": "Read More",
        "href": "/learn/importing-and-exporting-components"
      },
      {
        "text": "converter",
        "href": "https://transform.tools/html-to-jsx"
      },
      {
        "text": "Writing Markup with JSX",
        "href": "/learn/writing-markup-with-jsx"
      },
      {
        "text": "Read More",
        "href": "/learn/writing-markup-with-jsx"
      },
      {
        "text": "JavaScript in JSX with Curly Braces",
        "href": "/learn/javascript-in-jsx-with-curly-braces"
      },
      {
        "text": "Read More",
        "href": "/learn/javascript-in-jsx-with-curly-braces"
      },
      {
        "text": "Passing Props to a Component",
        "href": "/learn/passing-props-to-a-component"
      },
      {
        "text": "Read More",
        "href": "/learn/passing-props-to-a-component"
      },
      {
        "text": "Conditional Rendering",
        "href": "/learn/conditional-rendering"
      },
      {
        "text": "Read More",
        "href": "/learn/conditional-rendering"
      },
      {
        "text": "Rendering Lists",
        "href": "/learn/rendering-lists"
      },
      {
        "text": "Read More",
        "href": "/learn/rendering-lists"
      },
      {
        "text": "Keeping Components Pure",
        "href": "/learn/keeping-components-pure"
      },
      {
        "text": "Read More",
        "href": "/learn/keeping-components-pure"
      },
      {
        "text": "Your UI as a Tree",
        "href": "/learn/understanding-your-ui-as-a-tree"
      },
      {
        "text": "Read More",
        "href": "/learn/understanding-your-ui-as-a-tree"
      },
      {
        "text": "Your First Component",
        "href": "/learn/your-first-component"
      },
      {
        "text": "Adding Interactivity",
        "href": "/learn/adding-interactivity"
      },
      {
        "text": "NextYour First Component",
        "href": "/learn/your-first-component"
      }
    ],
    "meta": {
      "description": "",
      "keywords": ""
    },
    "summary": "Learn ReactDescribing the UIReact is a JavaScript library for rendering user interfaces (UI). UI is built from small units like buttons, text, and images",
    "tags": [
      "react",
      "angular",
      "javascript",
      "typescript",
      "css",
      "html",
      "node",
      "webpack",
      "vite",
      "this"
    ],
    "id": "describing-the-ui-react-describingtheui-part-1",
    "quality": 100
  },
  {
    "title": "Adding Interactivity – React",
    "url": "https://react.dev/learn/adding-interactivity",
    "category": "react",
    "content": "Learn ReactAdding InteractivitySome things on the screen update in response to user input. For example, clicking an image gallery switches the active image. In React, data that changes over time is called state. You can add state to any component, and update it as needed. In this chapter, youll learn how to write components that handle interactions, update their state, and display different output over time. In this chapter How to handle user-initiated events How to make components remember information with state How React updates the UI in two phases Why state doesnt update right after you change it How to queue multiple state updates How to update an object in state How to update an array in state Responding to events React lets you add event handlers to your JSX. Event handlers are your own functions that will be triggered in response to user interactions like clicking, hovering, focusing on form inputs, and so on. Built-in components like button only support built-in browser events like onClick. However, you can also create your own components, and give their event handler props any application-specific names that you like. App.jsApp.js Download ResetForkexport default function App() { return ( Toolbar onPlayMovie={() = alert('Playing!')} onUploadImage={() = alert('Uploading!')} / ); } function Toolbar({ onPlayMovie, onUploadImage }) { return ( div Button onClick={onPlayMovie} Play Movie /Button Button onClick={onUploadImage} Upload Image /Button /div ); } function Button({ onClick, children }) { return ( button onClick={onClick} {children} /button ); } Open on CodeSandboxOpen SandboxShow more Ready to learn this topic?Read Responding to Events to learn how to add event handlers.Read More State: a components memory Components often need to change whats on the screen as a result of an interaction. Typing into the form should update the input field, clicking next on an image carousel should change which image is displayed, clicking buy puts a product in the shopping cart. Components need to remember things: the current input value, the current image, the shopping cart. In React, this kind of component-specific memory is called state. You can add state to a component with a useState Hook. Hooks are special functions that let your components use React features (state is one of those features). The useState Hook lets you declare a state variable. It takes the initial state and returns a pair of values: the current state, and a state setter function that lets you update it. const [index, setIndex] = useState(0);const [showMore, setShowMore] = useState(false); Here is how an image gallery uses and updates state on click: App.jsdata.jsApp.js ResetForkimport { useState } from 'react'; import { sculptureList } from './data.js'; export default function Gallery() { const [index, setIndex] = useState(0); const [showMore, setShowMore] = useState(false); const hasNext = index  sculptureList.length - 1; function handleNextClick() { if (hasNext) { setIndex(index + 1); } else { setIndex(0); } } function handleMoreClick() { setShowMore(!showMore); } let sculpture = sculptureList[index]; return (  button onClick={handleNextClick} Next /button h2 i{sculpture.name} /i by {sculpture.artist} /h2 h3 ({index + 1} of {sculptureList.length}) /h3 button onClick={handleMoreClick} {showMore ? 'Hide' : 'Show'} details /button {showMore && p{sculpture.description}/p} img src={sculpture.url} alt={sculpture.alt} / / ); } Show more Ready to learn this topic?Read State: A Components Memory to learn how to remember a value and update it on interaction.Read More Render and commit Before your components are displayed on the screen, they must be rendered by React. Understanding the steps in this process will help you think about how your code executes and explain its behavior. Imagine that your components are cooks in the kitchen, assembling tasty dishes from ingredients. In this scenario, React is the waiter who puts in requests from customers and brings them their orders. This process of requesting and serving UI has three steps: Triggering a render (delivering the diners order to the kitchen) Rendering the component (preparing the order in the kitchen) Committing to the DOM (placing the order on the table) TriggerRenderCommitIllustrated by Rachel Lee Nabors Ready to learn this topic?Read Render and Commit to learn the lifecycle of a UI update.Read More State as a snapshot Unlike regular JavaScript variables, React state behaves more like a snapshot. Setting it does not change the state variable you already have, but instead triggers a re-render. This can be surprising at first! console.log(count); // 0setCount(count + 1); // Request a re-render with 1console.log(count); // Still 0! This behavior helps you avoid subtle bugs. Here is a little chat app. Try to guess what happens if you press Send first and then change the recipient to Bob. Whose name will appear in the alert five seconds later? App.jsApp.js Download ResetForkimport { useState } from 'react'; export default function Form() { const [to, setTo] = useState('Alice'); const [message, setMessage] = useState('Hello'); function handleSubmit(e) { e.preventDefault(); setTimeout(() = { alert(You said ${message} to ${to}); }, 5000); } return ( form onSubmit={handleSubmit} label To:{' '} select value={to} onChange={e = setTo(e.target.value)} option value=\"Alice\"Alice/option option value=\"Bob\"Bob/option /select /label textarea placeholder=\"Message\" value={message} onChange={e = setMessage(e.target.value)} / button type=\"submit\"Send/button /form ); } Show more Ready to learn this topic?Read State as a Snapshot to learn why state appears fixed and unchanging inside the event handlers.Read More Queueing a series of state updates This component is buggy: clicking +3 increments the score only once. App.jsApp.js Download ResetForkimport { useState } from 'react'; export default function Counter() { const [score, setScore] = useState(0); function increment() { setScore(score + 1); } return (  button onClick={() = increment()}+1/button button onClick={() = { increment(); increment(); increment(); }}+3/button h1Score: {score}/h1 / ) } Show more State as a Snapshot explains why this is happening. Setting state requests a new re-render, but does not change it in the already running code. So score continues to be 0 right after you call setScore(score + 1). console.log(score); // 0setScore(score + 1); // setScore(0 + 1);console.log(score); // 0setScore(score + 1); // setScore(0 + 1);console.log(score); // 0setScore(score + 1); // setScore(0 + 1);console.log(score); // 0 You can fix this by passing an updater function when setting state. Notice how replacing setScore(score + 1) with setScore(s = s + 1) fixes the +3 button. This lets you queue multiple state updates. App.jsApp.js Download ResetForkimport { useState } from 'react'; export default function Counter() { const [score, setScore] = useState(0); function increment() { setScore(s = s + 1); } return (  button onClick={() = increment()}+1/button button onClick={() = { increment(); increment(); increment(); }}+3/button h1Score: {score}/h1 / ) } Show more Ready to learn this topic?Read Queueing a Series of State Updates to learn how to queue a sequence of state updates.Read More Updating objects in state State can hold any kind of JavaScript value, including objects. But you shouldnt change objects and arrays that you hold in the React state directly. Instead, when you want to update an object and array, you need to create a new one (or make a copy of an existing one), and then update the state to use that copy. Usually, you will use the ... spread syntax to copy objects and arrays that you want to change. For example, updating a nested object could look like this: App.jsApp.js Download ResetForkimport { useState } from 'react'; export default function Form() { const [person, setPerson] = useState({ name: 'Niki de Saint Phalle', artwork: { title: 'Blue Nana', city: 'Hamburg', image: 'https://i.imgur.com/Sd1AgUOm.jpg', } }); function handleNameChange(e) { setPerson({ ...person, name: e.target.value }); } function handleTitleChange(e) { setPerson({ ...person, artwork: { ...person.artwork, title: e.target.value } }); } function handleCityChange(e) { setPerson({ ...person, artwork: { ...person.artwork, city: e.target.value } }); } function handleImageChange(e) { setPerson({ ...person, artwork: { ...person.artwork, image: e.target.value } }); } return (  label Name: input value={person.name} onChange={handleNameChange} / /label label Title: input value={person.artwork.title} onChange={handleTitleChange} / /label label City: input value={person.artwork.city} onChange={handleCityChange} / /label label Image: input value={person.artwork.image} onChange={handleImageChange} / /label p i{person.artwork.title}/i {' by '} {person.name} br / (located in {person.artwork.city}) /p img src={person.artwork.image} alt={person.artwork.title} / / ); } Show more If copying objects in code gets tedious, you can use a library like Immer to reduce repetitive code: package.jsonApp.jspackage.json ResetFork{ \"dependencies\": { \"immer\": \"1.7.3\", \"react\": \"latest\", \"react-dom\": \"latest\", \"react-scripts\": \"latest\", \"use-immer\": \"0.5.1\" }, \"scripts\": { \"start\": \"react-scripts start\", \"build\": \"react-scripts build\", \"test\": \"react-scripts test --env=jsdom\", \"eject\": \"react-scripts eject\" }, \"devDependencies\": {} } Ready to learn this topic?Read Updating Objects in State to learn how to update objects correctly.Read More Updating arrays in state Arrays are another type of mutable JavaScript objects you can store in state and should treat as read-only. Just like with objects, when you want to update an array stored in state, you need to create a new one (or make a copy of an existing one), and then set state to use the new array: App.jsApp.js Download ResetForkimport { useState } from 'react'; const initialList = [ { id: 0, title: 'Big Bellies', seen: false }, { id: 1, title: 'Lunar Landscape', seen: false }, { id: 2, title: 'Terracotta Army', seen: true }, ]; export default function BucketList() { const [list, setList] = useState( initialList ); function handleToggle(artworkId, nextSeen) { setList(list.map(artwork = { if (artwork.id === artworkId) { return { ...artwork, seen: nextSeen }; } else { return artwork; } })); } return (  h1Art Bucket List/h1 h2My list of art to see:/h2 ItemList artworks={list} onToggle={handleToggle} / / ); } function ItemList({ artworks, onToggle }) { return ( ul {artworks.map(artwork = ( li key={artwork.id} label input type=\"checkbox\" checked={artwork.seen} onChange={e = { onToggle( artwork.id, e.target.checked ); }} / {artwork.title} /label /li ))} /ul ); } Show more If copying arrays in code gets tedious, you can use a library like Immer to reduce repetitive code: package.jsonApp.jspackage.json ResetFork{ \"dependencies\": { \"immer\": \"1.7.3\", \"react\": \"latest\", \"react-dom\": \"latest\", \"react-scripts\": \"latest\", \"use-immer\": \"0.5.1\" }, \"scripts\": { \"start\": \"react-scripts start\", \"build\": \"react-scripts build\", \"test\": \"react-scripts test --env=jsdom\", \"eject\": \"react-scripts eject\" }, \"devDependencies\": {} } Ready to learn this topic?Read Updating Arrays in State to learn how to update arrays correctly.Read More Whats next? Head over to Responding to Events to start reading this chapter page by page! Or, if youre already familiar with these topics, why not read about Managing State?PreviousYour UI as a TreeNextResponding to Events",
    "headings": [
      {
        "level": 1,
        "text": "Adding Interactivity",
        "id": ""
      },
      {
        "level": 2,
        "text": "Responding to events",
        "id": "responding-to-events"
      },
      {
        "level": 2,
        "text": "Ready to learn this topic?",
        "id": ""
      },
      {
        "level": 2,
        "text": "State: a component’s memory",
        "id": "state-a-components-memory"
      },
      {
        "level": 2,
        "text": "Ready to learn this topic?",
        "id": ""
      },
      {
        "level": 2,
        "text": "Render and commit",
        "id": "render-and-commit"
      },
      {
        "level": 2,
        "text": "Ready to learn this topic?",
        "id": ""
      },
      {
        "level": 2,
        "text": "State as a snapshot",
        "id": "state-as-a-snapshot"
      },
      {
        "level": 2,
        "text": "Ready to learn this topic?",
        "id": ""
      },
      {
        "level": 2,
        "text": "Queueing a series of state updates",
        "id": "queueing-a-series-of-state-updates"
      },
      {
        "level": 2,
        "text": "Ready to learn this topic?",
        "id": ""
      },
      {
        "level": 2,
        "text": "Updating objects in state",
        "id": "updating-objects-in-state"
      },
      {
        "level": 2,
        "text": "Ready to learn this topic?",
        "id": ""
      },
      {
        "level": 2,
        "text": "Updating arrays in state",
        "id": "updating-arrays-in-state"
      },
      {
        "level": 2,
        "text": "Ready to learn this topic?",
        "id": ""
      },
      {
        "level": 2,
        "text": "What’s next?",
        "id": "whats-next"
      },
      {
        "level": 3,
        "text": "In this chapter",
        "id": ""
      }
    ],
    "codeBlocks": [
      {
        "language": "text",
        "code": "export default function App() {\n  return (\n    <Toolbar\n      onPlayMovie={() => alert('Playing!')}\n      onUploadImage={() => alert('Uploading!')}\n    />\n  );\n}\n\nfunction Toolbar({ onPlayMovie, onUploadImage }) {\n  return (\n    <div>\n      <Button onClick={onPlayMovie}>\n        Play Movie\n      </Button>\n      <Button onClick={onUploadImage}>\n        Upload Image\n      </Button>\n    </div>\n  );\n}\n\nfunction Button({ onClick, children }) {\n  return (\n    <button onClick={onClick}>\n      {children}\n    </button>\n  );\n}"
      },
      {
        "language": "text",
        "code": "const [index, setIndex] = useState(0);const [showMore, setShowMore] = useState(false);"
      },
      {
        "language": "text",
        "code": "const [index, setIndex] = useState(0);const [showMore, setShowMore] = useState(false);"
      },
      {
        "language": "text",
        "code": "import { useState } from 'react';\nimport { sculptureList } from './data.js';\n\nexport default function Gallery() {\n  const [index, setIndex] = useState(0);\n  const [showMore, setShowMore] = useState(false);\n  const hasNext = index < sculptureList.length - 1;\n\n  function handleNextClick() {\n    if (hasNext) {\n      setIndex(index + 1);\n    } else {\n      setIndex(0);\n    }\n  }\n\n  function handleMoreClick() {\n    setShowMore(!showMore);\n  }\n\n  let sculpture = sculptureList[index];\n  return (\n    <>\n      <button onClick={handleNextClick}>\n        Next\n      </button>\n      <h2>\n        <i>{sculpture.name} </i>\n        by {sculpture.artist}\n      </h2>\n      <h3>\n        ({index + 1} of {sculptureList.length})\n      </h3>\n      <button onClick={handleMoreClick}>\n        {showMore ? 'Hide' : 'Show'} details\n      </button>\n      {showMore && <p>{sculpture.description}</p>}\n      <img\n        src={sculpture.url}\n        alt={sculpture.alt}\n      />\n    </>\n  );\n}"
      },
      {
        "language": "text",
        "code": "console.log(count);  // 0setCount(count + 1); // Request a re-render with 1console.log(count);  // Still 0!"
      },
      {
        "language": "text",
        "code": "console.log(count);  // 0setCount(count + 1); // Request a re-render with 1console.log(count);  // Still 0!"
      },
      {
        "language": "text",
        "code": "import { useState } from 'react';\n\nexport default function Form() {\n  const [to, setTo] = useState('Alice');\n  const [message, setMessage] = useState('Hello');\n\n  function handleSubmit(e) {\n    e.preventDefault();\n    setTimeout(() => {\n      alert(`You said ${message} to ${to}`);\n    }, 5000);\n  }\n\n  return (\n    <form onSubmit={handleSubmit}>\n      <label>\n        To:{' '}\n        <select\n          value={to}\n          onChange={e => setTo(e.target.value)}>\n          <option value=\"Alice\">Alice</option>\n          <option value=\"Bob\">Bob</option>\n        </select>\n      </label>\n      <textarea\n        placeholder=\"Message\"\n        value={message}\n        onChange={e => setMessage(e.target.value)}\n      />\n      <button type=\"submit\">Send</button>\n    </form>\n  );\n}"
      },
      {
        "language": "text",
        "code": "import { useState } from 'react';\n\nexport default function Counter() {\n  const [score, setScore] = useState(0);\n\n  function increment() {\n    setScore(score + 1);\n  }\n\n  return (\n    <>\n      <button onClick={() => increment()}>+1</button>\n      <button onClick={() => {\n        increment();\n        increment();\n        increment();\n      }}>+3</button>\n      <h1>Score: {score}</h1>\n    </>\n  )\n}"
      },
      {
        "language": "text",
        "code": "setScore(score + 1)"
      },
      {
        "language": "text",
        "code": "console.log(score);  // 0setScore(score + 1); // setScore(0 + 1);console.log(score);  // 0setScore(score + 1); // setScore(0 + 1);console.log(score);  // 0setScore(score + 1); // setScore(0 + 1);console.log(score);  // 0"
      },
      {
        "language": "text",
        "code": "console.log(score);  // 0setScore(score + 1); // setScore(0 + 1);console.log(score);  // 0setScore(score + 1); // setScore(0 + 1);console.log(score);  // 0setScore(score + 1); // setScore(0 + 1);console.log(score);  // 0"
      },
      {
        "language": "text",
        "code": "setScore(score + 1)"
      },
      {
        "language": "text",
        "code": "setScore(s => s + 1)"
      },
      {
        "language": "text",
        "code": "import { useState } from 'react';\n\nexport default function Counter() {\n  const [score, setScore] = useState(0);\n\n  function increment() {\n    setScore(s => s + 1);\n  }\n\n  return (\n    <>\n      <button onClick={() => increment()}>+1</button>\n      <button onClick={() => {\n        increment();\n        increment();\n        increment();\n      }}>+3</button>\n      <h1>Score: {score}</h1>\n    </>\n  )\n}"
      },
      {
        "language": "text",
        "code": "import { useState } from 'react';\n\nexport default function Form() {\n  const [person, setPerson] = useState({\n    name: 'Niki de Saint Phalle',\n    artwork: {\n      title: 'Blue Nana',\n      city: 'Hamburg',\n      image: 'https://i.imgur.com/Sd1AgUOm.jpg',\n    }\n  });\n\n  function handleNameChange(e) {\n    setPerson({\n      ...person,\n      name: e.target.value\n    });\n  }\n\n  function handleTitleChange(e) {\n    setPerson({\n      ...person,\n      artwork: {\n        ...person.artwork,\n        title: e.target.value\n      }\n    });\n  }\n\n  function handleCityChange(e) {\n    setPerson({\n      ...person,\n      artwork: {\n        ...person.artwork,\n        city: e.target.value\n      }\n    });\n  }\n\n  function handleImageChange(e) {\n    setPerson({\n      ...person,\n      artwork: {\n        ...person.artwork,\n        image: e.target.value\n      }\n    });\n  }\n\n  return (\n    <>\n      <label>\n        Name:\n        <input\n          value={person.name}\n          onChange={handleNameChange}\n        />\n      </label>\n      <label>\n        Title:\n        <input\n          value={person.artwork.title}\n          onChange={handleTitleChange}\n        />\n      </label>\n      <label>\n        City:\n        <input\n          value={person.artwork.city}\n          onChange={handleCityChange}\n        />\n      </label>\n      <label>\n        Image:\n        <input\n          value={person.artwork.image}\n          onChange={handleImageChange}\n        />\n      </label>\n      <p>\n        <i>{person.artwork.title}</i>\n        {' by '}\n        {person.name}\n        <br />\n        (located in {person.artwork.city})\n      </p>\n      <img\n        src={person.artwork.image}\n        alt={person.artwork.title}\n      />\n    </>\n  );\n}"
      },
      {
        "language": "text",
        "code": "{\n  \"dependencies\": {\n    \"immer\": \"1.7.3\",\n    \"react\": \"latest\",\n    \"react-dom\": \"latest\",\n    \"react-scripts\": \"latest\",\n    \"use-immer\": \"0.5.1\"\n  },\n  \"scripts\": {\n    \"start\": \"react-scripts start\",\n    \"build\": \"react-scripts build\",\n    \"test\": \"react-scripts test --env=jsdom\",\n    \"eject\": \"react-scripts eject\"\n  },\n  \"devDependencies\": {}\n}"
      },
      {
        "language": "text",
        "code": "import { useState } from 'react';\n\nconst initialList = [\n  { id: 0, title: 'Big Bellies', seen: false },\n  { id: 1, title: 'Lunar Landscape', seen: false },\n  { id: 2, title: 'Terracotta Army', seen: true },\n];\n\nexport default function BucketList() {\n  const [list, setList] = useState(\n    initialList\n  );\n\n  function handleToggle(artworkId, nextSeen) {\n    setList(list.map(artwork => {\n      if (artwork.id === artworkId) {\n        return { ...artwork, seen: nextSeen };\n      } else {\n        return artwork;\n      }\n    }));\n  }\n\n  return (\n    <>\n      <h1>Art Bucket List</h1>\n      <h2>My list of art to see:</h2>\n      <ItemList\n        artworks={list}\n        onToggle={handleToggle} />\n    </>\n  );\n}\n\nfunction ItemList({ artworks, onToggle }) {\n  return (\n    <ul>\n      {artworks.map(artwork => (\n        <li key={artwork.id}>\n          <label>\n            <input\n              type=\"checkbox\"\n              checked={artwork.seen}\n              onChange={e => {\n                onToggle(\n                  artwork.id,\n                  e.target.checked\n                );\n              }}\n            />\n            {artwork.title}\n          </label>\n        </li>\n      ))}\n    </ul>\n  );\n}"
      },
      {
        "language": "text",
        "code": "{\n  \"dependencies\": {\n    \"immer\": \"1.7.3\",\n    \"react\": \"latest\",\n    \"react-dom\": \"latest\",\n    \"react-scripts\": \"latest\",\n    \"use-immer\": \"0.5.1\"\n  },\n  \"scripts\": {\n    \"start\": \"react-scripts start\",\n    \"build\": \"react-scripts build\",\n    \"test\": \"react-scripts test --env=jsdom\",\n    \"eject\": \"react-scripts eject\"\n  },\n  \"devDependencies\": {}\n}"
      }
    ],
    "links": [
      {
        "text": "Learn React",
        "href": "/learn"
      },
      {
        "text": "How to handle user-initiated events",
        "href": "/learn/responding-to-events"
      },
      {
        "text": "How to make components “remember” information with state",
        "href": "/learn/state-a-components-memory"
      },
      {
        "text": "How React updates the UI in two phases",
        "href": "/learn/render-and-commit"
      },
      {
        "text": "Why state doesn’t update right after you change it",
        "href": "/learn/state-as-a-snapshot"
      },
      {
        "text": "How to queue multiple state updates",
        "href": "/learn/queueing-a-series-of-state-updates"
      },
      {
        "text": "How to update an object in state",
        "href": "/learn/updating-objects-in-state"
      },
      {
        "text": "How to update an array in state",
        "href": "/learn/updating-arrays-in-state"
      },
      {
        "text": "Responding to Events",
        "href": "/learn/responding-to-events"
      },
      {
        "text": "Read More",
        "href": "/learn/responding-to-events"
      },
      {
        "text": "useState",
        "href": "/reference/react/useState"
      },
      {
        "text": "State: A Component’s Memory",
        "href": "/learn/state-a-components-memory"
      },
      {
        "text": "Read More",
        "href": "/learn/state-a-components-memory"
      },
      {
        "text": "Rachel Lee Nabors",
        "href": "https://nearestnabors.com/"
      },
      {
        "text": "Render and Commit",
        "href": "/learn/render-and-commit"
      },
      {
        "text": "Read More",
        "href": "/learn/render-and-commit"
      },
      {
        "text": "State as a Snapshot",
        "href": "/learn/state-as-a-snapshot"
      },
      {
        "text": "Read More",
        "href": "/learn/state-as-a-snapshot"
      },
      {
        "text": "State as a Snapshot",
        "href": "/learn/state-as-a-snapshot"
      },
      {
        "text": "Queueing a Series of State Updates",
        "href": "/learn/queueing-a-series-of-state-updates"
      },
      {
        "text": "Read More",
        "href": "/learn/queueing-a-series-of-state-updates"
      },
      {
        "text": "Immer",
        "href": "https://github.com/immerjs/use-immer"
      },
      {
        "text": "Updating Objects in State",
        "href": "/learn/updating-objects-in-state"
      },
      {
        "text": "Read More",
        "href": "/learn/updating-objects-in-state"
      },
      {
        "text": "Immer",
        "href": "https://github.com/immerjs/use-immer"
      },
      {
        "text": "Updating Arrays in State",
        "href": "/learn/updating-arrays-in-state"
      },
      {
        "text": "Read More",
        "href": "/learn/updating-arrays-in-state"
      },
      {
        "text": "Responding to Events",
        "href": "/learn/responding-to-events"
      },
      {
        "text": "Managing State",
        "href": "/learn/managing-state"
      },
      {
        "text": "PreviousYour UI as a Tree",
        "href": "/learn/understanding-your-ui-as-a-tree"
      },
      {
        "text": "NextResponding to Events",
        "href": "/learn/responding-to-events"
      }
    ],
    "meta": {
      "description": "",
      "keywords": ""
    },
    "summary": "Learn ReactAdding InteractivitySome things on the screen update in response to user input. For example, clicking an image gallery switches the active image",
    "tags": [
      "react",
      "angular",
      "javascript",
      "typescript",
      "html",
      "vite",
      "this",
      "ready",
      "learn",
      "topic"
    ],
    "id": "adding-interactivity-react-addinginteractivity-part-1",
    "quality": 100
  },
  {
    "title": "Managing State – React",
    "url": "https://react.dev/learn/managing-state",
    "category": "react",
    "content": "Learn ReactManaging StateIntermediateAs your application grows, it helps to be more intentional about how your state is organized and how the data flows between your components. Redundant or duplicate state is a common source of bugs. In this chapter, youll learn how to structure your state well, how to keep your state update logic maintainable, and how to share state between distant components. In this chapter How to think about UI changes as state changes How to structure state well How to lift state up to share it between components How to control whether the state gets preserved or reset How to consolidate complex state logic in a function How to pass information without prop drilling How to scale state management as your app grows Reacting to input with state With React, you wont modify the UI from code directly. For example, you wont write commands like disable the button, enable the button, show the success message, etc. Instead, you will describe the UI you want to see for the different visual states of your component (initial state, typing state, success state), and then trigger the state changes in response to user input. This is similar to how designers think about UI. Here is a quiz form built using React. Note how it uses the status state variable to determine whether to enable or disable the submit button, and whether to show the success message instead. App.jsApp.js Download ResetForkimport { useState } from 'react'; export default function Form() { const [answer, setAnswer] = useState(''); const [error, setError] = useState(null); const [status, setStatus] = useState('typing'); if (status === 'success') { return h1That's right!/h1 } async function handleSubmit(e) { e.preventDefault(); setStatus('submitting'); try { await submitForm(answer); setStatus('success'); } catch (err) { setStatus('typing'); setError(err); } } function handleTextareaChange(e) { setAnswer(e.target.value); } return (  h2City quiz/h2 p In which city is there a billboard that turns air into drinkable water? /p form onSubmit={handleSubmit} textarea value={answer} onChange={handleTextareaChange} disabled={status === 'submitting'} / br / button disabled={ answer.length === 0  status === 'submitting' } Submit /button {error !== null && p className=\"Error\" {error.message} /p } /form / ); } function submitForm(answer) { // Pretend it's hitting the network. return new Promise((resolve, reject) = { setTimeout(() = { let shouldError = answer.toLowerCase() !== 'lima' if (shouldError) { reject(new Error('Good guess but a wrong answer. Try again!')); } else { resolve(); } }, 1500); }); } Show more Ready to learn this topic?Read Reacting to Input with State to learn how to approach interactions with a state-driven mindset.Read More Choosing the state structure Structuring state well can make a difference between a component that is pleasant to modify and debug, and one that is a constant source of bugs. The most important principle is that state shouldnt contain redundant or duplicated information. If theres unnecessary state, its easy to forget to update it, and introduce bugs! For example, this form has a redundant fullName state variable: App.jsApp.js Download ResetForkimport { useState } from 'react'; export default function Form() { const [firstName, setFirstName] = useState(''); const [lastName, setLastName] = useState(''); const [fullName, setFullName] = useState(''); function handleFirstNameChange(e) { setFirstName(e.target.value); setFullName(e.target.value + ' ' + lastName); } function handleLastNameChange(e) { setLastName(e.target.value); setFullName(firstName + ' ' + e.target.value); } return (  h2Lets check you in/h2 label First name:{' '} input value={firstName} onChange={handleFirstNameChange} / /label label Last name:{' '} input value={lastName} onChange={handleLastNameChange} / /label p Your ticket will be issued to: b{fullName}/b /p / ); } Show more You can remove it and simplify the code by calculating fullName while the component is rendering: App.jsApp.js Download ResetForkimport { useState } from 'react'; export default function Form() { const [firstName, setFirstName] = useState(''); const [lastName, setLastName] = useState(''); const fullName = firstName + ' ' + lastName; function handleFirstNameChange(e) { setFirstName(e.target.value); } function handleLastNameChange(e) { setLastName(e.target.value); } return (  h2Lets check you in/h2 label First name:{' '} input value={firstName} onChange={handleFirstNameChange} / /label label Last name:{' '} input value={lastName} onChange={handleLastNameChange} / /label p Your ticket will be issued to: b{fullName}/b /p / ); } Show more This might seem like a small change, but many bugs in React apps are fixed this way. Ready to learn this topic?Read Choosing the State Structure to learn how to design the state shape to avoid bugs.Read More Sharing state between components Sometimes, you want the state of two components to always change together. To do it, remove state from both of them, move it to their closest common parent, and then pass it down to them via props. This is known as lifting state up, and its one of the most common things you will do writing React code. In this example, only one panel should be active at a time. To achieve this, instead of keeping the active state inside each individual panel, the parent component holds the state and specifies the props for its children. App.jsApp.js Download ResetForkimport { useState } from 'react'; export default function Accordion() { const [activeIndex, setActiveIndex] = useState(0); return (  h2Almaty, Kazakhstan/h2 Panel title=\"About\" isActive={activeIndex === 0} onShow={() = setActiveIndex(0)}  With a population of about 2 million, Almaty is Kazakhstan's largest city. From 1929 to 1997, it was its capital city. /Panel Panel title=\"Etymology\" isActive={activeIndex === 1} onShow={() = setActiveIndex(1)}  The name comes from span lang=\"kk-KZ\"/span, the Kazakh word for \"apple\" and is often translated as \"full of apples\". In fact, the region surrounding Almaty is thought to be the ancestral home of the apple, and the wild i lang=\"la\"Malus sieversii/i is considered a likely candidate for the ancestor of the modern domestic apple. /Panel / ); } function Panel({ title, children, isActive, onShow }) { return ( section className=\"panel\" h3{title}/h3 {isActive ? ( p{children}/p ) : ( button onClick={onShow} Show /button )} /section ); } Show more Ready to learn this topic?Read Sharing State Between Components to learn how to lift state up and keep components in sync.Read More Preserving and resetting state When you re-render a component, React needs to decide which parts of the tree to keep (and update), and which parts to discard or re-create from scratch. In most cases, Reacts automatic behavior works well enough. By default, React preserves the parts of the tree that match up with the previously rendered component tree. However, sometimes this is not what you want. In this chat app, typing a message and then switching the recipient does not reset the input. This can make the user accidentally send a message to the wrong person: App.jsContactList.jsChat.jsApp.js ResetForkimport { useState } from 'react'; import Chat from './Chat.js'; import ContactList from './ContactList.js'; export default function Messenger() { const [to, setTo] = useState(contacts[0]); return ( div ContactList contacts={contacts} selectedContact={to} onSelect={contact = setTo(contact)} / Chat contact={to} / /div ) } const contacts = [ { name: 'Taylor', email: 'taylor@mail.com' }, { name: 'Alice', email: 'alice@mail.com' }, { name: 'Bob', email: 'bob@mail.com' } ]; Show more React lets you override the default behavior, and force a component to reset its state by passing it a different key, like Chat key={email} /. This tells React that if the recipient is different, it should be considered a different Chat component that needs to be re-created from scratch with the new data (and UI like inputs). Now switching between the recipients resets the input fieldeven though you render the same component. App.jsContactList.jsChat.jsApp.js ResetForkimport { useState } from 'react'; import Chat from './Chat.js'; import ContactList from './ContactList.js'; export default function Messenger() { const [to, setTo] = useState(contacts[0]); return ( div ContactList contacts={contacts} selectedContact={to} onSelect={contact = setTo(contact)} / Chat key={to.email} contact={to} / /div ) } const contacts = [ { name: 'Taylor', email: 'taylor@mail.com' }, { name: 'Alice', email: 'alice@mail.com' }, { name: 'Bob', email: 'bob@mail.com' } ]; Show more Ready to learn this topic?Read Preserving and Resetting State to learn the lifetime of state and how to control it.Read More Extracting state logic into a reducer Components with many state updates spread across many event handlers can get overwhelming. For these cases, you can consolidate all the state update logic outside your component in a single function, called reducer. Your event handlers become concise because they only specify the user actions. At the bottom of the file, the reducer function specifies how the state should update in response to each action! App.jsApp.js ResetForkimport { useReducer } from 'react'; import AddTask from './AddTask.js'; import TaskList from './TaskList.js'; export default function TaskApp() { const [tasks, dispatch] = useReducer( tasksReducer, initialTasks ); function handleAddTask(text) { dispatch({ type: 'added', id: nextId++, text: text, }); } function handleChangeTask(task) { dispatch({ type: 'changed', task: task }); } function handleDeleteTask(taskId) { dispatch({ type: 'deleted', id: taskId }); } return (  h1Prague itinerary/h1 AddTask onAddTask={handleAddTask} / TaskList tasks={tasks} onChangeTask={handleChangeTask} onDeleteTask={handleDeleteTask} / / ); } function tasksReducer(tasks, action) { switch (action.type) { case 'added': { return [...tasks, { id: action.id, text: action.text, done: false }]; } case 'changed': { return tasks.map(t = { if (t.id === action.task.id) { return action.task; } else { return t; } }); } case 'deleted': { return tasks.filter(t = t.id !== action.id); } default: { throw Error('Unknown action: ' + action.type); } } } let nextId = 3; const initialTasks = [ { id: 0, text: 'Visit Kafka Museum', done: true }, { id: 1, text: 'Watch a puppet show', done: false }, { id: 2, text: 'Lennon Wall pic', done: false } ]; Show more Ready to learn this topic?Read Extracting State Logic into a Reducer to learn how to consolidate logic in the reducer function.Read More Passing data deeply with context Usually, you will pass information from a parent component to a child component via props. But passing props can become inconvenient if you need to pass some prop through many components, or if many components need the same information. Context lets the parent component make some information available to any component in the tree below itno matter how deep it iswithout passing it explicitly through props. Here, the Heading component determines its heading level by asking the closest Section for its level. Each Section tracks its own level by asking the parent Section and adding one to it. Every Section provides information to all components below it without passing propsit does that through context. App.jsSection.jsHeading.jsLevelContext.jsApp.js ResetForkimport Heading from './Heading.js'; import Section from './Section.js'; export default function Page() { return ( Section HeadingTitle/Heading Section HeadingHeading/Heading HeadingHeading/Heading HeadingHeading/Heading Section HeadingSub-heading/Heading HeadingSub-heading/Heading HeadingSub-heading/Heading Section HeadingSub-sub-heading/Heading HeadingSub-sub-heading/Heading HeadingSub-sub-heading/Heading /Section /Section /Section /Section ); } Show more Ready to learn this topic?Read Passing Data Deeply with Context to learn about using context as an alternative to passing props.Read More Scaling up with reducer and context Reducers let you consolidate a components state update logic. Context lets you pass information deep down to other components. You can combine reducers and context together to manage state of a complex screen. With this approach, a parent component with complex state manages it with a reducer. Other components anywhere deep in the tree can read its state via context. They can also dispatch actions to update that state. App.jsTasksContext.jsAddTask.jsTaskList.jsApp.js ResetForkimport AddTask from './AddTask.js'; import TaskList from './TaskList.js'; import { TasksProvider } from './TasksContext.js'; export default function TaskApp() { return ( TasksProvider h1Day off in Kyoto/h1 AddTask / TaskList / /TasksProvider ); } Ready to learn this topic?Read Scaling Up with Reducer and Context to learn how state management scales in a growing app.Read More Whats next? Head over to Reacting to Input with State to start reading this chapter page by page! Or, if youre already familiar with these topics, why not read about Escape Hatches?PreviousUpdating Arrays in StateNextReacting to Input with State",
    "headings": [
      {
        "level": 1,
        "text": "Managing State",
        "id": ""
      },
      {
        "level": 2,
        "text": "Reacting to input with state",
        "id": "reacting-to-input-with-state"
      },
      {
        "level": 2,
        "text": "Ready to learn this topic?",
        "id": ""
      },
      {
        "level": 2,
        "text": "Choosing the state structure",
        "id": "choosing-the-state-structure"
      },
      {
        "level": 2,
        "text": "Ready to learn this topic?",
        "id": ""
      },
      {
        "level": 2,
        "text": "Sharing state between components",
        "id": "sharing-state-between-components"
      },
      {
        "level": 2,
        "text": "Ready to learn this topic?",
        "id": ""
      },
      {
        "level": 2,
        "text": "Preserving and resetting state",
        "id": "preserving-and-resetting-state"
      },
      {
        "level": 2,
        "text": "Ready to learn this topic?",
        "id": ""
      },
      {
        "level": 2,
        "text": "Extracting state logic into a reducer",
        "id": "extracting-state-logic-into-a-reducer"
      },
      {
        "level": 2,
        "text": "Ready to learn this topic?",
        "id": ""
      },
      {
        "level": 2,
        "text": "Passing data deeply with context",
        "id": "passing-data-deeply-with-context"
      },
      {
        "level": 2,
        "text": "Ready to learn this topic?",
        "id": ""
      },
      {
        "level": 2,
        "text": "Scaling up with reducer and context",
        "id": "scaling-up-with-reducer-and-context"
      },
      {
        "level": 2,
        "text": "Ready to learn this topic?",
        "id": ""
      },
      {
        "level": 2,
        "text": "What’s next?",
        "id": "whats-next"
      },
      {
        "level": 3,
        "text": "In this chapter",
        "id": ""
      }
    ],
    "codeBlocks": [
      {
        "language": "text",
        "code": "import { useState } from 'react';\n\nexport default function Form() {\n  const [answer, setAnswer] = useState('');\n  const [error, setError] = useState(null);\n  const [status, setStatus] = useState('typing');\n\n  if (status === 'success') {\n    return <h1>That's right!</h1>\n  }\n\n  async function handleSubmit(e) {\n    e.preventDefault();\n    setStatus('submitting');\n    try {\n      await submitForm(answer);\n      setStatus('success');\n    } catch (err) {\n      setStatus('typing');\n      setError(err);\n    }\n  }\n\n  function handleTextareaChange(e) {\n    setAnswer(e.target.value);\n  }\n\n  return (\n    <>\n      <h2>City quiz</h2>\n      <p>\n        In which city is there a billboard that turns air into drinkable water?\n      </p>\n      <form onSubmit={handleSubmit}>\n        <textarea\n          value={answer}\n          onChange={handleTextareaChange}\n          disabled={status === 'submitting'}\n        />\n        <br />\n        <button disabled={\n          answer.length === 0 ||\n          status === 'submitting'\n        }>\n          Submit\n        </button>\n        {error !== null &&\n          <p className=\"Error\">\n            {error.message}\n          </p>\n        }\n      </form>\n    </>\n  );\n}\n\nfunction submitForm(answer) {\n  // Pretend it's hitting the network.\n  return new Promise((resolve, reject) => {\n    setTimeout(() => {\n      let shouldError = answer.toLowerCase() !== 'lima'\n      if (shouldError) {\n        reject(new Error('Good guess but a wrong answer. Try again!'));\n      } else {\n        resolve();\n      }\n    }, 1500);\n  });\n}"
      },
      {
        "language": "text",
        "code": "import { useState } from 'react';\n\nexport default function Form() {\n  const [firstName, setFirstName] = useState('');\n  const [lastName, setLastName] = useState('');\n  const [fullName, setFullName] = useState('');\n\n  function handleFirstNameChange(e) {\n    setFirstName(e.target.value);\n    setFullName(e.target.value + ' ' + lastName);\n  }\n\n  function handleLastNameChange(e) {\n    setLastName(e.target.value);\n    setFullName(firstName + ' ' + e.target.value);\n  }\n\n  return (\n    <>\n      <h2>Let’s check you in</h2>\n      <label>\n        First name:{' '}\n        <input\n          value={firstName}\n          onChange={handleFirstNameChange}\n        />\n      </label>\n      <label>\n        Last name:{' '}\n        <input\n          value={lastName}\n          onChange={handleLastNameChange}\n        />\n      </label>\n      <p>\n        Your ticket will be issued to: <b>{fullName}</b>\n      </p>\n    </>\n  );\n}"
      },
      {
        "language": "text",
        "code": "import { useState } from 'react';\n\nexport default function Form() {\n  const [firstName, setFirstName] = useState('');\n  const [lastName, setLastName] = useState('');\n\n  const fullName = firstName + ' ' + lastName;\n\n  function handleFirstNameChange(e) {\n    setFirstName(e.target.value);\n  }\n\n  function handleLastNameChange(e) {\n    setLastName(e.target.value);\n  }\n\n  return (\n    <>\n      <h2>Let’s check you in</h2>\n      <label>\n        First name:{' '}\n        <input\n          value={firstName}\n          onChange={handleFirstNameChange}\n        />\n      </label>\n      <label>\n        Last name:{' '}\n        <input\n          value={lastName}\n          onChange={handleLastNameChange}\n        />\n      </label>\n      <p>\n        Your ticket will be issued to: <b>{fullName}</b>\n      </p>\n    </>\n  );\n}"
      },
      {
        "language": "text",
        "code": "import { useState } from 'react';\n\nexport default function Accordion() {\n  const [activeIndex, setActiveIndex] = useState(0);\n  return (\n    <>\n      <h2>Almaty, Kazakhstan</h2>\n      <Panel\n        title=\"About\"\n        isActive={activeIndex === 0}\n        onShow={() => setActiveIndex(0)}\n      >\n        With a population of about 2 million, Almaty is Kazakhstan's largest city. From 1929 to 1997, it was its capital city.\n      </Panel>\n      <Panel\n        title=\"Etymology\"\n        isActive={activeIndex === 1}\n        onShow={() => setActiveIndex(1)}\n      >\n        The name comes from <span lang=\"kk-KZ\">алма</span>, the Kazakh word for \"apple\" and is often translated as \"full of apples\". In fact, the region surrounding Almaty is thought to be the ancestral home of the apple, and the wild <i lang=\"la\">Malus sieversii</i> is considered a likely candidate for the ancestor of the modern domestic apple.\n      </Panel>\n    </>\n  );\n}\n\nfunction Panel({\n  title,\n  children,\n  isActive,\n  onShow\n}) {\n  return (\n    <section className=\"panel\">\n      <h3>{title}</h3>\n      {isActive ? (\n        <p>{children}</p>\n      ) : (\n        <button onClick={onShow}>\n          Show\n        </button>\n      )}\n    </section>\n  );\n}"
      },
      {
        "language": "text",
        "code": "import { useState } from 'react';\nimport Chat from './Chat.js';\nimport ContactList from './ContactList.js';\n\nexport default function Messenger() {\n  const [to, setTo] = useState(contacts[0]);\n  return (\n    <div>\n      <ContactList\n        contacts={contacts}\n        selectedContact={to}\n        onSelect={contact => setTo(contact)}\n      />\n      <Chat contact={to} />\n    </div>\n  )\n}\n\nconst contacts = [\n  { name: 'Taylor', email: 'taylor@mail.com' },\n  { name: 'Alice', email: 'alice@mail.com' },\n  { name: 'Bob', email: 'bob@mail.com' }\n];"
      },
      {
        "language": "text",
        "code": "<Chat key={email} />"
      },
      {
        "language": "text",
        "code": "import { useState } from 'react';\nimport Chat from './Chat.js';\nimport ContactList from './ContactList.js';\n\nexport default function Messenger() {\n  const [to, setTo] = useState(contacts[0]);\n  return (\n    <div>\n      <ContactList\n        contacts={contacts}\n        selectedContact={to}\n        onSelect={contact => setTo(contact)}\n      />\n      <Chat key={to.email} contact={to} />\n    </div>\n  )\n}\n\nconst contacts = [\n  { name: 'Taylor', email: 'taylor@mail.com' },\n  { name: 'Alice', email: 'alice@mail.com' },\n  { name: 'Bob', email: 'bob@mail.com' }\n];"
      },
      {
        "language": "text",
        "code": "import { useReducer } from 'react';\nimport AddTask from './AddTask.js';\nimport TaskList from './TaskList.js';\n\nexport default function TaskApp() {\n  const [tasks, dispatch] = useReducer(\n    tasksReducer,\n    initialTasks\n  );\n\n  function handleAddTask(text) {\n    dispatch({\n      type: 'added',\n      id: nextId++,\n      text: text,\n    });\n  }\n\n  function handleChangeTask(task) {\n    dispatch({\n      type: 'changed',\n      task: task\n    });\n  }\n\n  function handleDeleteTask(taskId) {\n    dispatch({\n      type: 'deleted',\n      id: taskId\n    });\n  }\n\n  return (\n    <>\n      <h1>Prague itinerary</h1>\n      <AddTask\n        onAddTask={handleAddTask}\n      />\n      <TaskList\n        tasks={tasks}\n        onChangeTask={handleChangeTask}\n        onDeleteTask={handleDeleteTask}\n      />\n    </>\n  );\n}\n\nfunction tasksReducer(tasks, action) {\n  switch (action.type) {\n    case 'added': {\n      return [...tasks, {\n        id: action.id,\n        text: action.text,\n        done: false\n      }];\n    }\n    case 'changed': {\n      return tasks.map(t => {\n        if (t.id === action.task.id) {\n          return action.task;\n        } else {\n          return t;\n        }\n      });\n    }\n    case 'deleted': {\n      return tasks.filter(t => t.id !== action.id);\n    }\n    default: {\n      throw Error('Unknown action: ' + action.type);\n    }\n  }\n}\n\nlet nextId = 3;\nconst initialTasks = [\n  { id: 0, text: 'Visit Kafka Museum', done: true },\n  { id: 1, text: 'Watch a puppet show', done: false },\n  { id: 2, text: 'Lennon Wall pic', done: false }\n];"
      },
      {
        "language": "text",
        "code": "import Heading from './Heading.js';\nimport Section from './Section.js';\n\nexport default function Page() {\n  return (\n    <Section>\n      <Heading>Title</Heading>\n      <Section>\n        <Heading>Heading</Heading>\n        <Heading>Heading</Heading>\n        <Heading>Heading</Heading>\n        <Section>\n          <Heading>Sub-heading</Heading>\n          <Heading>Sub-heading</Heading>\n          <Heading>Sub-heading</Heading>\n          <Section>\n            <Heading>Sub-sub-heading</Heading>\n            <Heading>Sub-sub-heading</Heading>\n            <Heading>Sub-sub-heading</Heading>\n          </Section>\n        </Section>\n      </Section>\n    </Section>\n  );\n}"
      },
      {
        "language": "text",
        "code": "import AddTask from './AddTask.js';\nimport TaskList from './TaskList.js';\nimport { TasksProvider } from './TasksContext.js';\n\nexport default function TaskApp() {\n  return (\n    <TasksProvider>\n      <h1>Day off in Kyoto</h1>\n      <AddTask />\n      <TaskList />\n    </TasksProvider>\n  );\n}"
      }
    ],
    "links": [
      {
        "text": "Learn React",
        "href": "/learn"
      },
      {
        "text": "How to think about UI changes as state changes",
        "href": "/learn/reacting-to-input-with-state"
      },
      {
        "text": "How to structure state well",
        "href": "/learn/choosing-the-state-structure"
      },
      {
        "text": "How to “lift state up” to share it between components",
        "href": "/learn/sharing-state-between-components"
      },
      {
        "text": "How to control whether the state gets preserved or reset",
        "href": "/learn/preserving-and-resetting-state"
      },
      {
        "text": "How to consolidate complex state logic in a function",
        "href": "/learn/extracting-state-logic-into-a-reducer"
      },
      {
        "text": "How to pass information without “prop drilling”",
        "href": "/learn/passing-data-deeply-with-context"
      },
      {
        "text": "How to scale state management as your app grows",
        "href": "/learn/scaling-up-with-reducer-and-context"
      },
      {
        "text": "Reacting to Input with State",
        "href": "/learn/reacting-to-input-with-state"
      },
      {
        "text": "Read More",
        "href": "/learn/reacting-to-input-with-state"
      },
      {
        "text": "Choosing the State Structure",
        "href": "/learn/choosing-the-state-structure"
      },
      {
        "text": "Read More",
        "href": "/learn/choosing-the-state-structure"
      },
      {
        "text": "Sharing State Between Components",
        "href": "/learn/sharing-state-between-components"
      },
      {
        "text": "Read More",
        "href": "/learn/sharing-state-between-components"
      },
      {
        "text": "Preserving and Resetting State",
        "href": "/learn/preserving-and-resetting-state"
      },
      {
        "text": "Read More",
        "href": "/learn/preserving-and-resetting-state"
      },
      {
        "text": "Extracting State Logic into a Reducer",
        "href": "/learn/extracting-state-logic-into-a-reducer"
      },
      {
        "text": "Read More",
        "href": "/learn/extracting-state-logic-into-a-reducer"
      },
      {
        "text": "Passing Data Deeply with Context",
        "href": "/learn/passing-data-deeply-with-context"
      },
      {
        "text": "Read More",
        "href": "/learn/passing-data-deeply-with-context"
      },
      {
        "text": "Scaling Up with Reducer and Context",
        "href": "/learn/scaling-up-with-reducer-and-context"
      },
      {
        "text": "Read More",
        "href": "/learn/scaling-up-with-reducer-and-context"
      },
      {
        "text": "Reacting to Input with State",
        "href": "/learn/reacting-to-input-with-state"
      },
      {
        "text": "Escape Hatches",
        "href": "/learn/escape-hatches"
      },
      {
        "text": "PreviousUpdating Arrays in State",
        "href": "/learn/updating-arrays-in-state"
      },
      {
        "text": "NextReacting to Input with State",
        "href": "/learn/reacting-to-input-with-state"
      }
    ],
    "meta": {
      "description": "",
      "keywords": ""
    },
    "summary": "Learn ReactManaging StateIntermediateAs your application grows, it helps to be more intentional about how your state is organized and how the data flows between your components",
    "tags": [
      "react",
      "angular",
      "javascript",
      "typescript",
      "html",
      "vite",
      "this",
      "state",
      "ready",
      "learn"
    ],
    "id": "managing-state-react-managingstate-part-1",
    "quality": 100
  },
  {
    "title": "memo – React",
    "url": "https://react.dev/reference/react/memo",
    "category": "react",
    "content": "API ReferenceAPIsmemomemo lets you skip re-rendering a component when its props are unchanged.const MemoizedComponent = memo(SomeComponent, arePropsEqual?) NoteReact Compiler automatically applies the equivalent of memo to all components, reducing the need for manual memoization. You can use the compiler to handle component memoization automatically. Reference memo(Component, arePropsEqual?) Usage Skipping re-rendering when props are unchanged Updating a memoized component using state Updating a memoized component using a context Minimizing props changes Specifying a custom comparison function Do I still need React.memo if I use React Compiler? Troubleshooting My component re-renders when a prop is an object, array, or function Reference memo(Component, arePropsEqual?) Wrap a component in memo to get a memoized version of that component. This memoized version of your component will usually not be re-rendered when its parent component is re-rendered as long as its props have not changed. But React may still re-render it: memoization is a performance optimization, not a guarantee. import { memo } from 'react';const SomeComponent = memo(function SomeComponent(props) { // ...}); See more examples below. Parameters Component: The component that you want to memoize. The memo does not modify this component, but returns a new, memoized component instead. Any valid React component, including functions and forwardRef components, is accepted. optional arePropsEqual: A function that accepts two arguments: the components previous props, and its new props. It should return true if the old and new props are equal: that is, if the component will render the same output and behave in the same way with the new props as with the old. Otherwise it should return false. Usually, you will not specify this function. By default, React will compare each prop with Object.is. Returns memo returns a new React component. It behaves the same as the component provided to memo except that React will not always re-render it when its parent is being re-rendered unless its props have changed. Usage Skipping re-rendering when props are unchanged React normally re-renders a component whenever its parent re-renders. With memo, you can create a component that React will not re-render when its parent re-renders so long as its new props are the same as the old props. Such a component is said to be memoized. To memoize a component, wrap it in memo and use the value that it returns in place of your original component: const Greeting = memo(function Greeting({ name }) { return h1Hello, {name}!/h1;});export default Greeting; A React component should always have pure rendering logic. This means that it must return the same output if its props, state, and context havent changed. By using memo, you are telling React that your component complies with this requirement, so React doesnt need to re-render as long as its props havent changed. Even with memo, your component will re-render if its own state changes or if a context that its using changes. In this example, notice that the Greeting component re-renders whenever name is changed (because thats one of its props), but not when address is changed (because its not passed to Greeting as a prop): App.jsApp.js Download ResetForkimport { memo, useState } from 'react'; export default function MyApp() { const [name, setName] = useState(''); const [address, setAddress] = useState(''); return (  label Name{': '} input value={name} onChange={e = setName(e.target.value)} / /label label Address{': '} input value={address} onChange={e = setAddress(e.target.value)} / /label Greeting name={name} / / ); } const Greeting = memo(function Greeting({ name }) { console.log(\"Greeting was rendered at\", new Date().toLocaleTimeString()); return h3Hello{name && ', '}{name}!/h3; }); Show more NoteYou should only rely on memo as a performance optimization. If your code doesnt work without it, find the underlying problem and fix it first. Then you may add memo to improve performance. Deep DiveShould you add memo everywhere? Show DetailsIf your app is like this site, and most interactions are coarse (like replacing a page or an entire section), memoization is usually unnecessary. On the other hand, if your app is more like a drawing editor, and most interactions are granular (like moving shapes), then you might find memoization very helpful.Optimizing with memo is only valuable when your component re-renders often with the same exact props, and its re-rendering logic is expensive. If there is no perceptible lag when your component re-renders, memo is unnecessary. Keep in mind that memo is completely useless if the props passed to your component are always different, such as if you pass an object or a plain function defined during rendering. This is why you will often need useMemo and useCallback together with memo.There is no benefit to wrapping a component in memo in other cases. There is no significant harm to doing that either, so some teams choose to not think about individual cases, and memoize as much as possible. The downside of this approach is that code becomes less readable. Also, not all memoization is effective: a single value thats always new is enough to break memoization for an entire component.In practice, you can make a lot of memoization unnecessary by following a few principles: When a component visually wraps other components, let it accept JSX as children. This way, when the wrapper component updates its own state, React knows that its children dont need to re-render. Prefer local state and dont lift state up any further than necessary. For example, dont keep transient state like forms and whether an item is hovered at the top of your tree or in a global state library. Keep your rendering logic pure. If re-rendering a component causes a problem or produces some noticeable visual artifact, its a bug in your component! Fix the bug instead of adding memoization. Avoid unnecessary Effects that update state. Most performance problems in React apps are caused by chains of updates originating from Effects that cause your components to render over and over. Try to remove unnecessary dependencies from your Effects. For example, instead of memoization, its often simpler to move some object or a function inside an Effect or outside the component. If a specific interaction still feels laggy, use the React Developer Tools profiler to see which components would benefit the most from memoization, and add memoization where needed. These principles make your components easier to debug and understand, so its good to follow them in any case. In the long term, were researching doing granular memoization automatically to solve this once and for all. Updating a memoized component using state Even when a component is memoized, it will still re-render when its own state changes. Memoization only has to do with props that are passed to the component from its parent. App.jsApp.js Download ResetForkimport { memo, useState } from 'react'; export default function MyApp() { const [name, setName] = useState(''); const [address, setAddress] = useState(''); return (  label Name{': '} input value={name} onChange={e = setName(e.target.value)} / /label label Address{': '} input value={address} onChange={e = setAddress(e.target.value)} / /label Greeting name={name} / / ); } const Greeting = memo(function Greeting({ name }) { console.log('Greeting was rendered at', new Date().toLocaleTimeString()); const [greeting, setGreeting] = useState('Hello'); return (  h3{greeting}{name && ', '}{name}!/h3 GreetingSelector value={greeting} onChange={setGreeting} / / ); }); function GreetingSelector({ value, onChange }) { return (  label input type=\"radio\" checked={value === 'Hello'} onChange={e = onChange('Hello')} / Regular greeting /label label input type=\"radio\" checked={value === 'Hello and welcome'} onChange={e = onChange('Hello and welcome')} / Enthusiastic greeting /label / ); } Show more If you set a state variable to its current value, React will skip re-rendering your component even without memo. You may still see your component function being called an extra time, but the result will be discarded. Updating a memoized component using a context Even when a component is memoized, it will still re-render when a context that its using changes. Memoization only has to do with props that are passed to the component from its parent. App.jsApp.js Download ResetForkimport { createContext, memo, useContext, useState } from 'react'; const ThemeContext = createContext(null); export default function MyApp() { const [theme, setTheme] = useState('dark'); function handleClick() { setTheme(theme === 'dark' ? 'light' : 'dark'); } return ( ThemeContext value={theme} button onClick={handleClick} Switch theme /button Greeting name=\"Taylor\" / /ThemeContext ); } const Greeting = memo(function Greeting({ name }) { console.log(\"Greeting was rendered at\", new Date().toLocaleTimeString()); const theme = useContext(ThemeContext); return ( h3 className={theme}Hello, {name}!/h3 ); }); Show more To make your component re-render only when a part of some context changes, split your component in two. Read what you need from the context in the outer component, and pass it down to a memoized child as a prop. Minimizing props changes When you use memo, your component re-renders whenever any prop is not shallowly equal to what it was previously. This means that React compares every prop in your component with its previous value using the Object.is comparison. Note that Object.is(3, 3) is true, but Object.is({}, {}) is false. To get the most out of memo, minimize the times that the props change. For example, if the prop is an object, prevent the parent component from re-creating that object every time by using useMemo: function Page() { const [name, setName] = useState('Taylor'); const [age, setAge] = useState(42); const person = useMemo( () = ({ name, age }), [name, age] ); return Profile person={person} /;}const Profile = memo(function Profile({ person }) { // ...}); A better way to minimize props changes is to make sure the component accepts the minimum necessary information in its props. For example, it could accept individual values instead of a whole object: function Page() { const [name, setName] = useState('Taylor'); const [age, setAge] = useState(42); return Profile name={name} age={age} /;}const Profile = memo(function Profile({ name, age }) { // ...}); Even individual values can sometimes be projected to ones that change less frequently. For example, here a component accepts a boolean indicating the presence of a value rather than the value itself: function GroupsLanding({ person }) { const hasGroups = person.groups !== null; return CallToAction hasGroups={hasGroups} /;}const CallToAction = memo(function CallToAction({ hasGroups }) { // ...}); When you need to pass a function to memoized component, either declare it outside your component so that it never changes, or useCallback to cache its definition between re-renders. Specifying a custom comparison function In rare cases it may be infeasible to minimize the props changes of a memoized component. In that case, you can provide a custom comparison function, which React will use to compare the old and new props instead of using shallow equality. This function is passed as a second argument to memo. It should return true only if the new props would result in the same output as the old props; otherwise it should return false. const Chart = memo(function Chart({ dataPoints }) { // ...}, arePropsEqual);function arePropsEqual(oldProps, newProps) { return ( oldProps.dataPoints.length === newProps.dataPoints.length && oldProps.dataPoints.every((oldPoint, index) = { const newPoint = newProps.dataPoints[index]; return oldPoint.x === newPoint.x && oldPoint.y === newPoint.y; }) );} If you do this, use the Performance panel in your browser developer tools to make sure that your comparison function is actually faster than re-rendering the component. You might be surprised. When you do performance measurements, make sure that React is running in the production mode. PitfallIf you provide a custom arePropsEqual implementation, you must compare every prop, including functions. Functions often close over the props and state of parent components. If you return true when oldProps.onClick !== newProps.onClick, your component will keep seeing the props and state from a previous render inside its onClick handler, leading to very confusing bugs.Avoid doing deep equality checks inside arePropsEqual unless you are 100% sure that the data structure youre working with has a known limited depth. Deep equality checks can become incredibly slow and can freeze your app for many seconds if someone changes the data structure later. Do I still need React.memo if I use React Compiler? When you enable React Compiler, you typically dont need React.memo anymore. The compiler automatically optimizes component re-rendering for you. Heres how it works: Without React Compiler, you need React.memo to prevent unnecessary re-renders: // Parent re-renders every secondfunction Parent() { const [seconds, setSeconds] = useState(0); useEffect(() = { const interval = setInterval(() = { setSeconds(s = s + 1); }, 1000); return () = clearInterval(interval); }, []); return (  h1Seconds: {seconds}/h1 ExpensiveChild name=\"John\" / / );}// Without memo, this re-renders every second even though props don't changeconst ExpensiveChild = memo(function ExpensiveChild({ name }) { console.log('ExpensiveChild rendered'); return divHello, {name}!/div;}); With React Compiler enabled, the same optimization happens automatically: // No memo needed - compiler prevents re-renders automaticallyfunction ExpensiveChild({ name }) { console.log('ExpensiveChild rendered'); return divHello, {name}!/div;} Heres the key part of what the React Compiler generates: function Parent() { const $ = _c(7); const [seconds, setSeconds] = useState(0); // ... other code ... let t3; if ($[4] === Symbol.for(\"react.memo_cache_sentinel\")) { t3 = ExpensiveChild name=\"John\" /; $[4] = t3; } else { t3 = $[4]; } // ... return statement ...} Notice the highlighted lines: The compiler wraps ExpensiveChild name=\"John\" / in a cache check. Since the name prop is always \"John\", this JSX is created once and reused on every parent re-render. This is exactly what React.memo does - it prevents the child from re-rendering when its props havent changed. The React Compiler automatically: Tracks that the name prop passed to ExpensiveChild hasnt changed Reuses the previously created JSX for ExpensiveChild name=\"John\" / Skips re-rendering ExpensiveChild entirely This means you can safely remove React.memo from your components when using React Compiler. The compiler provides the same optimization automatically, making your code cleaner and easier to maintain. NoteThe compilers optimization is actually more comprehensive than React.memo. It also memoizes intermediate values and expensive computations within your components, similar to combining React.memo with useMemo throughout your component tree. Troubleshooting My component re-renders when a prop is an object, array, or function React compares old and new props by shallow equality: that is, it considers whether each new prop is reference-equal to the old prop. If you create a new object or array each time the parent is re-rendered, even if the individual elements are each the same, React will still consider it to be changed. Similarly, if you create a new function when rendering the parent component, React will consider it to have changed even if the function has the same definition. To avoid this, simplify props or memoize props in the parent component.PreviouslazyNextstartTransition",
    "headings": [
      {
        "level": 1,
        "text": "memo",
        "id": ""
      },
      {
        "level": 2,
        "text": "Reference",
        "id": "reference"
      },
      {
        "level": 2,
        "text": "Usage",
        "id": "usage"
      },
      {
        "level": 2,
        "text": "Troubleshooting",
        "id": "troubleshooting"
      },
      {
        "level": 3,
        "text": "Note",
        "id": ""
      },
      {
        "level": 3,
        "text": "memo(Component, arePropsEqual?)",
        "id": "memo"
      },
      {
        "level": 3,
        "text": "Skipping re-rendering when props are unchanged",
        "id": "skipping-re-rendering-when-props-are-unchanged"
      },
      {
        "level": 3,
        "text": "Note",
        "id": ""
      },
      {
        "level": 3,
        "text": "Updating a memoized component using state",
        "id": "updating-a-memoized-component-using-state"
      },
      {
        "level": 3,
        "text": "Updating a memoized component using a context",
        "id": "updating-a-memoized-component-using-a-context"
      },
      {
        "level": 3,
        "text": "Minimizing props changes",
        "id": "minimizing-props-changes"
      },
      {
        "level": 3,
        "text": "Specifying a custom comparison function",
        "id": "specifying-a-custom-comparison-function"
      },
      {
        "level": 3,
        "text": "Pitfall",
        "id": ""
      },
      {
        "level": 3,
        "text": "Do I still need React.memo if I use React Compiler?",
        "id": "react-compiler-memo"
      },
      {
        "level": 3,
        "text": "Note",
        "id": ""
      },
      {
        "level": 3,
        "text": "My component re-renders when a prop is an object, array, or function",
        "id": "my-component-rerenders-when-a-prop-is-an-object-or-array"
      },
      {
        "level": 4,
        "text": "Parameters",
        "id": "parameters"
      },
      {
        "level": 4,
        "text": "Returns",
        "id": "returns"
      },
      {
        "level": 4,
        "text": "Should you add memo everywhere?",
        "id": "should-you-add-memo-everywhere"
      },
      {
        "level": 5,
        "text": "Deep Dive",
        "id": ""
      }
    ],
    "codeBlocks": [
      {
        "language": "text",
        "code": "const MemoizedComponent = memo(SomeComponent, arePropsEqual?)"
      },
      {
        "language": "text",
        "code": "const MemoizedComponent = memo(SomeComponent, arePropsEqual?)"
      },
      {
        "language": "text",
        "code": "memo(Component, arePropsEqual?)"
      },
      {
        "language": "text",
        "code": "memo(Component, arePropsEqual?)"
      },
      {
        "language": "text",
        "code": "import { memo } from 'react';const SomeComponent = memo(function SomeComponent(props) {  // ...});"
      },
      {
        "language": "text",
        "code": "import { memo } from 'react';const SomeComponent = memo(function SomeComponent(props) {  // ...});"
      },
      {
        "language": "text",
        "code": "arePropsEqual"
      },
      {
        "language": "text",
        "code": "const Greeting = memo(function Greeting({ name }) {  return <h1>Hello, {name}!</h1>;});export default Greeting;"
      },
      {
        "language": "text",
        "code": "const Greeting = memo(function Greeting({ name }) {  return <h1>Hello, {name}!</h1>;});export default Greeting;"
      },
      {
        "language": "text",
        "code": "import { memo, useState } from 'react';\n\nexport default function MyApp() {\n  const [name, setName] = useState('');\n  const [address, setAddress] = useState('');\n  return (\n    <>\n      <label>\n        Name{': '}\n        <input value={name} onChange={e => setName(e.target.value)} />\n      </label>\n      <label>\n        Address{': '}\n        <input value={address} onChange={e => setAddress(e.target.value)} />\n      </label>\n      <Greeting name={name} />\n    </>\n  );\n}\n\nconst Greeting = memo(function Greeting({ name }) {\n  console.log(\"Greeting was rendered at\", new Date().toLocaleTimeString());\n  return <h3>Hello{name && ', '}{name}!</h3>;\n});"
      },
      {
        "language": "text",
        "code": "useCallback"
      },
      {
        "language": "text",
        "code": "import { memo, useState } from 'react';\n\nexport default function MyApp() {\n  const [name, setName] = useState('');\n  const [address, setAddress] = useState('');\n  return (\n    <>\n      <label>\n        Name{': '}\n        <input value={name} onChange={e => setName(e.target.value)} />\n      </label>\n      <label>\n        Address{': '}\n        <input value={address} onChange={e => setAddress(e.target.value)} />\n      </label>\n      <Greeting name={name} />\n    </>\n  );\n}\n\nconst Greeting = memo(function Greeting({ name }) {\n  console.log('Greeting was rendered at', new Date().toLocaleTimeString());\n  const [greeting, setGreeting] = useState('Hello');\n  return (\n    <>\n      <h3>{greeting}{name && ', '}{name}!</h3>\n      <GreetingSelector value={greeting} onChange={setGreeting} />\n    </>\n  );\n});\n\nfunction GreetingSelector({ value, onChange }) {\n  return (\n    <>\n      <label>\n        <input\n          type=\"radio\"\n          checked={value === 'Hello'}\n          onChange={e => onChange('Hello')}\n        />\n        Regular greeting\n      </label>\n      <label>\n        <input\n          type=\"radio\"\n          checked={value === 'Hello and welcome'}\n          onChange={e => onChange('Hello and welcome')}\n        />\n        Enthusiastic greeting\n      </label>\n    </>\n  );\n}"
      },
      {
        "language": "text",
        "code": "import { createContext, memo, useContext, useState } from 'react';\n\nconst ThemeContext = createContext(null);\n\nexport default function MyApp() {\n  const [theme, setTheme] = useState('dark');\n\n  function handleClick() {\n    setTheme(theme === 'dark' ? 'light' : 'dark');\n  }\n\n  return (\n    <ThemeContext value={theme}>\n      <button onClick={handleClick}>\n        Switch theme\n      </button>\n      <Greeting name=\"Taylor\" />\n    </ThemeContext>\n  );\n}\n\nconst Greeting = memo(function Greeting({ name }) {\n  console.log(\"Greeting was rendered at\", new Date().toLocaleTimeString());\n  const theme = useContext(ThemeContext);\n  return (\n    <h3 className={theme}>Hello, {name}!</h3>\n  );\n});"
      },
      {
        "language": "text",
        "code": "Object.is(3, 3)"
      },
      {
        "language": "text",
        "code": "Object.is({}, {})"
      },
      {
        "language": "text",
        "code": "function Page() {  const [name, setName] = useState('Taylor');  const [age, setAge] = useState(42);  const person = useMemo(    () => ({ name, age }),    [name, age]  );  return <Profile person={person} />;}const Profile = memo(function Profile({ person }) {  // ...});"
      },
      {
        "language": "text",
        "code": "function Page() {  const [name, setName] = useState('Taylor');  const [age, setAge] = useState(42);  const person = useMemo(    () => ({ name, age }),    [name, age]  );  return <Profile person={person} />;}const Profile = memo(function Profile({ person }) {  // ...});"
      },
      {
        "language": "text",
        "code": "function Page() {  const [name, setName] = useState('Taylor');  const [age, setAge] = useState(42);  return <Profile name={name} age={age} />;}const Profile = memo(function Profile({ name, age }) {  // ...});"
      },
      {
        "language": "text",
        "code": "function Page() {  const [name, setName] = useState('Taylor');  const [age, setAge] = useState(42);  return <Profile name={name} age={age} />;}const Profile = memo(function Profile({ name, age }) {  // ...});"
      },
      {
        "language": "text",
        "code": "function GroupsLanding({ person }) {  const hasGroups = person.groups !== null;  return <CallToAction hasGroups={hasGroups} />;}const CallToAction = memo(function CallToAction({ hasGroups }) {  // ...});"
      },
      {
        "language": "text",
        "code": "function GroupsLanding({ person }) {  const hasGroups = person.groups !== null;  return <CallToAction hasGroups={hasGroups} />;}const CallToAction = memo(function CallToAction({ hasGroups }) {  // ...});"
      },
      {
        "language": "text",
        "code": "useCallback"
      },
      {
        "language": "text",
        "code": "const Chart = memo(function Chart({ dataPoints }) {  // ...}, arePropsEqual);function arePropsEqual(oldProps, newProps) {  return (    oldProps.dataPoints.length === newProps.dataPoints.length &&    oldProps.dataPoints.every((oldPoint, index) => {      const newPoint = newProps.dataPoints[index];      return oldPoint.x === newPoint.x && oldPoint.y === newPoint.y;    })  );}"
      },
      {
        "language": "text",
        "code": "const Chart = memo(function Chart({ dataPoints }) {  // ...}, arePropsEqual);function arePropsEqual(oldProps, newProps) {  return (    oldProps.dataPoints.length === newProps.dataPoints.length &&    oldProps.dataPoints.every((oldPoint, index) => {      const newPoint = newProps.dataPoints[index];      return oldPoint.x === newPoint.x && oldPoint.y === newPoint.y;    })  );}"
      },
      {
        "language": "text",
        "code": "arePropsEqual"
      },
      {
        "language": "text",
        "code": "oldProps.onClick !== newProps.onClick"
      },
      {
        "language": "text",
        "code": "arePropsEqual"
      },
      {
        "language": "text",
        "code": "// Parent re-renders every secondfunction Parent() {  const [seconds, setSeconds] = useState(0);  useEffect(() => {    const interval = setInterval(() => {      setSeconds(s => s + 1);    }, 1000);    return () => clearInterval(interval);  }, []);  return (    <>      <h1>Seconds: {seconds}</h1>      <ExpensiveChild name=\"John\" />    </>  );}// Without memo, this re-renders every second even though props don't changeconst ExpensiveChild = memo(function ExpensiveChild({ name }) {  console.log('ExpensiveChild rendered');  return <div>Hello, {name}!</div>;});"
      },
      {
        "language": "text",
        "code": "// Parent re-renders every secondfunction Parent() {  const [seconds, setSeconds] = useState(0);  useEffect(() => {    const interval = setInterval(() => {      setSeconds(s => s + 1);    }, 1000);    return () => clearInterval(interval);  }, []);  return (    <>      <h1>Seconds: {seconds}</h1>      <ExpensiveChild name=\"John\" />    </>  );}// Without memo, this re-renders every second even though props don't changeconst ExpensiveChild = memo(function ExpensiveChild({ name }) {  console.log('ExpensiveChild rendered');  return <div>Hello, {name}!</div>;});"
      },
      {
        "language": "text",
        "code": "// No memo needed - compiler prevents re-renders automaticallyfunction ExpensiveChild({ name }) {  console.log('ExpensiveChild rendered');  return <div>Hello, {name}!</div>;}"
      },
      {
        "language": "text",
        "code": "// No memo needed - compiler prevents re-renders automaticallyfunction ExpensiveChild({ name }) {  console.log('ExpensiveChild rendered');  return <div>Hello, {name}!</div>;}"
      },
      {
        "language": "text",
        "code": "function Parent() {  const $ = _c(7);  const [seconds, setSeconds] = useState(0);  // ... other code ...  let t3;  if ($[4] === Symbol.for(\"react.memo_cache_sentinel\")) {    t3 = <ExpensiveChild name=\"John\" />;    $[4] = t3;  } else {    t3 = $[4];  }  // ... return statement ...}"
      },
      {
        "language": "text",
        "code": "function Parent() {  const $ = _c(7);  const [seconds, setSeconds] = useState(0);  // ... other code ...  let t3;  if ($[4] === Symbol.for(\"react.memo_cache_sentinel\")) {    t3 = <ExpensiveChild name=\"John\" />;    $[4] = t3;  } else {    t3 = $[4];  }  // ... return statement ...}"
      },
      {
        "language": "text",
        "code": "<ExpensiveChild name=\"John\" />"
      },
      {
        "language": "text",
        "code": "ExpensiveChild"
      },
      {
        "language": "text",
        "code": "<ExpensiveChild name=\"John\" />"
      },
      {
        "language": "text",
        "code": "ExpensiveChild"
      }
    ],
    "links": [
      {
        "text": "API Reference",
        "href": "/reference/react"
      },
      {
        "text": "APIs",
        "href": "/reference/react/apis"
      },
      {
        "text": "React Compiler",
        "href": "/learn/react-compiler"
      },
      {
        "text": "forwardRef",
        "href": "/reference/react/forwardRef"
      },
      {
        "text": "Object.is.",
        "href": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/is"
      },
      {
        "text": "pure rendering logic.",
        "href": "/learn/keeping-components-pure"
      },
      {
        "text": "useMemo",
        "href": "/reference/react/useMemo#skipping-re-rendering-of-components"
      },
      {
        "text": "useCallback",
        "href": "/reference/react/useCallback#skipping-re-rendering-of-components"
      },
      {
        "text": "accept JSX as children.",
        "href": "/learn/passing-props-to-a-component#passing-jsx-as-children"
      },
      {
        "text": "lift state up",
        "href": "/learn/sharing-state-between-components"
      },
      {
        "text": "rendering logic pure.",
        "href": "/learn/keeping-components-pure"
      },
      {
        "text": "unnecessary Effects that update state.",
        "href": "/learn/you-might-not-need-an-effect"
      },
      {
        "text": "remove unnecessary dependencies from your Effects.",
        "href": "/learn/removing-effect-dependencies"
      },
      {
        "text": "use the React Developer Tools profiler",
        "href": "https://legacy.reactjs.org/blog/2018/09/10/introducing-the-react-profiler.html"
      },
      {
        "text": "doing granular memoization automatically",
        "href": "https://www.youtube.com/watch?v=lGEMwh32soc"
      },
      {
        "text": "Object.is",
        "href": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/is"
      },
      {
        "text": "useMemo:",
        "href": "/reference/react/useMemo"
      },
      {
        "text": "useCallback",
        "href": "/reference/react/useCallback#skipping-re-rendering-of-components"
      },
      {
        "text": "close over",
        "href": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Closures"
      },
      {
        "text": "React Compiler",
        "href": "/learn/react-compiler"
      },
      {
        "text": "Previouslazy",
        "href": "/reference/react/lazy"
      },
      {
        "text": "NextstartTransition",
        "href": "/reference/react/startTransition"
      }
    ],
    "meta": {
      "description": "",
      "keywords": ""
    },
    "summary": "API ReferenceAPIsmemomemo lets you skip re-rendering a component when its props are unchanged. const MemoizedComponent = memo(SomeComponent, arePropsEqual",
    "tags": [
      "react",
      "angular",
      "javascript",
      "typescript",
      "html",
      "vite",
      "memo",
      "component",
      "note",
      "when"
    ],
    "id": "memo-react-memo-part-1",
    "quality": 100
  },
  {
    "title": "lazy – React",
    "url": "https://react.dev/reference/react/lazy",
    "category": "react",
    "content": "API ReferenceAPIslazylazy lets you defer loading components code until it is rendered for the first time.const SomeComponent = lazy(load) Reference lazy(load) load function Usage Lazy-loading components with Suspense Troubleshooting My lazy components state gets reset unexpectedly Reference lazy(load) Call lazy outside your components to declare a lazy-loaded React component: import { lazy } from 'react';const MarkdownPreview = lazy(() = import('./MarkdownPreview.js')); See more examples below. Parameters load: A function that returns a Promise or another thenable (a Promise-like object with a then method). React will not call load until the first time you attempt to render the returned component. After React first calls load, it will wait for it to resolve, and then render the resolved values .default as a React component. Both the returned Promise and the Promises resolved value will be cached, so React will not call load more than once. If the Promise rejects, React will throw the rejection reason for the nearest Error Boundary to handle. Returns lazy returns a React component you can render in your tree. While the code for the lazy component is still loading, attempting to render it will suspend. Use Suspense to display a loading indicator while its loading. load function Parameters load receives no parameters. Returns You need to return a Promise or some other thenable (a Promise-like object with a then method). It needs to eventually resolve to an object whose .default property is a valid React component type, such as a function, memo, or a forwardRef component. Usage Lazy-loading components with Suspense Usually, you import components with the static import declaration: import MarkdownPreview from './MarkdownPreview.js'; To defer loading this components code until its rendered for the first time, replace this import with: import { lazy } from 'react';const MarkdownPreview = lazy(() = import('./MarkdownPreview.js')); This code relies on dynamic import(), which might require support from your bundler or framework. Using this pattern requires that the lazy component youre importing was exported as the default export. Now that your components code loads on demand, you also need to specify what should be displayed while it is loading. You can do this by wrapping the lazy component or any of its parents into a Suspense boundary: Suspense fallback={Loading /} h2Preview/h2 MarkdownPreview //Suspense In this example, the code for MarkdownPreview wont be loaded until you attempt to render it. If MarkdownPreview hasnt loaded yet, Loading will be shown in its place. Try ticking the checkbox: App.jsLoading.jsMarkdownPreview.jsApp.js ResetForkimport { useState, Suspense, lazy } from 'react'; import Loading from './Loading.js'; const MarkdownPreview = lazy(() = delayForDemo(import('./MarkdownPreview.js'))); export default function MarkdownEditor() { const [showPreview, setShowPreview] = useState(false); const [markdown, setMarkdown] = useState('Hello, **world**!'); return (  textarea value={markdown} onChange={e = setMarkdown(e.target.value)} / label input type=\"checkbox\" checked={showPreview} onChange={e = setShowPreview(e.target.checked)} / Show preview /label hr / {showPreview && ( Suspense fallback={Loading /} h2Preview/h2 MarkdownPreview markdown={markdown} / /Suspense )} / ); } // Add a fixed delay so you can see the loading state function delayForDemo(promise) { return new Promise(resolve = { setTimeout(resolve, 2000); }).then(() = promise); } Show more This demo loads with an artificial delay. The next time you untick and tick the checkbox, Preview will be cached, so there will be no loading state. To see the loading state again, click Reset on the sandbox. Learn more about managing loading states with Suspense. Troubleshooting My lazy components state gets reset unexpectedly Do not declare lazy components inside other components: import { lazy } from 'react';function Editor() { //  Bad: This will cause all state to be reset on re-renders const MarkdownPreview = lazy(() = import('./MarkdownPreview.js')); // ...} Instead, always declare them at the top level of your module: import { lazy } from 'react';//  Good: Declare lazy components outside of your componentsconst MarkdownPreview = lazy(() = import('./MarkdownPreview.js'));function Editor() { // ...}PreviouscreateContextNextmemo",
    "headings": [
      {
        "level": 1,
        "text": "lazy",
        "id": ""
      },
      {
        "level": 2,
        "text": "Reference",
        "id": "reference"
      },
      {
        "level": 2,
        "text": "Usage",
        "id": "usage"
      },
      {
        "level": 2,
        "text": "Troubleshooting",
        "id": "troubleshooting"
      },
      {
        "level": 3,
        "text": "lazy(load)",
        "id": "lazy"
      },
      {
        "level": 3,
        "text": "load function",
        "id": "load"
      },
      {
        "level": 3,
        "text": "Lazy-loading components with Suspense",
        "id": "suspense-for-code-splitting"
      },
      {
        "level": 3,
        "text": "My lazy component’s state gets reset unexpectedly",
        "id": "my-lazy-components-state-gets-reset-unexpectedly"
      },
      {
        "level": 4,
        "text": "Parameters",
        "id": "parameters"
      },
      {
        "level": 4,
        "text": "Returns",
        "id": "returns"
      },
      {
        "level": 4,
        "text": "Parameters",
        "id": "load-parameters"
      },
      {
        "level": 4,
        "text": "Returns",
        "id": "load-returns"
      }
    ],
    "codeBlocks": [
      {
        "language": "text",
        "code": "const SomeComponent = lazy(load)"
      },
      {
        "language": "text",
        "code": "const SomeComponent = lazy(load)"
      },
      {
        "language": "text",
        "code": "import { lazy } from 'react';const MarkdownPreview = lazy(() => import('./MarkdownPreview.js'));"
      },
      {
        "language": "text",
        "code": "import { lazy } from 'react';const MarkdownPreview = lazy(() => import('./MarkdownPreview.js'));"
      },
      {
        "language": "text",
        "code": "import MarkdownPreview from './MarkdownPreview.js';"
      },
      {
        "language": "text",
        "code": "import MarkdownPreview from './MarkdownPreview.js';"
      },
      {
        "language": "text",
        "code": "import { lazy } from 'react';const MarkdownPreview = lazy(() => import('./MarkdownPreview.js'));"
      },
      {
        "language": "text",
        "code": "import { lazy } from 'react';const MarkdownPreview = lazy(() => import('./MarkdownPreview.js'));"
      },
      {
        "language": "text",
        "code": "<Suspense fallback={<Loading />}>  <h2>Preview</h2>  <MarkdownPreview /></Suspense>"
      },
      {
        "language": "text",
        "code": "<Suspense fallback={<Loading />}>  <h2>Preview</h2>  <MarkdownPreview /></Suspense>"
      },
      {
        "language": "text",
        "code": "MarkdownPreview"
      },
      {
        "language": "text",
        "code": "MarkdownPreview"
      },
      {
        "language": "text",
        "code": "import { useState, Suspense, lazy } from 'react';\nimport Loading from './Loading.js';\n\nconst MarkdownPreview = lazy(() => delayForDemo(import('./MarkdownPreview.js')));\n\nexport default function MarkdownEditor() {\n  const [showPreview, setShowPreview] = useState(false);\n  const [markdown, setMarkdown] = useState('Hello, **world**!');\n  return (\n    <>\n      <textarea value={markdown} onChange={e => setMarkdown(e.target.value)} />\n      <label>\n        <input type=\"checkbox\" checked={showPreview} onChange={e => setShowPreview(e.target.checked)} />\n        Show preview\n      </label>\n      <hr />\n      {showPreview && (\n        <Suspense fallback={<Loading />}>\n          <h2>Preview</h2>\n          <MarkdownPreview markdown={markdown} />\n        </Suspense>\n      )}\n    </>\n  );\n}\n\n// Add a fixed delay so you can see the loading state\nfunction delayForDemo(promise) {\n  return new Promise(resolve => {\n    setTimeout(resolve, 2000);\n  }).then(() => promise);\n}"
      },
      {
        "language": "text",
        "code": "import { lazy } from 'react';function Editor() {  // 🔴 Bad: This will cause all state to be reset on re-renders  const MarkdownPreview = lazy(() => import('./MarkdownPreview.js'));  // ...}"
      },
      {
        "language": "text",
        "code": "import { lazy } from 'react';function Editor() {  // 🔴 Bad: This will cause all state to be reset on re-renders  const MarkdownPreview = lazy(() => import('./MarkdownPreview.js'));  // ...}"
      },
      {
        "language": "text",
        "code": "import { lazy } from 'react';// ✅ Good: Declare lazy components outside of your componentsconst MarkdownPreview = lazy(() => import('./MarkdownPreview.js'));function Editor() {  // ...}"
      },
      {
        "language": "text",
        "code": "import { lazy } from 'react';// ✅ Good: Declare lazy components outside of your componentsconst MarkdownPreview = lazy(() => import('./MarkdownPreview.js'));function Editor() {  // ...}"
      }
    ],
    "links": [
      {
        "text": "API Reference",
        "href": "/reference/react"
      },
      {
        "text": "APIs",
        "href": "/reference/react/apis"
      },
      {
        "text": "Promise",
        "href": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Promise"
      },
      {
        "text": "<Suspense>",
        "href": "/reference/react/Suspense"
      },
      {
        "text": "Promise",
        "href": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Promise"
      },
      {
        "text": "memo",
        "href": "/reference/react/memo"
      },
      {
        "text": "forwardRef",
        "href": "/reference/react/forwardRef"
      },
      {
        "text": "import",
        "href": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Statements/import"
      },
      {
        "text": "dynamic import(),",
        "href": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/import"
      },
      {
        "text": "<Suspense>",
        "href": "/reference/react/Suspense"
      },
      {
        "text": "Learn more about managing loading states with Suspense.",
        "href": "/reference/react/Suspense"
      },
      {
        "text": "PreviouscreateContext",
        "href": "/reference/react/createContext"
      },
      {
        "text": "Nextmemo",
        "href": "/reference/react/memo"
      }
    ],
    "meta": {
      "description": "",
      "keywords": ""
    },
    "summary": "API ReferenceAPIslazylazy lets you defer loading components code until it is rendered for the first time",
    "tags": [
      "react",
      "angular",
      "javascript",
      "typescript",
      "node",
      "webpack",
      "lazy",
      "load",
      "parameters",
      "returns"
    ],
    "id": "lazy-react-lazy-part-1",
    "quality": 100
  },
  {
    "title": "<Suspense> – React",
    "url": "https://react.dev/reference/react/Suspense",
    "category": "react",
    "content": "API ReferenceComponentsSuspenseSuspense lets you display a fallback until its children have finished loading.Suspense fallback={Loading /} SomeComponent //Suspense Reference Suspense Usage Displaying a fallback while content is loading Revealing content together at once Revealing nested content as it loads Showing stale content while fresh content is loading Preventing already revealed content from hiding Indicating that a Transition is happening Resetting Suspense boundaries on navigation Providing a fallback for server errors and client-only content Troubleshooting How do I prevent the UI from being replaced by a fallback during an update? Reference Suspense Props children: The actual UI you intend to render. If children suspends while rendering, the Suspense boundary will switch to rendering fallback. fallback: An alternate UI to render in place of the actual UI if it has not finished loading. Any valid React node is accepted, though in practice, a fallback is a lightweight placeholder view, such as a loading spinner or skeleton. Suspense will automatically switch to fallback when children suspends, and back to children when the data is ready. If fallback suspends while rendering, it will activate the closest parent Suspense boundary. Caveats React does not preserve any state for renders that got suspended before they were able to mount for the first time. When the component has loaded, React will retry rendering the suspended tree from scratch. If Suspense was displaying content for the tree, but then it suspended again, the fallback will be shown again unless the update causing it was caused by startTransition or useDeferredValue. If React needs to hide the already visible content because it suspended again, it will clean up layout Effects in the content tree. When the content is ready to be shown again, React will fire the layout Effects again. This ensures that Effects measuring the DOM layout dont try to do this while the content is hidden. React includes under-the-hood optimizations like Streaming Server Rendering and Selective Hydration that are integrated with Suspense. Read an architectural overview and watch a technical talk to learn more. Usage Displaying a fallback while content is loading You can wrap any part of your application with a Suspense boundary: Suspense fallback={Loading /} Albums //Suspense React will display your loading fallback until all the code and data needed by the children has been loaded. In the example below, the Albums component suspends while fetching the list of albums. Until its ready to render, React switches the closest Suspense boundary above to show the fallbackyour Loading component. Then, when the data loads, React hides the Loading fallback and renders the Albums component with data. ArtistPage.jsAlbums.jsArtistPage.js ResetForkimport { Suspense } from 'react'; import Albums from './Albums.js'; export default function ArtistPage({ artist }) { return (  h1{artist.name}/h1 Suspense fallback={Loading /} Albums artistId={artist.id} / /Suspense / ); } function Loading() { return h2 Loading.../h2; } Show more NoteOnly Suspense-enabled data sources will activate the Suspense component. They include: Data fetching with Suspense-enabled frameworks like Relay and Next.js Lazy-loading component code with lazy Reading the value of a cached Promise with use Suspense does not detect when data is fetched inside an Effect or event handler.The exact way you would load data in the Albums component above depends on your framework. If you use a Suspense-enabled framework, youll find the details in its data fetching documentation.Suspense-enabled data fetching without the use of an opinionated framework is not yet supported. The requirements for implementing a Suspense-enabled data source are unstable and undocumented. An official API for integrating data sources with Suspense will be released in a future version of React. Revealing content together at once By default, the whole tree inside Suspense is treated as a single unit. For example, even if only one of these components suspends waiting for some data, all of them together will be replaced by the loading indicator: Suspense fallback={Loading /} Biography / Panel Albums / /Panel/Suspense Then, after all of them are ready to be displayed, they will all appear together at once. In the example below, both Biography and Albums fetch some data. However, because they are grouped under a single Suspense boundary, these components always pop in together at the same time. ArtistPage.jsPanel.jsBiography.jsAlbums.jsArtistPage.js ResetForkimport { Suspense } from 'react'; import Albums from './Albums.js'; import Biography from './Biography.js'; import Panel from './Panel.js'; export default function ArtistPage({ artist }) { return (  h1{artist.name}/h1 Suspense fallback={Loading /} Biography artistId={artist.id} / Panel Albums artistId={artist.id} / /Panel /Suspense / ); } function Loading() { return h2 Loading.../h2; } Show more Components that load data dont have to be direct children of the Suspense boundary. For example, you can move Biography and Albums into a new Details component. This doesnt change the behavior. Biography and Albums share the same closest parent Suspense boundary, so their reveal is coordinated together. Suspense fallback={Loading /} Details artistId={artist.id} //Suspensefunction Details({ artistId }) { return (  Biography artistId={artistId} / Panel Albums artistId={artistId} / /Panel / );} Revealing nested content as it loads When a component suspends, the closest parent Suspense component shows the fallback. This lets you nest multiple Suspense components to create a loading sequence. Each Suspense boundarys fallback will be filled in as the next level of content becomes available. For example, you can give the album list its own fallback: Suspense fallback={BigSpinner /} Biography / Suspense fallback={AlbumsGlimmer /} Panel Albums / /Panel /Suspense/Suspense With this change, displaying the Biography doesnt need to wait for the Albums to load. The sequence will be: If Biography hasnt loaded yet, BigSpinner is shown in place of the entire content area. Once Biography finishes loading, BigSpinner is replaced by the content. If Albums hasnt loaded yet, AlbumsGlimmer is shown in place of Albums and its parent Panel. Finally, once Albums finishes loading, it replaces AlbumsGlimmer. ArtistPage.jsPanel.jsBiography.jsAlbums.jsArtistPage.js ResetForkimport { Suspense } from 'react'; import Albums from './Albums.js'; import Biography from './Biography.js'; import Panel from './Panel.js'; export default function ArtistPage({ artist }) { return (  h1{artist.name}/h1 Suspense fallback={BigSpinner /} Biography artistId={artist.id} / Suspense fallback={AlbumsGlimmer /} Panel Albums artistId={artist.id} / /Panel /Suspense /Suspense / ); } function BigSpinner() { return h2 Loading.../h2; } function AlbumsGlimmer() { return ( div className=\"glimmer-panel\" div className=\"glimmer-line\" / div className=\"glimmer-line\" / div className=\"glimmer-line\" / /div ); } Show more Suspense boundaries let you coordinate which parts of your UI should always pop in together at the same time, and which parts should progressively reveal more content in a sequence of loading states. You can add, move, or delete Suspense boundaries in any place in the tree without affecting the rest of your apps behavior. Dont put a Suspense boundary around every component. Suspense boundaries should not be more granular than the loading sequence that you want the user to experience. If you work with a designer, ask them where the loading states should be placedits likely that theyve already included them in their design wireframes. Showing stale content while fresh content is loading In this example, the SearchResults component suspends while fetching the search results. Type \"a\", wait for the results, and then edit it to \"ab\". The results for \"a\" will get replaced by the loading fallback. App.jsSearchResults.jsApp.js ResetForkimport { Suspense, useState } from 'react'; import SearchResults from './SearchResults.js'; export default function App() { const [query, setQuery] = useState(''); return (  label Search albums: input value={query} onChange={e = setQuery(e.target.value)} / /label Suspense fallback={h2Loading.../h2} SearchResults query={query} / /Suspense / ); } Show more A common alternative UI pattern is to defer updating the list and to keep showing the previous results until the new results are ready. The useDeferredValue Hook lets you pass a deferred version of the query down: export default function App() { const [query, setQuery] = useState(''); const deferredQuery = useDeferredValue(query); return (  label Search albums: input value={query} onChange={e = setQuery(e.target.value)} / /label Suspense fallback={h2Loading.../h2} SearchResults query={deferredQuery} / /Suspense / );} The query will update immediately, so the input will display the new value. However, the deferredQuery will keep its previous value until the data has loaded, so SearchResults will show the stale results for a bit. To make it more obvious to the user, you can add a visual indication when the stale result list is displayed: div style={{ opacity: query !== deferredQuery ? 0.5 : 1 }} SearchResults query={deferredQuery} //div Enter \"a\" in the example below, wait for the results to load, and then edit the input to \"ab\". Notice how instead of the Suspense fallback, you now see the dimmed stale result list until the new results have loaded: App.jsApp.js ResetForkimport { Suspense, useState, useDeferredValue } from 'react'; import SearchResults from './SearchResults.js'; export default function App() { const [query, setQuery] = useState(''); const deferredQuery = useDeferredValue(query); const isStale = query !== deferredQuery; return (  label Search albums: input value={query} onChange={e = setQuery(e.target.value)} / /label Suspense fallback={h2Loading.../h2} div style={{ opacity: isStale ? 0.5 : 1 }} SearchResults query={deferredQuery} / /div /Suspense / ); } Show more NoteBoth deferred values and Transitions let you avoid showing Suspense fallback in favor of inline indicators. Transitions mark the whole update as non-urgent so they are typically used by frameworks and router libraries for navigation. Deferred values, on the other hand, are mostly useful in application code where you want to mark a part of UI as non-urgent and let it lag behind the rest of the UI. Preventing already revealed content from hiding When a component suspends, the closest parent Suspense boundary switches to showing the fallback. This can lead to a jarring user experience if it was already displaying some content. Try pressing this button: App.jsLayout.jsIndexPage.jsArtistPage.jsAlbums.jsBiography.jsPanel.jsApp.js ResetForkimport { Suspense, useState } from 'react'; import IndexPage from './IndexPage.js'; import ArtistPage from './ArtistPage.js'; import Layout from './Layout.js'; export default function App() { return ( Suspense fallback={BigSpinner /} Router / /Suspense ); } function Router() { const [page, setPage] = useState('/'); function navigate(url) { setPage(url); } let content; if (page === '/') { content = ( IndexPage navigate={navigate} / ); } else if (page === '/the-beatles') { content = ( ArtistPage artist={{ id: 'the-beatles', name: 'The Beatles', }} / ); } return ( Layout {content} /Layout ); } function BigSpinner() { return h2 Loading.../h2; } Show more When you pressed the button, the Router component rendered ArtistPage instead of IndexPage. A component inside ArtistPage suspended, so the closest Suspense boundary started showing the fallback. The closest Suspense boundary was near the root, so the whole site layout got replaced by BigSpinner. To prevent this, you can mark the navigation state update as a Transition with startTransition: function Router() { const [page, setPage] = useState('/'); function navigate(url) { startTransition(() = { setPage(url); }); } // ... This tells React that the state transition is not urgent, and its better to keep showing the previous page instead of hiding any already revealed content. Now clicking the button waits for the Biography to load: App.jsLayout.jsIndexPage.jsArtistPage.jsAlbums.jsBiography.jsPanel.jsApp.js ResetForkimport { Suspense, startTransition, useState } from 'react'; import IndexPage from './IndexPage.js'; import ArtistPage from './ArtistPage.js'; import Layout from './Layout.js'; export default function App() { return ( Suspense fallback={BigSpinner /} Router / /Suspense ); } function Router() { const [page, setPage] = useState('/'); function navigate(url) { startTransition(() = { setPage(url); }); } let content; if (page === '/') { content = ( IndexPage navigate={navigate} / ); } else if (page === '/the-beatles') { content = ( ArtistPage artist={{ id: 'the-beatles', name: 'The Beatles', }} / ); } return ( Layout {content} /Layout ); } function BigSpinner() { return h2 Loading.../h2; } Show more A Transition doesnt wait for all content to load. It only waits long enough to avoid hiding already revealed content. For example, the website Layout was already revealed, so it would be bad to hide it behind a loading spinner. However, the nested Suspense boundary around Albums is new, so the Transition doesnt wait for it. NoteSuspense-enabled routers are expected to wrap the navigation updates into Transitions by default. Indicating that a Transition is happening In the above example, once you click the button, there is no visual indication that a navigation is in progress. To add an indicator, you can replace startTransition with useTransition which gives you a boolean isPending value. In the example below, its used to change the website header styling while a Transition is happening: App.jsLayout.jsIndexPage.jsArtistPage.jsAlbums.jsBiography.jsPanel.jsApp.js ResetForkimport { Suspense, useState, useTransition } from 'react'; import IndexPage from './IndexPage.js'; import ArtistPage from './ArtistPage.js'; import Layout from './Layout.js'; export default function App() { return ( Suspense fallback={BigSpinner /} Router / /Suspense ); } function Router() { const [page, setPage] = useState('/'); const [isPending, startTransition] = useTransition(); function navigate(url) { startTransition(() = { setPage(url); }); } let content; if (page === '/') { content = ( IndexPage navigate={navigate} / ); } else if (page === '/the-beatles') { content = ( ArtistPage artist={{ id: 'the-beatles', name: 'The Beatles', }} / ); } return ( Layout isPending={isPending} {content} /Layout ); } function BigSpinner() { return h2 Loading.../h2; } Show more Resetting Suspense boundaries on navigation During a Transition, React will avoid hiding already revealed content. However, if you navigate to a route with different parameters, you might want to tell React it is different content. You can express this with a key: ProfilePage key={queryParams.id} / Imagine youre navigating within a users profile page, and something suspends. If that update is wrapped in a Transition, it will not trigger the fallback for already visible content. Thats the expected behavior. However, now imagine youre navigating between two different user profiles. In that case, it makes sense to show the fallback. For example, one users timeline is different content from another users timeline. By specifying a key, you ensure that React treats different users profiles as different components, and resets the Suspense boundaries during navigation. Suspense-integrated routers should do this automatically. Providing a fallback for server errors and client-only content If you use one of the streaming server rendering APIs (or a framework that relies on them), React will also use your Suspense boundaries to handle errors on the server. If a component throws an error on the server, React will not abort the server render. Instead, it will find the closest Suspense component above it and include its fallback (such as a spinner) into the generated server HTML. The user will see a spinner at first. On the client, React will attempt to render the same component again. If it errors on the client too, React will throw the error and display the closest error boundary. However, if it does not error on the client, React will not display the error to the user since the content was eventually displayed successfully. You can use this to opt out some components from rendering on the server. To do this, throw an error in the server environment and then wrap them in a Suspense boundary to replace their HTML with fallbacks: Suspense fallback={Loading /} Chat //Suspensefunction Chat() { if (typeof window === 'undefined') { throw Error('Chat should only render on the client.'); } // ...} The server HTML will include the loading indicator. It will be replaced by the Chat component on the client. Troubleshooting How do I prevent the UI from being replaced by a fallback during an update? Replacing visible UI with a fallback creates a jarring user experience. This can happen when an update causes a component to suspend, and the nearest Suspense boundary is already showing content to the user. To prevent this from happening, mark the update as non-urgent using startTransition. During a Transition, React will wait until enough data has loaded to prevent an unwanted fallback from appearing: function handleNextPageClick() { // If this update suspends, don't hide the already displayed content startTransition(() = { setCurrentPage(currentPage + 1); });} This will avoid hiding existing content. However, any newly rendered Suspense boundaries will still immediately display fallbacks to avoid blocking the UI and let the user see the content as it becomes available. React will only prevent unwanted fallbacks during non-urgent updates. It will not delay a render if its the result of an urgent update. You must opt in with an API like startTransition or useDeferredValue. If your router is integrated with Suspense, it should wrap its updates into startTransition automatically.PreviousStrictModeNextActivity",
    "headings": [
      {
        "level": 1,
        "text": "<Suspense>",
        "id": ""
      },
      {
        "level": 2,
        "text": "Reference",
        "id": "reference"
      },
      {
        "level": 2,
        "text": "Usage",
        "id": "usage"
      },
      {
        "level": 2,
        "text": "Troubleshooting",
        "id": "troubleshooting"
      },
      {
        "level": 3,
        "text": "<Suspense>",
        "id": "suspense"
      },
      {
        "level": 3,
        "text": "Displaying a fallback while content is loading",
        "id": "displaying-a-fallback-while-content-is-loading"
      },
      {
        "level": 3,
        "text": "Note",
        "id": ""
      },
      {
        "level": 3,
        "text": "Revealing content together at once",
        "id": "revealing-content-together-at-once"
      },
      {
        "level": 3,
        "text": "Revealing nested content as it loads",
        "id": "revealing-nested-content-as-it-loads"
      },
      {
        "level": 3,
        "text": "Showing stale content while fresh content is loading",
        "id": "showing-stale-content-while-fresh-content-is-loading"
      },
      {
        "level": 3,
        "text": "Note",
        "id": ""
      },
      {
        "level": 3,
        "text": "Preventing already revealed content from hiding",
        "id": "preventing-already-revealed-content-from-hiding"
      },
      {
        "level": 3,
        "text": "Note",
        "id": ""
      },
      {
        "level": 3,
        "text": "Indicating that a Transition is happening",
        "id": "indicating-that-a-transition-is-happening"
      },
      {
        "level": 3,
        "text": "Resetting Suspense boundaries on navigation",
        "id": "resetting-suspense-boundaries-on-navigation"
      },
      {
        "level": 3,
        "text": "Providing a fallback for server errors and client-only content",
        "id": "providing-a-fallback-for-server-errors-and-client-only-content"
      },
      {
        "level": 3,
        "text": "How do I prevent the UI from being replaced by a fallback during an update?",
        "id": "preventing-unwanted-fallbacks"
      },
      {
        "level": 4,
        "text": "Props",
        "id": "props"
      },
      {
        "level": 4,
        "text": "Caveats",
        "id": "caveats"
      }
    ],
    "codeBlocks": [
      {
        "language": "text",
        "code": "<Suspense fallback={<Loading />}>  <SomeComponent /></Suspense>"
      },
      {
        "language": "text",
        "code": "<Suspense fallback={<Loading />}>  <SomeComponent /></Suspense>"
      },
      {
        "language": "text",
        "code": "startTransition"
      },
      {
        "language": "text",
        "code": "useDeferredValue"
      },
      {
        "language": "text",
        "code": "<Suspense fallback={<Loading />}>  <Albums /></Suspense>"
      },
      {
        "language": "text",
        "code": "<Suspense fallback={<Loading />}>  <Albums /></Suspense>"
      },
      {
        "language": "text",
        "code": "import { Suspense } from 'react';\nimport Albums from './Albums.js';\n\nexport default function ArtistPage({ artist }) {\n  return (\n    <>\n      <h1>{artist.name}</h1>\n      <Suspense fallback={<Loading />}>\n        <Albums artistId={artist.id} />\n      </Suspense>\n    </>\n  );\n}\n\nfunction Loading() {\n  return <h2>🌀 Loading...</h2>;\n}"
      },
      {
        "language": "text",
        "code": "<Suspense fallback={<Loading />}>  <Biography />  <Panel>    <Albums />  </Panel></Suspense>"
      },
      {
        "language": "text",
        "code": "<Suspense fallback={<Loading />}>  <Biography />  <Panel>    <Albums />  </Panel></Suspense>"
      },
      {
        "language": "text",
        "code": "import { Suspense } from 'react';\nimport Albums from './Albums.js';\nimport Biography from './Biography.js';\nimport Panel from './Panel.js';\n\nexport default function ArtistPage({ artist }) {\n  return (\n    <>\n      <h1>{artist.name}</h1>\n      <Suspense fallback={<Loading />}>\n        <Biography artistId={artist.id} />\n        <Panel>\n          <Albums artistId={artist.id} />\n        </Panel>\n      </Suspense>\n    </>\n  );\n}\n\nfunction Loading() {\n  return <h2>🌀 Loading...</h2>;\n}"
      },
      {
        "language": "text",
        "code": "<Suspense fallback={<Loading />}>  <Details artistId={artist.id} /></Suspense>function Details({ artistId }) {  return (    <>      <Biography artistId={artistId} />      <Panel>        <Albums artistId={artistId} />      </Panel>    </>  );}"
      },
      {
        "language": "text",
        "code": "<Suspense fallback={<Loading />}>  <Details artistId={artist.id} /></Suspense>function Details({ artistId }) {  return (    <>      <Biography artistId={artistId} />      <Panel>        <Albums artistId={artistId} />      </Panel>    </>  );}"
      },
      {
        "language": "text",
        "code": "<Suspense fallback={<BigSpinner />}>  <Biography />  <Suspense fallback={<AlbumsGlimmer />}>    <Panel>      <Albums />    </Panel>  </Suspense></Suspense>"
      },
      {
        "language": "text",
        "code": "<Suspense fallback={<BigSpinner />}>  <Biography />  <Suspense fallback={<AlbumsGlimmer />}>    <Panel>      <Albums />    </Panel>  </Suspense></Suspense>"
      },
      {
        "language": "text",
        "code": "AlbumsGlimmer"
      },
      {
        "language": "text",
        "code": "AlbumsGlimmer"
      },
      {
        "language": "text",
        "code": "import { Suspense } from 'react';\nimport Albums from './Albums.js';\nimport Biography from './Biography.js';\nimport Panel from './Panel.js';\n\nexport default function ArtistPage({ artist }) {\n  return (\n    <>\n      <h1>{artist.name}</h1>\n      <Suspense fallback={<BigSpinner />}>\n        <Biography artistId={artist.id} />\n        <Suspense fallback={<AlbumsGlimmer />}>\n          <Panel>\n            <Albums artistId={artist.id} />\n          </Panel>\n        </Suspense>\n      </Suspense>\n    </>\n  );\n}\n\nfunction BigSpinner() {\n  return <h2>🌀 Loading...</h2>;\n}\n\nfunction AlbumsGlimmer() {\n  return (\n    <div className=\"glimmer-panel\">\n      <div className=\"glimmer-line\" />\n      <div className=\"glimmer-line\" />\n      <div className=\"glimmer-line\" />\n    </div>\n  );\n}"
      },
      {
        "language": "text",
        "code": "SearchResults"
      },
      {
        "language": "text",
        "code": "import { Suspense, useState } from 'react';\nimport SearchResults from './SearchResults.js';\n\nexport default function App() {\n  const [query, setQuery] = useState('');\n  return (\n    <>\n      <label>\n        Search albums:\n        <input value={query} onChange={e => setQuery(e.target.value)} />\n      </label>\n      <Suspense fallback={<h2>Loading...</h2>}>\n        <SearchResults query={query} />\n      </Suspense>\n    </>\n  );\n}"
      },
      {
        "language": "text",
        "code": "useDeferredValue"
      },
      {
        "language": "text",
        "code": "export default function App() {  const [query, setQuery] = useState('');  const deferredQuery = useDeferredValue(query);  return (    <>      <label>        Search albums:        <input value={query} onChange={e => setQuery(e.target.value)} />      </label>      <Suspense fallback={<h2>Loading...</h2>}>        <SearchResults query={deferredQuery} />      </Suspense>    </>  );}"
      },
      {
        "language": "text",
        "code": "export default function App() {  const [query, setQuery] = useState('');  const deferredQuery = useDeferredValue(query);  return (    <>      <label>        Search albums:        <input value={query} onChange={e => setQuery(e.target.value)} />      </label>      <Suspense fallback={<h2>Loading...</h2>}>        <SearchResults query={deferredQuery} />      </Suspense>    </>  );}"
      },
      {
        "language": "text",
        "code": "deferredQuery"
      },
      {
        "language": "text",
        "code": "SearchResults"
      },
      {
        "language": "text",
        "code": "<div style={{  opacity: query !== deferredQuery ? 0.5 : 1 }}>  <SearchResults query={deferredQuery} /></div>"
      },
      {
        "language": "text",
        "code": "<div style={{  opacity: query !== deferredQuery ? 0.5 : 1 }}>  <SearchResults query={deferredQuery} /></div>"
      },
      {
        "language": "text",
        "code": "import { Suspense, useState, useDeferredValue } from 'react';\nimport SearchResults from './SearchResults.js';\n\nexport default function App() {\n  const [query, setQuery] = useState('');\n  const deferredQuery = useDeferredValue(query);\n  const isStale = query !== deferredQuery;\n  return (\n    <>\n      <label>\n        Search albums:\n        <input value={query} onChange={e => setQuery(e.target.value)} />\n      </label>\n      <Suspense fallback={<h2>Loading...</h2>}>\n        <div style={{ opacity: isStale ? 0.5 : 1 }}>\n          <SearchResults query={deferredQuery} />\n        </div>\n      </Suspense>\n    </>\n  );\n}"
      },
      {
        "language": "text",
        "code": "import { Suspense, useState } from 'react';\nimport IndexPage from './IndexPage.js';\nimport ArtistPage from './ArtistPage.js';\nimport Layout from './Layout.js';\n\nexport default function App() {\n  return (\n    <Suspense fallback={<BigSpinner />}>\n      <Router />\n    </Suspense>\n  );\n}\n\nfunction Router() {\n  const [page, setPage] = useState('/');\n\n  function navigate(url) {\n    setPage(url);\n  }\n\n  let content;\n  if (page === '/') {\n    content = (\n      <IndexPage navigate={navigate} />\n    );\n  } else if (page === '/the-beatles') {\n    content = (\n      <ArtistPage\n        artist={{\n          id: 'the-beatles',\n          name: 'The Beatles',\n        }}\n      />\n    );\n  }\n  return (\n    <Layout>\n      {content}\n    </Layout>\n  );\n}\n\nfunction BigSpinner() {\n  return <h2>🌀 Loading...</h2>;\n}"
      },
      {
        "language": "text",
        "code": "startTransition"
      },
      {
        "language": "text",
        "code": "function Router() {  const [page, setPage] = useState('/');  function navigate(url) {    startTransition(() => {      setPage(url);          });  }  // ..."
      },
      {
        "language": "text",
        "code": "function Router() {  const [page, setPage] = useState('/');  function navigate(url) {    startTransition(() => {      setPage(url);          });  }  // ..."
      },
      {
        "language": "text",
        "code": "import { Suspense, startTransition, useState } from 'react';\nimport IndexPage from './IndexPage.js';\nimport ArtistPage from './ArtistPage.js';\nimport Layout from './Layout.js';\n\nexport default function App() {\n  return (\n    <Suspense fallback={<BigSpinner />}>\n      <Router />\n    </Suspense>\n  );\n}\n\nfunction Router() {\n  const [page, setPage] = useState('/');\n\n  function navigate(url) {\n    startTransition(() => {\n      setPage(url);\n    });\n  }\n\n  let content;\n  if (page === '/') {\n    content = (\n      <IndexPage navigate={navigate} />\n    );\n  } else if (page === '/the-beatles') {\n    content = (\n      <ArtistPage\n        artist={{\n          id: 'the-beatles',\n          name: 'The Beatles',\n        }}\n      />\n    );\n  }\n  return (\n    <Layout>\n      {content}\n    </Layout>\n  );\n}\n\nfunction BigSpinner() {\n  return <h2>🌀 Loading...</h2>;\n}"
      },
      {
        "language": "text",
        "code": "startTransition"
      },
      {
        "language": "text",
        "code": "useTransition"
      },
      {
        "language": "text",
        "code": "import { Suspense, useState, useTransition } from 'react';\nimport IndexPage from './IndexPage.js';\nimport ArtistPage from './ArtistPage.js';\nimport Layout from './Layout.js';\n\nexport default function App() {\n  return (\n    <Suspense fallback={<BigSpinner />}>\n      <Router />\n    </Suspense>\n  );\n}\n\nfunction Router() {\n  const [page, setPage] = useState('/');\n  const [isPending, startTransition] = useTransition();\n\n  function navigate(url) {\n    startTransition(() => {\n      setPage(url);\n    });\n  }\n\n  let content;\n  if (page === '/') {\n    content = (\n      <IndexPage navigate={navigate} />\n    );\n  } else if (page === '/the-beatles') {\n    content = (\n      <ArtistPage\n        artist={{\n          id: 'the-beatles',\n          name: 'The Beatles',\n        }}\n      />\n    );\n  }\n  return (\n    <Layout isPending={isPending}>\n      {content}\n    </Layout>\n  );\n}\n\nfunction BigSpinner() {\n  return <h2>🌀 Loading...</h2>;\n}"
      },
      {
        "language": "text",
        "code": "<ProfilePage key={queryParams.id} />"
      },
      {
        "language": "text",
        "code": "<ProfilePage key={queryParams.id} />"
      },
      {
        "language": "text",
        "code": "<Suspense fallback={<Loading />}>  <Chat /></Suspense>function Chat() {  if (typeof window === 'undefined') {    throw Error('Chat should only render on the client.');  }  // ...}"
      },
      {
        "language": "text",
        "code": "<Suspense fallback={<Loading />}>  <Chat /></Suspense>function Chat() {  if (typeof window === 'undefined') {    throw Error('Chat should only render on the client.');  }  // ...}"
      },
      {
        "language": "text",
        "code": "startTransition"
      },
      {
        "language": "text",
        "code": "function handleNextPageClick() {  // If this update suspends, don't hide the already displayed content  startTransition(() => {    setCurrentPage(currentPage + 1);  });}"
      },
      {
        "language": "text",
        "code": "function handleNextPageClick() {  // If this update suspends, don't hide the already displayed content  startTransition(() => {    setCurrentPage(currentPage + 1);  });}"
      },
      {
        "language": "text",
        "code": "startTransition"
      },
      {
        "language": "text",
        "code": "useDeferredValue"
      },
      {
        "language": "text",
        "code": "startTransition"
      }
    ],
    "links": [
      {
        "text": "API Reference",
        "href": "/reference/react"
      },
      {
        "text": "Components",
        "href": "/reference/react/components"
      },
      {
        "text": "startTransition",
        "href": "/reference/react/startTransition"
      },
      {
        "text": "useDeferredValue",
        "href": "/reference/react/useDeferredValue"
      },
      {
        "text": "layout Effects",
        "href": "/reference/react/useLayoutEffect"
      },
      {
        "text": "an architectural overview",
        "href": "https://github.com/reactwg/react-18/discussions/37"
      },
      {
        "text": "a technical talk",
        "href": "https://www.youtube.com/watch?v=pj5N-Khihgc"
      },
      {
        "text": "Relay",
        "href": "https://relay.dev/docs/guided-tour/rendering/loading-states/"
      },
      {
        "text": "Next.js",
        "href": "https://nextjs.org/docs/app/building-your-application/routing/loading-ui-and-streaming#streaming-with-suspense"
      },
      {
        "text": "lazy",
        "href": "/reference/react/lazy"
      },
      {
        "text": "use",
        "href": "/reference/react/use"
      },
      {
        "text": "useDeferredValue",
        "href": "/reference/react/useDeferredValue"
      },
      {
        "text": "startTransition:",
        "href": "/reference/react/startTransition"
      },
      {
        "text": "startTransition",
        "href": "/reference/react/startTransition"
      },
      {
        "text": "useTransition",
        "href": "/reference/react/useTransition"
      },
      {
        "text": "streaming server rendering APIs",
        "href": "/reference/react-dom/server"
      },
      {
        "text": "error boundary.",
        "href": "/reference/react/Component#static-getderivedstatefromerror"
      },
      {
        "text": "startTransition",
        "href": "/reference/react/startTransition"
      },
      {
        "text": "useDeferredValue",
        "href": "/reference/react/useDeferredValue"
      },
      {
        "text": "startTransition",
        "href": "/reference/react/startTransition"
      },
      {
        "text": "Previous<StrictMode>",
        "href": "/reference/react/StrictMode"
      },
      {
        "text": "Next<Activity>",
        "href": "/reference/react/Activity"
      }
    ],
    "meta": {
      "description": "",
      "keywords": ""
    },
    "summary": "API ReferenceComponentsSuspenseSuspense lets you display a fallback until its children have finished loading",
    "tags": [
      "react",
      "angular",
      "javascript",
      "typescript",
      "css",
      "html",
      "node",
      "content",
      "suspense",
      "fallback"
    ],
    "id": "suspense-react-Suspense-part-1",
    "quality": 100
  },
  {
    "title": "Reactivity Fundamentals",
    "url": "https://vuejs.org/guide/essentials/reactivity-fundamentals.html",
    "category": "vue",
    "content": "Reactivity Fundamentals API PreferenceThis page and many other chapters later in the guide contain different content for the Options API and the Composition API. Your current preference is Options APIComposition API. You can toggle between the API styles using the \"API Preference\" switches at the top of the left sidebar.Declaring Reactive State With the Options API, we use the data option to declare reactive state of a component. The option value should be a function that returns an object. Vue will call the function when creating a new component instance, and wrap the returned object in its reactivity system. Any top-level properties of this object are proxied on the component instance (this in methods and lifecycle hooks):jsexport default { data() { return { count: 1 } }, // mounted is a lifecycle hook which we will explain later mounted() { // this refers to the component instance. console.log(this.count) // = 1 // data can be mutated as well this.count = 2 } }Try it in the PlaygroundThese instance properties are only added when the instance is first created, so you need to ensure they are all present in the object returned by the data function. Where necessary, use null, undefined or some other placeholder value for properties where the desired value isn't yet available.It is possible to add a new property directly to this without including it in data. However, properties added this way will not be able to trigger reactive updates.Vue uses a $ prefix when exposing its own built-in APIs via the component instance. It also reserves the prefix _ for internal properties. You should avoid using names for top-level data properties that start with either of these characters.Reactive Proxy vs. Original In Vue 3, data is made reactive by leveraging JavaScript Proxies. Users coming from Vue 2 should be aware of the following edge case:jsexport default { data() { return { someObject: {} } }, mounted() { const newObject = {} this.someObject = newObject console.log(newObject === this.someObject) // false } }When you access this.someObject after assigning it, the value is a reactive proxy of the original newObject. Unlike in Vue 2, the original newObject is left intact and will not be made reactive: make sure to always access reactive state as a property of this.Declaring Reactive State ref() In Composition API, the recommended way to declare reactive state is using the ref() function:jsimport { ref } from 'vue' const count = ref(0)ref() takes the argument and returns it wrapped within a ref object with a .value property:jsconst count = ref(0) console.log(count) // { value: 0 } console.log(count.value) // 0 count.value++ console.log(count.value) // 1See also: Typing Refs To access refs in a component's template, declare and return them from a component's setup() function:jsimport { ref } from 'vue' export default { // setup is a special hook dedicated for the Composition API. setup() { const count = ref(0) // expose the ref to the template return { count } } }templatediv{{ count }}/divNotice that we did not need to append .value when using the ref in the template. For convenience, refs are automatically unwrapped when used inside templates (with a few caveats).You can also mutate a ref directly in event handlers:templatebutton @click=\"count++\" {{ count }} /buttonFor more complex logic, we can declare functions that mutate refs in the same scope and expose them as methods alongside the state:jsimport { ref } from 'vue' export default { setup() { const count = ref(0) function increment() { // .value is needed in JavaScript count.value++ } // don't forget to expose the function as well. return { count, increment } } }Exposed methods can then be used as event handlers:templatebutton @click=\"increment\" {{ count }} /buttonHere's the example live on Codepen, without using any build tools.script setup Manually exposing state and methods via setup() can be verbose. Luckily, it can be avoided when using Single-File Components (SFCs). We can simplify the usage with script setup:vuescript setup import { ref } from 'vue' const count = ref(0) function increment() { count.value++ } /script template button @click=\"increment\" {{ count }} /button /templateTry it in the PlaygroundTop-level imports, variables and functions declared in script setup are automatically usable in the template of the same component. Think of the template as a JavaScript function declared in the same scope - it naturally has access to everything declared alongside it.TIPFor the rest of the guide, we will be primarily using SFC + script setup syntax for the Composition API code examples, as that is the most common usage for Vue developers.If you are not using SFC, you can still use Composition API with the setup() option.Why Refs? You might be wondering why we need refs with the .value instead of plain variables. To explain that, we will need to briefly discuss how Vue's reactivity system works.When you use a ref in a template, and change the ref's value later, Vue automatically detects the change and updates the DOM accordingly. This is made possible with a dependency-tracking based reactivity system. When a component is rendered for the first time, Vue tracks every ref that was used during the render. Later on, when a ref is mutated, it will trigger a re-render for components that are tracking it.In standard JavaScript, there is no way to detect the access or mutation of plain variables. However, we can intercept the get and set operations of an object's properties using getter and setter methods.The .value property gives Vue the opportunity to detect when a ref has been accessed or mutated. Under the hood, Vue performs the tracking in its getter, and performs triggering in its setter. Conceptually, you can think of a ref as an object that looks like this:js// pseudo code, not actual implementation const myRef = { _value: 0, get value() { track() return this._value }, set value(newValue) { this._value = newValue trigger() } }Another nice trait of refs is that unlike plain variables, you can pass refs into functions while retaining access to the latest value and the reactivity connection. This is particularly useful when refactoring complex logic into reusable code.The reactivity system is discussed in more details in the Reactivity in Depth section.Declaring Methods Watch a free video lesson on Vue SchoolTo add methods to a component instance we use the methods option. This should be an object containing the desired methods:jsexport default { data() { return { count: 0 } }, methods: { increment() { this.count++ } }, mounted() { // methods can be called in lifecycle hooks, or other methods! this.increment() } }Vue automatically binds the this value for methods so that it always refers to the component instance. This ensures that a method retains the correct this value if it's used as an event listener or callback. You should avoid using arrow functions when defining methods, as that prevents Vue from binding the appropriate this value:jsexport default { methods: { increment: () = { // BAD: no this access here! } } }Just like all other properties of the component instance, the methods are accessible from within the component's template. Inside a template they are most commonly used as event listeners:templatebutton @click=\"increment\"{{ count }}/buttonTry it in the PlaygroundIn the example above, the method increment will be called when the button is clicked.Deep Reactivity In Vue, state is deeply reactive by default. This means you can expect changes to be detected even when you mutate nested objects or arrays:jsexport default { data() { return { obj: { nested: { count: 0 }, arr: ['foo', 'bar'] } } }, methods: { mutateDeeply() { // these will work as expected. this.obj.nested.count++ this.obj.arr.push('baz') } } }Refs can hold any value type, including deeply nested objects, arrays, or JavaScript built-in data structures like Map.A ref will make its value deeply reactive. This means you can expect changes to be detected even when you mutate nested objects or arrays:jsimport { ref } from 'vue' const obj = ref({ nested: { count: 0 }, arr: ['foo', 'bar'] }) function mutateDeeply() { // these will work as expected. obj.value.nested.count++ obj.value.arr.push('baz') }Non-primitive values are turned into reactive proxies via reactive(), which is discussed below.It is also possible to opt-out of deep reactivity with shallow refs. For shallow refs, only .value access is tracked for reactivity. Shallow refs can be used for optimizing performance by avoiding the observation cost of large objects, or in cases where the inner state is managed by an external library.Further reading:Reduce Reactivity Overhead for Large Immutable StructuresIntegration with External State SystemsDOM Update Timing When you mutate reactive state, the DOM is updated automatically. However, it should be noted that the DOM updates are not applied synchronously. Instead, Vue buffers them until the \"next tick\" in the update cycle to ensure that each component updates only once no matter how many state changes you have made.To wait for the DOM update to complete after a state change, you can use the nextTick() global API:jsimport { nextTick } from 'vue' async function increment() { count.value++ await nextTick() // Now the DOM is updated }jsimport { nextTick } from 'vue' export default { methods: { async increment() { this.count++ await nextTick() // Now the DOM is updated } } }reactive() There is another way to declare reactive state, with the reactive() API. Unlike a ref which wraps the inner value in a special object, reactive() makes an object itself reactive:jsimport { reactive } from 'vue' const state = reactive({ count: 0 })See also: Typing Reactive Usage in template:templatebutton @click=\"state.count++\" {{ state.count }} /buttonReactive objects are JavaScript Proxies and behave just like normal objects. The difference is that Vue is able to intercept the access and mutation of all properties of a reactive object for reactivity tracking and triggering.reactive() converts the object deeply: nested objects are also wrapped with reactive() when accessed. It is also called by ref() internally when the ref value is an object. Similar to shallow refs, there is also the shallowReactive() API for opting-out of deep reactivity.Reactive Proxy vs. Original It is important to note that the returned value from reactive() is a Proxy of the original object, which is not equal to the original object:jsconst raw = {} const proxy = reactive(raw) // proxy is NOT equal to the original. console.log(proxy === raw) // falseOnly the proxy is reactive - mutating the original object will not trigger updates. Therefore, the best practice when working with Vue's reactivity system is to exclusively use the proxied versions of your state.To ensure consistent access to the proxy, calling reactive() on the same object always returns the same proxy, and calling reactive() on an existing proxy also returns that same proxy:js// calling reactive() on the same object returns the same proxy console.log(reactive(raw) === proxy) // true // calling reactive() on a proxy returns itself console.log(reactive(proxy) === proxy) // trueThis rule applies to nested objects as well. Due to deep reactivity, nested objects inside a reactive object are also proxies:jsconst proxy = reactive({}) const raw = {} proxy.nested = raw console.log(proxy.nested === raw) // falseLimitations of reactive() The reactive() API has a few limitations:Limited value types: it only works for object types (objects, arrays, and collection types such as Map and Set). It cannot hold primitive types such as string, number or boolean.Cannot replace entire object: since Vue's reactivity tracking works over property access, we must always keep the same reference to the reactive object. This means we can't easily \"replace\" a reactive object because the reactivity connection to the first reference is lost:jslet state = reactive({ count: 0 }) // the above reference ({ count: 0 }) is no longer being tracked // (reactivity connection is lost!) state = reactive({ count: 1 })Not destructure-friendly: when we destructure a reactive object's primitive type property into local variables, or when we pass that property into a function, we will lose the reactivity connection:jsconst state = reactive({ count: 0 }) // count is disconnected from state.count when destructured. let { count } = state // does not affect original state count++ // the function receives a plain number and // won't be able to track changes to state.count // we have to pass the entire object in to retain reactivity callSomeFunction(state.count)Due to these limitations, we recommend using ref() as the primary API for declaring reactive state.Additional Ref Unwrapping Details As Reactive Object Property A ref is automatically unwrapped when accessed or mutated as a property of a reactive object. In other words, it behaves like a normal property:jsconst count = ref(0) const state = reactive({ count }) console.log(state.count) // 0 state.count = 1 console.log(count.value) // 1If a new ref is assigned to a property linked to an existing ref, it will replace the old ref:jsconst otherCount = ref(2) state.count = otherCount console.log(state.count) // 2 // original ref is now disconnected from state.count console.log(count.value) // 1Ref unwrapping only happens when nested inside a deep reactive object. It does not apply when it is accessed as a property of a shallow reactive object.Caveat in Arrays and Collections Unlike reactive objects, there is no unwrapping performed when the ref is accessed as an element of a reactive array or a native collection type like Map:jsconst books = reactive([ref('Vue 3 Guide')]) // need .value here console.log(books[0].value) const map = reactive(new Map([['count', ref(0)]])) // need .value here console.log(map.get('count').value)Caveat when Unwrapping in Templates Ref unwrapping in templates only applies if the ref is a top-level property in the template render context.In the example below, count and object are top-level properties, but object.id is not:jsconst count = ref(0) const object = { id: ref(1) }Therefore, this expression works as expected:template{{ count + 1 }}...while this one does NOT:template{{ object.id + 1 }}The rendered result will be [object Object]1 because object.id is not unwrapped when evaluating the expression and remains a ref object. To fix this, we can destructure id into a top-level property:jsconst { id } = objecttemplate{{ id + 1 }}Now the render result will be 2.Another thing to note is that a ref does get unwrapped if it is the final evaluated value of a text interpolation (i.e. a {{ }} tag), so the following will render 1:template{{ object.id }}This is just a convenience feature of text interpolation and is equivalent to {{ object.id.value }}.Stateful Methods In some cases, we may need to dynamically create a method function, for example creating a debounced event handler:jsimport { debounce } from 'lodash-es' export default { methods: { // Debouncing with Lodash click: debounce(function () { // ... respond to click ... }, 500) } }However, this approach is problematic for components that are reused because a debounced function is stateful: it maintains some internal state on the elapsed time. If multiple component instances share the same debounced function, they will interfere with one another.To keep each component instance's debounced function independent of the others, we can create the debounced version in the created lifecycle hook:jsexport default { created() { // each instance now has its own copy of debounced handler this.debouncedClick = _.debounce(this.click, 500) }, unmounted() { // also a good idea to cancel the timer // when the component is removed this.debouncedClick.cancel() }, methods: { click() { // ... respond to click ... } } }Edit this page on GitHub",
    "headings": [
      {
        "level": 1,
        "text": "Reactivity Fundamentals ​",
        "id": "reactivity-fundamentals"
      },
      {
        "level": 2,
        "text": "Declaring Reactive State ​",
        "id": "declaring-reactive-state"
      },
      {
        "level": 2,
        "text": "Declaring Reactive State ​",
        "id": "declaring-reactive-state-1"
      },
      {
        "level": 2,
        "text": "Declaring Methods ​",
        "id": "declaring-methods"
      },
      {
        "level": 2,
        "text": "reactive() ​",
        "id": "reactive"
      },
      {
        "level": 2,
        "text": "Additional Ref Unwrapping Details ​",
        "id": "additional-ref-unwrapping-details"
      },
      {
        "level": 3,
        "text": "Reactive Proxy vs. Original ​",
        "id": "reactive-proxy-vs-original"
      },
      {
        "level": 3,
        "text": "ref() ​",
        "id": "ref"
      },
      {
        "level": 3,
        "text": "<script setup> ​",
        "id": "script-setup"
      },
      {
        "level": 3,
        "text": "Why Refs? ​",
        "id": "why-refs"
      },
      {
        "level": 3,
        "text": "Deep Reactivity ​",
        "id": "deep-reactivity"
      },
      {
        "level": 3,
        "text": "DOM Update Timing ​",
        "id": "dom-update-timing"
      },
      {
        "level": 3,
        "text": "Reactive Proxy vs. Original ​",
        "id": "reactive-proxy-vs-original-1"
      },
      {
        "level": 3,
        "text": "Limitations of reactive() ​",
        "id": "limitations-of-reactive"
      },
      {
        "level": 3,
        "text": "As Reactive Object Property ​",
        "id": "ref-unwrapping-as-reactive-object-property"
      },
      {
        "level": 3,
        "text": "Caveat in Arrays and Collections ​",
        "id": "caveat-in-arrays-and-collections"
      },
      {
        "level": 3,
        "text": "Caveat when Unwrapping in Templates ​",
        "id": "caveat-when-unwrapping-in-templates"
      },
      {
        "level": 3,
        "text": "Stateful Methods ​",
        "id": "stateful-methods"
      }
    ],
    "codeBlocks": [
      {
        "language": "text",
        "code": "export default {\n  data() {\n    return {\n      count: 1\n    }\n  },\n\n  // `mounted` is a lifecycle hook which we will explain later\n  mounted() {\n    // `this` refers to the component instance.\n    console.log(this.count) // => 1\n\n    // data can be mutated as well\n    this.count = 2\n  }\n}"
      },
      {
        "language": "text",
        "code": "export default {\n  data() {\n    return {\n      count: 1\n    }\n  },\n\n  // `mounted` is a lifecycle hook which we will explain later\n  mounted() {\n    // `this` refers to the component instance.\n    console.log(this.count) // => 1\n\n    // data can be mutated as well\n    this.count = 2\n  }\n}"
      },
      {
        "language": "text",
        "code": "export default {\n  data() {\n    return {\n      someObject: {}\n    }\n  },\n  mounted() {\n    const newObject = {}\n    this.someObject = newObject\n\n    console.log(newObject === this.someObject) // false\n  }\n}"
      },
      {
        "language": "text",
        "code": "export default {\n  data() {\n    return {\n      someObject: {}\n    }\n  },\n  mounted() {\n    const newObject = {}\n    this.someObject = newObject\n\n    console.log(newObject === this.someObject) // false\n  }\n}"
      },
      {
        "language": "text",
        "code": "this.someObject"
      },
      {
        "language": "text",
        "code": "import { ref } from 'vue'\n\nconst count = ref(0)"
      },
      {
        "language": "text",
        "code": "import { ref } from 'vue'\n\nconst count = ref(0)"
      },
      {
        "language": "text",
        "code": "const count = ref(0)\n\nconsole.log(count) // { value: 0 }\nconsole.log(count.value) // 0\n\ncount.value++\nconsole.log(count.value) // 1"
      },
      {
        "language": "text",
        "code": "const count = ref(0)\n\nconsole.log(count) // { value: 0 }\nconsole.log(count.value) // 0\n\ncount.value++\nconsole.log(count.value) // 1"
      },
      {
        "language": "text",
        "code": "import { ref } from 'vue'\n\nexport default {\n  // `setup` is a special hook dedicated for the Composition API.\n  setup() {\n    const count = ref(0)\n\n    // expose the ref to the template\n    return {\n      count\n    }\n  }\n}"
      },
      {
        "language": "text",
        "code": "import { ref } from 'vue'\n\nexport default {\n  // `setup` is a special hook dedicated for the Composition API.\n  setup() {\n    const count = ref(0)\n\n    // expose the ref to the template\n    return {\n      count\n    }\n  }\n}"
      },
      {
        "language": "text",
        "code": "<div>{{ count }}</div>"
      },
      {
        "language": "text",
        "code": "<div>{{ count }}</div>"
      },
      {
        "language": "text",
        "code": "<button @click=\"count++\">\n  {{ count }}\n</button>"
      },
      {
        "language": "text",
        "code": "<button @click=\"count++\">\n  {{ count }}\n</button>"
      },
      {
        "language": "text",
        "code": "import { ref } from 'vue'\n\nexport default {\n  setup() {\n    const count = ref(0)\n\n    function increment() {\n      // .value is needed in JavaScript\n      count.value++\n    }\n\n    // don't forget to expose the function as well.\n    return {\n      count,\n      increment\n    }\n  }\n}"
      },
      {
        "language": "text",
        "code": "import { ref } from 'vue'\n\nexport default {\n  setup() {\n    const count = ref(0)\n\n    function increment() {\n      // .value is needed in JavaScript\n      count.value++\n    }\n\n    // don't forget to expose the function as well.\n    return {\n      count,\n      increment\n    }\n  }\n}"
      },
      {
        "language": "text",
        "code": "<button @click=\"increment\">\n  {{ count }}\n</button>"
      },
      {
        "language": "text",
        "code": "<button @click=\"increment\">\n  {{ count }}\n</button>"
      },
      {
        "language": "text",
        "code": "<script setup>"
      },
      {
        "language": "text",
        "code": "<script setup>"
      },
      {
        "language": "text",
        "code": "<script setup>\nimport { ref } from 'vue'\n\nconst count = ref(0)\n\nfunction increment() {\n  count.value++\n}\n</script>\n\n<template>\n  <button @click=\"increment\">\n    {{ count }}\n  </button>\n</template>"
      },
      {
        "language": "text",
        "code": "<script setup>\nimport { ref } from 'vue'\n\nconst count = ref(0)\n\nfunction increment() {\n  count.value++\n}\n</script>\n\n<template>\n  <button @click=\"increment\">\n    {{ count }}\n  </button>\n</template>"
      },
      {
        "language": "text",
        "code": "<script setup>"
      },
      {
        "language": "text",
        "code": "<script setup>"
      },
      {
        "language": "text",
        "code": "// pseudo code, not actual implementation\nconst myRef = {\n  _value: 0,\n  get value() {\n    track()\n    return this._value\n  },\n  set value(newValue) {\n    this._value = newValue\n    trigger()\n  }\n}"
      },
      {
        "language": "text",
        "code": "// pseudo code, not actual implementation\nconst myRef = {\n  _value: 0,\n  get value() {\n    track()\n    return this._value\n  },\n  set value(newValue) {\n    this._value = newValue\n    trigger()\n  }\n}"
      },
      {
        "language": "text",
        "code": "export default {\n  data() {\n    return {\n      count: 0\n    }\n  },\n  methods: {\n    increment() {\n      this.count++\n    }\n  },\n  mounted() {\n    // methods can be called in lifecycle hooks, or other methods!\n    this.increment()\n  }\n}"
      },
      {
        "language": "text",
        "code": "export default {\n  data() {\n    return {\n      count: 0\n    }\n  },\n  methods: {\n    increment() {\n      this.count++\n    }\n  },\n  mounted() {\n    // methods can be called in lifecycle hooks, or other methods!\n    this.increment()\n  }\n}"
      },
      {
        "language": "text",
        "code": "export default {\n  methods: {\n    increment: () => {\n      // BAD: no `this` access here!\n    }\n  }\n}"
      },
      {
        "language": "text",
        "code": "export default {\n  methods: {\n    increment: () => {\n      // BAD: no `this` access here!\n    }\n  }\n}"
      },
      {
        "language": "text",
        "code": "<button @click=\"increment\">{{ count }}</button>"
      },
      {
        "language": "text",
        "code": "<button @click=\"increment\">{{ count }}</button>"
      },
      {
        "language": "text",
        "code": "export default {\n  data() {\n    return {\n      obj: {\n        nested: { count: 0 },\n        arr: ['foo', 'bar']\n      }\n    }\n  },\n  methods: {\n    mutateDeeply() {\n      // these will work as expected.\n      this.obj.nested.count++\n      this.obj.arr.push('baz')\n    }\n  }\n}"
      },
      {
        "language": "text",
        "code": "export default {\n  data() {\n    return {\n      obj: {\n        nested: { count: 0 },\n        arr: ['foo', 'bar']\n      }\n    }\n  },\n  methods: {\n    mutateDeeply() {\n      // these will work as expected.\n      this.obj.nested.count++\n      this.obj.arr.push('baz')\n    }\n  }\n}"
      },
      {
        "language": "text",
        "code": "import { ref } from 'vue'\n\nconst obj = ref({\n  nested: { count: 0 },\n  arr: ['foo', 'bar']\n})\n\nfunction mutateDeeply() {\n  // these will work as expected.\n  obj.value.nested.count++\n  obj.value.arr.push('baz')\n}"
      },
      {
        "language": "text",
        "code": "import { ref } from 'vue'\n\nconst obj = ref({\n  nested: { count: 0 },\n  arr: ['foo', 'bar']\n})\n\nfunction mutateDeeply() {\n  // these will work as expected.\n  obj.value.nested.count++\n  obj.value.arr.push('baz')\n}"
      },
      {
        "language": "text",
        "code": "import { nextTick } from 'vue'\n\nasync function increment() {\n  count.value++\n  await nextTick()\n  // Now the DOM is updated\n}"
      },
      {
        "language": "text",
        "code": "import { nextTick } from 'vue'\n\nasync function increment() {\n  count.value++\n  await nextTick()\n  // Now the DOM is updated\n}"
      },
      {
        "language": "text",
        "code": "import { nextTick } from 'vue'\n\nexport default {\n  methods: {\n    async increment() {\n      this.count++\n      await nextTick()\n      // Now the DOM is updated\n    }\n  }\n}"
      },
      {
        "language": "text",
        "code": "import { nextTick } from 'vue'\n\nexport default {\n  methods: {\n    async increment() {\n      this.count++\n      await nextTick()\n      // Now the DOM is updated\n    }\n  }\n}"
      },
      {
        "language": "text",
        "code": "import { reactive } from 'vue'\n\nconst state = reactive({ count: 0 })"
      },
      {
        "language": "text",
        "code": "import { reactive } from 'vue'\n\nconst state = reactive({ count: 0 })"
      },
      {
        "language": "text",
        "code": "<button @click=\"state.count++\">\n  {{ state.count }}\n</button>"
      },
      {
        "language": "text",
        "code": "<button @click=\"state.count++\">\n  {{ state.count }}\n</button>"
      },
      {
        "language": "text",
        "code": "shallowReactive()"
      },
      {
        "language": "text",
        "code": "const raw = {}\nconst proxy = reactive(raw)\n\n// proxy is NOT equal to the original.\nconsole.log(proxy === raw) // false"
      },
      {
        "language": "text",
        "code": "const raw = {}\nconst proxy = reactive(raw)\n\n// proxy is NOT equal to the original.\nconsole.log(proxy === raw) // false"
      },
      {
        "language": "text",
        "code": "// calling reactive() on the same object returns the same proxy\nconsole.log(reactive(raw) === proxy) // true\n\n// calling reactive() on a proxy returns itself\nconsole.log(reactive(proxy) === proxy) // true"
      },
      {
        "language": "text",
        "code": "// calling reactive() on the same object returns the same proxy\nconsole.log(reactive(raw) === proxy) // true\n\n// calling reactive() on a proxy returns itself\nconsole.log(reactive(proxy) === proxy) // true"
      },
      {
        "language": "text",
        "code": "const proxy = reactive({})\n\nconst raw = {}\nproxy.nested = raw\n\nconsole.log(proxy.nested === raw) // false"
      },
      {
        "language": "text",
        "code": "const proxy = reactive({})\n\nconst raw = {}\nproxy.nested = raw\n\nconsole.log(proxy.nested === raw) // false"
      },
      {
        "language": "text",
        "code": "let state = reactive({ count: 0 })\n\n// the above reference ({ count: 0 }) is no longer being tracked\n// (reactivity connection is lost!)\nstate = reactive({ count: 1 })"
      },
      {
        "language": "text",
        "code": "let state = reactive({ count: 0 })\n\n// the above reference ({ count: 0 }) is no longer being tracked\n// (reactivity connection is lost!)\nstate = reactive({ count: 1 })"
      },
      {
        "language": "text",
        "code": "const state = reactive({ count: 0 })\n\n// count is disconnected from state.count when destructured.\nlet { count } = state\n// does not affect original state\ncount++\n\n// the function receives a plain number and\n// won't be able to track changes to state.count\n// we have to pass the entire object in to retain reactivity\ncallSomeFunction(state.count)"
      },
      {
        "language": "text",
        "code": "const state = reactive({ count: 0 })\n\n// count is disconnected from state.count when destructured.\nlet { count } = state\n// does not affect original state\ncount++\n\n// the function receives a plain number and\n// won't be able to track changes to state.count\n// we have to pass the entire object in to retain reactivity\ncallSomeFunction(state.count)"
      },
      {
        "language": "text",
        "code": "const count = ref(0)\nconst state = reactive({\n  count\n})\n\nconsole.log(state.count) // 0\n\nstate.count = 1\nconsole.log(count.value) // 1"
      },
      {
        "language": "text",
        "code": "const count = ref(0)\nconst state = reactive({\n  count\n})\n\nconsole.log(state.count) // 0\n\nstate.count = 1\nconsole.log(count.value) // 1"
      },
      {
        "language": "text",
        "code": "const otherCount = ref(2)\n\nstate.count = otherCount\nconsole.log(state.count) // 2\n// original ref is now disconnected from state.count\nconsole.log(count.value) // 1"
      },
      {
        "language": "text",
        "code": "const otherCount = ref(2)\n\nstate.count = otherCount\nconsole.log(state.count) // 2\n// original ref is now disconnected from state.count\nconsole.log(count.value) // 1"
      },
      {
        "language": "text",
        "code": "const books = reactive([ref('Vue 3 Guide')])\n// need .value here\nconsole.log(books[0].value)\n\nconst map = reactive(new Map([['count', ref(0)]]))\n// need .value here\nconsole.log(map.get('count').value)"
      },
      {
        "language": "text",
        "code": "const books = reactive([ref('Vue 3 Guide')])\n// need .value here\nconsole.log(books[0].value)\n\nconst map = reactive(new Map([['count', ref(0)]]))\n// need .value here\nconsole.log(map.get('count').value)"
      },
      {
        "language": "text",
        "code": "const count = ref(0)\nconst object = { id: ref(1) }"
      },
      {
        "language": "text",
        "code": "const count = ref(0)\nconst object = { id: ref(1) }"
      },
      {
        "language": "text",
        "code": "{{ count + 1 }}"
      },
      {
        "language": "text",
        "code": "{{ count + 1 }}"
      },
      {
        "language": "text",
        "code": "{{ object.id + 1 }}"
      },
      {
        "language": "text",
        "code": "{{ object.id + 1 }}"
      },
      {
        "language": "text",
        "code": "[object Object]1"
      },
      {
        "language": "text",
        "code": "const { id } = object"
      },
      {
        "language": "text",
        "code": "const { id } = object"
      },
      {
        "language": "text",
        "code": "{{ id + 1 }}"
      },
      {
        "language": "text",
        "code": "{{ id + 1 }}"
      },
      {
        "language": "text",
        "code": "{{ object.id }}"
      },
      {
        "language": "text",
        "code": "{{ object.id }}"
      },
      {
        "language": "text",
        "code": "{{ object.id.value }}"
      },
      {
        "language": "text",
        "code": "import { debounce } from 'lodash-es'\n\nexport default {\n  methods: {\n    // Debouncing with Lodash\n    click: debounce(function () {\n      // ... respond to click ...\n    }, 500)\n  }\n}"
      },
      {
        "language": "text",
        "code": "import { debounce } from 'lodash-es'\n\nexport default {\n  methods: {\n    // Debouncing with Lodash\n    click: debounce(function () {\n      // ... respond to click ...\n    }, 500)\n  }\n}"
      },
      {
        "language": "text",
        "code": "export default {\n  created() {\n    // each instance now has its own copy of debounced handler\n    this.debouncedClick = _.debounce(this.click, 500)\n  },\n  unmounted() {\n    // also a good idea to cancel the timer\n    // when the component is removed\n    this.debouncedClick.cancel()\n  },\n  methods: {\n    click() {\n      // ... respond to click ...\n    }\n  }\n}"
      },
      {
        "language": "text",
        "code": "export default {\n  created() {\n    // each instance now has its own copy of debounced handler\n    this.debouncedClick = _.debounce(this.click, 500)\n  },\n  unmounted() {\n    // also a good idea to cancel the timer\n    // when the component is removed\n    this.debouncedClick.cancel()\n  },\n  methods: {\n    click() {\n      // ... respond to click ...\n    }\n  }\n}"
      }
    ],
    "links": [
      {
        "text": "Try it in the Playground",
        "href": "https://play.vuejs.org/#eNpFUNFqhDAQ/JXBpzsoHu2j3B2U/oYPpnGtoetGkrW2iP/eRFsPApthd2Zndilex7H8mqioimu0wY16r4W+Rx8ULXVmYsVSC9AaNafz/gcC6RTkHwHWT6IVnne85rI+1ZLr5YJmyG1qG7gIA3Yd2R/LhN77T8y9sz1mwuyYkXazcQI2SiHz/7iP3VlQexeb5KKjEKEe2lPyMIxeSBROohqxVO4E6yV6ppL9xykTy83tOQvd7tnzoZtDwhrBO2GYNFloYWLyxrzPPOi44WWLWUt618txvASUhhRCKSHgbZt2scKy7HfCujGOqWL9BVfOgyI="
      },
      {
        "text": "JavaScript Proxies",
        "href": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Proxy"
      },
      {
        "text": "ref()",
        "href": "/api/reactivity-core#ref"
      },
      {
        "text": "Typing Refs",
        "href": "/guide/typescript/composition-api#typing-ref"
      },
      {
        "text": "Codepen",
        "href": "https://codepen.io/vuejs-examples/pen/WNYbaqo"
      },
      {
        "text": "Single-File Components (SFCs)",
        "href": "/guide/scaling-up/sfc"
      },
      {
        "text": "Try it in the Playground",
        "href": "https://play.vuejs.org/#eNo9jUEKgzAQRa8yZKMiaNcllvYe2dgwQqiZhDhxE3L3jrW4/DPvv1/UK8Zhz6juSm82uciwIef4MOR8DImhQMIFKiwpeGgEbQwZsoE2BhsyMUwH0d66475ksuwCgSOb0CNx20ExBCc77POase8NVUN6PBdlSwKjj+vMKAlAvzOzWJ52dfYzGXXpjPoBAKX856uopDGeFfnq8XKp+gWq4FAi"
      },
      {
        "text": "setup()",
        "href": "/api/composition-api-setup"
      },
      {
        "text": "Reactivity in Depth",
        "href": "/guide/extras/reactivity-in-depth"
      },
      {
        "text": "Watch a free video lesson on Vue School",
        "href": "https://vueschool.io/lessons/methods-in-vue-3?friend=vuejs"
      },
      {
        "text": "Try it in the Playground",
        "href": "https://play.vuejs.org/#eNplj9EKwyAMRX8l+LSx0e65uLL9hy+dZlTWqtg4BuK/z1baDgZicsPJgUR2d656B2QN45P02lErDH6c9QQKn10YCKIwAKqj7nAsPYBHCt6sCUDaYKiBS8lpLuk8/yNSb9XUrKg20uOIhnYXAPV6qhbF6fRvmOeodn6hfzwLKkx+vN5OyIFwdENHmBMAfwQia+AmBy1fV8E2gWBtjOUASInXBcxLvN4MLH0BCe1i4Q=="
      },
      {
        "text": "shallow refs",
        "href": "/api/reactivity-advanced#shallowref"
      },
      {
        "text": "Reduce Reactivity Overhead for Large Immutable Structures",
        "href": "/guide/best-practices/performance#reduce-reactivity-overhead-for-large-immutable-structures"
      },
      {
        "text": "Integration with External State Systems",
        "href": "/guide/extras/reactivity-in-depth#integration-with-external-state-systems"
      },
      {
        "text": "nextTick()",
        "href": "/api/general#nexttick"
      },
      {
        "text": "Typing Reactive",
        "href": "/guide/typescript/composition-api#typing-reactive"
      },
      {
        "text": "JavaScript Proxies",
        "href": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Proxy"
      },
      {
        "text": "shallowReactive()",
        "href": "/api/reactivity-advanced#shallowreactive"
      },
      {
        "text": "Proxy",
        "href": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Proxy"
      },
      {
        "text": "collection types",
        "href": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects#keyed_collections"
      },
      {
        "text": "primitive types",
        "href": "https://developer.mozilla.org/en-US/docs/Glossary/Primitive"
      },
      {
        "text": "shallow reactive object",
        "href": "/api/reactivity-advanced#shallowreactive"
      },
      {
        "text": "Edit this page on GitHub",
        "href": "https://github.com/vuejs/docs/edit/main/src/guide/essentials/reactivity-fundamentals.md"
      }
    ],
    "meta": {
      "description": "Vue.js - The Progressive JavaScript Framework",
      "keywords": ""
    },
    "summary": "Reactivity Fundamentals API PreferenceThis page and many other chapters later in the guide contain different content for the Options API and the Composition API",
    "tags": [
      "react",
      "vue",
      "angular",
      "javascript",
      "typescript",
      "css",
      "html",
      "vite",
      "reactive",
      "reactivity"
    ],
    "id": "reactivity-fundamentals-reactivityfundamentalshtml-part-1",
    "quality": 100
  },
  {
    "title": "Computed Properties",
    "url": "https://vuejs.org/guide/essentials/computed.html",
    "category": "vue",
    "content": "Computed Properties Watch a free video lesson on Vue SchoolWatch a free video lesson on Vue SchoolBasic Example In-template expressions are very convenient, but they are meant for simple operations. Putting too much logic in your templates can make them bloated and hard to maintain. For example, if we have an object with a nested array:jsexport default { data() { return { author: { name: 'John Doe', books: [ 'Vue 2 - Advanced Guide', 'Vue 3 - Basic Guide', 'Vue 4 - The Mystery' ] } } } }jsconst author = reactive({ name: 'John Doe', books: [ 'Vue 2 - Advanced Guide', 'Vue 3 - Basic Guide', 'Vue 4 - The Mystery' ] })And we want to display different messages depending on if author already has some books or not:templatepHas published books:/p span{{ author.books.length  0 ? 'Yes' : 'No' }}/spanAt this point, the template is getting a bit cluttered. We have to look at it for a second before realizing that it performs a calculation depending on author.books. More importantly, we probably don't want to repeat ourselves if we need to include this calculation in the template more than once.That's why for complex logic that includes reactive data, it is recommended to use a computed property. Here's the same example, refactored:jsexport default { data() { return { author: { name: 'John Doe', books: [ 'Vue 2 - Advanced Guide', 'Vue 3 - Basic Guide', 'Vue 4 - The Mystery' ] } } }, computed: { // a computed getter publishedBooksMessage() { // this points to the component instance return this.author.books.length  0 ? 'Yes' : 'No' } } }templatepHas published books:/p span{{ publishedBooksMessage }}/spanTry it in the PlaygroundHere we have declared a computed property publishedBooksMessage.Try to change the value of the books array in the application data and you will see how publishedBooksMessage is changing accordingly.You can data-bind to computed properties in templates just like a normal property. Vue is aware that this.publishedBooksMessage depends on this.author.books, so it will update any bindings that depend on this.publishedBooksMessage when this.author.books changes.See also: Typing Computed Properties vuescript setup import { reactive, computed } from 'vue' const author = reactive({ name: 'John Doe', books: [ 'Vue 2 - Advanced Guide', 'Vue 3 - Basic Guide', 'Vue 4 - The Mystery' ] }) // a computed ref const publishedBooksMessage = computed(() = { return author.books.length  0 ? 'Yes' : 'No' }) /script template pHas published books:/p span{{ publishedBooksMessage }}/span /templateTry it in the PlaygroundHere we have declared a computed property publishedBooksMessage. The computed() function expects to be passed a getter function, and the returned value is a computed ref. Similar to normal refs, you can access the computed result as publishedBooksMessage.value. Computed refs are also auto-unwrapped in templates so you can reference them without .value in template expressions.A computed property automatically tracks its reactive dependencies. Vue is aware that the computation of publishedBooksMessage depends on author.books, so it will update any bindings that depend on publishedBooksMessage when author.books changes.See also: Typing Computed Computed Caching vs. Methods You may have noticed we can achieve the same result by invoking a method in the expression:templatep{{ calculateBooksMessage() }}/pjs// in component methods: { calculateBooksMessage() { return this.author.books.length  0 ? 'Yes' : 'No' } }js// in component function calculateBooksMessage() { return author.books.length  0 ? 'Yes' : 'No' }Instead of a computed property, we can define the same function as a method. For the end result, the two approaches are indeed exactly the same. However, the difference is that computed properties are cached based on their reactive dependencies. A computed property will only re-evaluate when some of its reactive dependencies have changed. This means as long as author.books has not changed, multiple access to publishedBooksMessage will immediately return the previously computed result without having to run the getter function again.This also means the following computed property will never update, because Date.now() is not a reactive dependency:jscomputed: { now() { return Date.now() } }jsconst now = computed(() = Date.now())In comparison, a method invocation will always run the function whenever a re-render happens.Why do we need caching? Imagine we have an expensive computed property list, which requires looping through a huge array and doing a lot of computations. Then we may have other computed properties that in turn depend on list. Without caching, we would be executing lists getter many more times than necessary! In cases where you do not want caching, use a method call instead.Writable Computed Computed properties are by default getter-only. If you attempt to assign a new value to a computed property, you will receive a runtime warning. In the rare cases where you need a \"writable\" computed property, you can create one by providing both a getter and a setter:jsexport default { data() { return { firstName: 'John', lastName: 'Doe' } }, computed: { fullName: { // getter get() { return this.firstName + ' ' + this.lastName }, // setter set(newValue) { // Note: we are using destructuring assignment syntax here. [this.firstName, this.lastName] = newValue.split(' ') } } } }Now when you run this.fullName = 'John Doe', the setter will be invoked and this.firstName and this.lastName will be updated accordingly.vuescript setup import { ref, computed } from 'vue' const firstName = ref('John') const lastName = ref('Doe') const fullName = computed({ // getter get() { return firstName.value + ' ' + lastName.value }, // setter set(newValue) { // Note: we are using destructuring assignment syntax here. [firstName.value, lastName.value] = newValue.split(' ') } }) /scriptNow when you run fullName.value = 'John Doe', the setter will be invoked and firstName and lastName will be updated accordingly.Getting the Previous Value Only supported in 3.4+ In case you need it, you can get the previous value returned by the computed property accessing the second argument of the getter: In case you need it, you can get the previous value returned by the computed property accessing the first argument of the getter: jsexport default { data() { return { count: 2 } }, computed: { // This computed will return the value of count when it's less or equal to 3. // When count is =4, the last value that fulfilled our condition will be returned // instead until count is less or equal to 3 alwaysSmall(_, previous) { if (this.count = 3) { return this.count } return previous } } }vuescript setup import { ref, computed } from 'vue' const count = ref(2) // This computed will return the value of count when it's less or equal to 3. // When count is =4, the last value that fulfilled our condition will be returned // instead until count is less or equal to 3 const alwaysSmall = computed((previous) = { if (count.value = 3) { return count.value } return previous }) /scriptIn case you're using a writable computed:jsexport default { data() { return { count: 2 } }, computed: { alwaysSmall: { get(_, previous) { if (this.count = 3) { return this.count } return previous; }, set(newValue) { this.count = newValue * 2 } } } }vuescript setup import { ref, computed } from 'vue' const count = ref(2) const alwaysSmall = computed({ get(previous) { if (count.value = 3) { return count.value } return previous }, set(newValue) { count.value = newValue * 2 } }) /scriptBest Practices Getters should be side-effect free It is important to remember that computed getter functions should only perform pure computation and be free of side effects. For example, don't mutate other state, make async requests, or mutate the DOM inside a computed getter! Think of a computed property as declaratively describing how to derive a value based on other values - its only responsibility should be computing and returning that value. Later in the guide we will discuss how we can perform side effects in reaction to state changes with watchers.Avoid mutating computed value The returned value from a computed property is derived state. Think of it as a temporary snapshot - every time the source state changes, a new snapshot is created. It does not make sense to mutate a snapshot, so a computed return value should be treated as read-only and never be mutated - instead, update the source state it depends on to trigger new computations.Edit this page on GitHub",
    "headings": [
      {
        "level": 1,
        "text": "Computed Properties ​",
        "id": "computed-properties"
      },
      {
        "level": 2,
        "text": "Basic Example ​",
        "id": "basic-example"
      },
      {
        "level": 2,
        "text": "Computed Caching vs. Methods ​",
        "id": "computed-caching-vs-methods"
      },
      {
        "level": 2,
        "text": "Writable Computed ​",
        "id": "writable-computed"
      },
      {
        "level": 2,
        "text": "Getting the Previous Value ​",
        "id": "previous"
      },
      {
        "level": 2,
        "text": "Best Practices ​",
        "id": "best-practices"
      },
      {
        "level": 3,
        "text": "Getters should be side-effect free ​",
        "id": "getters-should-be-side-effect-free"
      },
      {
        "level": 3,
        "text": "Avoid mutating computed value ​",
        "id": "avoid-mutating-computed-value"
      }
    ],
    "codeBlocks": [
      {
        "language": "text",
        "code": "export default {\n  data() {\n    return {\n      author: {\n        name: 'John Doe',\n        books: [\n          'Vue 2 - Advanced Guide',\n          'Vue 3 - Basic Guide',\n          'Vue 4 - The Mystery'\n        ]\n      }\n    }\n  }\n}"
      },
      {
        "language": "text",
        "code": "export default {\n  data() {\n    return {\n      author: {\n        name: 'John Doe',\n        books: [\n          'Vue 2 - Advanced Guide',\n          'Vue 3 - Basic Guide',\n          'Vue 4 - The Mystery'\n        ]\n      }\n    }\n  }\n}"
      },
      {
        "language": "text",
        "code": "const author = reactive({\n  name: 'John Doe',\n  books: [\n    'Vue 2 - Advanced Guide',\n    'Vue 3 - Basic Guide',\n    'Vue 4 - The Mystery'\n  ]\n})"
      },
      {
        "language": "text",
        "code": "const author = reactive({\n  name: 'John Doe',\n  books: [\n    'Vue 2 - Advanced Guide',\n    'Vue 3 - Basic Guide',\n    'Vue 4 - The Mystery'\n  ]\n})"
      },
      {
        "language": "text",
        "code": "<p>Has published books:</p>\n<span>{{ author.books.length > 0 ? 'Yes' : 'No' }}</span>"
      },
      {
        "language": "text",
        "code": "<p>Has published books:</p>\n<span>{{ author.books.length > 0 ? 'Yes' : 'No' }}</span>"
      },
      {
        "language": "text",
        "code": "author.books"
      },
      {
        "language": "text",
        "code": "export default {\n  data() {\n    return {\n      author: {\n        name: 'John Doe',\n        books: [\n          'Vue 2 - Advanced Guide',\n          'Vue 3 - Basic Guide',\n          'Vue 4 - The Mystery'\n        ]\n      }\n    }\n  },\n  computed: {\n    // a computed getter\n    publishedBooksMessage() {\n      // `this` points to the component instance\n      return this.author.books.length > 0 ? 'Yes' : 'No'\n    }\n  }\n}"
      },
      {
        "language": "text",
        "code": "export default {\n  data() {\n    return {\n      author: {\n        name: 'John Doe',\n        books: [\n          'Vue 2 - Advanced Guide',\n          'Vue 3 - Basic Guide',\n          'Vue 4 - The Mystery'\n        ]\n      }\n    }\n  },\n  computed: {\n    // a computed getter\n    publishedBooksMessage() {\n      // `this` points to the component instance\n      return this.author.books.length > 0 ? 'Yes' : 'No'\n    }\n  }\n}"
      },
      {
        "language": "text",
        "code": "<p>Has published books:</p>\n<span>{{ publishedBooksMessage }}</span>"
      },
      {
        "language": "text",
        "code": "<p>Has published books:</p>\n<span>{{ publishedBooksMessage }}</span>"
      },
      {
        "language": "text",
        "code": "publishedBooksMessage"
      },
      {
        "language": "text",
        "code": "publishedBooksMessage"
      },
      {
        "language": "text",
        "code": "this.publishedBooksMessage"
      },
      {
        "language": "text",
        "code": "this.author.books"
      },
      {
        "language": "text",
        "code": "this.publishedBooksMessage"
      },
      {
        "language": "text",
        "code": "this.author.books"
      },
      {
        "language": "text",
        "code": "<script setup>\nimport { reactive, computed } from 'vue'\n\nconst author = reactive({\n  name: 'John Doe',\n  books: [\n    'Vue 2 - Advanced Guide',\n    'Vue 3 - Basic Guide',\n    'Vue 4 - The Mystery'\n  ]\n})\n\n// a computed ref\nconst publishedBooksMessage = computed(() => {\n  return author.books.length > 0 ? 'Yes' : 'No'\n})\n</script>\n\n<template>\n  <p>Has published books:</p>\n  <span>{{ publishedBooksMessage }}</span>\n</template>"
      },
      {
        "language": "text",
        "code": "<script setup>\nimport { reactive, computed } from 'vue'\n\nconst author = reactive({\n  name: 'John Doe',\n  books: [\n    'Vue 2 - Advanced Guide',\n    'Vue 3 - Basic Guide',\n    'Vue 4 - The Mystery'\n  ]\n})\n\n// a computed ref\nconst publishedBooksMessage = computed(() => {\n  return author.books.length > 0 ? 'Yes' : 'No'\n})\n</script>\n\n<template>\n  <p>Has published books:</p>\n  <span>{{ publishedBooksMessage }}</span>\n</template>"
      },
      {
        "language": "text",
        "code": "publishedBooksMessage"
      },
      {
        "language": "text",
        "code": "publishedBooksMessage.value"
      },
      {
        "language": "text",
        "code": "publishedBooksMessage"
      },
      {
        "language": "text",
        "code": "author.books"
      },
      {
        "language": "text",
        "code": "publishedBooksMessage"
      },
      {
        "language": "text",
        "code": "author.books"
      },
      {
        "language": "text",
        "code": "<p>{{ calculateBooksMessage() }}</p>"
      },
      {
        "language": "text",
        "code": "<p>{{ calculateBooksMessage() }}</p>"
      },
      {
        "language": "text",
        "code": "// in component\nmethods: {\n  calculateBooksMessage() {\n    return this.author.books.length > 0 ? 'Yes' : 'No'\n  }\n}"
      },
      {
        "language": "text",
        "code": "// in component\nmethods: {\n  calculateBooksMessage() {\n    return this.author.books.length > 0 ? 'Yes' : 'No'\n  }\n}"
      },
      {
        "language": "text",
        "code": "// in component\nfunction calculateBooksMessage() {\n  return author.books.length > 0 ? 'Yes' : 'No'\n}"
      },
      {
        "language": "text",
        "code": "// in component\nfunction calculateBooksMessage() {\n  return author.books.length > 0 ? 'Yes' : 'No'\n}"
      },
      {
        "language": "text",
        "code": "author.books"
      },
      {
        "language": "text",
        "code": "publishedBooksMessage"
      },
      {
        "language": "text",
        "code": "computed: {\n  now() {\n    return Date.now()\n  }\n}"
      },
      {
        "language": "text",
        "code": "computed: {\n  now() {\n    return Date.now()\n  }\n}"
      },
      {
        "language": "text",
        "code": "const now = computed(() => Date.now())"
      },
      {
        "language": "text",
        "code": "const now = computed(() => Date.now())"
      },
      {
        "language": "text",
        "code": "export default {\n  data() {\n    return {\n      firstName: 'John',\n      lastName: 'Doe'\n    }\n  },\n  computed: {\n    fullName: {\n      // getter\n      get() {\n        return this.firstName + ' ' + this.lastName\n      },\n      // setter\n      set(newValue) {\n        // Note: we are using destructuring assignment syntax here.\n        [this.firstName, this.lastName] = newValue.split(' ')\n      }\n    }\n  }\n}"
      },
      {
        "language": "text",
        "code": "export default {\n  data() {\n    return {\n      firstName: 'John',\n      lastName: 'Doe'\n    }\n  },\n  computed: {\n    fullName: {\n      // getter\n      get() {\n        return this.firstName + ' ' + this.lastName\n      },\n      // setter\n      set(newValue) {\n        // Note: we are using destructuring assignment syntax here.\n        [this.firstName, this.lastName] = newValue.split(' ')\n      }\n    }\n  }\n}"
      },
      {
        "language": "text",
        "code": "this.fullName = 'John Doe'"
      },
      {
        "language": "text",
        "code": "this.firstName"
      },
      {
        "language": "text",
        "code": "this.lastName"
      },
      {
        "language": "text",
        "code": "<script setup>\nimport { ref, computed } from 'vue'\n\nconst firstName = ref('John')\nconst lastName = ref('Doe')\n\nconst fullName = computed({\n  // getter\n  get() {\n    return firstName.value + ' ' + lastName.value\n  },\n  // setter\n  set(newValue) {\n    // Note: we are using destructuring assignment syntax here.\n    [firstName.value, lastName.value] = newValue.split(' ')\n  }\n})\n</script>"
      },
      {
        "language": "text",
        "code": "<script setup>\nimport { ref, computed } from 'vue'\n\nconst firstName = ref('John')\nconst lastName = ref('Doe')\n\nconst fullName = computed({\n  // getter\n  get() {\n    return firstName.value + ' ' + lastName.value\n  },\n  // setter\n  set(newValue) {\n    // Note: we are using destructuring assignment syntax here.\n    [firstName.value, lastName.value] = newValue.split(' ')\n  }\n})\n</script>"
      },
      {
        "language": "text",
        "code": "fullName.value = 'John Doe'"
      },
      {
        "language": "text",
        "code": "export default {\n  data() {\n    return {\n      count: 2\n    }\n  },\n  computed: {\n    // This computed will return the value of count when it's less or equal to 3.\n    // When count is >=4, the last value that fulfilled our condition will be returned\n    // instead until count is less or equal to 3\n    alwaysSmall(_, previous) {\n      if (this.count <= 3) {\n        return this.count\n      }\n\n      return previous\n    }\n  }\n}"
      },
      {
        "language": "text",
        "code": "export default {\n  data() {\n    return {\n      count: 2\n    }\n  },\n  computed: {\n    // This computed will return the value of count when it's less or equal to 3.\n    // When count is >=4, the last value that fulfilled our condition will be returned\n    // instead until count is less or equal to 3\n    alwaysSmall(_, previous) {\n      if (this.count <= 3) {\n        return this.count\n      }\n\n      return previous\n    }\n  }\n}"
      },
      {
        "language": "text",
        "code": "<script setup>\nimport { ref, computed } from 'vue'\n\nconst count = ref(2)\n\n// This computed will return the value of count when it's less or equal to 3.\n// When count is >=4, the last value that fulfilled our condition will be returned\n// instead until count is less or equal to 3\nconst alwaysSmall = computed((previous) => {\n  if (count.value <= 3) {\n    return count.value\n  }\n\n  return previous\n})\n</script>"
      },
      {
        "language": "text",
        "code": "<script setup>\nimport { ref, computed } from 'vue'\n\nconst count = ref(2)\n\n// This computed will return the value of count when it's less or equal to 3.\n// When count is >=4, the last value that fulfilled our condition will be returned\n// instead until count is less or equal to 3\nconst alwaysSmall = computed((previous) => {\n  if (count.value <= 3) {\n    return count.value\n  }\n\n  return previous\n})\n</script>"
      },
      {
        "language": "text",
        "code": "export default {\n  data() {\n    return {\n      count: 2\n    }\n  },\n  computed: {\n    alwaysSmall: {\n      get(_, previous) {\n        if (this.count <= 3) {\n          return this.count\n        }\n\n        return previous;\n      },\n      set(newValue) {\n        this.count = newValue * 2\n      }\n    }\n  }\n}"
      },
      {
        "language": "text",
        "code": "export default {\n  data() {\n    return {\n      count: 2\n    }\n  },\n  computed: {\n    alwaysSmall: {\n      get(_, previous) {\n        if (this.count <= 3) {\n          return this.count\n        }\n\n        return previous;\n      },\n      set(newValue) {\n        this.count = newValue * 2\n      }\n    }\n  }\n}"
      },
      {
        "language": "text",
        "code": "<script setup>\nimport { ref, computed } from 'vue'\n\nconst count = ref(2)\n\nconst alwaysSmall = computed({\n  get(previous) {\n    if (count.value <= 3) {\n      return count.value\n    }\n\n    return previous\n  },\n  set(newValue) {\n    count.value = newValue * 2\n  }\n})\n</script>"
      },
      {
        "language": "text",
        "code": "<script setup>\nimport { ref, computed } from 'vue'\n\nconst count = ref(2)\n\nconst alwaysSmall = computed({\n  get(previous) {\n    if (count.value <= 3) {\n      return count.value\n    }\n\n    return previous\n  },\n  set(newValue) {\n    count.value = newValue * 2\n  }\n})\n</script>"
      }
    ],
    "links": [
      {
        "text": "Watch a free video lesson on Vue School",
        "href": "https://vueschool.io/lessons/computed-properties-in-vue-3?friend=vuejs"
      },
      {
        "text": "Watch a free video lesson on Vue School",
        "href": "https://vueschool.io/lessons/vue-fundamentals-capi-computed-properties-in-vue-with-the-composition-api?friend=vuejs"
      },
      {
        "text": "Try it in the Playground",
        "href": "https://play.vuejs.org/#eNqFkN1KxDAQhV/l0JsqaFfUq1IquwiKsF6JINaLbDNui20S8rO4lL676c82eCFCIDOZMzkzXxetlUoOjqI0ykypa2XzQtC3ktqC0ydzjUVXCIAzy87OpxjQZJ0WpwxgzlZSp+EBEKylFPGTrATuJcUXobST8sukeA8vQPzqCNe4xJofmCiJ48HV/FfbLLrxog0zdfmn4tYrXirC9mgs6WMcBB+nsJ+C8erHH0rZKmeJL0sot2tqUxHfDONuyRi2p4BggWCr2iQTgGTcLGlI7G2FHFe4Q/xGJoYn8SznQSbTQviTrRboPrHUqoZZ8hmQqfyRmTDFTC1bqalsFBN5183o/3NG33uvoWUwXYyi/gdTEpwK"
      },
      {
        "text": "Typing Computed Properties",
        "href": "/guide/typescript/options-api#typing-computed-properties"
      },
      {
        "text": "Try it in the Playground",
        "href": "https://play.vuejs.org/#eNp1kE9Lw0AQxb/KI5dtoTainkoaaREUoZ5EEONhm0ybYLO77J9CCfnuzta0vdjbzr6Zeb95XbIwZroPlMySzJW2MR6OfDB5oZrWaOvRwZIsfbOnCUrdmuCpQo+N1S0ET4pCFarUynnI4GttMT9PjLpCAUq2NIN41bXCkyYxiZ9rrX/cDF/xDYiPQLjDDRbVXqqSHZ5DUw2tg3zP8lK6pvxHe2DtvSasDs6TPTAT8F2ofhzh0hTygm5pc+I1Yb1rXE3VMsKsyDm5JcY/9Y5GY8xzHI+wnIpVw4nTI/10R2rra+S4xSPEJzkBvvNNs310ztK/RDlLLjy1Zic9cQVkJn+R7gIwxJGlMXiWnZEq77orhH3Pq2NH9DjvTfpfSBSbmA=="
      },
      {
        "text": "getter function",
        "href": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Functions/get#description"
      },
      {
        "text": "Typing Computed",
        "href": "/guide/typescript/composition-api#typing-computed"
      },
      {
        "text": "watchers",
        "href": "/guide/essentials/watchers"
      },
      {
        "text": "Edit this page on GitHub",
        "href": "https://github.com/vuejs/docs/edit/main/src/guide/essentials/computed.md"
      }
    ],
    "meta": {
      "description": "Vue.js - The Progressive JavaScript Framework",
      "keywords": ""
    },
    "summary": "Computed Properties Watch a free video lesson on Vue SchoolWatch a free video lesson on Vue SchoolBasic Example In-template expressions are very convenient, but they are meant for simple operations",
    "tags": [
      "react",
      "vue",
      "angular",
      "javascript",
      "typescript",
      "html",
      "computed",
      "properties",
      "value",
      "basic"
    ],
    "id": "computed-properties-computedhtml-part-1",
    "quality": 100
  },
  {
    "title": "Watchers",
    "url": "https://vuejs.org/guide/essentials/watchers.html",
    "category": "vue",
    "content": "Watchers Basic Example Computed properties allow us to declaratively compute derived values. However, there are cases where we need to perform \"side effects\" in reaction to state changes - for example, mutating the DOM, or changing another piece of state based on the result of an async operation.With the Options API, we can use the watch option to trigger a function whenever a reactive property changes:jsexport default { data() { return { question: '', answer: 'Questions usually contain a question mark. ;-)', loading: false } }, watch: { // whenever question changes, this function will run question(newQuestion, oldQuestion) { if (newQuestion.includes('?')) { this.getAnswer() } } }, methods: { async getAnswer() { this.loading = true this.answer = 'Thinking...' try { const res = await fetch('https://yesno.wtf/api') this.answer = (await res.json()).answer } catch (error) { this.answer = 'Error! Could not reach the API. ' + error } finally { this.loading = false } } } }templatep Ask a yes/no question: input v-model=\"question\" :disabled=\"loading\" / /p p{{ answer }}/pTry it in the PlaygroundThe watch option also supports a dot-delimited path as the key:jsexport default { watch: { // Note: only simple paths. Expressions are not supported. 'some.nested.key'(newValue) { // ... } } }With Composition API, we can use the watch function to trigger a callback whenever a piece of reactive state changes:vuescript setup import { ref, watch } from 'vue' const question = ref('') const answer = ref('Questions usually contain a question mark. ;-)') const loading = ref(false) // watch works directly on a ref watch(question, async (newQuestion, oldQuestion) = { if (newQuestion.includes('?')) { loading.value = true answer.value = 'Thinking...' try { const res = await fetch('https://yesno.wtf/api') answer.value = (await res.json()).answer } catch (error) { answer.value = 'Error! Could not reach the API. ' + error } finally { loading.value = false } } }) /script template p Ask a yes/no question: input v-model=\"question\" :disabled=\"loading\" / /p p{{ answer }}/p /templateTry it in the PlaygroundWatch Source Types watch's first argument can be different types of reactive \"sources\": it can be a ref (including computed refs), a reactive object, a getter function, or an array of multiple sources:jsconst x = ref(0) const y = ref(0) // single ref watch(x, (newX) = { console.log(x is ${newX}) }) // getter watch( () = x.value + y.value, (sum) = { console.log(sum of x + y is: ${sum}) } ) // array of multiple sources watch([x, () = y.value], ([newX, newY]) = { console.log(x is ${newX} and y is ${newY}) })Do note that you can't watch a property of a reactive object like this:jsconst obj = reactive({ count: 0 }) // this won't work because we are passing a number to watch() watch(obj.count, (count) = { console.log(Count is: ${count}) })Instead, use a getter:js// instead, use a getter: watch( () = obj.count, (count) = { console.log(Count is: ${count}) } )Deep Watchers watch is shallow by default: the callback will only trigger when the watched property has been assigned a new value - it won't trigger on nested property changes. If you want the callback to fire on all nested mutations, you need to use a deep watcher:jsexport default { watch: { someObject: { handler(newValue, oldValue) { // Note: newValue will be equal to oldValue here // on nested mutations as long as the object itself // hasn't been replaced. }, deep: true } } }When you call watch() directly on a reactive object, it will implicitly create a deep watcher - the callback will be triggered on all nested mutations:jsconst obj = reactive({ count: 0 }) watch(obj, (newValue, oldValue) = { // fires on nested property mutations // Note: newValue will be equal to oldValue here // because they both point to the same object! }) obj.count++This should be differentiated with a getter that returns a reactive object - in the latter case, the callback will only fire if the getter returns a different object:jswatch( () = state.someObject, () = { // fires only when state.someObject is replaced } )You can, however, force the second case into a deep watcher by explicitly using the deep option:jswatch( () = state.someObject, (newValue, oldValue) = { // Note: newValue will be equal to oldValue here // *unless* state.someObject has been replaced }, { deep: true } )In Vue 3.5+, the deep option can also be a number indicating the max traversal depth - i.e. how many levels should Vue traverse an object's nested properties.Use with CautionDeep watch requires traversing all nested properties in the watched object, and can be expensive when used on large data structures. Use it only when necessary and beware of the performance implications.Eager Watchers watch is lazy by default: the callback won't be called until the watched source has changed. But in some cases we may want the same callback logic to be run eagerly - for example, we may want to fetch some initial data, and then re-fetch the data whenever relevant state changes.We can force a watcher's callback to be executed immediately by declaring it using an object with a handler function and the immediate: true option:jsexport default { // ... watch: { question: { handler(newQuestion) { // this will be run immediately on component creation. }, // force eager callback execution immediate: true } } // ... }The initial execution of the handler function will happen just before the created hook. Vue will have already processed the data, computed, and methods options, so those properties will be available on the first invocation.We can force a watcher's callback to be executed immediately by passing the immediate: true option:jswatch( source, (newValue, oldValue) = { // executed immediately, then again when source changes }, { immediate: true } )Once Watchers Only supported in 3.4+Watcher's callback will execute whenever the watched source changes. If you want the callback to trigger only once when the source changes, use the once: true option.jsexport default { watch: { source: { handler(newValue, oldValue) { // when source changes, triggers only once }, once: true } } }jswatch( source, (newValue, oldValue) = { // when source changes, triggers only once }, { once: true } )watchEffect() It is common for the watcher callback to use exactly the same reactive state as the source. For example, consider the following code, which uses a watcher to load a remote resource whenever the todoId ref changes:jsconst todoId = ref(1) const data = ref(null) watch( todoId, async () = { const response = await fetch( https://jsonplaceholder.typicode.com/todos/${todoId.value} ) data.value = await response.json() }, { immediate: true } )In particular, notice how the watcher uses todoId twice, once as the source and then again inside the callback.This can be simplified with watchEffect(). watchEffect() allows us to track the callback's reactive dependencies automatically. The watcher above can be rewritten as:jswatchEffect(async () = { const response = await fetch( https://jsonplaceholder.typicode.com/todos/${todoId.value} ) data.value = await response.json() })Here, the callback will run immediately, there's no need to specify immediate: true. During its execution, it will automatically track todoId.value as a dependency (similar to computed properties). Whenever todoId.value changes, the callback will be run again. With watchEffect(), we no longer need to pass todoId explicitly as the source value.You can check out this example of watchEffect() and reactive data-fetching in action.For examples like these, with only one dependency, the benefit of watchEffect() is relatively small. But for watchers that have multiple dependencies, using watchEffect() removes the burden of having to maintain the list of dependencies manually. In addition, if you need to watch several properties in a nested data structure, watchEffect() may prove more efficient than a deep watcher, as it will only track the properties that are used in the callback, rather than recursively tracking all of them.TIPwatchEffect only tracks dependencies during its synchronous execution. When using it with an async callback, only properties accessed before the first await tick will be tracked.watch vs. watchEffect watch and watchEffect both allow us to reactively perform side effects. Their main difference is the way they track their reactive dependencies:watch only tracks the explicitly watched source. It won't track anything accessed inside the callback. In addition, the callback only triggers when the source has actually changed. watch separates dependency tracking from the side effect, giving us more precise control over when the callback should fire.watchEffect, on the other hand, combines dependency tracking and side effect into one phase. It automatically tracks every reactive property accessed during its synchronous execution. This is more convenient and typically results in terser code, but makes its reactive dependencies less explicit.Side Effect Cleanup Sometimes we may perform side effects, e.g. asynchronous requests, in a watcher:jswatch(id, (newId) = { fetch(/api/${newId}).then(() = { // callback logic }) })jsexport default { watch: { id(newId) { fetch(/api/${newId}).then(() = { // callback logic }) } } }But what if id changes before the request completes? When the previous request completes, it will still fire the callback with an ID value that is already stale. Ideally, we want to be able to cancel the stale request when id changes to a new value.We can use the onWatcherCleanup() API to register a cleanup function that will be called when the watcher is invalidated and is about to re-run:jsimport { watch, onWatcherCleanup } from 'vue' watch(id, (newId) = { const controller = new AbortController() fetch(/api/${newId}, { signal: controller.signal }).then(() = { // callback logic }) onWatcherCleanup(() = { // abort stale request controller.abort() }) })jsimport { onWatcherCleanup } from 'vue' export default { watch: { id(newId) { const controller = new AbortController() fetch(/api/${newId}, { signal: controller.signal }).then(() = { // callback logic }) onWatcherCleanup(() = { // abort stale request controller.abort() }) } } }Note that onWatcherCleanup is only supported in Vue 3.5+ and must be called during the synchronous execution of a watchEffect effect function or watch callback function: you cannot call it after an await statement in an async function.Alternatively, an onCleanup function is also passed to watcher callbacks as the 3rd argument, and to the watchEffect effect function as the first argument:jswatch(id, (newId, oldId, onCleanup) = { // ... onCleanup(() = { // cleanup logic }) }) watchEffect((onCleanup) = { // ... onCleanup(() = { // cleanup logic }) })jsexport default { watch: { id(newId, oldId, onCleanup) { // ... onCleanup(() = { // cleanup logic }) } } }This works in versions before 3.5. In addition, onCleanup passed via function argument is bound to the watcher instance so it is not subject to the synchronously constraint of onWatcherCleanup.Callback Flush Timing When you mutate reactive state, it may trigger both Vue component updates and watcher callbacks created by you.Similar to component updates, user-created watcher callbacks are batched to avoid duplicate invocations. For example, we probably don't want a watcher to fire a thousand times if we synchronously push a thousand items into an array being watched.By default, a watcher's callback is called after parent component updates (if any), and before the owner component's DOM updates. This means if you attempt to access the owner component's own DOM inside a watcher callback, the DOM will be in a pre-update state.Post Watchers If you want to access the owner component's DOM in a watcher callback after Vue has updated it, you need to specify the flush: 'post' option:jsexport default { // ... watch: { key: { handler() {}, flush: 'post' } } }jswatch(source, callback, { flush: 'post' }) watchEffect(callback, { flush: 'post' })Post-flush watchEffect() also has a convenience alias, watchPostEffect():jsimport { watchPostEffect } from 'vue' watchPostEffect(() = { /* executed after Vue updates */ })Sync Watchers It's also possible to create a watcher that fires synchronously, before any Vue-managed updates:jsexport default { // ... watch: { key: { handler() {}, flush: 'sync' } } }jswatch(source, callback, { flush: 'sync' }) watchEffect(callback, { flush: 'sync' })Sync watchEffect() also has a convenience alias, watchSyncEffect():jsimport { watchSyncEffect } from 'vue' watchSyncEffect(() = { /* executed synchronously upon reactive data change */ })Use with CautionSync watchers do not have batching and triggers every time a reactive mutation is detected. It's ok to use them to watch simple boolean values, but avoid using them on data sources that might be synchronously mutated many times, e.g. arrays.this.$watch() It's also possible to imperatively create watchers using the $watch() instance method:jsexport default { created() { this.$watch('question', (newQuestion) = { // ... }) } }This is useful when you need to conditionally set up a watcher, or only watch something in response to user interaction. It also allows you to stop the watcher early.Stopping a Watcher Watchers declared using the watch option or the $watch() instance method are automatically stopped when the owner component is unmounted, so in most cases you don't need to worry about stopping the watcher yourself.In the rare case where you need to stop a watcher before the owner component unmounts, the $watch() API returns a function for that:jsconst unwatch = this.$watch('foo', callback) // ...when the watcher is no longer needed: unwatch()Watchers declared synchronously inside setup() or script setup are bound to the owner component instance, and will be automatically stopped when the owner component is unmounted. In most cases, you don't need to worry about stopping the watcher yourself.The key here is that the watcher must be created synchronously: if the watcher is created in an async callback, it won't be bound to the owner component and must be stopped manually to avoid memory leaks. Here's an example:vuescript setup import { watchEffect } from 'vue' // this one will be automatically stopped watchEffect(() = {}) // ...this one will not! setTimeout(() = { watchEffect(() = {}) }, 100) /scriptTo manually stop a watcher, use the returned handle function. This works for both watch and watchEffect:jsconst unwatch = watchEffect(() = {}) // ...later, when no longer needed unwatch()Note that there should be very few cases where you need to create watchers asynchronously, and synchronous creation should be preferred whenever possible. If you need to wait for some async data, you can make your watch logic conditional instead:js// data to be loaded asynchronously const data = ref(null) watchEffect(() = { if (data.value) { // do something when data is loaded } })Edit this page on GitHub",
    "headings": [
      {
        "level": 1,
        "text": "Watchers ​",
        "id": "watchers"
      },
      {
        "level": 2,
        "text": "Basic Example ​",
        "id": "basic-example"
      },
      {
        "level": 2,
        "text": "Deep Watchers ​",
        "id": "deep-watchers"
      },
      {
        "level": 2,
        "text": "Eager Watchers ​",
        "id": "eager-watchers"
      },
      {
        "level": 2,
        "text": "Once Watchers ​",
        "id": "once-watchers"
      },
      {
        "level": 2,
        "text": "watchEffect() ​",
        "id": "watcheffect"
      },
      {
        "level": 2,
        "text": "Side Effect Cleanup ​",
        "id": "side-effect-cleanup"
      },
      {
        "level": 2,
        "text": "Callback Flush Timing ​",
        "id": "callback-flush-timing"
      },
      {
        "level": 2,
        "text": "this.$watch() ​",
        "id": "this-watch"
      },
      {
        "level": 2,
        "text": "Stopping a Watcher ​",
        "id": "stopping-a-watcher"
      },
      {
        "level": 3,
        "text": "Watch Source Types ​",
        "id": "watch-source-types"
      },
      {
        "level": 3,
        "text": "watch vs. watchEffect ​",
        "id": "watch-vs-watcheffect"
      },
      {
        "level": 3,
        "text": "Post Watchers ​",
        "id": "post-watchers"
      },
      {
        "level": 3,
        "text": "Sync Watchers ​",
        "id": "sync-watchers"
      }
    ],
    "codeBlocks": [
      {
        "language": "text",
        "code": "export default {\n  data() {\n    return {\n      question: '',\n      answer: 'Questions usually contain a question mark. ;-)',\n      loading: false\n    }\n  },\n  watch: {\n    // whenever question changes, this function will run\n    question(newQuestion, oldQuestion) {\n      if (newQuestion.includes('?')) {\n        this.getAnswer()\n      }\n    }\n  },\n  methods: {\n    async getAnswer() {\n      this.loading = true\n      this.answer = 'Thinking...'\n      try {\n        const res = await fetch('https://yesno.wtf/api')\n        this.answer = (await res.json()).answer\n      } catch (error) {\n        this.answer = 'Error! Could not reach the API. ' + error\n      } finally {\n        this.loading = false\n      }\n    }\n  }\n}"
      },
      {
        "language": "text",
        "code": "export default {\n  data() {\n    return {\n      question: '',\n      answer: 'Questions usually contain a question mark. ;-)',\n      loading: false\n    }\n  },\n  watch: {\n    // whenever question changes, this function will run\n    question(newQuestion, oldQuestion) {\n      if (newQuestion.includes('?')) {\n        this.getAnswer()\n      }\n    }\n  },\n  methods: {\n    async getAnswer() {\n      this.loading = true\n      this.answer = 'Thinking...'\n      try {\n        const res = await fetch('https://yesno.wtf/api')\n        this.answer = (await res.json()).answer\n      } catch (error) {\n        this.answer = 'Error! Could not reach the API. ' + error\n      } finally {\n        this.loading = false\n      }\n    }\n  }\n}"
      },
      {
        "language": "text",
        "code": "<p>\n  Ask a yes/no question:\n  <input v-model=\"question\" :disabled=\"loading\" />\n</p>\n<p>{{ answer }}</p>"
      },
      {
        "language": "text",
        "code": "<p>\n  Ask a yes/no question:\n  <input v-model=\"question\" :disabled=\"loading\" />\n</p>\n<p>{{ answer }}</p>"
      },
      {
        "language": "text",
        "code": "export default {\n  watch: {\n    // Note: only simple paths. Expressions are not supported.\n    'some.nested.key'(newValue) {\n      // ...\n    }\n  }\n}"
      },
      {
        "language": "text",
        "code": "export default {\n  watch: {\n    // Note: only simple paths. Expressions are not supported.\n    'some.nested.key'(newValue) {\n      // ...\n    }\n  }\n}"
      },
      {
        "language": "text",
        "code": "<script setup>\nimport { ref, watch } from 'vue'\n\nconst question = ref('')\nconst answer = ref('Questions usually contain a question mark. ;-)')\nconst loading = ref(false)\n\n// watch works directly on a ref\nwatch(question, async (newQuestion, oldQuestion) => {\n  if (newQuestion.includes('?')) {\n    loading.value = true\n    answer.value = 'Thinking...'\n    try {\n      const res = await fetch('https://yesno.wtf/api')\n      answer.value = (await res.json()).answer\n    } catch (error) {\n      answer.value = 'Error! Could not reach the API. ' + error\n    } finally {\n      loading.value = false\n    }\n  }\n})\n</script>\n\n<template>\n  <p>\n    Ask a yes/no question:\n    <input v-model=\"question\" :disabled=\"loading\" />\n  </p>\n  <p>{{ answer }}</p>\n</template>"
      },
      {
        "language": "text",
        "code": "<script setup>\nimport { ref, watch } from 'vue'\n\nconst question = ref('')\nconst answer = ref('Questions usually contain a question mark. ;-)')\nconst loading = ref(false)\n\n// watch works directly on a ref\nwatch(question, async (newQuestion, oldQuestion) => {\n  if (newQuestion.includes('?')) {\n    loading.value = true\n    answer.value = 'Thinking...'\n    try {\n      const res = await fetch('https://yesno.wtf/api')\n      answer.value = (await res.json()).answer\n    } catch (error) {\n      answer.value = 'Error! Could not reach the API. ' + error\n    } finally {\n      loading.value = false\n    }\n  }\n})\n</script>\n\n<template>\n  <p>\n    Ask a yes/no question:\n    <input v-model=\"question\" :disabled=\"loading\" />\n  </p>\n  <p>{{ answer }}</p>\n</template>"
      },
      {
        "language": "text",
        "code": "const x = ref(0)\nconst y = ref(0)\n\n// single ref\nwatch(x, (newX) => {\n  console.log(`x is ${newX}`)\n})\n\n// getter\nwatch(\n  () => x.value + y.value,\n  (sum) => {\n    console.log(`sum of x + y is: ${sum}`)\n  }\n)\n\n// array of multiple sources\nwatch([x, () => y.value], ([newX, newY]) => {\n  console.log(`x is ${newX} and y is ${newY}`)\n})"
      },
      {
        "language": "text",
        "code": "const x = ref(0)\nconst y = ref(0)\n\n// single ref\nwatch(x, (newX) => {\n  console.log(`x is ${newX}`)\n})\n\n// getter\nwatch(\n  () => x.value + y.value,\n  (sum) => {\n    console.log(`sum of x + y is: ${sum}`)\n  }\n)\n\n// array of multiple sources\nwatch([x, () => y.value], ([newX, newY]) => {\n  console.log(`x is ${newX} and y is ${newY}`)\n})"
      },
      {
        "language": "text",
        "code": "const obj = reactive({ count: 0 })\n\n// this won't work because we are passing a number to watch()\nwatch(obj.count, (count) => {\n  console.log(`Count is: ${count}`)\n})"
      },
      {
        "language": "text",
        "code": "const obj = reactive({ count: 0 })\n\n// this won't work because we are passing a number to watch()\nwatch(obj.count, (count) => {\n  console.log(`Count is: ${count}`)\n})"
      },
      {
        "language": "text",
        "code": "// instead, use a getter:\nwatch(\n  () => obj.count,\n  (count) => {\n    console.log(`Count is: ${count}`)\n  }\n)"
      },
      {
        "language": "text",
        "code": "// instead, use a getter:\nwatch(\n  () => obj.count,\n  (count) => {\n    console.log(`Count is: ${count}`)\n  }\n)"
      },
      {
        "language": "text",
        "code": "export default {\n  watch: {\n    someObject: {\n      handler(newValue, oldValue) {\n        // Note: `newValue` will be equal to `oldValue` here\n        // on nested mutations as long as the object itself\n        // hasn't been replaced.\n      },\n      deep: true\n    }\n  }\n}"
      },
      {
        "language": "text",
        "code": "export default {\n  watch: {\n    someObject: {\n      handler(newValue, oldValue) {\n        // Note: `newValue` will be equal to `oldValue` here\n        // on nested mutations as long as the object itself\n        // hasn't been replaced.\n      },\n      deep: true\n    }\n  }\n}"
      },
      {
        "language": "text",
        "code": "const obj = reactive({ count: 0 })\n\nwatch(obj, (newValue, oldValue) => {\n  // fires on nested property mutations\n  // Note: `newValue` will be equal to `oldValue` here\n  // because they both point to the same object!\n})\n\nobj.count++"
      },
      {
        "language": "text",
        "code": "const obj = reactive({ count: 0 })\n\nwatch(obj, (newValue, oldValue) => {\n  // fires on nested property mutations\n  // Note: `newValue` will be equal to `oldValue` here\n  // because they both point to the same object!\n})\n\nobj.count++"
      },
      {
        "language": "text",
        "code": "watch(\n  () => state.someObject,\n  () => {\n    // fires only when state.someObject is replaced\n  }\n)"
      },
      {
        "language": "text",
        "code": "watch(\n  () => state.someObject,\n  () => {\n    // fires only when state.someObject is replaced\n  }\n)"
      },
      {
        "language": "text",
        "code": "watch(\n  () => state.someObject,\n  (newValue, oldValue) => {\n    // Note: `newValue` will be equal to `oldValue` here\n    // *unless* state.someObject has been replaced\n  },\n  { deep: true }\n)"
      },
      {
        "language": "text",
        "code": "watch(\n  () => state.someObject,\n  (newValue, oldValue) => {\n    // Note: `newValue` will be equal to `oldValue` here\n    // *unless* state.someObject has been replaced\n  },\n  { deep: true }\n)"
      },
      {
        "language": "text",
        "code": "immediate: true"
      },
      {
        "language": "text",
        "code": "export default {\n  // ...\n  watch: {\n    question: {\n      handler(newQuestion) {\n        // this will be run immediately on component creation.\n      },\n      // force eager callback execution\n      immediate: true\n    }\n  }\n  // ...\n}"
      },
      {
        "language": "text",
        "code": "export default {\n  // ...\n  watch: {\n    question: {\n      handler(newQuestion) {\n        // this will be run immediately on component creation.\n      },\n      // force eager callback execution\n      immediate: true\n    }\n  }\n  // ...\n}"
      },
      {
        "language": "text",
        "code": "immediate: true"
      },
      {
        "language": "text",
        "code": "watch(\n  source,\n  (newValue, oldValue) => {\n    // executed immediately, then again when `source` changes\n  },\n  { immediate: true }\n)"
      },
      {
        "language": "text",
        "code": "watch(\n  source,\n  (newValue, oldValue) => {\n    // executed immediately, then again when `source` changes\n  },\n  { immediate: true }\n)"
      },
      {
        "language": "text",
        "code": "export default {\n  watch: {\n    source: {\n      handler(newValue, oldValue) {\n        // when `source` changes, triggers only once\n      },\n      once: true\n    }\n  }\n}"
      },
      {
        "language": "text",
        "code": "export default {\n  watch: {\n    source: {\n      handler(newValue, oldValue) {\n        // when `source` changes, triggers only once\n      },\n      once: true\n    }\n  }\n}"
      },
      {
        "language": "text",
        "code": "watch(\n  source,\n  (newValue, oldValue) => {\n    // when `source` changes, triggers only once\n  },\n  { once: true }\n)"
      },
      {
        "language": "text",
        "code": "watch(\n  source,\n  (newValue, oldValue) => {\n    // when `source` changes, triggers only once\n  },\n  { once: true }\n)"
      },
      {
        "language": "text",
        "code": "watchEffect()"
      },
      {
        "language": "text",
        "code": "const todoId = ref(1)\nconst data = ref(null)\n\nwatch(\n  todoId,\n  async () => {\n    const response = await fetch(\n      `https://jsonplaceholder.typicode.com/todos/${todoId.value}`\n    )\n    data.value = await response.json()\n  },\n  { immediate: true }\n)"
      },
      {
        "language": "text",
        "code": "const todoId = ref(1)\nconst data = ref(null)\n\nwatch(\n  todoId,\n  async () => {\n    const response = await fetch(\n      `https://jsonplaceholder.typicode.com/todos/${todoId.value}`\n    )\n    data.value = await response.json()\n  },\n  { immediate: true }\n)"
      },
      {
        "language": "text",
        "code": "watchEffect()"
      },
      {
        "language": "text",
        "code": "watchEffect()"
      },
      {
        "language": "text",
        "code": "watchEffect(async () => {\n  const response = await fetch(\n    `https://jsonplaceholder.typicode.com/todos/${todoId.value}`\n  )\n  data.value = await response.json()\n})"
      },
      {
        "language": "text",
        "code": "watchEffect(async () => {\n  const response = await fetch(\n    `https://jsonplaceholder.typicode.com/todos/${todoId.value}`\n  )\n  data.value = await response.json()\n})"
      },
      {
        "language": "text",
        "code": "immediate: true"
      },
      {
        "language": "text",
        "code": "todoId.value"
      },
      {
        "language": "text",
        "code": "todoId.value"
      },
      {
        "language": "text",
        "code": "watchEffect()"
      },
      {
        "language": "text",
        "code": "watchEffect()"
      },
      {
        "language": "text",
        "code": "watchEffect()"
      },
      {
        "language": "text",
        "code": "watchEffect()"
      },
      {
        "language": "text",
        "code": "watchEffect()"
      },
      {
        "language": "text",
        "code": "watchEffect"
      },
      {
        "language": "text",
        "code": "watchEffect"
      },
      {
        "language": "text",
        "code": "watchEffect"
      },
      {
        "language": "text",
        "code": "watchEffect"
      },
      {
        "language": "text",
        "code": "watch(id, (newId) => {\n  fetch(`/api/${newId}`).then(() => {\n    // callback logic\n  })\n})"
      },
      {
        "language": "text",
        "code": "watch(id, (newId) => {\n  fetch(`/api/${newId}`).then(() => {\n    // callback logic\n  })\n})"
      },
      {
        "language": "text",
        "code": "export default {\n  watch: {\n    id(newId) {\n      fetch(`/api/${newId}`).then(() => {\n        // callback logic\n      })\n    }\n  }\n}"
      },
      {
        "language": "text",
        "code": "export default {\n  watch: {\n    id(newId) {\n      fetch(`/api/${newId}`).then(() => {\n        // callback logic\n      })\n    }\n  }\n}"
      },
      {
        "language": "text",
        "code": "onWatcherCleanup()"
      },
      {
        "language": "text",
        "code": "import { watch, onWatcherCleanup } from 'vue'\n\nwatch(id, (newId) => {\n  const controller = new AbortController()\n\n  fetch(`/api/${newId}`, { signal: controller.signal }).then(() => {\n    // callback logic\n  })\n\n  onWatcherCleanup(() => {\n    // abort stale request\n    controller.abort()\n  })\n})"
      },
      {
        "language": "text",
        "code": "import { watch, onWatcherCleanup } from 'vue'\n\nwatch(id, (newId) => {\n  const controller = new AbortController()\n\n  fetch(`/api/${newId}`, { signal: controller.signal }).then(() => {\n    // callback logic\n  })\n\n  onWatcherCleanup(() => {\n    // abort stale request\n    controller.abort()\n  })\n})"
      },
      {
        "language": "text",
        "code": "import { onWatcherCleanup } from 'vue'\n\nexport default {\n  watch: {\n    id(newId) {\n      const controller = new AbortController()\n\n      fetch(`/api/${newId}`, { signal: controller.signal }).then(() => {\n        // callback logic\n      })\n\n      onWatcherCleanup(() => {\n        // abort stale request\n        controller.abort()\n      })\n    }\n  }\n}"
      },
      {
        "language": "text",
        "code": "import { onWatcherCleanup } from 'vue'\n\nexport default {\n  watch: {\n    id(newId) {\n      const controller = new AbortController()\n\n      fetch(`/api/${newId}`, { signal: controller.signal }).then(() => {\n        // callback logic\n      })\n\n      onWatcherCleanup(() => {\n        // abort stale request\n        controller.abort()\n      })\n    }\n  }\n}"
      },
      {
        "language": "text",
        "code": "onWatcherCleanup"
      },
      {
        "language": "text",
        "code": "watchEffect"
      },
      {
        "language": "text",
        "code": "watchEffect"
      },
      {
        "language": "text",
        "code": "watch(id, (newId, oldId, onCleanup) => {\n  // ...\n  onCleanup(() => {\n    // cleanup logic\n  })\n})\n\nwatchEffect((onCleanup) => {\n  // ...\n  onCleanup(() => {\n    // cleanup logic\n  })\n})"
      },
      {
        "language": "text",
        "code": "watch(id, (newId, oldId, onCleanup) => {\n  // ...\n  onCleanup(() => {\n    // cleanup logic\n  })\n})\n\nwatchEffect((onCleanup) => {\n  // ...\n  onCleanup(() => {\n    // cleanup logic\n  })\n})"
      },
      {
        "language": "text",
        "code": "export default {\n  watch: {\n    id(newId, oldId, onCleanup) {\n      // ...\n      onCleanup(() => {\n        // cleanup logic\n      })\n    }\n  }\n}"
      },
      {
        "language": "text",
        "code": "export default {\n  watch: {\n    id(newId, oldId, onCleanup) {\n      // ...\n      onCleanup(() => {\n        // cleanup logic\n      })\n    }\n  }\n}"
      },
      {
        "language": "text",
        "code": "onWatcherCleanup"
      },
      {
        "language": "text",
        "code": "flush: 'post'"
      },
      {
        "language": "text",
        "code": "export default {\n  // ...\n  watch: {\n    key: {\n      handler() {},\n      flush: 'post'\n    }\n  }\n}"
      },
      {
        "language": "text",
        "code": "export default {\n  // ...\n  watch: {\n    key: {\n      handler() {},\n      flush: 'post'\n    }\n  }\n}"
      },
      {
        "language": "text",
        "code": "watch(source, callback, {\n  flush: 'post'\n})\n\nwatchEffect(callback, {\n  flush: 'post'\n})"
      },
      {
        "language": "text",
        "code": "watch(source, callback, {\n  flush: 'post'\n})\n\nwatchEffect(callback, {\n  flush: 'post'\n})"
      },
      {
        "language": "text",
        "code": "watchEffect()"
      },
      {
        "language": "text",
        "code": "watchPostEffect()"
      },
      {
        "language": "text",
        "code": "import { watchPostEffect } from 'vue'\n\nwatchPostEffect(() => {\n  /* executed after Vue updates */\n})"
      },
      {
        "language": "text",
        "code": "import { watchPostEffect } from 'vue'\n\nwatchPostEffect(() => {\n  /* executed after Vue updates */\n})"
      },
      {
        "language": "text",
        "code": "export default {\n  // ...\n  watch: {\n    key: {\n      handler() {},\n      flush: 'sync'\n    }\n  }\n}"
      },
      {
        "language": "text",
        "code": "export default {\n  // ...\n  watch: {\n    key: {\n      handler() {},\n      flush: 'sync'\n    }\n  }\n}"
      },
      {
        "language": "text",
        "code": "watch(source, callback, {\n  flush: 'sync'\n})\n\nwatchEffect(callback, {\n  flush: 'sync'\n})"
      },
      {
        "language": "text",
        "code": "watch(source, callback, {\n  flush: 'sync'\n})\n\nwatchEffect(callback, {\n  flush: 'sync'\n})"
      },
      {
        "language": "text",
        "code": "watchEffect()"
      },
      {
        "language": "text",
        "code": "watchSyncEffect()"
      },
      {
        "language": "text",
        "code": "import { watchSyncEffect } from 'vue'\n\nwatchSyncEffect(() => {\n  /* executed synchronously upon reactive data change */\n})"
      },
      {
        "language": "text",
        "code": "import { watchSyncEffect } from 'vue'\n\nwatchSyncEffect(() => {\n  /* executed synchronously upon reactive data change */\n})"
      },
      {
        "language": "text",
        "code": "this.$watch()"
      },
      {
        "language": "text",
        "code": "export default {\n  created() {\n    this.$watch('question', (newQuestion) => {\n      // ...\n    })\n  }\n}"
      },
      {
        "language": "text",
        "code": "export default {\n  created() {\n    this.$watch('question', (newQuestion) => {\n      // ...\n    })\n  }\n}"
      },
      {
        "language": "text",
        "code": "const unwatch = this.$watch('foo', callback)\n\n// ...when the watcher is no longer needed:\nunwatch()"
      },
      {
        "language": "text",
        "code": "const unwatch = this.$watch('foo', callback)\n\n// ...when the watcher is no longer needed:\nunwatch()"
      },
      {
        "language": "text",
        "code": "<script setup>"
      },
      {
        "language": "text",
        "code": "<script setup>\nimport { watchEffect } from 'vue'\n\n// this one will be automatically stopped\nwatchEffect(() => {})\n\n// ...this one will not!\nsetTimeout(() => {\n  watchEffect(() => {})\n}, 100)\n</script>"
      },
      {
        "language": "text",
        "code": "<script setup>\nimport { watchEffect } from 'vue'\n\n// this one will be automatically stopped\nwatchEffect(() => {})\n\n// ...this one will not!\nsetTimeout(() => {\n  watchEffect(() => {})\n}, 100)\n</script>"
      },
      {
        "language": "text",
        "code": "watchEffect"
      },
      {
        "language": "text",
        "code": "const unwatch = watchEffect(() => {})\n\n// ...later, when no longer needed\nunwatch()"
      },
      {
        "language": "text",
        "code": "const unwatch = watchEffect(() => {})\n\n// ...later, when no longer needed\nunwatch()"
      },
      {
        "language": "text",
        "code": "// data to be loaded asynchronously\nconst data = ref(null)\n\nwatchEffect(() => {\n  if (data.value) {\n    // do something when data is loaded\n  }\n})"
      },
      {
        "language": "text",
        "code": "// data to be loaded asynchronously\nconst data = ref(null)\n\nwatchEffect(() => {\n  if (data.value) {\n    // do something when data is loaded\n  }\n})"
      }
    ],
    "links": [
      {
        "text": "watch option",
        "href": "/api/options-state#watch"
      },
      {
        "text": "Try it in the Playground",
        "href": "https://play.vuejs.org/#eNp9VE1v2zAM/SucLnaw1D70lqUbsiKH7rB1W4++aDYdq5ElTx9xgiD/fbT8lXZFAQO2+Mgn8pH0mW2aJjl4ZCu2trkRjfucKTw22jgosOReOjhnCqDgjseL/hvAoPNGjSeAvx6tE1qtIIqWo5Er26Ih088BteCt51KeINfKcaGAT5FQc7NP4NPNYiaQmhdC7VZQcmlxMF+61yUcWu7yajVmkabQVqjwgGZmzSuudmiX4CphofQqD+ZWSAnGqz5y9I4VtmOuS9CyGA9T3QCihGu3RKhc+gJtHH2JFld+EG5Mdug2QYZ4MSKhgBd11OgqXdipEm5PKoer0Jk2kA66wB044/EF1GtOSPRUCbUnryRJosnFnK4zpC5YR7205M9bLhyUSIrGUeVcY1dpekKrdNK6MuWNiKYKXt8V98FElDxbknGxGLCpZMi7VkGMxmjzv0pz1tvO4QPcay8LULoj5RToKoTN40MCEXyEQDJTl0KFmXpNOqsUxudN+TNFzzqdJp8ODutGcod0Alg34QWwsXsaVtIjVXqe9h5bC9V4B4ebWhco7zI24hmDVSEs/yOxIPOQEFnTnjzt2emS83nYFrhcevM6nRJhS+Ys9aoUu6Av7WqoNWO5rhsh0fxownplbBqhjJEmuv0WbN2UDNtDMRXm+zfsz/bY2TL2SH1Ec8CMTZjjhqaxh7e/v+ORvieQqvaSvN8Bf6HV0veSdG5fvSoo7Su/kO1D3f13SKInuz06VHYsahzzfl0yRj+s+3dKn9O9TW7HPrPLP624lFU="
      },
      {
        "text": "watch function",
        "href": "/api/reactivity-core#watch"
      },
      {
        "text": "Try it in the Playground",
        "href": "https://play.vuejs.org/#eNp9U8Fy0zAQ/ZVFF9tDah96C2mZ0umhHKBAj7oIe52oUSQjyXEyGf87KytyoDC9JPa+p+e3b1cndtd15b5HtmQrV1vZeXDo++6Wa7nrjPVwAovtAgbh6w2M0Fqzg4xOZFxzXRvtPPzq0XlpNNwEbp5lRUKEdgPaVP925jnoXS+UOgKxvJAaxEVjJ+y2hA9XxUVFGdFIvT7LtEI5JIzrqjrbGozdOmikxdqTKqmIQOV6gvOkvQDhjrqGXOOQvCzAqCa9FHBzCyeuAWT7F6uUulZ9gy7PPmZFETmQjJV7oXoke972GJHY+Axkzxupt4FalhRcYHh7TDIQcqA+LTriikFIDy0G59nG+84tq+qITpty8G0lOhmSiedefSaPZ0mnfHFG50VRRkbkj1BPceVorbFzF/+6fQj4O7g3vWpAm6Ao6JzfINw9PZaQwXuYNJJuK/U0z1nxdTLT0M7s8Ec/I3WxquLS0brRi8ddp4RHegNYhR0M/Du3pXFSAJU285osI7aSuus97K92pkF1w1nCOYNlI534qbCh8tkOVasoXkV1+sjplLZ0HGN5Vc1G2IJ5R8Np5XpKlK7J1CJntdl1UqH92k0bzdkyNc8ZRWGGz1MtbMQi1esN1tv/1F/cIdQ4e6LJod0jZzPmhV2jj/DDjy94oOcZpK57Rew3wO/ojOpjJIH2qdcN2f6DN7l9nC47RfTsHg4etUtNpZUeJz5ndPPv32j9Yve6vE6DZuNvu1R2Tg=="
      },
      {
        "text": "getter function",
        "href": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Functions/get#description"
      },
      {
        "text": "watchEffect()",
        "href": "/api/reactivity-core#watcheffect"
      },
      {
        "text": "this example",
        "href": "/examples/#fetching-data"
      },
      {
        "text": "onWatcherCleanup()",
        "href": "/api/reactivity-core#onwatchercleanup"
      },
      {
        "text": "$watch() instance method",
        "href": "/api/component-instance#watch"
      },
      {
        "text": "Edit this page on GitHub",
        "href": "https://github.com/vuejs/docs/edit/main/src/guide/essentials/watchers.md"
      }
    ],
    "meta": {
      "description": "Vue.js - The Progressive JavaScript Framework",
      "keywords": ""
    },
    "summary": "Watchers Basic Example Computed properties allow us to declaratively compute derived values",
    "tags": [
      "react",
      "vue",
      "angular",
      "javascript",
      "typescript",
      "html",
      "watchers",
      "watch",
      "watcheffect",
      "basic"
    ],
    "id": "watchers-watchershtml-part-1",
    "quality": 90
  },
  {
    "title": "Lifecycle Hooks",
    "url": "https://vuejs.org/guide/essentials/lifecycle.html",
    "category": "vue",
    "content": "Lifecycle Hooks Each Vue component instance goes through a series of initialization steps when it's created - for example, it needs to set up data observation, compile the template, mount the instance to the DOM, and update the DOM when data changes. Along the way, it also runs functions called lifecycle hooks, giving users the opportunity to add their own code at specific stages.Registering Lifecycle Hooks For example, the onMountedmounted hook can be used to run code after the component has finished the initial rendering and created the DOM nodes:vuescript setup import { onMounted } from 'vue' onMounted(() = { console.log(the component is now mounted.) }) /scriptjsexport default { mounted() { console.log(the component is now mounted.) } }There are also other hooks which will be called at different stages of the instance's lifecycle, with the most commonly used being onMounted, onUpdated, and onUnmounted.mounted, updated, and unmounted.All lifecycle hooks are called with their this context pointing to the current active instance invoking it. Note this means you should avoid using arrow functions when declaring lifecycle hooks, as you won't be able to access the component instance via this if you do so.When calling onMounted, Vue automatically associates the registered callback function with the current active component instance. This requires these hooks to be registered synchronously during component setup. For example, do not do this:jssetTimeout(() = { onMounted(() = { // this won't work. }) }, 100)Do note this doesn't mean that the call must be placed lexically inside setup() or script setup. onMounted() can be called in an external function as long as the call stack is synchronous and originates from within setup().Lifecycle Diagram Below is a diagram for the instance lifecycle. You don't need to fully understand everything going on right now, but as you learn and build more, it will be a useful reference.Consult the Lifecycle Hooks API referenceLifecycle Hooks API reference for details on all lifecycle hooks and their respective use cases.Edit this page on GitHub",
    "headings": [
      {
        "level": 1,
        "text": "Lifecycle Hooks ​",
        "id": "lifecycle-hooks"
      },
      {
        "level": 2,
        "text": "Registering Lifecycle Hooks ​",
        "id": "registering-lifecycle-hooks"
      },
      {
        "level": 2,
        "text": "Lifecycle Diagram ​",
        "id": "lifecycle-diagram"
      }
    ],
    "codeBlocks": [
      {
        "language": "text",
        "code": "<script setup>\nimport { onMounted } from 'vue'\n\nonMounted(() => {\n  console.log(`the component is now mounted.`)\n})\n</script>"
      },
      {
        "language": "text",
        "code": "<script setup>\nimport { onMounted } from 'vue'\n\nonMounted(() => {\n  console.log(`the component is now mounted.`)\n})\n</script>"
      },
      {
        "language": "text",
        "code": "export default {\n  mounted() {\n    console.log(`the component is now mounted.`)\n  }\n}"
      },
      {
        "language": "text",
        "code": "export default {\n  mounted() {\n    console.log(`the component is now mounted.`)\n  }\n}"
      },
      {
        "language": "text",
        "code": "onUnmounted"
      },
      {
        "language": "text",
        "code": "setTimeout(() => {\n  onMounted(() => {\n    // this won't work.\n  })\n}, 100)"
      },
      {
        "language": "text",
        "code": "setTimeout(() => {\n  onMounted(() => {\n    // this won't work.\n  })\n}, 100)"
      },
      {
        "language": "text",
        "code": "<script setup>"
      },
      {
        "language": "text",
        "code": "onMounted()"
      }
    ],
    "links": [
      {
        "text": "onMounted",
        "href": "/api/composition-api-lifecycle#onmounted"
      },
      {
        "text": "onUpdated",
        "href": "/api/composition-api-lifecycle#onupdated"
      },
      {
        "text": "onUnmounted",
        "href": "/api/composition-api-lifecycle#onunmounted"
      },
      {
        "text": "mounted",
        "href": "/api/options-lifecycle#mounted"
      },
      {
        "text": "updated",
        "href": "/api/options-lifecycle#updated"
      },
      {
        "text": "unmounted",
        "href": "/api/options-lifecycle#unmounted"
      },
      {
        "text": "Lifecycle Hooks API reference",
        "href": "/api/composition-api-lifecycle"
      },
      {
        "text": "Lifecycle Hooks API reference",
        "href": "/api/options-lifecycle"
      },
      {
        "text": "Edit this page on GitHub",
        "href": "https://github.com/vuejs/docs/edit/main/src/guide/essentials/lifecycle.md"
      }
    ],
    "meta": {
      "description": "Vue.js - The Progressive JavaScript Framework",
      "keywords": ""
    },
    "summary": "Lifecycle Hooks Each Vue component instance goes through a series of initialization steps when it's created - for example, it needs to set up data observation, compile the template, mount the instance...",
    "tags": [
      "react",
      "vue",
      "angular",
      "javascript",
      "node",
      "vite",
      "lifecycle",
      "hooks",
      "registering",
      "diagram"
    ],
    "id": "lifecycle-hooks-lifecyclehtml-part-1",
    "quality": 100
  },
  {
    "title": "Template Syntax",
    "url": "https://vuejs.org/guide/essentials/template-syntax.html",
    "category": "vue",
    "content": "Template Syntax  Watch an interactive video lesson on Scrimba Vue uses an HTML-based template syntax that allows you to declaratively bind the rendered DOM to the underlying component instance's data. All Vue templates are syntactically valid HTML that can be parsed by spec-compliant browsers and HTML parsers.Under the hood, Vue compiles the templates into highly-optimized JavaScript code. Combined with the reactivity system, Vue can intelligently figure out the minimal number of components to re-render and apply the minimal amount of DOM manipulations when the app state changes.If you are familiar with Virtual DOM concepts and prefer the raw power of JavaScript, you can also directly write render functions instead of templates, with optional JSX support. However, do note that they do not enjoy the same level of compile-time optimizations as templates.Text Interpolation The most basic form of data binding is text interpolation using the \"Mustache\" syntax (double curly braces):templatespanMessage: {{ msg }}/spanThe mustache tag will be replaced with the value of the msg property from the corresponding component instance. It will also be updated whenever the msg property changes.Raw HTML The double mustaches interpret the data as plain text, not HTML. In order to output real HTML, you will need to use the v-html directive:templatepUsing text interpolation: {{ rawHtml }}/p pUsing v-html directive: span v-html=\"rawHtml\"/span/pUsing text interpolation: span style=\"color: red\"This should be red./spanUsing v-html directive: This should be red.Here we're encountering something new. The v-html attribute you're seeing is called a directive. Directives are prefixed with v- to indicate that they are special attributes provided by Vue, and as you may have guessed, they apply special reactive behavior to the rendered DOM. Here, we're basically saying \"keep this element's inner HTML up-to-date with the rawHtml property on the current active instance.\"The contents of the span will be replaced with the value of the rawHtml property, interpreted as plain HTML - data bindings are ignored. Note that you cannot use v-html to compose template partials, because Vue is not a string-based templating engine. Instead, components are preferred as the fundamental unit for UI reuse and composition.Security WarningDynamically rendering arbitrary HTML on your website can be very dangerous because it can easily lead to XSS vulnerabilities. Only use v-html on trusted content and never on user-provided content.Attribute Bindings Mustaches cannot be used inside HTML attributes. Instead, use a v-bind directive:templatediv v-bind:id=\"dynamicId\"/divThe v-bind directive instructs Vue to keep the element's id attribute in sync with the component's dynamicId property. If the bound value is null or undefined, then the attribute will be removed from the rendered element.Shorthand Because v-bind is so commonly used, it has a dedicated shorthand syntax:templatediv :id=\"dynamicId\"/divAttributes that start with : may look a bit different from normal HTML, but it is in fact a valid character for attribute names and all Vue-supported browsers can parse it correctly. In addition, they do not appear in the final rendered markup. The shorthand syntax is optional, but you will likely appreciate it when you learn more about its usage later.For the rest of the guide, we will be using the shorthand syntax in code examples, as that's the most common usage for Vue developers.Same-name Shorthand Only supported in 3.4+If the attribute has the same name as the variable name of the JavaScript value being bound, the syntax can be further shortened to omit the attribute value:template!-- same as :id=\"id\" -- div :id/div !-- this also works -- div v-bind:id/divThis is similar to the property shorthand syntax when declaring objects in JavaScript. Note this is a feature that is only available in Vue 3.4 and above.Boolean Attributes Boolean attributes are attributes that can indicate true / false values by their presence on an element. For example, disabled is one of the most commonly used boolean attributes.v-bind works a bit differently in this case:templatebutton :disabled=\"isButtonDisabled\"Button/buttonThe disabled attribute will be included if isButtonDisabled has a truthy value. It will also be included if the value is an empty string, maintaining consistency with button disabled=\"\". For other falsy values the attribute will be omitted.Dynamically Binding Multiple Attributes If you have a JavaScript object representing multiple attributes that looks like this:jsconst objectOfAttrs = { id: 'container', class: 'wrapper', style: 'background-color:green' }jsdata() { return { objectOfAttrs: { id: 'container', class: 'wrapper' } } }You can bind them to a single element by using v-bind without an argument:templatediv v-bind=\"objectOfAttrs\"/divUsing JavaScript Expressions So far we've only been binding to simple property keys in our templates. But Vue actually supports the full power of JavaScript expressions inside all data bindings:template{{ number + 1 }} {{ ok ? 'YES' : 'NO' }} {{ message.split('').reverse().join('') }} div :id=\"list-${id}\"/divThese expressions will be evaluated as JavaScript in the data scope of the current component instance.In Vue templates, JavaScript expressions can be used in the following positions:Inside text interpolations (mustaches)In the attribute value of any Vue directives (special attributes that start with v-)Expressions Only Each binding can only contain one single expression. An expression is a piece of code that can be evaluated to a value. A simple check is whether it can be used after return.Therefore, the following will NOT work:template!-- this is a statement, not an expression: -- {{ var a = 1 }} !-- flow control won't work either, use ternary expressions -- {{ if (ok) { return message } }}Calling Functions It is possible to call a component-exposed method inside a binding expression:templatetime :title=\"toTitleDate(date)\" :datetime=\"date\" {{ formatDate(date) }} /timeTIPFunctions called inside binding expressions will be called every time the component updates, so they should not have any side effects, such as changing data or triggering asynchronous operations.Restricted Globals Access Template expressions are sandboxed and only have access to a restricted list of globals. The list exposes commonly used built-in globals such as Math and Date.Globals not explicitly included in the list, for example user-attached properties on window, will not be accessible in template expressions. You can, however, explicitly define additional globals for all Vue expressions by adding them to app.config.globalProperties.Directives Directives are special attributes with the v- prefix. Vue provides a number of built-in directives, including v-html and v-bind which we have introduced above.Directive attribute values are expected to be single JavaScript expressions (with the exception of v-for, v-on and v-slot, which will be discussed in their respective sections later). A directive's job is to reactively apply updates to the DOM when the value of its expression changes. Take v-if as an example:templatep v-if=\"seen\"Now you see me/pHere, the v-if directive would remove or insert the p element based on the truthiness of the value of the expression seen.Arguments Some directives can take an \"argument\", denoted by a colon after the directive name. For example, the v-bind directive is used to reactively update an HTML attribute:templatea v-bind:href=\"url\" ... /a !-- shorthand -- a :href=\"url\" ... /aHere, href is the argument, which tells the v-bind directive to bind the element's href attribute to the value of the expression url. In the shorthand, everything before the argument (i.e., v-bind:) is condensed into a single character, :.Another example is the v-on directive, which listens to DOM events:templatea v-on:click=\"doSomething\" ... /a !-- shorthand -- a @click=\"doSomething\" ... /aHere, the argument is the event name to listen to: click. v-on has a corresponding shorthand, namely the @ character. We will talk about event handling in more detail too.Dynamic Arguments It is also possible to use a JavaScript expression in a directive argument by wrapping it with square brackets:template!-- Note that there are some constraints to the argument expression, as explained in the \"Dynamic Argument Value Constraints\" and \"Dynamic Argument Syntax Constraints\" sections below. -- a v-bind:[attributeName]=\"url\" ... /a !-- shorthand -- a :[attributeName]=\"url\" ... /aHere, attributeName will be dynamically evaluated as a JavaScript expression, and its evaluated value will be used as the final value for the argument. For example, if your component instance has a data property, attributeName, whose value is \"href\", then this binding will be equivalent to v-bind:href.Similarly, you can use dynamic arguments to bind a handler to a dynamic event name:templatea v-on:[eventName]=\"doSomething\" ... /a !-- shorthand -- a @[eventName]=\"doSomething\" ... /aIn this example, when eventName's value is \"focus\", v-on:[eventName] will be equivalent to v-on:focus.Dynamic Argument Value Constraints Dynamic arguments are expected to evaluate to a string, with the exception of null. The special value null can be used to explicitly remove the binding. Any other non-string value will trigger a warning.Dynamic Argument Syntax Constraints Dynamic argument expressions have some syntax constraints because certain characters, such as spaces and quotes, are invalid inside HTML attribute names. For example, the following is invalid:template!-- This will trigger a compiler warning. -- a :['foo' + bar]=\"value\" ... /aIf you need to pass a complex dynamic argument, it's probably better to use a computed property, which we will cover shortly.When using in-DOM templates (templates directly written in an HTML file), you should also avoid naming keys with uppercase characters, as browsers will coerce attribute names into lowercase:templatea :[someAttr]=\"value\" ... /aThe above will be converted to :[someattr] in in-DOM templates. If your component has a someAttr property instead of someattr, your code won't work. Templates inside Single-File Components are not subject to this constraint.Modifiers Modifiers are special postfixes denoted by a dot, which indicate that a directive should be bound in some special way. For example, the .prevent modifier tells the v-on directive to call event.preventDefault() on the triggered event:templateform @submit.prevent=\"onSubmit\".../formYou'll see other examples of modifiers later, for v-on and for v-model, when we explore those features.And finally, here's the full directive syntax visualized:Edit this page on GitHub",
    "headings": [
      {
        "level": 1,
        "text": "Template Syntax ​",
        "id": "template-syntax"
      },
      {
        "level": 2,
        "text": "Text Interpolation ​",
        "id": "text-interpolation"
      },
      {
        "level": 2,
        "text": "Raw HTML ​",
        "id": "raw-html"
      },
      {
        "level": 2,
        "text": "Attribute Bindings ​",
        "id": "attribute-bindings"
      },
      {
        "level": 2,
        "text": "Using JavaScript Expressions ​",
        "id": "using-javascript-expressions"
      },
      {
        "level": 2,
        "text": "Directives ​",
        "id": "directives"
      },
      {
        "level": 3,
        "text": "Shorthand ​",
        "id": "shorthand"
      },
      {
        "level": 3,
        "text": "Same-name Shorthand ​",
        "id": "same-name-shorthand"
      },
      {
        "level": 3,
        "text": "Boolean Attributes ​",
        "id": "boolean-attributes"
      },
      {
        "level": 3,
        "text": "Dynamically Binding Multiple Attributes ​",
        "id": "dynamically-binding-multiple-attributes"
      },
      {
        "level": 3,
        "text": "Expressions Only ​",
        "id": "expressions-only"
      },
      {
        "level": 3,
        "text": "Calling Functions ​",
        "id": "calling-functions"
      },
      {
        "level": 3,
        "text": "Restricted Globals Access ​",
        "id": "restricted-globals-access"
      },
      {
        "level": 3,
        "text": "Arguments ​",
        "id": "arguments"
      },
      {
        "level": 3,
        "text": "Dynamic Arguments ​",
        "id": "dynamic-arguments"
      },
      {
        "level": 3,
        "text": "Modifiers ​",
        "id": "modifiers"
      },
      {
        "level": 4,
        "text": "Dynamic Argument Value Constraints ​",
        "id": "dynamic-argument-value-constraints"
      },
      {
        "level": 4,
        "text": "Dynamic Argument Syntax Constraints ​",
        "id": "dynamic-argument-syntax-constraints"
      }
    ],
    "codeBlocks": [
      {
        "language": "text",
        "code": "<span>Message: {{ msg }}</span>"
      },
      {
        "language": "text",
        "code": "<span>Message: {{ msg }}</span>"
      },
      {
        "language": "text",
        "code": "<p>Using text interpolation: {{ rawHtml }}</p>\n<p>Using v-html directive: <span v-html=\"rawHtml\"></span></p>"
      },
      {
        "language": "text",
        "code": "<p>Using text interpolation: {{ rawHtml }}</p>\n<p>Using v-html directive: <span v-html=\"rawHtml\"></span></p>"
      },
      {
        "language": "text",
        "code": "<div v-bind:id=\"dynamicId\"></div>"
      },
      {
        "language": "text",
        "code": "<div v-bind:id=\"dynamicId\"></div>"
      },
      {
        "language": "text",
        "code": "<div :id=\"dynamicId\"></div>"
      },
      {
        "language": "text",
        "code": "<div :id=\"dynamicId\"></div>"
      },
      {
        "language": "text",
        "code": "<!-- same as :id=\"id\" -->\n<div :id></div>\n\n<!-- this also works -->\n<div v-bind:id></div>"
      },
      {
        "language": "text",
        "code": "<!-- same as :id=\"id\" -->\n<div :id></div>\n\n<!-- this also works -->\n<div v-bind:id></div>"
      },
      {
        "language": "text",
        "code": "<button :disabled=\"isButtonDisabled\">Button</button>"
      },
      {
        "language": "text",
        "code": "<button :disabled=\"isButtonDisabled\">Button</button>"
      },
      {
        "language": "text",
        "code": "isButtonDisabled"
      },
      {
        "language": "text",
        "code": "<button disabled=\"\">"
      },
      {
        "language": "text",
        "code": "const objectOfAttrs = {\n  id: 'container',\n  class: 'wrapper',\n  style: 'background-color:green'\n}"
      },
      {
        "language": "text",
        "code": "const objectOfAttrs = {\n  id: 'container',\n  class: 'wrapper',\n  style: 'background-color:green'\n}"
      },
      {
        "language": "text",
        "code": "data() {\n  return {\n    objectOfAttrs: {\n      id: 'container',\n      class: 'wrapper'\n    }\n  }\n}"
      },
      {
        "language": "text",
        "code": "data() {\n  return {\n    objectOfAttrs: {\n      id: 'container',\n      class: 'wrapper'\n    }\n  }\n}"
      },
      {
        "language": "text",
        "code": "<div v-bind=\"objectOfAttrs\"></div>"
      },
      {
        "language": "text",
        "code": "<div v-bind=\"objectOfAttrs\"></div>"
      },
      {
        "language": "text",
        "code": "{{ number + 1 }}\n\n{{ ok ? 'YES' : 'NO' }}\n\n{{ message.split('').reverse().join('') }}\n\n<div :id=\"`list-${id}`\"></div>"
      },
      {
        "language": "text",
        "code": "{{ number + 1 }}\n\n{{ ok ? 'YES' : 'NO' }}\n\n{{ message.split('').reverse().join('') }}\n\n<div :id=\"`list-${id}`\"></div>"
      },
      {
        "language": "text",
        "code": "<!-- this is a statement, not an expression: -->\n{{ var a = 1 }}\n\n<!-- flow control won't work either, use ternary expressions -->\n{{ if (ok) { return message } }}"
      },
      {
        "language": "text",
        "code": "<!-- this is a statement, not an expression: -->\n{{ var a = 1 }}\n\n<!-- flow control won't work either, use ternary expressions -->\n{{ if (ok) { return message } }}"
      },
      {
        "language": "text",
        "code": "<time :title=\"toTitleDate(date)\" :datetime=\"date\">\n  {{ formatDate(date) }}\n</time>"
      },
      {
        "language": "text",
        "code": "<time :title=\"toTitleDate(date)\" :datetime=\"date\">\n  {{ formatDate(date) }}\n</time>"
      },
      {
        "language": "text",
        "code": "app.config.globalProperties"
      },
      {
        "language": "text",
        "code": "<p v-if=\"seen\">Now you see me</p>"
      },
      {
        "language": "text",
        "code": "<p v-if=\"seen\">Now you see me</p>"
      },
      {
        "language": "text",
        "code": "<a v-bind:href=\"url\"> ... </a>\n\n<!-- shorthand -->\n<a :href=\"url\"> ... </a>"
      },
      {
        "language": "text",
        "code": "<a v-bind:href=\"url\"> ... </a>\n\n<!-- shorthand -->\n<a :href=\"url\"> ... </a>"
      },
      {
        "language": "text",
        "code": "<a v-on:click=\"doSomething\"> ... </a>\n\n<!-- shorthand -->\n<a @click=\"doSomething\"> ... </a>"
      },
      {
        "language": "text",
        "code": "<a v-on:click=\"doSomething\"> ... </a>\n\n<!-- shorthand -->\n<a @click=\"doSomething\"> ... </a>"
      },
      {
        "language": "text",
        "code": "<!--\nNote that there are some constraints to the argument expression,\nas explained in the \"Dynamic Argument Value Constraints\" and \"Dynamic Argument Syntax Constraints\" sections below.\n-->\n<a v-bind:[attributeName]=\"url\"> ... </a>\n\n<!-- shorthand -->\n<a :[attributeName]=\"url\"> ... </a>"
      },
      {
        "language": "text",
        "code": "<!--\nNote that there are some constraints to the argument expression,\nas explained in the \"Dynamic Argument Value Constraints\" and \"Dynamic Argument Syntax Constraints\" sections below.\n-->\n<a v-bind:[attributeName]=\"url\"> ... </a>\n\n<!-- shorthand -->\n<a :[attributeName]=\"url\"> ... </a>"
      },
      {
        "language": "text",
        "code": "attributeName"
      },
      {
        "language": "text",
        "code": "attributeName"
      },
      {
        "language": "text",
        "code": "v-bind:href"
      },
      {
        "language": "text",
        "code": "<a v-on:[eventName]=\"doSomething\"> ... </a>\n\n<!-- shorthand -->\n<a @[eventName]=\"doSomething\"> ... </a>"
      },
      {
        "language": "text",
        "code": "<a v-on:[eventName]=\"doSomething\"> ... </a>\n\n<!-- shorthand -->\n<a @[eventName]=\"doSomething\"> ... </a>"
      },
      {
        "language": "text",
        "code": "v-on:[eventName]"
      },
      {
        "language": "text",
        "code": "<!-- This will trigger a compiler warning. -->\n<a :['foo' + bar]=\"value\"> ... </a>"
      },
      {
        "language": "text",
        "code": "<!-- This will trigger a compiler warning. -->\n<a :['foo' + bar]=\"value\"> ... </a>"
      },
      {
        "language": "text",
        "code": "<a :[someAttr]=\"value\"> ... </a>"
      },
      {
        "language": "text",
        "code": "<a :[someAttr]=\"value\"> ... </a>"
      },
      {
        "language": "text",
        "code": ":[someattr]"
      },
      {
        "language": "text",
        "code": "event.preventDefault()"
      },
      {
        "language": "text",
        "code": "<form @submit.prevent=\"onSubmit\">...</form>"
      },
      {
        "language": "text",
        "code": "<form @submit.prevent=\"onSubmit\">...</form>"
      }
    ],
    "links": [
      {
        "text": "Watch an interactive video lesson on Scrimba",
        "href": "https://scrimba.com/links/vue-template-syntax"
      },
      {
        "text": "directly write render functions",
        "href": "/guide/extras/render-function"
      },
      {
        "text": "from the corresponding component instance",
        "href": "/guide/essentials/reactivity-fundamentals#declaring-reactive-state"
      },
      {
        "text": "v-html directive",
        "href": "/api/built-in-directives#v-html"
      },
      {
        "text": "XSS vulnerabilities",
        "href": "https://en.wikipedia.org/wiki/Cross-site_scripting"
      },
      {
        "text": "v-bind directive",
        "href": "/api/built-in-directives#v-bind"
      },
      {
        "text": "Boolean attributes",
        "href": "https://html.spec.whatwg.org/multipage/common-microsyntaxes.html#boolean-attributes"
      },
      {
        "text": "disabled",
        "href": "https://developer.mozilla.org/en-US/docs/Web/HTML/Attributes/disabled"
      },
      {
        "text": "truthy value",
        "href": "https://developer.mozilla.org/en-US/docs/Glossary/Truthy"
      },
      {
        "text": "falsy values",
        "href": "https://developer.mozilla.org/en-US/docs/Glossary/Falsy"
      },
      {
        "text": "restricted list of globals",
        "href": "https://github.com/vuejs/core/blob/main/packages/shared/src/globalsAllowList.ts#L3"
      },
      {
        "text": "app.config.globalProperties",
        "href": "/api/application#app-config-globalproperties"
      },
      {
        "text": "built-in directives",
        "href": "/api/built-in-directives"
      },
      {
        "text": "v-if",
        "href": "/api/built-in-directives#v-if"
      },
      {
        "text": "computed property",
        "href": "/guide/essentials/computed"
      },
      {
        "text": "for v-on",
        "href": "/guide/essentials/event-handling#event-modifiers"
      },
      {
        "text": "for v-model",
        "href": "/guide/essentials/forms#modifiers"
      },
      {
        "text": "Edit this page on GitHub",
        "href": "https://github.com/vuejs/docs/edit/main/src/guide/essentials/template-syntax.md"
      }
    ],
    "meta": {
      "description": "Vue.js - The Progressive JavaScript Framework",
      "keywords": ""
    },
    "summary": "Template Syntax  Watch an interactive video lesson on Scrimba Vue uses an HTML-based template syntax that allows you to declaratively bind the rendered DOM to the underlying component instance's data",
    "tags": [
      "react",
      "vue",
      "angular",
      "javascript",
      "typescript",
      "css",
      "html",
      "vite",
      "syntax",
      "dynamic"
    ],
    "id": "template-syntax-templatesyntaxhtml-part-1",
    "quality": 100
  },
  {
    "title": "Event Handling",
    "url": "https://vuejs.org/guide/essentials/event-handling.html",
    "category": "vue",
    "content": "Event Handling Watch a free video lesson on Vue SchoolWatch a free video lesson on Vue SchoolListening to Events We can use the v-on directive, which we typically shorten to the @ symbol, to listen to DOM events and run some JavaScript when they're triggered. The usage would be v-on:click=\"handler\" or with the shortcut, @click=\"handler\".The handler value can be one of the following:Inline handlers: Inline JavaScript to be executed when the event is triggered (similar to the native onclick attribute).Method handlers: A property name or path that points to a method defined on the component.Inline Handlers Inline handlers are typically used in simple cases, for example:jsconst count = ref(0)jsdata() { return { count: 0 } }templatebutton @click=\"count++\"Add 1/button pCount is: {{ count }}/pTry it in the PlaygroundTry it in the PlaygroundMethod Handlers The logic for many event handlers will be more complex though, and likely isn't feasible with inline handlers. That's why v-on can also accept the name or path of a component method you'd like to call.For example:jsconst name = ref('Vue.js') function greet(event) { alert(Hello ${name.value}!) // event is the native DOM event if (event) { alert(event.target.tagName) } }jsdata() { return { name: 'Vue.js' } }, methods: { greet(event) { // this inside methods points to the current active instance alert(Hello ${this.name}!) // event is the native DOM event if (event) { alert(event.target.tagName) } } }template!-- greet is the name of the method defined above -- button @click=\"greet\"Greet/buttonTry it in the PlaygroundTry it in the PlaygroundA method handler automatically receives the native DOM Event object that triggers it - in the example above, we are able to access the element dispatching the event via event.target.See also: Typing Event Handlers See also: Typing Event Handlers Method vs. Inline Detection The template compiler detects method handlers by checking whether the v-on value string is a valid JavaScript identifier or property access path. For example, foo, foo.bar and foo['bar'] are treated as method handlers, while foo() and count++ are treated as inline handlers.Calling Methods in Inline Handlers Instead of binding directly to a method name, we can also call methods in an inline handler. This allows us to pass the method custom arguments instead of the native event:jsfunction say(message) { alert(message) }jsmethods: { say(message) { alert(message) } }templatebutton @click=\"say('hello')\"Say hello/button button @click=\"say('bye')\"Say bye/buttonTry it in the PlaygroundTry it in the PlaygroundAccessing Event Argument in Inline Handlers Sometimes we also need to access the original DOM event in an inline handler. You can pass it into a method using the special $event variable, or use an inline arrow function:template!-- using $event special variable -- button @click=\"warn('Form cannot be submitted yet.', $event)\" Submit /button !-- using inline arrow function -- button @click=\"(event) = warn('Form cannot be submitted yet.', event)\" Submit /buttonjsfunction warn(message, event) { // now we have access to the native event if (event) { event.preventDefault() } alert(message) }jsmethods: { warn(message, event) { // now we have access to the native event if (event) { event.preventDefault() } alert(message) } }Event Modifiers It is a very common need to call event.preventDefault() or event.stopPropagation() inside event handlers. Although we can do this easily inside methods, it would be better if the methods can be purely about data logic rather than having to deal with DOM event details.To address this problem, Vue provides event modifiers for v-on. Recall that modifiers are directive postfixes denoted by a dot..stop.prevent.self.capture.once.passivetemplate!-- the click event's propagation will be stopped -- a @click.stop=\"doThis\"/a !-- the submit event will no longer reload the page -- form @submit.prevent=\"onSubmit\"/form !-- modifiers can be chained -- a @click.stop.prevent=\"doThat\"/a !-- just the modifier -- form @submit.prevent/form !-- only trigger handler if event.target is the element itself -- !-- i.e. not from a child element -- div @click.self=\"doThat\".../divTIPOrder matters when using modifiers because the relevant code is generated in the same order. Therefore using @click.prevent.self will prevent click's default action on the element itself and its children, while @click.self.prevent will only prevent click's default action on the element itself.The .capture, .once, and .passive modifiers mirror the options of the native addEventListener method:template!-- use capture mode when adding the event listener -- !-- i.e. an event targeting an inner element is handled -- !-- here before being handled by that element -- div @click.capture=\"doThis\".../div !-- the click event will be triggered at most once -- a @click.once=\"doThis\"/a !-- the scroll event's default behavior (scrolling) will happen -- !-- immediately, instead of waiting for onScroll to complete -- !-- in case it contains event.preventDefault() -- div @scroll.passive=\"onScroll\".../divThe .passive modifier is typically used with touch event listeners for improving performance on mobile devices.TIPDo not use .passive and .prevent together, because .passive already indicates to the browser that you do not intend to prevent the event's default behavior, and you will likely see a warning from the browser if you do so.Key Modifiers When listening for keyboard events, we often need to check for specific keys. Vue allows adding key modifiers for v-on or @ when listening for key events:template!-- only call submit when the key is Enter -- input @keyup.enter=\"submit\" /You can directly use any valid key names exposed via KeyboardEvent.key as modifiers by converting them to kebab-case.templateinput @keyup.page-down=\"onPageDown\" /In the above example, the handler will only be called if $event.key is equal to 'PageDown'.Key Aliases Vue provides aliases for the most commonly used keys:.enter.tab.delete (captures both \"Delete\" and \"Backspace\" keys).esc.space.up.down.left.rightSystem Modifier Keys You can use the following modifiers to trigger mouse or keyboard event listeners only when the corresponding modifier key is pressed:.ctrl.alt.shift.metaNoteOn Macintosh keyboards, meta is the command key (). On Windows keyboards, meta is the Windows key (). On Sun Microsystems keyboards, meta is marked as a solid diamond (). On certain keyboards, specifically MIT and Lisp machine keyboards and successors, such as the Knight keyboard, space-cadet keyboard, meta is labeled META. On Symbolics keyboards, meta is labeled META or Meta.For example:template!-- Alt + Enter -- input @keyup.alt.enter=\"clear\" / !-- Ctrl + Click -- div @click.ctrl=\"doSomething\"Do something/divTIPNote that modifier keys are different from regular keys and when used with keyup events, they have to be pressed when the event is emitted. In other words, keyup.ctrl will only trigger if you release a key while holding down ctrl. It won't trigger if you release the ctrl key alone..exact Modifier The .exact modifier allows control of the exact combination of system modifiers needed to trigger an event.template!-- this will fire even if Alt or Shift is also pressed -- button @click.ctrl=\"onClick\"A/button !-- this will only fire when Ctrl and no other keys are pressed -- button @click.ctrl.exact=\"onCtrlClick\"A/button !-- this will only fire when no system modifiers are pressed -- button @click.exact=\"onClick\"A/buttonMouse Button Modifiers .left.right.middleThese modifiers restrict the handler to events triggered by a specific mouse button.Note, however, that .left, .right, and .middle modifier names are based on the typical right-handed mouse layout, but in fact represent \"main\", \"secondary\", and \"auxiliary\" pointing device event triggers, respectively, and not the actual physical buttons. So that for a left-handed mouse layout the \"main\" button might physically be the right one but would trigger the .left modifier handler. Or a trackpad might trigger the .left handler with a one-finger tap, the .right handler with a two-finger tap, and the .middle handler with a three-finger tap. Similarly, other devices and event sources generating \"mouse\" events might have trigger modes that are not related to \"left\" and \"right\" whatsoever.Edit this page on GitHub",
    "headings": [
      {
        "level": 1,
        "text": "Event Handling ​",
        "id": "event-handling"
      },
      {
        "level": 2,
        "text": "Listening to Events ​",
        "id": "listening-to-events"
      },
      {
        "level": 2,
        "text": "Inline Handlers ​",
        "id": "inline-handlers"
      },
      {
        "level": 2,
        "text": "Method Handlers ​",
        "id": "method-handlers"
      },
      {
        "level": 2,
        "text": "Calling Methods in Inline Handlers ​",
        "id": "calling-methods-in-inline-handlers"
      },
      {
        "level": 2,
        "text": "Accessing Event Argument in Inline Handlers ​",
        "id": "accessing-event-argument-in-inline-handlers"
      },
      {
        "level": 2,
        "text": "Event Modifiers ​",
        "id": "event-modifiers"
      },
      {
        "level": 2,
        "text": "Key Modifiers ​",
        "id": "key-modifiers"
      },
      {
        "level": 2,
        "text": "Mouse Button Modifiers ​",
        "id": "mouse-button-modifiers"
      },
      {
        "level": 3,
        "text": "Method vs. Inline Detection ​",
        "id": "method-vs-inline-detection"
      },
      {
        "level": 3,
        "text": "Key Aliases ​",
        "id": "key-aliases"
      },
      {
        "level": 3,
        "text": "System Modifier Keys ​",
        "id": "system-modifier-keys"
      },
      {
        "level": 3,
        "text": ".exact Modifier ​",
        "id": "exact-modifier"
      }
    ],
    "codeBlocks": [
      {
        "language": "text",
        "code": "v-on:click=\"handler\""
      },
      {
        "language": "text",
        "code": "@click=\"handler\""
      },
      {
        "language": "text",
        "code": "const count = ref(0)"
      },
      {
        "language": "text",
        "code": "const count = ref(0)"
      },
      {
        "language": "text",
        "code": "data() {\n  return {\n    count: 0\n  }\n}"
      },
      {
        "language": "text",
        "code": "data() {\n  return {\n    count: 0\n  }\n}"
      },
      {
        "language": "text",
        "code": "<button @click=\"count++\">Add 1</button>\n<p>Count is: {{ count }}</p>"
      },
      {
        "language": "text",
        "code": "<button @click=\"count++\">Add 1</button>\n<p>Count is: {{ count }}</p>"
      },
      {
        "language": "text",
        "code": "const name = ref('Vue.js')\n\nfunction greet(event) {\n  alert(`Hello ${name.value}!`)\n  // `event` is the native DOM event\n  if (event) {\n    alert(event.target.tagName)\n  }\n}"
      },
      {
        "language": "text",
        "code": "const name = ref('Vue.js')\n\nfunction greet(event) {\n  alert(`Hello ${name.value}!`)\n  // `event` is the native DOM event\n  if (event) {\n    alert(event.target.tagName)\n  }\n}"
      },
      {
        "language": "text",
        "code": "data() {\n  return {\n    name: 'Vue.js'\n  }\n},\nmethods: {\n  greet(event) {\n    // `this` inside methods points to the current active instance\n    alert(`Hello ${this.name}!`)\n    // `event` is the native DOM event\n    if (event) {\n      alert(event.target.tagName)\n    }\n  }\n}"
      },
      {
        "language": "text",
        "code": "data() {\n  return {\n    name: 'Vue.js'\n  }\n},\nmethods: {\n  greet(event) {\n    // `this` inside methods points to the current active instance\n    alert(`Hello ${this.name}!`)\n    // `event` is the native DOM event\n    if (event) {\n      alert(event.target.tagName)\n    }\n  }\n}"
      },
      {
        "language": "text",
        "code": "<!-- `greet` is the name of the method defined above -->\n<button @click=\"greet\">Greet</button>"
      },
      {
        "language": "text",
        "code": "<!-- `greet` is the name of the method defined above -->\n<button @click=\"greet\">Greet</button>"
      },
      {
        "language": "text",
        "code": "event.target"
      },
      {
        "language": "text",
        "code": "function say(message) {\n  alert(message)\n}"
      },
      {
        "language": "text",
        "code": "function say(message) {\n  alert(message)\n}"
      },
      {
        "language": "text",
        "code": "methods: {\n  say(message) {\n    alert(message)\n  }\n}"
      },
      {
        "language": "text",
        "code": "methods: {\n  say(message) {\n    alert(message)\n  }\n}"
      },
      {
        "language": "text",
        "code": "<button @click=\"say('hello')\">Say hello</button>\n<button @click=\"say('bye')\">Say bye</button>"
      },
      {
        "language": "text",
        "code": "<button @click=\"say('hello')\">Say hello</button>\n<button @click=\"say('bye')\">Say bye</button>"
      },
      {
        "language": "text",
        "code": "<!-- using $event special variable -->\n<button @click=\"warn('Form cannot be submitted yet.', $event)\">\n  Submit\n</button>\n\n<!-- using inline arrow function -->\n<button @click=\"(event) => warn('Form cannot be submitted yet.', event)\">\n  Submit\n</button>"
      },
      {
        "language": "text",
        "code": "<!-- using $event special variable -->\n<button @click=\"warn('Form cannot be submitted yet.', $event)\">\n  Submit\n</button>\n\n<!-- using inline arrow function -->\n<button @click=\"(event) => warn('Form cannot be submitted yet.', event)\">\n  Submit\n</button>"
      },
      {
        "language": "text",
        "code": "function warn(message, event) {\n  // now we have access to the native event\n  if (event) {\n    event.preventDefault()\n  }\n  alert(message)\n}"
      },
      {
        "language": "text",
        "code": "function warn(message, event) {\n  // now we have access to the native event\n  if (event) {\n    event.preventDefault()\n  }\n  alert(message)\n}"
      },
      {
        "language": "text",
        "code": "methods: {\n  warn(message, event) {\n    // now we have access to the native event\n    if (event) {\n      event.preventDefault()\n    }\n    alert(message)\n  }\n}"
      },
      {
        "language": "text",
        "code": "methods: {\n  warn(message, event) {\n    // now we have access to the native event\n    if (event) {\n      event.preventDefault()\n    }\n    alert(message)\n  }\n}"
      },
      {
        "language": "text",
        "code": "event.preventDefault()"
      },
      {
        "language": "text",
        "code": "event.stopPropagation()"
      },
      {
        "language": "text",
        "code": "<!-- the click event's propagation will be stopped -->\n<a @click.stop=\"doThis\"></a>\n\n<!-- the submit event will no longer reload the page -->\n<form @submit.prevent=\"onSubmit\"></form>\n\n<!-- modifiers can be chained -->\n<a @click.stop.prevent=\"doThat\"></a>\n\n<!-- just the modifier -->\n<form @submit.prevent></form>\n\n<!-- only trigger handler if event.target is the element itself -->\n<!-- i.e. not from a child element -->\n<div @click.self=\"doThat\">...</div>"
      },
      {
        "language": "text",
        "code": "<!-- the click event's propagation will be stopped -->\n<a @click.stop=\"doThis\"></a>\n\n<!-- the submit event will no longer reload the page -->\n<form @submit.prevent=\"onSubmit\"></form>\n\n<!-- modifiers can be chained -->\n<a @click.stop.prevent=\"doThat\"></a>\n\n<!-- just the modifier -->\n<form @submit.prevent></form>\n\n<!-- only trigger handler if event.target is the element itself -->\n<!-- i.e. not from a child element -->\n<div @click.self=\"doThat\">...</div>"
      },
      {
        "language": "text",
        "code": "@click.prevent.self"
      },
      {
        "language": "text",
        "code": "@click.self.prevent"
      },
      {
        "language": "text",
        "code": "addEventListener"
      },
      {
        "language": "text",
        "code": "<!-- use capture mode when adding the event listener     -->\n<!-- i.e. an event targeting an inner element is handled -->\n<!-- here before being handled by that element           -->\n<div @click.capture=\"doThis\">...</div>\n\n<!-- the click event will be triggered at most once -->\n<a @click.once=\"doThis\"></a>\n\n<!-- the scroll event's default behavior (scrolling) will happen -->\n<!-- immediately, instead of waiting for `onScroll` to complete  -->\n<!-- in case it contains `event.preventDefault()`                -->\n<div @scroll.passive=\"onScroll\">...</div>"
      },
      {
        "language": "text",
        "code": "<!-- use capture mode when adding the event listener     -->\n<!-- i.e. an event targeting an inner element is handled -->\n<!-- here before being handled by that element           -->\n<div @click.capture=\"doThis\">...</div>\n\n<!-- the click event will be triggered at most once -->\n<a @click.once=\"doThis\"></a>\n\n<!-- the scroll event's default behavior (scrolling) will happen -->\n<!-- immediately, instead of waiting for `onScroll` to complete  -->\n<!-- in case it contains `event.preventDefault()`                -->\n<div @scroll.passive=\"onScroll\">...</div>"
      },
      {
        "language": "text",
        "code": "<!-- only call `submit` when the `key` is `Enter` -->\n<input @keyup.enter=\"submit\" />"
      },
      {
        "language": "text",
        "code": "<!-- only call `submit` when the `key` is `Enter` -->\n<input @keyup.enter=\"submit\" />"
      },
      {
        "language": "text",
        "code": "KeyboardEvent.key"
      },
      {
        "language": "text",
        "code": "<input @keyup.page-down=\"onPageDown\" />"
      },
      {
        "language": "text",
        "code": "<input @keyup.page-down=\"onPageDown\" />"
      },
      {
        "language": "text",
        "code": "<!-- Alt + Enter -->\n<input @keyup.alt.enter=\"clear\" />\n\n<!-- Ctrl + Click -->\n<div @click.ctrl=\"doSomething\">Do something</div>"
      },
      {
        "language": "text",
        "code": "<!-- Alt + Enter -->\n<input @keyup.alt.enter=\"clear\" />\n\n<!-- Ctrl + Click -->\n<div @click.ctrl=\"doSomething\">Do something</div>"
      },
      {
        "language": "text",
        "code": "<!-- this will fire even if Alt or Shift is also pressed -->\n<button @click.ctrl=\"onClick\">A</button>\n\n<!-- this will only fire when Ctrl and no other keys are pressed -->\n<button @click.ctrl.exact=\"onCtrlClick\">A</button>\n\n<!-- this will only fire when no system modifiers are pressed -->\n<button @click.exact=\"onClick\">A</button>"
      },
      {
        "language": "text",
        "code": "<!-- this will fire even if Alt or Shift is also pressed -->\n<button @click.ctrl=\"onClick\">A</button>\n\n<!-- this will only fire when Ctrl and no other keys are pressed -->\n<button @click.ctrl.exact=\"onCtrlClick\">A</button>\n\n<!-- this will only fire when no system modifiers are pressed -->\n<button @click.exact=\"onClick\">A</button>"
      }
    ],
    "links": [
      {
        "text": "Watch a free video lesson on Vue School",
        "href": "https://vueschool.io/lessons/user-events-in-vue-3?friend=vuejs"
      },
      {
        "text": "Watch a free video lesson on Vue School",
        "href": "https://vueschool.io/lessons/vue-fundamentals-capi-user-events-in-vue-3?friend=vuejs"
      },
      {
        "text": "Try it in the Playground",
        "href": "https://play.vuejs.org/#eNo9jssKgzAURH/lko0tgrbbEqX+Q5fZaLxiqHmQ3LgJ+fdqFZcD58xMYp1z1RqRvRgP0itHEJCia4VR2llPkMDjBBkmbzUUG1oII4y0JhBIGw2hh2Znbo+7MLw+WjZ/C4TaLT3hnogPkcgaeMtFyW8j2GmXpWBtN47w5PWBHLhrPzPCKfWDXRHmPsCAaOBfgSOkdH3IGUhpDBWv9/e8vsZZ/gFFhFJN"
      },
      {
        "text": "Try it in the Playground",
        "href": "https://play.vuejs.org/#eNo9jcEKgzAQRH9lyKlF0PYqqdR/6DGXaLYo1RjiRgrivzepIizLzu7sm1XUzuVLIFEKObe+d1wpS183eYahtw4DY1UWMJr15ZpmxYAnDt7uF0BxOwXL5Evc0kbxlmyxxZLFyY2CaXSDZkqKZROYJ4tnO/Tt56HEgckyJaraGNxlsVt2u6teHeF40s20EDo9oyGy+CPIYF1xULBt4H6kOZeFiwBZnOFi+wH0B1hk"
      },
      {
        "text": "Try it in the Playground",
        "href": "https://play.vuejs.org/#eNpVj0FLxDAQhf/KMwjtXtq7dBcFQS/qzVMOrWFao2kSkkkvpf/dJIuCEBgm771vZnbx4H23JRJ3YogqaM+IxMlfpNWrd4GxI9CMA3NwK5psbaSVVjkbGXZaCediaJv3RN1XbE5FnZNVrJ3FEoi4pY0sn7BLC0yGArfjMxnjcLsXQrdNJtFxM+Ys0PcYa2CEjuBPylNYb4THtxdUobj0jH/YX3D963gKC5WyvGZ+xR7S5jf01yPzeblhWr2ZmErHw0dizivfK6PV91mKursUl6dSh/4qZ+vQ/+XE8QODonDi"
      },
      {
        "text": "Try it in the Playground",
        "href": "https://play.vuejs.org/#eNplUE1LxDAQ/StjEbYL0t5LXRQEvag3Tz00prNtNE1CMilC6X83SUkRhJDJfLz3Jm8tHo2pFo9FU7SOW2Ho0in8MdoSDHhlXhKsnQIYGLHyvL8BLJK3KmcAis3YwOnDY/XlTnt1i2G7i/eMNOnBNRkwWkQqcUFFByVAXUNPk3A9COXEgBkGRgtFDkgDTQjcWxuAwDiJBeMsMcUxszCJlsr+BaXUcLtGwiqut930579KST1IBd5Aqlgie3p/hdTIk+IK//bMGqleEbMjxjC+BZVDIv0+m9CpcNr6MDgkhLORjDBm1H56Iq3ggUvBv++7IhnUFZfnGNt6b4fRtj5wxfYL9p+Sjw=="
      },
      {
        "text": "Typing Event Handlers",
        "href": "/guide/typescript/composition-api#typing-event-handlers"
      },
      {
        "text": "Typing Event Handlers",
        "href": "/guide/typescript/options-api#typing-event-handlers"
      },
      {
        "text": "Try it in the Playground",
        "href": "https://play.vuejs.org/#eNp9jTEOwjAMRa8SeSld6I5CBWdg9ZJGBiJSN2ocpKjq3UmpFDGx+Vn//b/ANYTjOxGcQEc7uyAqkqTQI98TW3ETq2jyYaQYzYNatSArZTzNUn/IK7Ludr2IBYTG4I3QRqKHJFJ6LtY7+zojbIXNk7yfmhahv5msvqS7PfnHGjJVp9w/hu7qKKwfEd1NSg=="
      },
      {
        "text": "Try it in the Playground",
        "href": "https://play.vuejs.org/#eNptjUEKwjAQRa8yZFO7sfsSi57B7WzGdjTBtA3NVC2ldzehEFwIw8D7vM9f1cX742tmVSsd2sl6aXDgjx8ngY7vNDuBFQeAnsWMXagToQAEWg49h0APLncDAIUcT5LzlKJsqRBfPF3ljQjCvXcknEj0bRYZBzi3zrbPE6o0UBhblKiaKy1grK52J/oA//23IcmNBD8dXeVBtX0BF0pXsg=="
      },
      {
        "text": "options of the native addEventListener method",
        "href": "https://developer.mozilla.org/en-US/docs/Web/API/EventTarget/addEventListener#options"
      },
      {
        "text": "improving performance on mobile devices",
        "href": "https://developer.mozilla.org/en-US/docs/Web/API/EventTarget/addEventListener#improving_scroll_performance_using_passive_listeners"
      },
      {
        "text": "KeyboardEvent.key",
        "href": "https://developer.mozilla.org/en-US/docs/Web/API/UI_Events/Keyboard_event_key_values"
      },
      {
        "text": "Edit this page on GitHub",
        "href": "https://github.com/vuejs/docs/edit/main/src/guide/essentials/event-handling.md"
      }
    ],
    "meta": {
      "description": "Vue.js - The Progressive JavaScript Framework",
      "keywords": ""
    },
    "summary": "Event Handling Watch a free video lesson on Vue SchoolWatch a free video lesson on Vue SchoolListening to Events We can use the v-on directive, which we typically shorten to the @ symbol, to listen to...",
    "tags": [
      "react",
      "vue",
      "angular",
      "javascript",
      "typescript",
      "html",
      "vite",
      "event",
      "inline",
      "handlers"
    ],
    "id": "event-handling-eventhandlinghtml-part-1",
    "quality": 100
  },
  {
    "title": "Form Input Bindings",
    "url": "https://vuejs.org/guide/essentials/forms.html",
    "category": "vue",
    "content": "Form Input Bindings Watch a free video lesson on Vue SchoolWatch a free video lesson on Vue SchoolWhen dealing with forms on the frontend, we often need to sync the state of form input elements with corresponding state in JavaScript. It can be cumbersome to manually wire up value bindings and change event listeners:templateinput :value=\"text\" @input=\"event = text = event.target.value\"The v-model directive helps us simplify the above to:templateinput v-model=\"text\"In addition, v-model can be used on inputs of different types, textarea, and select elements. It automatically expands to different DOM property and event pairs based on the element it is used on:input with text types and textarea elements use value property and input event;input type=\"checkbox\" and input type=\"radio\" use checked property and change event;select uses value as a prop and change as an event.Notev-model will ignore the initial value, checked or selected attributes found on any form elements. It will always treat the current bound JavaScript state as the source of truth. You should declare the initial value on the JavaScript side, using the data optionreactivity APIs.Basic Usage Text templatepMessage is: {{ message }}/p input v-model=\"message\" placeholder=\"edit me\" /Message is: Try it in the PlaygroundTry it in the PlaygroundNoteFor languages that require an IME (Chinese, Japanese, Korean, etc.), you'll notice that v-model doesn't get updated during IME composition. If you want to respond to these updates as well, use your own input event listener and value binding instead of using v-model.Multiline Text templatespanMultiline message is:/span p style=\"white-space: pre-line;\"{{ message }}/p textarea v-model=\"message\" placeholder=\"add multiple lines\"/textareaMultiline message is:Try it in the PlaygroundTry it in the PlaygroundNote that interpolation inside textarea won't work. Use v-model instead.template!-- bad -- textarea{{ text }}/textarea !-- good -- textarea v-model=\"text\"/textareaCheckbox Single checkbox, boolean value:templateinput type=\"checkbox\" id=\"checkbox\" v-model=\"checked\" / label for=\"checkbox\"{{ checked }}/labelfalseTry it in the PlaygroundTry it in the PlaygroundWe can also bind multiple checkboxes to the same array or Set value:jsconst checkedNames = ref([])jsexport default { data() { return { checkedNames: [] } } }templatedivChecked names: {{ checkedNames }}/div input type=\"checkbox\" id=\"jack\" value=\"Jack\" v-model=\"checkedNames\" / label for=\"jack\"Jack/label input type=\"checkbox\" id=\"john\" value=\"John\" v-model=\"checkedNames\" / label for=\"john\"John/label input type=\"checkbox\" id=\"mike\" value=\"Mike\" v-model=\"checkedNames\" / label for=\"mike\"Mike/labelChecked names: []JackJohnMikeIn this case, the checkedNames array will always contain the values from the currently checked boxes.Try it in the PlaygroundTry it in the PlaygroundRadio templatedivPicked: {{ picked }}/div input type=\"radio\" id=\"one\" value=\"One\" v-model=\"picked\" / label for=\"one\"One/label input type=\"radio\" id=\"two\" value=\"Two\" v-model=\"picked\" / label for=\"two\"Two/labelPicked: OneTwoTry it in the PlaygroundTry it in the PlaygroundSelect Single select:templatedivSelected: {{ selected }}/div select v-model=\"selected\" option disabled value=\"\"Please select one/option optionA/option optionB/option optionC/option /selectSelected: Please select oneABCTry it in the PlaygroundTry it in the PlaygroundNoteIf the initial value of your v-model expression does not match any of the options, the select element will render in an \"unselected\" state. On iOS this will cause the user not being able to select the first item because iOS does not fire a change event in this case. It is therefore recommended to provide a disabled option with an empty value, as demonstrated in the example above.Multiple select (bound to array):templatedivSelected: {{ selected }}/div select v-model=\"selected\" multiple optionA/option optionB/option optionC/option /selectSelected: []ABCTry it in the PlaygroundTry it in the PlaygroundSelect options can be dynamically rendered with v-for:jsconst selected = ref('A') const options = ref([ { text: 'One', value: 'A' }, { text: 'Two', value: 'B' }, { text: 'Three', value: 'C' } ])jsexport default { data() { return { selected: 'A', options: [ { text: 'One', value: 'A' }, { text: 'Two', value: 'B' }, { text: 'Three', value: 'C' } ] } } }templatedivSelected: {{ selected }}/div select v-model=\"selected\" option v-for=\"option in options\" :value=\"option.value\" {{ option.text }} /option /selectSelected: AOneTwoThreeTry it in the PlaygroundTry it in the PlaygroundValue Bindings For radio, checkbox and select options, the v-model binding values are usually static strings (or booleans for checkbox):template!-- picked is a string \"a\" when checked -- input type=\"radio\" v-model=\"picked\" value=\"a\" / !-- toggle is either true or false -- input type=\"checkbox\" v-model=\"toggle\" / !-- selected is a string \"abc\" when the first option is selected -- select v-model=\"selected\" option value=\"abc\"ABC/option /selectBut sometimes we may want to bind the value to a dynamic property on the current active instance. We can use v-bind to achieve that. In addition, using v-bind allows us to bind the input value to non-string values.Checkbox templateinput type=\"checkbox\" v-model=\"toggle\" true-value=\"yes\" false-value=\"no\" /true-value and false-value are Vue-specific attributes that only work with v-model. Here the toggle property's value will be set to 'yes' when the box is checked, and set to 'no' when unchecked. You can also bind them to dynamic values using v-bind:templateinput type=\"checkbox\" v-model=\"toggle\" :true-value=\"dynamicTrueValue\" :false-value=\"dynamicFalseValue\" /TipThe true-value and false-value attributes don't affect the input's value attribute, because browsers don't include unchecked boxes in form submissions. To guarantee that one of two values is submitted in a form (e.g. \"yes\" or \"no\"), use radio inputs instead.Radio templateinput type=\"radio\" v-model=\"pick\" :value=\"first\" / input type=\"radio\" v-model=\"pick\" :value=\"second\" /pick will be set to the value of first when the first radio input is checked, and set to the value of second when the second one is checked.Select Options templateselect v-model=\"selected\" !-- inline object literal -- option :value=\"{ number: 123 }\"123/option /selectv-model supports value bindings of non-string values as well! In the above example, when the option is selected, selected will be set to the object literal value of { number: 123 }.Modifiers .lazy By default, v-model syncs the input with the data after each input event (with the exception of IME composition as stated above). You can add the lazy modifier to instead sync after change events:template!-- synced after \"change\" instead of \"input\" -- input v-model.lazy=\"msg\" /.number If you want user input to be automatically typecast as a number, you can add the number modifier to your v-model managed inputs:templateinput v-model.number=\"age\" /If the value cannot be parsed with parseFloat(), then the original (string) value is used instead. In particular, if the input is empty (for instance after the user clearing the input field), an empty string is returned. This behavior differs from the DOM property valueAsNumber.The number modifier is applied automatically if the input has type=\"number\"..trim If you want whitespace from user input to be trimmed automatically, you can add the trim modifier to your v-model-managed inputs:templateinput v-model.trim=\"msg\" /v-model with Components If you're not yet familiar with Vue's components, you can skip this for now.HTML's built-in input types won't always meet your needs. Fortunately, Vue components allow you to build reusable inputs with completely customized behavior. These inputs even work with v-model! To learn more, read about Usage with v-model in the Components guide.Edit this page on GitHub",
    "headings": [
      {
        "level": 1,
        "text": "Form Input Bindings ​",
        "id": "form-input-bindings"
      },
      {
        "level": 2,
        "text": "Basic Usage ​",
        "id": "basic-usage"
      },
      {
        "level": 2,
        "text": "Value Bindings ​",
        "id": "value-bindings"
      },
      {
        "level": 2,
        "text": "Modifiers ​",
        "id": "modifiers"
      },
      {
        "level": 2,
        "text": "v-model with Components ​",
        "id": "v-model-with-components"
      },
      {
        "level": 3,
        "text": "Text ​",
        "id": "text"
      },
      {
        "level": 3,
        "text": "Multiline Text ​",
        "id": "multiline-text"
      },
      {
        "level": 3,
        "text": "Checkbox ​",
        "id": "checkbox"
      },
      {
        "level": 3,
        "text": "Radio ​",
        "id": "radio"
      },
      {
        "level": 3,
        "text": "Select ​",
        "id": "select"
      },
      {
        "level": 3,
        "text": "Checkbox ​",
        "id": "checkbox-1"
      },
      {
        "level": 3,
        "text": "Radio ​",
        "id": "radio-1"
      },
      {
        "level": 3,
        "text": "Select Options ​",
        "id": "select-options"
      },
      {
        "level": 3,
        "text": ".lazy ​",
        "id": "lazy"
      },
      {
        "level": 3,
        "text": ".number ​",
        "id": "number"
      },
      {
        "level": 3,
        "text": ".trim ​",
        "id": "trim"
      }
    ],
    "codeBlocks": [
      {
        "language": "text",
        "code": "<input\n  :value=\"text\"\n  @input=\"event => text = event.target.value\">"
      },
      {
        "language": "text",
        "code": "<input\n  :value=\"text\"\n  @input=\"event => text = event.target.value\">"
      },
      {
        "language": "text",
        "code": "<input v-model=\"text\">"
      },
      {
        "language": "text",
        "code": "<input v-model=\"text\">"
      },
      {
        "language": "text",
        "code": "<input type=\"checkbox\">"
      },
      {
        "language": "text",
        "code": "<input type=\"radio\">"
      },
      {
        "language": "text",
        "code": "<p>Message is: {{ message }}</p>\n<input v-model=\"message\" placeholder=\"edit me\" />"
      },
      {
        "language": "text",
        "code": "<p>Message is: {{ message }}</p>\n<input v-model=\"message\" placeholder=\"edit me\" />"
      },
      {
        "language": "text",
        "code": "<span>Multiline message is:</span>\n<p style=\"white-space: pre-line;\">{{ message }}</p>\n<textarea v-model=\"message\" placeholder=\"add multiple lines\"></textarea>"
      },
      {
        "language": "text",
        "code": "<span>Multiline message is:</span>\n<p style=\"white-space: pre-line;\">{{ message }}</p>\n<textarea v-model=\"message\" placeholder=\"add multiple lines\"></textarea>"
      },
      {
        "language": "text",
        "code": "<!-- bad -->\n<textarea>{{ text }}</textarea>\n\n<!-- good -->\n<textarea v-model=\"text\"></textarea>"
      },
      {
        "language": "text",
        "code": "<!-- bad -->\n<textarea>{{ text }}</textarea>\n\n<!-- good -->\n<textarea v-model=\"text\"></textarea>"
      },
      {
        "language": "text",
        "code": "<input type=\"checkbox\" id=\"checkbox\" v-model=\"checked\" />\n<label for=\"checkbox\">{{ checked }}</label>"
      },
      {
        "language": "text",
        "code": "<input type=\"checkbox\" id=\"checkbox\" v-model=\"checked\" />\n<label for=\"checkbox\">{{ checked }}</label>"
      },
      {
        "language": "text",
        "code": "const checkedNames = ref([])"
      },
      {
        "language": "text",
        "code": "const checkedNames = ref([])"
      },
      {
        "language": "text",
        "code": "export default {\n  data() {\n    return {\n      checkedNames: []\n    }\n  }\n}"
      },
      {
        "language": "text",
        "code": "export default {\n  data() {\n    return {\n      checkedNames: []\n    }\n  }\n}"
      },
      {
        "language": "text",
        "code": "<div>Checked names: {{ checkedNames }}</div>\n\n<input type=\"checkbox\" id=\"jack\" value=\"Jack\" v-model=\"checkedNames\" />\n<label for=\"jack\">Jack</label>\n\n<input type=\"checkbox\" id=\"john\" value=\"John\" v-model=\"checkedNames\" />\n<label for=\"john\">John</label>\n\n<input type=\"checkbox\" id=\"mike\" value=\"Mike\" v-model=\"checkedNames\" />\n<label for=\"mike\">Mike</label>"
      },
      {
        "language": "text",
        "code": "<div>Checked names: {{ checkedNames }}</div>\n\n<input type=\"checkbox\" id=\"jack\" value=\"Jack\" v-model=\"checkedNames\" />\n<label for=\"jack\">Jack</label>\n\n<input type=\"checkbox\" id=\"john\" value=\"John\" v-model=\"checkedNames\" />\n<label for=\"john\">John</label>\n\n<input type=\"checkbox\" id=\"mike\" value=\"Mike\" v-model=\"checkedNames\" />\n<label for=\"mike\">Mike</label>"
      },
      {
        "language": "text",
        "code": "checkedNames"
      },
      {
        "language": "text",
        "code": "<div>Picked: {{ picked }}</div>\n\n<input type=\"radio\" id=\"one\" value=\"One\" v-model=\"picked\" />\n<label for=\"one\">One</label>\n\n<input type=\"radio\" id=\"two\" value=\"Two\" v-model=\"picked\" />\n<label for=\"two\">Two</label>"
      },
      {
        "language": "text",
        "code": "<div>Picked: {{ picked }}</div>\n\n<input type=\"radio\" id=\"one\" value=\"One\" v-model=\"picked\" />\n<label for=\"one\">One</label>\n\n<input type=\"radio\" id=\"two\" value=\"Two\" v-model=\"picked\" />\n<label for=\"two\">Two</label>"
      },
      {
        "language": "text",
        "code": "<div>Selected: {{ selected }}</div>\n\n<select v-model=\"selected\">\n  <option disabled value=\"\">Please select one</option>\n  <option>A</option>\n  <option>B</option>\n  <option>C</option>\n</select>"
      },
      {
        "language": "text",
        "code": "<div>Selected: {{ selected }}</div>\n\n<select v-model=\"selected\">\n  <option disabled value=\"\">Please select one</option>\n  <option>A</option>\n  <option>B</option>\n  <option>C</option>\n</select>"
      },
      {
        "language": "text",
        "code": "<div>Selected: {{ selected }}</div>\n\n<select v-model=\"selected\" multiple>\n  <option>A</option>\n  <option>B</option>\n  <option>C</option>\n</select>"
      },
      {
        "language": "text",
        "code": "<div>Selected: {{ selected }}</div>\n\n<select v-model=\"selected\" multiple>\n  <option>A</option>\n  <option>B</option>\n  <option>C</option>\n</select>"
      },
      {
        "language": "text",
        "code": "const selected = ref('A')\n\nconst options = ref([\n  { text: 'One', value: 'A' },\n  { text: 'Two', value: 'B' },\n  { text: 'Three', value: 'C' }\n])"
      },
      {
        "language": "text",
        "code": "const selected = ref('A')\n\nconst options = ref([\n  { text: 'One', value: 'A' },\n  { text: 'Two', value: 'B' },\n  { text: 'Three', value: 'C' }\n])"
      },
      {
        "language": "text",
        "code": "export default {\n  data() {\n    return {\n      selected: 'A',\n      options: [\n        { text: 'One', value: 'A' },\n        { text: 'Two', value: 'B' },\n        { text: 'Three', value: 'C' }\n      ]\n    }\n  }\n}"
      },
      {
        "language": "text",
        "code": "export default {\n  data() {\n    return {\n      selected: 'A',\n      options: [\n        { text: 'One', value: 'A' },\n        { text: 'Two', value: 'B' },\n        { text: 'Three', value: 'C' }\n      ]\n    }\n  }\n}"
      },
      {
        "language": "text",
        "code": "<div>Selected: {{ selected }}</div>\n\n<select v-model=\"selected\">\n  <option v-for=\"option in options\" :value=\"option.value\">\n    {{ option.text }}\n  </option>\n</select>"
      },
      {
        "language": "text",
        "code": "<div>Selected: {{ selected }}</div>\n\n<select v-model=\"selected\">\n  <option v-for=\"option in options\" :value=\"option.value\">\n    {{ option.text }}\n  </option>\n</select>"
      },
      {
        "language": "text",
        "code": "<!-- `picked` is a string \"a\" when checked -->\n<input type=\"radio\" v-model=\"picked\" value=\"a\" />\n\n<!-- `toggle` is either true or false -->\n<input type=\"checkbox\" v-model=\"toggle\" />\n\n<!-- `selected` is a string \"abc\" when the first option is selected -->\n<select v-model=\"selected\">\n  <option value=\"abc\">ABC</option>\n</select>"
      },
      {
        "language": "text",
        "code": "<!-- `picked` is a string \"a\" when checked -->\n<input type=\"radio\" v-model=\"picked\" value=\"a\" />\n\n<!-- `toggle` is either true or false -->\n<input type=\"checkbox\" v-model=\"toggle\" />\n\n<!-- `selected` is a string \"abc\" when the first option is selected -->\n<select v-model=\"selected\">\n  <option value=\"abc\">ABC</option>\n</select>"
      },
      {
        "language": "text",
        "code": "<input\n  type=\"checkbox\"\n  v-model=\"toggle\"\n  true-value=\"yes\"\n  false-value=\"no\" />"
      },
      {
        "language": "text",
        "code": "<input\n  type=\"checkbox\"\n  v-model=\"toggle\"\n  true-value=\"yes\"\n  false-value=\"no\" />"
      },
      {
        "language": "text",
        "code": "false-value"
      },
      {
        "language": "text",
        "code": "<input\n  type=\"checkbox\"\n  v-model=\"toggle\"\n  :true-value=\"dynamicTrueValue\"\n  :false-value=\"dynamicFalseValue\" />"
      },
      {
        "language": "text",
        "code": "<input\n  type=\"checkbox\"\n  v-model=\"toggle\"\n  :true-value=\"dynamicTrueValue\"\n  :false-value=\"dynamicFalseValue\" />"
      },
      {
        "language": "text",
        "code": "false-value"
      },
      {
        "language": "text",
        "code": "<input type=\"radio\" v-model=\"pick\" :value=\"first\" />\n<input type=\"radio\" v-model=\"pick\" :value=\"second\" />"
      },
      {
        "language": "text",
        "code": "<input type=\"radio\" v-model=\"pick\" :value=\"first\" />\n<input type=\"radio\" v-model=\"pick\" :value=\"second\" />"
      },
      {
        "language": "text",
        "code": "<select v-model=\"selected\">\n  <!-- inline object literal -->\n  <option :value=\"{ number: 123 }\">123</option>\n</select>"
      },
      {
        "language": "text",
        "code": "<select v-model=\"selected\">\n  <!-- inline object literal -->\n  <option :value=\"{ number: 123 }\">123</option>\n</select>"
      },
      {
        "language": "text",
        "code": "{ number: 123 }"
      },
      {
        "language": "text",
        "code": "<!-- synced after \"change\" instead of \"input\" -->\n<input v-model.lazy=\"msg\" />"
      },
      {
        "language": "text",
        "code": "<!-- synced after \"change\" instead of \"input\" -->\n<input v-model.lazy=\"msg\" />"
      },
      {
        "language": "text",
        "code": "<input v-model.number=\"age\" />"
      },
      {
        "language": "text",
        "code": "<input v-model.number=\"age\" />"
      },
      {
        "language": "text",
        "code": "parseFloat()"
      },
      {
        "language": "text",
        "code": "valueAsNumber"
      },
      {
        "language": "text",
        "code": "type=\"number\""
      },
      {
        "language": "text",
        "code": "<input v-model.trim=\"msg\" />"
      },
      {
        "language": "text",
        "code": "<input v-model.trim=\"msg\" />"
      }
    ],
    "links": [
      {
        "text": "Watch a free video lesson on Vue School",
        "href": "https://vueschool.io/lessons/user-inputs-vue-devtools-in-vue-3?friend=vuejs"
      },
      {
        "text": "Watch a free video lesson on Vue School",
        "href": "https://vueschool.io/lessons/vue-fundamentals-capi-user-inputs-in-vue?friend=vuejs"
      },
      {
        "text": "data",
        "href": "/api/options-state#data"
      },
      {
        "text": "reactivity APIs",
        "href": "/api/reactivity-core#reactivity-api-core"
      },
      {
        "text": "Try it in the Playground",
        "href": "https://play.vuejs.org/#eNo9jUEOgyAQRa8yYUO7aNkbNOkBegM2RseWRGACoxvC3TumxuX/+f+9ql5Ez31D1SlbpuyJoSBvNLjoA6XMUCHjAg2WnAJomWoXXZxSLAwBSxk/CP2xuWl9d9GaP0YAEhgDrSOjJABLw/s8+NJBrde/NWsOpWPrI20M+yOkGdfeqXPiFAhowm9aZ8zS4+wPv/RGjtZcJtV+YpNK1g=="
      },
      {
        "text": "Try it in the Playground",
        "href": "https://play.vuejs.org/#eNo9jdEKwjAMRX8l9EV90L2POvAD/IO+lDVqoetCmw6h9N/NmBuEJPeSc1PVg+i2FFS90nlMnngwEb80JwaHL1sCQzURwFm258u2AyTkkuKuACbM2b6xh9Nps9o6pEnp7ggWwThRsIyiADQNz40En3uodQ+C1nRHK8HaRyoMy3WaHYa7Uf8To0CCRvzMwWESH51n4cXvBNTd8Um1H0FuTq0="
      },
      {
        "text": "IME",
        "href": "https://en.wikipedia.org/wiki/Input_method"
      },
      {
        "text": "Try it in the Playground",
        "href": "https://play.vuejs.org/#eNo9jktuwzAMRK9CaON24XrvKgZ6gN5AG8FmGgH6ECKdJjB891D5LYec9zCb+SH6Oq9oRmN5roEEGGWlyeWQqFSBDSoeYYdjLQk6rXYuuzyXzAIJmf0fwqF1Prru02U7PDQq0CCYKHrBlsQy+Tz9rlFCDBnfdOBRqfa7twhYrhEPzvyfgmCvnxlHoIp9w76dmbbtDe+7HdpaBQUv4it6OPepLBjV8Gw5AzpjxlOJC1a9+2WB1IZQRGhWVqsdXgb1tfDcbvYbJDRqLQ=="
      },
      {
        "text": "Try it in the Playground",
        "href": "https://play.vuejs.org/#eNo9jk2OwyAMha9isenMIpN9hok0B+gN2FjBbZEIscDpj6LcvaZpKiHg2X6f32L+mX+uM5nO2DLkwNK7RHeesoCnE85RYHEJwKPg1/f2B8gkc067AhipFDxTB4fDVlrro5ce237AKoRGjihUldjCmPqjLgkxJNoxEEqnrtp7TTEUeUT6c+Z2CUKNdgbdxZmaavt1pl+Wj3ldbcubUegumAnh2oyTp6iE95QzoDEGukzRU9Y6eg9jDcKRoFKLUm27E5RXxTu7WZ89/G4E"
      },
      {
        "text": "Try it in the Playground",
        "href": "https://play.vuejs.org/#eNpVjssKgzAURH/lko3tonVfotD/yEaTKw3Ni3gjLSH/3qhUcDnDnMNk9gzhviRkD8ZnGXUgmJFS6IXTNvhIkCHiBAWm6C00ddoIJ5z0biaQL5RvVNCtmwvFhFfheLuLqqIGQhvMQLgm4tqFREDfgJ1gGz36j2Cg1TkvN+sVmn+JqnbtrjDDiAYmH09En/PxphTebqsK8PY4wMoPslBUxQ=="
      },
      {
        "text": "Try it in the Playground",
        "href": "https://play.vuejs.org/#eNpVjtEKgzAMRX8l9Gl72Po+OmH/0ZdqI5PVNnSpOEr/fVVREEKSc0kuN4sX0X1KKB5Cfbs4EDfa40whMljsTXIMWXsAa9hcrtsOEJFT9DsBdG/sPmgfwDHhJpZl1FZLycO6AuNIzjAuxGrwlBj4R/jUYrVpw6wFDPbM020MFt0uoq2a3CycadFBH+Lpo8l5jwWlKLle1QcljwCi/AH7gFic"
      },
      {
        "text": "Set",
        "href": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Set"
      },
      {
        "text": "Try it in the Playground",
        "href": "https://play.vuejs.org/#eNqVkUtqwzAURbfy0CTtoNU8KILSWaHdQNWBIj8T1fohyybBeO+RbOc3i2e+vHvuMWggHyG89x2SLWGtijokaDF1gQunbfAxwQARaxihjt7CJlc3wgmnvGsTqAOqBqsfabGFXSm+/P69CsfovJVXckhog5EJcwJgle7558yBK+AWhuFxaRwZLbVCZ0K70CVIp4A7Qabi3h8FAV3l/C9Vk797abpy/lrim/UVmkt/Gc4HOv+EkXs0UPt4XeCFZHQ6lM4TZn9w9+YlrjFPCC/kKrPVDd6Zv5e4wjwv8ELezIxeX4qMZwHduAs="
      },
      {
        "text": "Try it in the Playground",
        "href": "https://play.vuejs.org/#eNqVUc1qxCAQfpXBU3tovS9WKL0V2hdoenDjLGtjVNwxbAl592rMpru3DYjO5/cnOLLXEJ6HhGzHxKmNJpBsHJ6DjwQaDypZgrFxAFqRenisM0BEStFdEEB7xLZD/al6PO3g67veT+XIW16Cr+kZEPbBKsKMAIQ2g3yrAeBqwjjeRMI0CV5kxZ0dxoVEQL8BXxo2C/f+3DAwOuMf1XZ5HpRNhX5f4FPvNdqLfgnOBK+PsGqPFg4+rgmyOAWfiaK5o9kf3XXzArc0zxZZnJuae9PhVfPHAjc01wRZnP/Ngq8/xaY/yMW74g=="
      },
      {
        "text": "Try it in the Playground",
        "href": "https://play.vuejs.org/#eNqFkDFuwzAMRa9CaHE7tNoDxUBP0A4dtTgWDQiRJUKmHQSG7x7KhpMMAbLxk3z/g5zVD9H3NKI6KDO02RPDgDxSbaPvKWWGGTJ2sECXUw+VrFY22timODCQb8/o4FhWPqrfiNWnjUZvRmIhgrGn0DCKAjDOT/XfCh1gnnd+WYwukwJYNj7SyMBXwqNVuXE+WQXeiUgRpZyaMJaR5BX11SeHQfTmJi1dnNiE5oQBupR3shbC6LX9Posvpdyz/jf1OksOe85ayVqIR5bR9z+o5Qbc6oCk"
      },
      {
        "text": "Try it in the Playground",
        "href": "https://play.vuejs.org/#eNqNkEEOAiEMRa/SsFEXyt7gJJ5AFy5ng1ITIgLBMmomc3eLOONSEwJ9Lf//pL3YxrjqMoq1ULdTspGa1uMjhkRg8KyzI+hbD2A06fmi1gAJKSc/EkC0pwuaNcx2Hme1OZSHLz5KTtYMhNfoNGEhUsZ2zf6j7vuPEQyDkmVSBPzJ+pgJ6Blx04qkjQ2tAGsYgkcuO+1yGXF6oeU1GHTM1Y1bsoY5fUQH55BGZcMKJd/t31l0L+WYdaj0V9Zb2bDim6XktAcxvADR+YWb"
      },
      {
        "text": "Try it in the Playground",
        "href": "https://play.vuejs.org/#eNp1j7EOgyAQhl/lwmI7tO4Nmti+QJOuLFTPxASBALoQ3r2H2jYOjvff939wkTXWXucJ2Y1x37rBBvAYJlsLPYzWuAARHPaQoHdmhILQQmihW6N9RhW2ATuoMnQqirPQvFw9ZKAh4GiVDEgTAPdW6hpeW+sGMf4VKVEz73Mvs8sC5stoOlSVYF9SsEVGiLFhMBq6wcu3IsUs1YREEvFUKD1udjAaebnS+27dHOT3g/yxy+nHywM08PJ3KksfXwJ2dA=="
      },
      {
        "text": "Try it in the Playground",
        "href": "https://play.vuejs.org/#eNp1j1ELgyAUhf/KxZe2h633cEHbHxjstReXdxCYSt5iEP333XIJPQSinuN3jjqJyvvrOKAohAxN33oqa4tf73oCjR81GIKptgBakTqd4x6gRxp6uymAgAYbQl1AlkVvXhaeeMg8NbMg7LxRhKwAZPDKlvBK8WlKXTDPnFzOI7naMF46p9HcarFxtVgBRpyn1lnQbVBvwwWjMgMyycTToAr47wZnUeaR3mfL6sC/H/iPnc/vXS9gIfP0UTH/ACgWeYE="
      },
      {
        "text": "Try it in the Playground",
        "href": "https://play.vuejs.org/#eNp1kL2OwjAQhF9l5Ya74i7QBhMJeARKTIESIyz5Z5VsAsjyu7NOQEBB5xl/M7vaKNaI/0OvRSlkV7cGCTpNPVbKG4ehJYjQ6hMkOLXBwYzRmfLK18F3GbW6Jt3AKkM/+8Ov8rKYeriBBWmH9kiaFYBszFDtHpkSYnwVpCSL/JtDDE4+DH8uNNqulHiCSoDrLRm0UyWzAckEX61l8Xh9+psv/vbD563HCSxk8bY0y45u47AJ2D/HHyDm4MU0dC5hMZ/jdal8Gg8wJkS6A3nRew4="
      },
      {
        "text": "Try it in the Playground",
        "href": "https://play.vuejs.org/#eNp1UEEOgjAQ/MqmJz0oeMVKgj7BI3AgdI1NCjSwIIbwdxcqRA4mTbsznd2Z7CAia49diyIQsslrbSlMSuxtVRMofGStIRiSEkBllO32rgaokdq6XBBAgwZzQhVAnDpunB6++EhvncyAsLAmI2QEIJXuwvvaPAzrJBhH6U2/UxMLHQ/doagUmksiFmEioOCU2ho3krWVJV2VYSS9b7Xlr3/424bn1LMDA+n9hGbY0Hs2c4J4sU/dPl5a0TOAk+/b/rwsYO4Q4wdtRX7l"
      },
      {
        "text": "Try it in the Playground",
        "href": "https://play.vuejs.org/#eNp9kj9vwjAQxb/KyUtaiYahGwpIgBjaoVSFre6AkguEOnZkOwEpynfv2flDqlZkyt37+fye7ZotiyKsSmQzFplYZ4UFg7YsFlxmeaG0hRo0ptBAqlUOAaEBl1zGShqHCowtJjB30EOwDB5voipsRj+d9skl0CyLVzuDYCsxmEB1ECVStQygmfzS9xc10ld/9ZPG8YQ1EVx+0e7RtI1BAaiwmBfiYNFVNkqyarHrLM+grm/+myaaOtUtAojaPlRPuUpQzDnrQc4IAfqiNh0hqdIEdGUm+9icwcy7G8TQl8MESlN3cOhSkYdu9LTteo7i+K2piKZDGjZh1tApp9kxPBsl6fZqR3MWq7zIBOpt74JytmM5OwihLq++Z3WJ/kT9mhPG3//0z+bqepy9azSoK/I+aPagj2hbebN7I/8jkU6tFETfET/QKFE6jy22KmVCtkecd/vi32Amj3uzuVqUpg/ljDqyfRec0btc34l+s/scPvt1XDas+QENov3B"
      },
      {
        "text": "Try it in the Playground",
        "href": "https://play.vuejs.org/#eNp9ksFuwjAMhl/FyoVNYuWwG+omAeKwHcY0uC07VK2BspBUiVuQKt59Tkq6Hjakqortz87/J2nFrKqSpkYxFanLbVnRs9R4rowlKHCb1YqglRqgyCi7u+/WABaptjpGAA4V5oTFFEaz0ThmTUWl0W4KnzED0ALhmZhbaRyNoclUjaELLn3fgNqczICa/0ftLQ6nLZiL2Fe3CDH/+EsnvVMOCI+Vygh9RGlRNs/r3kzb9s7gckknvuqbANIuD83D0RSonqSIoBSM+B3Tzj4jW2MZuIaljuciBUyD4r6YhLCfwA7bK5x4p6zhOnrSZQPHdsLWHKST3o0YC3K50dtylxyc0XzB4bakyM2xKhXaVVTBPruxUmRKmdNryJGt8XrW3LPH/PuP/MGdfU6Kd4sObcPa+xpldofUlZfrN9Y/KPKp1YrpG8UPdEbVXmOHzWtdsOwBF9S+HP1jLfVu45ZnQu2iKS80XHrgpeBXvrhh/VfuY/IYH4u4/AD+8ADR"
      },
      {
        "text": "DOM property valueAsNumber",
        "href": "https://developer.mozilla.org/en-US/docs/Web/API/HTMLInputElement#valueasnumber"
      },
      {
        "text": "Usage with v-model",
        "href": "/guide/components/v-model"
      },
      {
        "text": "Edit this page on GitHub",
        "href": "https://github.com/vuejs/docs/edit/main/src/guide/essentials/forms.md"
      }
    ],
    "meta": {
      "description": "Vue.js - The Progressive JavaScript Framework",
      "keywords": ""
    },
    "summary": "Form Input Bindings Watch a free video lesson on Vue SchoolWatch a free video lesson on Vue SchoolWhen dealing with forms on the frontend, we often need to sync the state of form input elements with c...",
    "tags": [
      "react",
      "vue",
      "angular",
      "javascript",
      "typescript",
      "css",
      "html",
      "vite",
      "bindings",
      "form"
    ],
    "id": "form-input-bindings-formshtml-part-1",
    "quality": 100
  },
  {
    "title": "Composition API FAQ",
    "url": "https://vuejs.org/guide/extras/composition-api-faq.html",
    "category": "vue",
    "content": "Composition API FAQ TIPThis FAQ assumes prior experience with Vue - in particular, experience with Vue 2 while primarily using Options API.What is Composition API? Watch a free video lesson on Vue SchoolComposition API is a set of APIs that allows us to author Vue components using imported functions instead of declaring options. It is an umbrella term that covers the following APIs:Reactivity API, e.g. ref() and reactive(), that allows us to directly create reactive state, computed state, and watchers.Lifecycle Hooks, e.g. onMounted() and onUnmounted(), that allow us to programmatically hook into the component lifecycle.Dependency Injection, i.e. provide() and inject(), that allow us to leverage Vue's dependency injection system while using Reactivity APIs.Composition API is a built-in feature of Vue 3 and Vue 2.7. For older Vue 2 versions, use the officially maintained @vue/composition-api plugin. In Vue 3, it is also primarily used together with the script setup syntax in Single-File Components. Here's a basic example of a component using Composition API:vuescript setup import { ref, onMounted } from 'vue' // reactive state const count = ref(0) // functions that mutate state and trigger updates function increment() { count.value++ } // lifecycle hooks onMounted(() = { console.log(The initial count is ${count.value}.) }) /script template button @click=\"increment\"Count is: {{ count }}/button /templateDespite an API style based on function composition, Composition API is NOT functional programming. Composition API is based on Vue's mutable, fine-grained reactivity paradigm, whereas functional programming emphasizes immutability.If you are interested in learning how to use Vue with Composition API, you can set the site-wide API preference to Composition API using the toggle at the top of the left sidebar, and then go through the guide from the beginning.Why Composition API? Better Logic Reuse The primary advantage of Composition API is that it enables clean, efficient logic reuse in the form of Composable functions. It solves all the drawbacks of mixins, the primary logic reuse mechanism for Options API.Composition API's logic reuse capability has given rise to impressive community projects such as VueUse, an ever-growing collection of composable utilities. It also serves as a clean mechanism for easily integrating stateful third-party services or libraries into Vue's reactivity system, for example immutable data, state machines, and RxJS.More Flexible Code Organization Many users love that we write organized code by default with Options API: everything has its place based on the option it falls under. However, Options API poses serious limitations when a single component's logic grows beyond a certain complexity threshold. This limitation is particularly prominent in components that need to deal with multiple logical concerns, which we have witnessed first hand in many production Vue 2 apps.Take the folder explorer component from Vue CLI's GUI as an example: this component is responsible for the following logical concerns:Tracking current folder state and displaying its contentHandling folder navigation (opening, closing, refreshing...)Handling new folder creationToggling show favorite folders onlyToggling show hidden foldersHandling current working directory changesThe original version of the component was written in Options API. If we give each line of code a color based on the logical concern it is dealing with, this is how it looks:Notice how code dealing with the same logical concern is forced to be split under different options, located in different parts of the file. In a component that is several hundred lines long, understanding and navigating a single logical concern requires constantly scrolling up and down the file, making it much more difficult than it should be. In addition, if we ever intend to extract a logical concern into a reusable utility, it takes quite a bit of work to find and extract the right pieces of code from different parts of the file.Here's the same component, before and after the refactor into Composition API:Notice how the code related to the same logical concern can now be grouped together: we no longer need to jump between different options blocks while working on a specific logical concern. Moreover, we can now move a group of code into an external file with minimal effort, since we no longer need to shuffle the code around in order to extract them. This reduced friction for refactoring is key to the long-term maintainability in large codebases.Better Type Inference In recent years, more and more frontend developers are adopting TypeScript as it helps us write more robust code, make changes with more confidence, and provides a great development experience with IDE support. However, the Options API, originally conceived in 2013, was designed without type inference in mind. We had to implement some absurdly complex type gymnastics to make type inference work with the Options API. Even with all this effort, type inference for Options API can still break down for mixins and dependency injection.This had led many developers who wanted to use Vue with TS to lean towards Class API powered by vue-class-component. However, a class-based API heavily relies on ES decorators, a language feature that was only a stage 2 proposal when Vue 3 was being developed in 2019. We felt it was too risky to base an official API on an unstable proposal. Since then, the decorators proposal has gone through yet another complete overhaul, and finally reached stage 3 in 2022. In addition, class-based API suffers from logic reuse and organization limitations similar to Options API.In comparison, Composition API utilizes mostly plain variables and functions, which are naturally type friendly. Code written in Composition API can enjoy full type inference with little need for manual type hints. Most of the time, Composition API code will look largely identical in TypeScript and plain JavaScript. This also makes it possible for plain JavaScript users to benefit from partial type inference.Smaller Production Bundle and Less Overhead Code written in Composition API and script setup is also more efficient and minification-friendly than Options API equivalent. This is because the template in a script setup component is compiled as a function inlined in the same scope of the script setup code. Unlike property access from this, the compiled template code can directly access variables declared inside script setup, without an instance proxy in between. This also leads to better minification because all the variable names can be safely shortened.Relationship with Options API Trade-offs Some users moving from Options API found their Composition API code less organized, and concluded that Composition API is \"worse\" in terms of code organization. We recommend users with such opinions to look at that problem from a different perspective.It is true that Composition API no longer provides the \"guard rails\" that guide you to put your code into respective buckets. In return, you get to author component code like how you would write normal JavaScript. This means you can and should apply any code organization best practices to your Composition API code as you would when writing normal JavaScript. If you can write well-organized JavaScript, you should also be able to write well-organized Composition API code.Options API does allow you to \"think less\" when writing component code, which is why many users love it. However, in reducing the mental overhead, it also locks you into the prescribed code organization pattern with no escape hatch, which can make it difficult to refactor or improve code quality in larger scale projects. In this regard, Composition API provides better long term scalability.Does Composition API cover all use cases? Yes in terms of stateful logic. When using Composition API, there are only a few options that may still be needed: props, emits, name, and inheritAttrs.TIPSince 3.3 you can directly use defineOptions in script setup to set the component name or inheritAttrs propertyIf you intend to exclusively use Composition API (along with the options listed above), you can shave a few kbs off your production bundle via a compile-time flag that drops Options API related code from Vue. Note this also affects Vue components in your dependencies.Can I use both APIs in the same component? Yes. You can use Composition API via the setup() option in an Options API component.However, we only recommend doing so if you have an existing Options API codebase that needs to integrate with new features / external libraries written with Composition API.Will Options API be deprecated? No, we do not have any plan to do so. Options API is an integral part of Vue and the reason many developers love it. We also realize that many of the benefits of Composition API only manifest in larger-scale projects, and Options API remains a solid choice for many low-to-medium-complexity scenarios.Relationship with Class API We no longer recommend using Class API with Vue 3, given that Composition API provides great TypeScript integration with additional logic reuse and code organization benefits.Comparison with React Hooks Composition API provides the same level of logic composition capabilities as React Hooks, but with some important differences.React Hooks are invoked repeatedly every time a component updates. This creates a number of caveats that can confuse even seasoned React developers. It also leads to performance optimization issues that can severely affect development experience. Here are some examples:Hooks are call-order sensitive and cannot be conditional.Variables declared in a React component can be captured by a hook closure and become \"stale\" if the developer fails to pass in the correct dependencies array. This leads to React developers relying on ESLint rules to ensure correct dependencies are passed. However, the rule is often not smart enough and over-compensates for correctness, which leads to unnecessary invalidation and headaches when edge cases are encountered.Expensive computations require the use of useMemo, which again requires manually passing in the correct dependencies array.Event handlers passed to child components cause unnecessary child updates by default, and require explicit useCallback as an optimization. This is almost always needed, and again requires a correct dependencies array. Neglecting this leads to over-rendering apps by default and can cause performance issues without realizing it.The stale closure problem, combined with Concurrent features, makes it difficult to reason about when a piece of hooks code is run, and makes working with mutable state that should persist across renders (via useRef) cumbersome.Note: some of the above issues that are related to memoization can be resolved by the upcoming React Compiler.In comparison, Vue Composition API:Invokes setup() or script setup code only once. This makes the code align better with the intuitions of idiomatic JavaScript usage as there are no stale closures to worry about. Composition API calls are also not sensitive to call order and can be conditional.Vue's runtime reactivity system automatically collects reactive dependencies used in computed properties and watchers, so there's no need to manually declare dependencies.No need to manually cache callback functions to avoid unnecessary child updates. In general, Vue's fine-grained reactivity system ensures child components only update when they need to. Manual child-update optimizations are rarely a concern for Vue developers.We acknowledge the creativity of React Hooks, and it is a major source of inspiration for Composition API. However, the issues mentioned above do exist in its design and we noticed Vue's reactivity model happens to provide a way around them.Edit this page on GitHub",
    "headings": [
      {
        "level": 1,
        "text": "Composition API FAQ ​",
        "id": "composition-api-faq"
      },
      {
        "level": 2,
        "text": "What is Composition API? ​",
        "id": "what-is-composition-api"
      },
      {
        "level": 2,
        "text": "Why Composition API? ​",
        "id": "why-composition-api"
      },
      {
        "level": 2,
        "text": "Relationship with Options API ​",
        "id": "relationship-with-options-api"
      },
      {
        "level": 2,
        "text": "Relationship with Class API ​",
        "id": "relationship-with-class-api"
      },
      {
        "level": 2,
        "text": "Comparison with React Hooks ​",
        "id": "comparison-with-react-hooks"
      },
      {
        "level": 3,
        "text": "Better Logic Reuse ​",
        "id": "better-logic-reuse"
      },
      {
        "level": 3,
        "text": "More Flexible Code Organization ​",
        "id": "more-flexible-code-organization"
      },
      {
        "level": 3,
        "text": "Better Type Inference ​",
        "id": "better-type-inference"
      },
      {
        "level": 3,
        "text": "Smaller Production Bundle and Less Overhead ​",
        "id": "smaller-production-bundle-and-less-overhead"
      },
      {
        "level": 3,
        "text": "Trade-offs ​",
        "id": "trade-offs"
      },
      {
        "level": 3,
        "text": "Does Composition API cover all use cases? ​",
        "id": "does-composition-api-cover-all-use-cases"
      },
      {
        "level": 3,
        "text": "Can I use both APIs in the same component? ​",
        "id": "can-i-use-both-apis-in-the-same-component"
      },
      {
        "level": 3,
        "text": "Will Options API be deprecated? ​",
        "id": "will-options-api-be-deprecated"
      }
    ],
    "codeBlocks": [
      {
        "language": "text",
        "code": "onMounted()"
      },
      {
        "language": "text",
        "code": "onUnmounted()"
      },
      {
        "language": "text",
        "code": "@vue/composition-api"
      },
      {
        "language": "text",
        "code": "<script setup>"
      },
      {
        "language": "text",
        "code": "<script setup>\nimport { ref, onMounted } from 'vue'\n\n// reactive state\nconst count = ref(0)\n\n// functions that mutate state and trigger updates\nfunction increment() {\n  count.value++\n}\n\n// lifecycle hooks\nonMounted(() => {\n  console.log(`The initial count is ${count.value}.`)\n})\n</script>\n\n<template>\n  <button @click=\"increment\">Count is: {{ count }}</button>\n</template>"
      },
      {
        "language": "text",
        "code": "<script setup>\nimport { ref, onMounted } from 'vue'\n\n// reactive state\nconst count = ref(0)\n\n// functions that mutate state and trigger updates\nfunction increment() {\n  count.value++\n}\n\n// lifecycle hooks\nonMounted(() => {\n  console.log(`The initial count is ${count.value}.`)\n})\n</script>\n\n<template>\n  <button @click=\"increment\">Count is: {{ count }}</button>\n</template>"
      },
      {
        "language": "text",
        "code": "vue-class-component"
      },
      {
        "language": "text",
        "code": "<script setup>"
      },
      {
        "language": "text",
        "code": "<script setup>"
      },
      {
        "language": "text",
        "code": "<script setup>"
      },
      {
        "language": "text",
        "code": "<script setup>"
      },
      {
        "language": "text",
        "code": "inheritAttrs"
      },
      {
        "language": "text",
        "code": "defineOptions"
      },
      {
        "language": "text",
        "code": "<script setup>"
      },
      {
        "language": "text",
        "code": "inheritAttrs"
      },
      {
        "language": "text",
        "code": "useCallback"
      },
      {
        "language": "text",
        "code": "<script setup>"
      }
    ],
    "links": [
      {
        "text": "Watch a free video lesson on Vue School",
        "href": "https://vueschool.io/lessons/introduction-to-the-vue-js-3-composition-api?friend=vuejs"
      },
      {
        "text": "Reactivity API",
        "href": "/api/reactivity-core"
      },
      {
        "text": "Lifecycle Hooks",
        "href": "/api/composition-api-lifecycle"
      },
      {
        "text": "Dependency Injection",
        "href": "/api/composition-api-dependency-injection"
      },
      {
        "text": "Vue 2.7",
        "href": "https://blog.vuejs.org/posts/vue-2-7-naruto.html"
      },
      {
        "text": "@vue/composition-api",
        "href": "https://github.com/vuejs/composition-api"
      },
      {
        "text": "<script setup>",
        "href": "/api/sfc-script-setup"
      },
      {
        "text": "Composable functions",
        "href": "/guide/reusability/composables"
      },
      {
        "text": "all the drawbacks of mixins",
        "href": "/guide/reusability/composables#vs-mixins"
      },
      {
        "text": "VueUse",
        "href": "https://vueuse.org/"
      },
      {
        "text": "immutable data",
        "href": "/guide/extras/reactivity-in-depth#immutable-data"
      },
      {
        "text": "state machines",
        "href": "/guide/extras/reactivity-in-depth#state-machines"
      },
      {
        "text": "RxJS",
        "href": "/guide/extras/reactivity-in-depth#rxjs"
      },
      {
        "text": "original version",
        "href": "https://github.com/vuejs/vue-cli/blob/a09407dd5b9f18ace7501ddb603b95e31d6d93c0/packages/@vue/cli-ui/src/components/folder/FolderExplorer.vue#L198-L404"
      },
      {
        "text": "refactor into Composition API",
        "href": "https://gist.github.com/yyx990803/8854f8f6a97631576c14b63c8acd8f2e"
      },
      {
        "text": "TypeScript",
        "href": "https://www.typescriptlang.org/"
      },
      {
        "text": "absurdly complex type gymnastics",
        "href": "https://github.com/vuejs/core/blob/44b95276f5c086e1d88fa3c686a5f39eb5bb7821/packages/runtime-core/src/componentPublicInstance.ts#L132-L165"
      },
      {
        "text": "compile-time flag",
        "href": "/api/compile-time-flags"
      },
      {
        "text": "setup()",
        "href": "/api/composition-api-setup"
      },
      {
        "text": "React Compiler",
        "href": "https://react.dev/learn/react-compiler"
      },
      {
        "text": "Edit this page on GitHub",
        "href": "https://github.com/vuejs/docs/edit/main/src/guide/extras/composition-api-faq.md"
      }
    ],
    "meta": {
      "description": "Vue.js - The Progressive JavaScript Framework",
      "keywords": ""
    },
    "summary": "Composition API FAQ TIPThis FAQ assumes prior experience with Vue - in particular, experience with Vue 2 while primarily using Options API. What is Composition API",
    "tags": [
      "react",
      "vue",
      "angular",
      "javascript",
      "typescript",
      "css",
      "html",
      "webpack",
      "vite",
      "api"
    ],
    "id": "composition-api-faq-compositionapifaqhtml-part-1",
    "quality": 100
  },
  {
    "title": "Composition API: setup()",
    "url": "https://vuejs.org/api/composition-api-setup.html",
    "category": "vue",
    "content": "Composition API: setup() Basic Usage The setup() hook serves as the entry point for Composition API usage in components in the following cases:Using Composition API without a build step;Integrating with Composition-API-based code in an Options API component.NoteIf you are using Composition API with Single-File Components, script setup is strongly recommended for a more succinct and ergonomic syntax.We can declare reactive state using Reactivity APIs and expose them to the template by returning an object from setup(). The properties on the returned object will also be made available on the component instance (if other options are used):vuescript import { ref } from 'vue' export default { setup() { const count = ref(0) // expose to template and other options API hooks return { count } }, mounted() { console.log(this.count) // 0 } } /script template button @click=\"count++\"{{ count }}/button /templaterefs returned from setup are automatically shallow unwrapped when accessed in the template so you do not need to use .value when accessing them. They are also unwrapped in the same way when accessed on this.setup() itself does not have access to the component instance - this will have a value of undefined inside setup(). You can access Composition-API-exposed values from Options API, but not the other way around.setup() should return an object synchronously. The only case when async setup() can be used is when the component is a descendant of a Suspense component.Accessing Props The first argument in the setup function is the props argument. Just as you would expect in a standard component, props inside of a setup function are reactive and will be updated when new props are passed in.jsexport default { props: { title: String }, setup(props) { console.log(props.title) } }Note that if you destructure the props object, the destructured variables will lose reactivity. It is therefore recommended to always access props in the form of props.xxx.If you really need to destructure the props, or need to pass a prop into an external function while retaining reactivity, you can do so with the toRefs() and toRef() utility APIs:jsimport { toRefs, toRef } from 'vue' export default { setup(props) { // turn props into an object of refs, then destructure const { title } = toRefs(props) // title is a ref that tracks props.title console.log(title.value) // OR, turn a single property on props into a ref const title = toRef(props, 'title') } }Setup Context The second argument passed to the setup function is a Setup Context object. The context object exposes other values that may be useful inside setup:jsexport default { setup(props, context) { // Attributes (Non-reactive object, equivalent to $attrs) console.log(context.attrs) // Slots (Non-reactive object, equivalent to $slots) console.log(context.slots) // Emit events (Function, equivalent to $emit) console.log(context.emit) // Expose public properties (Function) console.log(context.expose) } }The context object is not reactive and can be safely destructured:jsexport default { setup(props, { attrs, slots, emit, expose }) { ... } }attrs and slots are stateful objects that are always updated when the component itself is updated. This means you should avoid destructuring them and always reference properties as attrs.x or slots.x. Also note that, unlike props, the properties of attrs and slots are not reactive. If you intend to apply side effects based on changes to attrs or slots, you should do so inside an onBeforeUpdate lifecycle hook.Exposing Public Properties expose is a function that can be used to explicitly limit the properties exposed when the component instance is accessed by a parent component via template refs:jsexport default { setup(props, { expose }) { // make the instance \"closed\" - // i.e. do not expose anything to the parent expose() const publicCount = ref(0) const privateCount = ref(0) // selectively expose local state expose({ count: publicCount }) } }Usage with Render Functions setup can also return a render function which can directly make use of the reactive state declared in the same scope:jsimport { h, ref } from 'vue' export default { setup() { const count = ref(0) return () = h('div', count.value) } }Returning a render function prevents us from returning anything else. Internally that shouldn't be a problem, but it can be problematic if we want to expose methods of this component to the parent component via template refs.We can solve this problem by calling expose():jsimport { h, ref } from 'vue' export default { setup(props, { expose }) { const count = ref(0) const increment = () = ++count.value expose({ increment }) return () = h('div', count.value) } }The increment method would then be available in the parent component via a template ref.Edit this page on GitHub",
    "headings": [
      {
        "level": 1,
        "text": "Composition API: setup() ​",
        "id": "composition-api-setup"
      },
      {
        "level": 2,
        "text": "Basic Usage ​",
        "id": "basic-usage"
      },
      {
        "level": 2,
        "text": "Accessing Props ​",
        "id": "accessing-props"
      },
      {
        "level": 2,
        "text": "Setup Context ​",
        "id": "setup-context"
      },
      {
        "level": 2,
        "text": "Usage with Render Functions ​",
        "id": "usage-with-render-functions"
      },
      {
        "level": 3,
        "text": "Exposing Public Properties ​",
        "id": "exposing-public-properties"
      }
    ],
    "codeBlocks": [
      {
        "language": "text",
        "code": "<script setup>"
      },
      {
        "language": "text",
        "code": "<script>\nimport { ref } from 'vue'\n\nexport default {\n  setup() {\n    const count = ref(0)\n\n    // expose to template and other options API hooks\n    return {\n      count\n    }\n  },\n\n  mounted() {\n    console.log(this.count) // 0\n  }\n}\n</script>\n\n<template>\n  <button @click=\"count++\">{{ count }}</button>\n</template>"
      },
      {
        "language": "text",
        "code": "<script>\nimport { ref } from 'vue'\n\nexport default {\n  setup() {\n    const count = ref(0)\n\n    // expose to template and other options API hooks\n    return {\n      count\n    }\n  },\n\n  mounted() {\n    console.log(this.count) // 0\n  }\n}\n</script>\n\n<template>\n  <button @click=\"count++\">{{ count }}</button>\n</template>"
      },
      {
        "language": "text",
        "code": "async setup()"
      },
      {
        "language": "text",
        "code": "export default {\n  props: {\n    title: String\n  },\n  setup(props) {\n    console.log(props.title)\n  }\n}"
      },
      {
        "language": "text",
        "code": "export default {\n  props: {\n    title: String\n  },\n  setup(props) {\n    console.log(props.title)\n  }\n}"
      },
      {
        "language": "text",
        "code": "import { toRefs, toRef } from 'vue'\n\nexport default {\n  setup(props) {\n    // turn `props` into an object of refs, then destructure\n    const { title } = toRefs(props)\n    // `title` is a ref that tracks `props.title`\n    console.log(title.value)\n\n    // OR, turn a single property on `props` into a ref\n    const title = toRef(props, 'title')\n  }\n}"
      },
      {
        "language": "text",
        "code": "import { toRefs, toRef } from 'vue'\n\nexport default {\n  setup(props) {\n    // turn `props` into an object of refs, then destructure\n    const { title } = toRefs(props)\n    // `title` is a ref that tracks `props.title`\n    console.log(title.value)\n\n    // OR, turn a single property on `props` into a ref\n    const title = toRef(props, 'title')\n  }\n}"
      },
      {
        "language": "text",
        "code": "export default {\n  setup(props, context) {\n    // Attributes (Non-reactive object, equivalent to $attrs)\n    console.log(context.attrs)\n\n    // Slots (Non-reactive object, equivalent to $slots)\n    console.log(context.slots)\n\n    // Emit events (Function, equivalent to $emit)\n    console.log(context.emit)\n\n    // Expose public properties (Function)\n    console.log(context.expose)\n  }\n}"
      },
      {
        "language": "text",
        "code": "export default {\n  setup(props, context) {\n    // Attributes (Non-reactive object, equivalent to $attrs)\n    console.log(context.attrs)\n\n    // Slots (Non-reactive object, equivalent to $slots)\n    console.log(context.slots)\n\n    // Emit events (Function, equivalent to $emit)\n    console.log(context.emit)\n\n    // Expose public properties (Function)\n    console.log(context.expose)\n  }\n}"
      },
      {
        "language": "text",
        "code": "export default {\n  setup(props, { attrs, slots, emit, expose }) {\n    ...\n  }\n}"
      },
      {
        "language": "text",
        "code": "export default {\n  setup(props, { attrs, slots, emit, expose }) {\n    ...\n  }\n}"
      },
      {
        "language": "text",
        "code": "onBeforeUpdate"
      },
      {
        "language": "text",
        "code": "export default {\n  setup(props, { expose }) {\n    // make the instance \"closed\" -\n    // i.e. do not expose anything to the parent\n    expose()\n\n    const publicCount = ref(0)\n    const privateCount = ref(0)\n    // selectively expose local state\n    expose({ count: publicCount })\n  }\n}"
      },
      {
        "language": "text",
        "code": "export default {\n  setup(props, { expose }) {\n    // make the instance \"closed\" -\n    // i.e. do not expose anything to the parent\n    expose()\n\n    const publicCount = ref(0)\n    const privateCount = ref(0)\n    // selectively expose local state\n    expose({ count: publicCount })\n  }\n}"
      },
      {
        "language": "text",
        "code": "import { h, ref } from 'vue'\n\nexport default {\n  setup() {\n    const count = ref(0)\n    return () => h('div', count.value)\n  }\n}"
      },
      {
        "language": "text",
        "code": "import { h, ref } from 'vue'\n\nexport default {\n  setup() {\n    const count = ref(0)\n    return () => h('div', count.value)\n  }\n}"
      },
      {
        "language": "text",
        "code": "import { h, ref } from 'vue'\n\nexport default {\n  setup(props, { expose }) {\n    const count = ref(0)\n    const increment = () => ++count.value\n\n    expose({\n      increment\n    })\n\n    return () => h('div', count.value)\n  }\n}"
      },
      {
        "language": "text",
        "code": "import { h, ref } from 'vue'\n\nexport default {\n  setup(props, { expose }) {\n    const count = ref(0)\n    const increment = () => ++count.value\n\n    expose({\n      increment\n    })\n\n    return () => h('div', count.value)\n  }\n}"
      }
    ],
    "links": [
      {
        "text": "<script setup>",
        "href": "/api/sfc-script-setup"
      },
      {
        "text": "Reactivity APIs",
        "href": "/api/reactivity-core"
      },
      {
        "text": "refs",
        "href": "/api/reactivity-core#ref"
      },
      {
        "text": "automatically shallow unwrapped",
        "href": "/guide/essentials/reactivity-fundamentals#deep-reactivity"
      },
      {
        "text": "Suspense",
        "href": "/guide/built-ins/suspense"
      },
      {
        "text": "toRefs()",
        "href": "/api/reactivity-utilities#torefs"
      },
      {
        "text": "toRef()",
        "href": "/api/reactivity-utilities#toref"
      },
      {
        "text": "template refs",
        "href": "/guide/essentials/template-refs#ref-on-component"
      },
      {
        "text": "render function",
        "href": "/guide/extras/render-function"
      },
      {
        "text": "Edit this page on GitHub",
        "href": "https://github.com/vuejs/docs/edit/main/src/api/composition-api-setup.md"
      }
    ],
    "meta": {
      "description": "Vue.js - The Progressive JavaScript Framework",
      "keywords": ""
    },
    "summary": "Composition API: setup() Basic Usage The setup() hook serves as the entry point for Composition API usage in components in the following cases:Using Composition API without a build step;Integrating wi...",
    "tags": [
      "react",
      "vue",
      "angular",
      "javascript",
      "typescript",
      "html",
      "vite",
      "setup",
      "composition",
      "api"
    ],
    "id": "composition-api-setup-compositionapisetuphtml-part-1",
    "quality": 100
  },
  {
    "title": "Reactivity API: Core",
    "url": "https://vuejs.org/api/reactivity-core.html",
    "category": "vue",
    "content": "Reactivity API: Core See alsoTo better understand the Reactivity APIs, it is recommended to read the following chapters in the guide:Reactivity Fundamentals (with the API preference set to Composition API)Reactivity in Depthref() Takes an inner value and returns a reactive and mutable ref object, which has a single property .value that points to the inner value.Typetsfunction refT(value: T): RefUnwrapRefT interface RefT { value: T }DetailsThe ref object is mutable - i.e. you can assign new values to .value. It is also reactive - i.e. any read operations to .value are tracked, and write operations will trigger associated effects.If an object is assigned as a ref's value, the object is made deeply reactive with reactive(). This also means if the object contains nested refs, they will be deeply unwrapped.To avoid the deep conversion, use shallowRef() instead.Examplejsconst count = ref(0) console.log(count.value) // 0 count.value = 1 console.log(count.value) // 1See alsoGuide - Reactivity Fundamentals with ref()Guide - Typing ref() computed() Takes a getter function and returns a readonly reactive ref object for the returned value from the getter. It can also take an object with get and set functions to create a writable ref object.Typets// read-only function computedT( getter: (oldValue: T  undefined) = T, // see \"Computed Debugging\" link below debuggerOptions?: DebuggerOptions ): ReadonlyRefReadonlyT // writable function computedT( options: { get: (oldValue: T  undefined) = T set: (value: T) = void }, debuggerOptions?: DebuggerOptions ): RefTExampleCreating a readonly computed ref:jsconst count = ref(1) const plusOne = computed(() = count.value + 1) console.log(plusOne.value) // 2 plusOne.value++ // errorCreating a writable computed ref:jsconst count = ref(1) const plusOne = computed({ get: () = count.value + 1, set: (val) = { count.value = val - 1 } }) plusOne.value = 1 console.log(count.value) // 0Debugging:jsconst plusOne = computed(() = count.value + 1, { onTrack(e) { debugger }, onTrigger(e) { debugger } })See alsoGuide - Computed PropertiesGuide - Computed DebuggingGuide - Typing computed() Guide - Performance - Computed Stabilityreactive() Returns a reactive proxy of the object.Typetsfunction reactiveT extends object(target: T): UnwrapNestedRefsTDetailsThe reactive conversion is \"deep\": it affects all nested properties. A reactive object also deeply unwraps any properties that are refs while maintaining reactivity.It should also be noted that there is no ref unwrapping performed when the ref is accessed as an element of a reactive array or a native collection type like Map.To avoid the deep conversion and only retain reactivity at the root level, use shallowReactive() instead.The returned object and its nested objects are wrapped with ES Proxy and not equal to the original objects. It is recommended to work exclusively with the reactive proxy and avoid relying on the original object.ExampleCreating a reactive object:jsconst obj = reactive({ count: 0 }) obj.count++Ref unwrapping:tsconst count = ref(1) const obj = reactive({ count }) // ref will be unwrapped console.log(obj.count === count.value) // true // it will update obj.count count.value++ console.log(count.value) // 2 console.log(obj.count) // 2 // it will also update count ref obj.count++ console.log(obj.count) // 3 console.log(count.value) // 3Note that refs are not unwrapped when accessed as array or collection elements:jsconst books = reactive([ref('Vue 3 Guide')]) // need .value here console.log(books[0].value) const map = reactive(new Map([['count', ref(0)]])) // need .value here console.log(map.get('count').value)When assigning a ref to a reactive property, that ref will also be automatically unwrapped:tsconst count = ref(1) const obj = reactive({}) obj.count = count console.log(obj.count) // 1 console.log(obj.count === count.value) // trueSee alsoGuide - Reactivity FundamentalsGuide - Typing reactive() readonly() Takes an object (reactive or plain) or a ref and returns a readonly proxy to the original.Typetsfunction readonlyT extends object( target: T ): DeepReadonlyUnwrapNestedRefsTDetailsA readonly proxy is deep: any nested property accessed will be readonly as well. It also has the same ref-unwrapping behavior as reactive(), except the unwrapped values will also be made readonly.To avoid the deep conversion, use shallowReadonly() instead.Examplejsconst original = reactive({ count: 0 }) const copy = readonly(original) watchEffect(() = { // works for reactivity tracking console.log(copy.count) }) // mutating original will trigger watchers relying on the copy original.count++ // mutating the copy will fail and result in a warning copy.count++ // warning!watchEffect() Runs a function immediately while reactively tracking its dependencies and re-runs it whenever the dependencies are changed.Typetsfunction watchEffect( effect: (onCleanup: OnCleanup) = void, options?: WatchEffectOptions ): WatchHandle type OnCleanup = (cleanupFn: () = void) = void interface WatchEffectOptions { flush?: 'pre'  'post'  'sync' // default: 'pre' onTrack?: (event: DebuggerEvent) = void onTrigger?: (event: DebuggerEvent) = void } interface WatchHandle { (): void // callable, same as stop pause: () = void resume: () = void stop: () = void }DetailsThe first argument is the effect function to be run. The effect function receives a function that can be used to register a cleanup callback. The cleanup callback will be called right before the next time the effect is re-run, and can be used to clean up invalidated side effects, e.g. a pending async request (see example below).The second argument is an optional options object that can be used to adjust the effect's flush timing or to debug the effect's dependencies.By default, watchers will run just prior to component rendering. Setting flush: 'post' will defer the watcher until after component rendering. See Callback Flush Timing for more information. In rare cases, it might be necessary to trigger a watcher immediately when a reactive dependency changes, e.g. to invalidate a cache. This can be achieved using flush: 'sync'. However, this setting should be used with caution, as it can lead to problems with performance and data consistency if multiple properties are being updated at the same time.The return value is a handle function that can be called to stop the effect from running again.Examplejsconst count = ref(0) watchEffect(() = console.log(count.value)) // - logs 0 count.value++ // - logs 1Stopping the watcher:jsconst stop = watchEffect(() = {}) // when the watcher is no longer needed: stop()Pausing / resuming the watcher: jsconst { stop, pause, resume } = watchEffect(() = {}) // temporarily pause the watcher pause() // resume later resume() // stop stop()Side effect cleanup:jswatchEffect(async (onCleanup) = { const { response, cancel } = doAsyncWork(newId) // cancel will be called if id changes, cancelling // the previous request if it hasn't completed yet onCleanup(cancel) data.value = await response })Side effect cleanup in 3.5+:jsimport { onWatcherCleanup } from 'vue' watchEffect(async () = { const { response, cancel } = doAsyncWork(newId) // cancel will be called if id changes, cancelling // the previous request if it hasn't completed yet onWatcherCleanup(cancel) data.value = await response })Options:jswatchEffect(() = {}, { flush: 'post', onTrack(e) { debugger }, onTrigger(e) { debugger } })See alsoGuide - WatchersGuide - Watcher DebuggingwatchPostEffect() Alias of watchEffect() with flush: 'post' option.watchSyncEffect() Alias of watchEffect() with flush: 'sync' option.watch() Watches one or more reactive data sources and invokes a callback function when the sources change.Typets// watching single source function watchT( source: WatchSourceT, callback: WatchCallbackT, options?: WatchOptions ): WatchHandle // watching multiple sources function watchT( sources: WatchSourceT[], callback: WatchCallbackT[], options?: WatchOptions ): WatchHandle type WatchCallbackT = ( value: T, oldValue: T, onCleanup: (cleanupFn: () = void) = void ) = void type WatchSourceT =  RefT // ref  (() = T) // getter  (T extends object ? T : never) // reactive object interface WatchOptions extends WatchEffectOptions { immediate?: boolean // default: false deep?: boolean  number // default: false flush?: 'pre'  'post'  'sync' // default: 'pre' onTrack?: (event: DebuggerEvent) = void onTrigger?: (event: DebuggerEvent) = void once?: boolean // default: false (3.4+) } interface WatchHandle { (): void // callable, same as stop pause: () = void resume: () = void stop: () = void }Types are simplified for readability.Detailswatch() is lazy by default - i.e. the callback is only called when the watched source has changed.The first argument is the watcher's source. The source can be one of the following:A getter function that returns a valueA refA reactive object...or an array of the above.The second argument is the callback that will be called when the source changes. The callback receives three arguments: the new value, the old value, and a function for registering a side effect cleanup callback. The cleanup callback will be called right before the next time the effect is re-run, and can be used to clean up invalidated side effects, e.g. a pending async request.When watching multiple sources, the callback receives two arrays containing new / old values corresponding to the source array.The third optional argument is an options object that supports the following options:immediate: trigger the callback immediately on watcher creation. Old value will be undefined on the first call.deep: force deep traversal of the source if it is an object, so that the callback fires on deep mutations. In 3.5+, this can also be a number indicating the max traversal depth. See Deep Watchers.flush: adjust the callback's flush timing. See Callback Flush Timing and watchEffect().onTrack / onTrigger: debug the watcher's dependencies. See Watcher Debugging.once: (3.4+) run the callback only once. The watcher is automatically stopped after the first callback run.Compared to watchEffect(), watch() allows us to:Perform the side effect lazily;Be more specific about what state should trigger the watcher to re-run;Access both the previous and current value of the watched state.ExampleWatching a getter:jsconst state = reactive({ count: 0 }) watch( () = state.count, (count, prevCount) = { /* ... */ } )Watching a ref:jsconst count = ref(0) watch(count, (count, prevCount) = { /* ... */ })When watching multiple sources, the callback receives arrays containing new / old values corresponding to the source array:jswatch([fooRef, barRef], ([foo, bar], [prevFoo, prevBar]) = { /* ... */ })When using a getter source, the watcher only fires if the getter's return value has changed. If you want the callback to fire even on deep mutations, you need to explicitly force the watcher into deep mode with { deep: true }. Note in deep mode, the new value and the old will be the same object if the callback was triggered by a deep mutation:jsconst state = reactive({ count: 0 }) watch( () = state, (newValue, oldValue) = { // newValue === oldValue }, { deep: true } )When directly watching a reactive object, the watcher is automatically in deep mode:jsconst state = reactive({ count: 0 }) watch(state, () = { /* triggers on deep mutation to state */ })watch() shares the same flush timing and debugging options with watchEffect():jswatch(source, callback, { flush: 'post', onTrack(e) { debugger }, onTrigger(e) { debugger } })Stopping the watcher:jsconst stop = watch(source, callback) // when the watcher is no longer needed: stop()Pausing / resuming the watcher: jsconst { stop, pause, resume } = watch(() = {}) // temporarily pause the watcher pause() // resume later resume() // stop stop()Side effect cleanup:jswatch(id, async (newId, oldId, onCleanup) = { const { response, cancel } = doAsyncWork(newId) // cancel will be called if id changes, cancelling // the previous request if it hasn't completed yet onCleanup(cancel) data.value = await response })Side effect cleanup in 3.5+:jsimport { onWatcherCleanup } from 'vue' watch(id, async (newId) = { const { response, cancel } = doAsyncWork(newId) onWatcherCleanup(cancel) data.value = await response })See alsoGuide - WatchersGuide - Watcher DebuggingonWatcherCleanup() Register a cleanup function to be executed when the current watcher is about to re-run. Can only be called during the synchronous execution of a watchEffect effect function or watch callback function (i.e. it cannot be called after an await statement in an async function.)Typetsfunction onWatcherCleanup( cleanupFn: () = void, failSilently?: boolean ): voidExampletsimport { watch, onWatcherCleanup } from 'vue' watch(id, (newId) = { const { response, cancel } = doAsyncWork(newId) // cancel will be called if id changes, cancelling // the previous request if it hasn't completed yet onWatcherCleanup(cancel) })Edit this page on GitHub",
    "headings": [
      {
        "level": 1,
        "text": "Reactivity API: Core ​",
        "id": "reactivity-api-core"
      },
      {
        "level": 2,
        "text": "ref() ​",
        "id": "ref"
      },
      {
        "level": 2,
        "text": "computed() ​",
        "id": "computed"
      },
      {
        "level": 2,
        "text": "reactive() ​",
        "id": "reactive"
      },
      {
        "level": 2,
        "text": "readonly() ​",
        "id": "readonly"
      },
      {
        "level": 2,
        "text": "watchEffect() ​",
        "id": "watcheffect"
      },
      {
        "level": 2,
        "text": "watchPostEffect() ​",
        "id": "watchposteffect"
      },
      {
        "level": 2,
        "text": "watchSyncEffect() ​",
        "id": "watchsynceffect"
      },
      {
        "level": 2,
        "text": "watch() ​",
        "id": "watch"
      },
      {
        "level": 2,
        "text": "onWatcherCleanup()  ​",
        "id": "onwatchercleanup"
      }
    ],
    "codeBlocks": [
      {
        "language": "text",
        "code": "function ref<T>(value: T): Ref<UnwrapRef<T>>\n\ninterface Ref<T> {\n  value: T\n}"
      },
      {
        "language": "text",
        "code": "function ref<T>(value: T): Ref<UnwrapRef<T>>\n\ninterface Ref<T> {\n  value: T\n}"
      },
      {
        "language": "text",
        "code": "shallowRef()"
      },
      {
        "language": "text",
        "code": "const count = ref(0)\nconsole.log(count.value) // 0\n\ncount.value = 1\nconsole.log(count.value) // 1"
      },
      {
        "language": "text",
        "code": "const count = ref(0)\nconsole.log(count.value) // 0\n\ncount.value = 1\nconsole.log(count.value) // 1"
      },
      {
        "language": "text",
        "code": "// read-only\nfunction computed<T>(\n  getter: (oldValue: T | undefined) => T,\n  // see \"Computed Debugging\" link below\n  debuggerOptions?: DebuggerOptions\n): Readonly<Ref<Readonly<T>>>\n\n// writable\nfunction computed<T>(\n  options: {\n    get: (oldValue: T | undefined) => T\n    set: (value: T) => void\n  },\n  debuggerOptions?: DebuggerOptions\n): Ref<T>"
      },
      {
        "language": "text",
        "code": "// read-only\nfunction computed<T>(\n  getter: (oldValue: T | undefined) => T,\n  // see \"Computed Debugging\" link below\n  debuggerOptions?: DebuggerOptions\n): Readonly<Ref<Readonly<T>>>\n\n// writable\nfunction computed<T>(\n  options: {\n    get: (oldValue: T | undefined) => T\n    set: (value: T) => void\n  },\n  debuggerOptions?: DebuggerOptions\n): Ref<T>"
      },
      {
        "language": "text",
        "code": "const count = ref(1)\nconst plusOne = computed(() => count.value + 1)\n\nconsole.log(plusOne.value) // 2\n\nplusOne.value++ // error"
      },
      {
        "language": "text",
        "code": "const count = ref(1)\nconst plusOne = computed(() => count.value + 1)\n\nconsole.log(plusOne.value) // 2\n\nplusOne.value++ // error"
      },
      {
        "language": "text",
        "code": "const count = ref(1)\nconst plusOne = computed({\n  get: () => count.value + 1,\n  set: (val) => {\n    count.value = val - 1\n  }\n})\n\nplusOne.value = 1\nconsole.log(count.value) // 0"
      },
      {
        "language": "text",
        "code": "const count = ref(1)\nconst plusOne = computed({\n  get: () => count.value + 1,\n  set: (val) => {\n    count.value = val - 1\n  }\n})\n\nplusOne.value = 1\nconsole.log(count.value) // 0"
      },
      {
        "language": "text",
        "code": "const plusOne = computed(() => count.value + 1, {\n  onTrack(e) {\n    debugger\n  },\n  onTrigger(e) {\n    debugger\n  }\n})"
      },
      {
        "language": "text",
        "code": "const plusOne = computed(() => count.value + 1, {\n  onTrack(e) {\n    debugger\n  },\n  onTrigger(e) {\n    debugger\n  }\n})"
      },
      {
        "language": "text",
        "code": "function reactive<T extends object>(target: T): UnwrapNestedRefs<T>"
      },
      {
        "language": "text",
        "code": "function reactive<T extends object>(target: T): UnwrapNestedRefs<T>"
      },
      {
        "language": "text",
        "code": "const obj = reactive({ count: 0 })\nobj.count++"
      },
      {
        "language": "text",
        "code": "const obj = reactive({ count: 0 })\nobj.count++"
      },
      {
        "language": "text",
        "code": "const count = ref(1)\nconst obj = reactive({ count })\n\n// ref will be unwrapped\nconsole.log(obj.count === count.value) // true\n\n// it will update `obj.count`\ncount.value++\nconsole.log(count.value) // 2\nconsole.log(obj.count) // 2\n\n// it will also update `count` ref\nobj.count++\nconsole.log(obj.count) // 3\nconsole.log(count.value) // 3"
      },
      {
        "language": "text",
        "code": "const count = ref(1)\nconst obj = reactive({ count })\n\n// ref will be unwrapped\nconsole.log(obj.count === count.value) // true\n\n// it will update `obj.count`\ncount.value++\nconsole.log(count.value) // 2\nconsole.log(obj.count) // 2\n\n// it will also update `count` ref\nobj.count++\nconsole.log(obj.count) // 3\nconsole.log(count.value) // 3"
      },
      {
        "language": "text",
        "code": "const books = reactive([ref('Vue 3 Guide')])\n// need .value here\nconsole.log(books[0].value)\n\nconst map = reactive(new Map([['count', ref(0)]]))\n// need .value here\nconsole.log(map.get('count').value)"
      },
      {
        "language": "text",
        "code": "const books = reactive([ref('Vue 3 Guide')])\n// need .value here\nconsole.log(books[0].value)\n\nconst map = reactive(new Map([['count', ref(0)]]))\n// need .value here\nconsole.log(map.get('count').value)"
      },
      {
        "language": "text",
        "code": "const count = ref(1)\nconst obj = reactive({})\n\nobj.count = count\n\nconsole.log(obj.count) // 1\nconsole.log(obj.count === count.value) // true"
      },
      {
        "language": "text",
        "code": "const count = ref(1)\nconst obj = reactive({})\n\nobj.count = count\n\nconsole.log(obj.count) // 1\nconsole.log(obj.count === count.value) // true"
      },
      {
        "language": "text",
        "code": "function readonly<T extends object>(\n  target: T\n): DeepReadonly<UnwrapNestedRefs<T>>"
      },
      {
        "language": "text",
        "code": "function readonly<T extends object>(\n  target: T\n): DeepReadonly<UnwrapNestedRefs<T>>"
      },
      {
        "language": "text",
        "code": "const original = reactive({ count: 0 })\n\nconst copy = readonly(original)\n\nwatchEffect(() => {\n  // works for reactivity tracking\n  console.log(copy.count)\n})\n\n// mutating original will trigger watchers relying on the copy\noriginal.count++\n\n// mutating the copy will fail and result in a warning\ncopy.count++ // warning!"
      },
      {
        "language": "text",
        "code": "const original = reactive({ count: 0 })\n\nconst copy = readonly(original)\n\nwatchEffect(() => {\n  // works for reactivity tracking\n  console.log(copy.count)\n})\n\n// mutating original will trigger watchers relying on the copy\noriginal.count++\n\n// mutating the copy will fail and result in a warning\ncopy.count++ // warning!"
      },
      {
        "language": "text",
        "code": "function watchEffect(\n  effect: (onCleanup: OnCleanup) => void,\n  options?: WatchEffectOptions\n): WatchHandle\n\ntype OnCleanup = (cleanupFn: () => void) => void\n\ninterface WatchEffectOptions {\n  flush?: 'pre' | 'post' | 'sync' // default: 'pre'\n  onTrack?: (event: DebuggerEvent) => void\n  onTrigger?: (event: DebuggerEvent) => void\n}\n\ninterface WatchHandle {\n  (): void // callable, same as `stop`\n  pause: () => void\n  resume: () => void\n  stop: () => void\n}"
      },
      {
        "language": "text",
        "code": "function watchEffect(\n  effect: (onCleanup: OnCleanup) => void,\n  options?: WatchEffectOptions\n): WatchHandle\n\ntype OnCleanup = (cleanupFn: () => void) => void\n\ninterface WatchEffectOptions {\n  flush?: 'pre' | 'post' | 'sync' // default: 'pre'\n  onTrack?: (event: DebuggerEvent) => void\n  onTrigger?: (event: DebuggerEvent) => void\n}\n\ninterface WatchHandle {\n  (): void // callable, same as `stop`\n  pause: () => void\n  resume: () => void\n  stop: () => void\n}"
      },
      {
        "language": "text",
        "code": "flush: 'post'"
      },
      {
        "language": "text",
        "code": "flush: 'sync'"
      },
      {
        "language": "text",
        "code": "const count = ref(0)\n\nwatchEffect(() => console.log(count.value))\n// -> logs 0\n\ncount.value++\n// -> logs 1"
      },
      {
        "language": "text",
        "code": "const count = ref(0)\n\nwatchEffect(() => console.log(count.value))\n// -> logs 0\n\ncount.value++\n// -> logs 1"
      },
      {
        "language": "text",
        "code": "const stop = watchEffect(() => {})\n\n// when the watcher is no longer needed:\nstop()"
      },
      {
        "language": "text",
        "code": "const stop = watchEffect(() => {})\n\n// when the watcher is no longer needed:\nstop()"
      },
      {
        "language": "text",
        "code": "const { stop, pause, resume } = watchEffect(() => {})\n\n// temporarily pause the watcher\npause()\n\n// resume later\nresume()\n\n// stop\nstop()"
      },
      {
        "language": "text",
        "code": "const { stop, pause, resume } = watchEffect(() => {})\n\n// temporarily pause the watcher\npause()\n\n// resume later\nresume()\n\n// stop\nstop()"
      },
      {
        "language": "text",
        "code": "watchEffect(async (onCleanup) => {\n  const { response, cancel } = doAsyncWork(newId)\n  // `cancel` will be called if `id` changes, cancelling\n  // the previous request if it hasn't completed yet\n  onCleanup(cancel)\n  data.value = await response\n})"
      },
      {
        "language": "text",
        "code": "watchEffect(async (onCleanup) => {\n  const { response, cancel } = doAsyncWork(newId)\n  // `cancel` will be called if `id` changes, cancelling\n  // the previous request if it hasn't completed yet\n  onCleanup(cancel)\n  data.value = await response\n})"
      },
      {
        "language": "text",
        "code": "import { onWatcherCleanup } from 'vue'\n\nwatchEffect(async () => {\n  const { response, cancel } = doAsyncWork(newId)\n  // `cancel` will be called if `id` changes, cancelling\n  // the previous request if it hasn't completed yet\n  onWatcherCleanup(cancel)\n  data.value = await response\n})"
      },
      {
        "language": "text",
        "code": "import { onWatcherCleanup } from 'vue'\n\nwatchEffect(async () => {\n  const { response, cancel } = doAsyncWork(newId)\n  // `cancel` will be called if `id` changes, cancelling\n  // the previous request if it hasn't completed yet\n  onWatcherCleanup(cancel)\n  data.value = await response\n})"
      },
      {
        "language": "text",
        "code": "watchEffect(() => {}, {\n  flush: 'post',\n  onTrack(e) {\n    debugger\n  },\n  onTrigger(e) {\n    debugger\n  }\n})"
      },
      {
        "language": "text",
        "code": "watchEffect(() => {}, {\n  flush: 'post',\n  onTrack(e) {\n    debugger\n  },\n  onTrigger(e) {\n    debugger\n  }\n})"
      },
      {
        "language": "text",
        "code": "watchEffect()"
      },
      {
        "language": "text",
        "code": "flush: 'post'"
      },
      {
        "language": "text",
        "code": "watchEffect()"
      },
      {
        "language": "text",
        "code": "flush: 'sync'"
      },
      {
        "language": "text",
        "code": "// watching single source\nfunction watch<T>(\n  source: WatchSource<T>,\n  callback: WatchCallback<T>,\n  options?: WatchOptions\n): WatchHandle\n\n// watching multiple sources\nfunction watch<T>(\n  sources: WatchSource<T>[],\n  callback: WatchCallback<T[]>,\n  options?: WatchOptions\n): WatchHandle\n\ntype WatchCallback<T> = (\n  value: T,\n  oldValue: T,\n  onCleanup: (cleanupFn: () => void) => void\n) => void\n\ntype WatchSource<T> =\n  | Ref<T> // ref\n  | (() => T) // getter\n  | (T extends object ? T : never) // reactive object\n\ninterface WatchOptions extends WatchEffectOptions {\n  immediate?: boolean // default: false\n  deep?: boolean | number // default: false\n  flush?: 'pre' | 'post' | 'sync' // default: 'pre'\n  onTrack?: (event: DebuggerEvent) => void\n  onTrigger?: (event: DebuggerEvent) => void\n  once?: boolean // default: false (3.4+)\n}\n\ninterface WatchHandle {\n  (): void // callable, same as `stop`\n  pause: () => void\n  resume: () => void\n  stop: () => void\n}"
      },
      {
        "language": "text",
        "code": "// watching single source\nfunction watch<T>(\n  source: WatchSource<T>,\n  callback: WatchCallback<T>,\n  options?: WatchOptions\n): WatchHandle\n\n// watching multiple sources\nfunction watch<T>(\n  sources: WatchSource<T>[],\n  callback: WatchCallback<T[]>,\n  options?: WatchOptions\n): WatchHandle\n\ntype WatchCallback<T> = (\n  value: T,\n  oldValue: T,\n  onCleanup: (cleanupFn: () => void) => void\n) => void\n\ntype WatchSource<T> =\n  | Ref<T> // ref\n  | (() => T) // getter\n  | (T extends object ? T : never) // reactive object\n\ninterface WatchOptions extends WatchEffectOptions {\n  immediate?: boolean // default: false\n  deep?: boolean | number // default: false\n  flush?: 'pre' | 'post' | 'sync' // default: 'pre'\n  onTrack?: (event: DebuggerEvent) => void\n  onTrigger?: (event: DebuggerEvent) => void\n  once?: boolean // default: false (3.4+)\n}\n\ninterface WatchHandle {\n  (): void // callable, same as `stop`\n  pause: () => void\n  resume: () => void\n  stop: () => void\n}"
      },
      {
        "language": "text",
        "code": "watchEffect()"
      },
      {
        "language": "text",
        "code": "onTrack / onTrigger"
      },
      {
        "language": "text",
        "code": "watchEffect()"
      },
      {
        "language": "text",
        "code": "const state = reactive({ count: 0 })\nwatch(\n  () => state.count,\n  (count, prevCount) => {\n    /* ... */\n  }\n)"
      },
      {
        "language": "text",
        "code": "const state = reactive({ count: 0 })\nwatch(\n  () => state.count,\n  (count, prevCount) => {\n    /* ... */\n  }\n)"
      },
      {
        "language": "text",
        "code": "const count = ref(0)\nwatch(count, (count, prevCount) => {\n  /* ... */\n})"
      },
      {
        "language": "text",
        "code": "const count = ref(0)\nwatch(count, (count, prevCount) => {\n  /* ... */\n})"
      },
      {
        "language": "text",
        "code": "watch([fooRef, barRef], ([foo, bar], [prevFoo, prevBar]) => {\n  /* ... */\n})"
      },
      {
        "language": "text",
        "code": "watch([fooRef, barRef], ([foo, bar], [prevFoo, prevBar]) => {\n  /* ... */\n})"
      },
      {
        "language": "text",
        "code": "{ deep: true }"
      },
      {
        "language": "text",
        "code": "const state = reactive({ count: 0 })\nwatch(\n  () => state,\n  (newValue, oldValue) => {\n    // newValue === oldValue\n  },\n  { deep: true }\n)"
      },
      {
        "language": "text",
        "code": "const state = reactive({ count: 0 })\nwatch(\n  () => state,\n  (newValue, oldValue) => {\n    // newValue === oldValue\n  },\n  { deep: true }\n)"
      },
      {
        "language": "text",
        "code": "const state = reactive({ count: 0 })\nwatch(state, () => {\n  /* triggers on deep mutation to state */\n})"
      },
      {
        "language": "text",
        "code": "const state = reactive({ count: 0 })\nwatch(state, () => {\n  /* triggers on deep mutation to state */\n})"
      },
      {
        "language": "text",
        "code": "watchEffect()"
      },
      {
        "language": "text",
        "code": "watch(source, callback, {\n  flush: 'post',\n  onTrack(e) {\n    debugger\n  },\n  onTrigger(e) {\n    debugger\n  }\n})"
      },
      {
        "language": "text",
        "code": "watch(source, callback, {\n  flush: 'post',\n  onTrack(e) {\n    debugger\n  },\n  onTrigger(e) {\n    debugger\n  }\n})"
      },
      {
        "language": "text",
        "code": "const stop = watch(source, callback)\n\n// when the watcher is no longer needed:\nstop()"
      },
      {
        "language": "text",
        "code": "const stop = watch(source, callback)\n\n// when the watcher is no longer needed:\nstop()"
      },
      {
        "language": "text",
        "code": "const { stop, pause, resume } = watch(() => {})\n\n// temporarily pause the watcher\npause()\n\n// resume later\nresume()\n\n// stop\nstop()"
      },
      {
        "language": "text",
        "code": "const { stop, pause, resume } = watch(() => {})\n\n// temporarily pause the watcher\npause()\n\n// resume later\nresume()\n\n// stop\nstop()"
      },
      {
        "language": "text",
        "code": "watch(id, async (newId, oldId, onCleanup) => {\n  const { response, cancel } = doAsyncWork(newId)\n  // `cancel` will be called if `id` changes, cancelling\n  // the previous request if it hasn't completed yet\n  onCleanup(cancel)\n  data.value = await response\n})"
      },
      {
        "language": "text",
        "code": "watch(id, async (newId, oldId, onCleanup) => {\n  const { response, cancel } = doAsyncWork(newId)\n  // `cancel` will be called if `id` changes, cancelling\n  // the previous request if it hasn't completed yet\n  onCleanup(cancel)\n  data.value = await response\n})"
      },
      {
        "language": "text",
        "code": "import { onWatcherCleanup } from 'vue'\n\nwatch(id, async (newId) => {\n  const { response, cancel } = doAsyncWork(newId)\n  onWatcherCleanup(cancel)\n  data.value = await response\n})"
      },
      {
        "language": "text",
        "code": "import { onWatcherCleanup } from 'vue'\n\nwatch(id, async (newId) => {\n  const { response, cancel } = doAsyncWork(newId)\n  onWatcherCleanup(cancel)\n  data.value = await response\n})"
      },
      {
        "language": "text",
        "code": "watchEffect"
      },
      {
        "language": "text",
        "code": "function onWatcherCleanup(\n  cleanupFn: () => void,\n  failSilently?: boolean\n): void"
      },
      {
        "language": "text",
        "code": "function onWatcherCleanup(\n  cleanupFn: () => void,\n  failSilently?: boolean\n): void"
      },
      {
        "language": "text",
        "code": "import { watch, onWatcherCleanup } from 'vue'\n\nwatch(id, (newId) => {\n  const { response, cancel } = doAsyncWork(newId)\n  // `cancel` will be called if `id` changes, cancelling\n  // the previous request if it hasn't completed yet\n  onWatcherCleanup(cancel)\n})"
      },
      {
        "language": "text",
        "code": "import { watch, onWatcherCleanup } from 'vue'\n\nwatch(id, (newId) => {\n  const { response, cancel } = doAsyncWork(newId)\n  // `cancel` will be called if `id` changes, cancelling\n  // the previous request if it hasn't completed yet\n  onWatcherCleanup(cancel)\n})"
      }
    ],
    "links": [
      {
        "text": "Reactivity Fundamentals",
        "href": "/guide/essentials/reactivity-fundamentals"
      },
      {
        "text": "Reactivity in Depth",
        "href": "/guide/extras/reactivity-in-depth"
      },
      {
        "text": "shallowRef()",
        "href": "/api/reactivity-advanced#shallowref"
      },
      {
        "text": "Guide - Reactivity Fundamentals with ref()",
        "href": "/guide/essentials/reactivity-fundamentals#ref"
      },
      {
        "text": "Guide - Typing ref()",
        "href": "/guide/typescript/composition-api#typing-ref"
      },
      {
        "text": "getter function",
        "href": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Functions/get#description"
      },
      {
        "text": "Guide - Computed Properties",
        "href": "/guide/essentials/computed"
      },
      {
        "text": "Guide - Computed Debugging",
        "href": "/guide/extras/reactivity-in-depth#computed-debugging"
      },
      {
        "text": "Guide - Typing computed()",
        "href": "/guide/typescript/composition-api#typing-computed"
      },
      {
        "text": "Guide - Performance - Computed Stability",
        "href": "/guide/best-practices/performance#computed-stability"
      },
      {
        "text": "shallowReactive()",
        "href": "/api/reactivity-advanced#shallowreactive"
      },
      {
        "text": "ES Proxy",
        "href": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Proxy"
      },
      {
        "text": "Guide - Reactivity Fundamentals",
        "href": "/guide/essentials/reactivity-fundamentals"
      },
      {
        "text": "Guide - Typing reactive()",
        "href": "/guide/typescript/composition-api#typing-reactive"
      },
      {
        "text": "shallowReadonly()",
        "href": "/api/reactivity-advanced#shallowreadonly"
      },
      {
        "text": "Callback Flush Timing",
        "href": "/guide/essentials/watchers#callback-flush-timing"
      },
      {
        "text": "Guide - Watchers",
        "href": "/guide/essentials/watchers#watcheffect"
      },
      {
        "text": "Guide - Watcher Debugging",
        "href": "/guide/extras/reactivity-in-depth#watcher-debugging"
      },
      {
        "text": "Deep Watchers",
        "href": "/guide/essentials/watchers#deep-watchers"
      },
      {
        "text": "Callback Flush Timing",
        "href": "/guide/essentials/watchers#callback-flush-timing"
      },
      {
        "text": "watchEffect()",
        "href": "/api/reactivity-core#watcheffect"
      },
      {
        "text": "Watcher Debugging",
        "href": "/guide/extras/reactivity-in-depth#watcher-debugging"
      },
      {
        "text": "Guide - Watchers",
        "href": "/guide/essentials/watchers"
      },
      {
        "text": "Guide - Watcher Debugging",
        "href": "/guide/extras/reactivity-in-depth#watcher-debugging"
      },
      {
        "text": "Edit this page on GitHub",
        "href": "https://github.com/vuejs/docs/edit/main/src/api/reactivity-core.md"
      }
    ],
    "meta": {
      "description": "Vue.js - The Progressive JavaScript Framework",
      "keywords": ""
    },
    "summary": "Reactivity API: Core See alsoTo better understand the Reactivity APIs, it is recommended to read the following chapters in the guide:Reactivity Fundamentals (with the API preference set to Composition...",
    "tags": [
      "react",
      "vue",
      "angular",
      "javascript",
      "typescript",
      "html",
      "reactivity",
      "api",
      "core",
      "ref"
    ],
    "id": "reactivity-api-core-reactivitycorehtml-part-1",
    "quality": 100
  },
  {
    "title": "Components Basics",
    "url": "https://vuejs.org/guide/essentials/component-basics.html",
    "category": "vue",
    "content": "Components Basics  Watch an interactive video lesson on Scrimba Components allow us to split the UI into independent and reusable pieces, and think about each piece in isolation. It's common for an app to be organized into a tree of nested components:This is very similar to how we nest native HTML elements, but Vue implements its own component model that allows us to encapsulate custom content and logic in each component. Vue also plays nicely with native Web Components. If you are curious about the relationship between Vue Components and native Web Components, read more here.Defining a Component When using a build step, we typically define each Vue component in a dedicated file using the .vue extension - known as a Single-File Component (SFC for short):vuescript export default { data() { return { count: 0 } } } /script template button @click=\"count++\"You clicked me {{ count }} times./button /templatevuescript setup import { ref } from 'vue' const count = ref(0) /script template button @click=\"count++\"You clicked me {{ count }} times./button /templateWhen not using a build step, a Vue component can be defined as a plain JavaScript object containing Vue-specific options:jsexport default { data() { return { count: 0 } }, template:  button @click=\"count++\" You clicked me {{ count }} times. /button }jsimport { ref } from 'vue' export default { setup() { const count = ref(0) return { count } }, template:  button @click=\"count++\" You clicked me {{ count }} times. /button // Can also target an in-DOM template: // template: '#my-template-element' }The template is inlined as a JavaScript string here, which Vue will compile on the fly. You can also use an ID selector pointing to an element (usually native template elements) - Vue will use its content as the template source.The example above defines a single component and exports it as the default export of a .js file, but you can use named exports to export multiple components from the same file.Using a Component TIPWe will be using SFC syntax for the rest of this guide - the concepts around components are the same regardless of whether you are using a build step or not. The Examples section shows component usage in both scenarios.To use a child component, we need to import it in the parent component. Assuming we placed our counter component inside a file called ButtonCounter.vue, the component will be exposed as the file's default export:vuescript import ButtonCounter from './ButtonCounter.vue' export default { components: { ButtonCounter } } /script template h1Here is a child component!/h1 ButtonCounter / /templateTo expose the imported component to our template, we need to register it with the components option. The component will then be available as a tag using the key it is registered under.vuescript setup import ButtonCounter from './ButtonCounter.vue' /script template h1Here is a child component!/h1 ButtonCounter / /templateWith script setup, imported components are automatically made available to the template.It's also possible to globally register a component, making it available to all components in a given app without having to import it. The pros and cons of global vs. local registration is discussed in the dedicated Component Registration section.Components can be reused as many times as you want:templateh1Here are many child components!/h1 ButtonCounter / ButtonCounter / ButtonCounter /Try it in the PlaygroundTry it in the PlaygroundNotice that when clicking on the buttons, each one maintains its own, separate count. That's because each time you use a component, a new instance of it is created.In SFCs, it's recommended to use PascalCase tag names for child components to differentiate from native HTML elements. Although native HTML tag names are case-insensitive, Vue SFC is a compiled format so we are able to use case-sensitive tag names in it. We are also able to use / to close a tag.If you are authoring your templates directly in a DOM (e.g. as the content of a native template element), the template will be subject to the browser's native HTML parsing behavior. In such cases, you will need to use kebab-case and explicit closing tags for components:template!-- if this template is written in the DOM -- button-counter/button-counter button-counter/button-counter button-counter/button-counterSee in-DOM template parsing caveats for more details.Passing Props If we are building a blog, we will likely need a component representing a blog post. We want all the blog posts to share the same visual layout, but with different content. Such a component won't be useful unless you can pass data to it, such as the title and content of the specific post we want to display. That's where props come in.Props are custom attributes you can register on a component. To pass a title to our blog post component, we must declare it in the list of props this component accepts, using the props optiondefineProps macro:BlogPost.vuevuescript export default { props: ['title'] } /script template h4{{ title }}/h4 /templateWhen a value is passed to a prop attribute, it becomes a property on that component instance. The value of that property is accessible within the template and on the component's this context, just like any other component property.BlogPost.vuevuescript setup defineProps(['title']) /script template h4{{ title }}/h4 /templatedefineProps is a compile-time macro that is only available inside script setup and does not need to be explicitly imported. Declared props are automatically exposed to the template. defineProps also returns an object that contains all the props passed to the component, so that we can access them in JavaScript if needed:jsconst props = defineProps(['title']) console.log(props.title)See also: Typing Component Props If you are not using script setup, props should be declared using the props option, and the props object will be passed to setup() as the first argument:jsexport default { props: ['title'], setup(props) { console.log(props.title) } }A component can have as many props as you like and, by default, any value can be passed to any prop.Once a prop is registered, you can pass data to it as a custom attribute, like this:templateBlogPost title=\"My journey with Vue\" / BlogPost title=\"Blogging with Vue\" / BlogPost title=\"Why Vue is so fun\" /In a typical app, however, you'll likely have an array of posts in your parent component:jsexport default { // ... data() { return { posts: [ { id: 1, title: 'My journey with Vue' }, { id: 2, title: 'Blogging with Vue' }, { id: 3, title: 'Why Vue is so fun' } ] } } }jsconst posts = ref([ { id: 1, title: 'My journey with Vue' }, { id: 2, title: 'Blogging with Vue' }, { id: 3, title: 'Why Vue is so fun' } ])Then want to render a component for each one, using v-for:templateBlogPost v-for=\"post in posts\" :key=\"post.id\" :title=\"post.title\" /Try it in the PlaygroundTry it in the PlaygroundNotice how v-bind syntax (:title=\"post.title\") is used to pass dynamic prop values. This is especially useful when you don't know the exact content you're going to render ahead of time.That's all you need to know about props for now, but once you've finished reading this page and feel comfortable with its content, we recommend coming back later to read the full guide on Props.Listening to Events As we develop our BlogPost component, some features may require communicating back up to the parent. For example, we may decide to include an accessibility feature to enlarge the text of blog posts, while leaving the rest of the page at its default size.In the parent, we can support this feature by adding a postFontSize data propertyref:jsdata() { return { posts: [ /* ... */ ], postFontSize: 1 } }jsconst posts = ref([ /* ... */ ]) const postFontSize = ref(1)Which can be used in the template to control the font size of all blog posts:templatediv :style=\"{ fontSize: postFontSize + 'em' }\" BlogPost v-for=\"post in posts\" :key=\"post.id\" :title=\"post.title\" / /divNow let's add a button to the BlogPost component's template:BlogPost.vuevue!-- omitting script -- template div class=\"blog-post\" h4{{ title }}/h4 buttonEnlarge text/button /div /templateThe button doesn't do anything yet - we want clicking the button to communicate to the parent that it should enlarge the text of all posts. To solve this problem, components provide a custom events system. The parent can choose to listen to any event on the child component instance with v-on or @, just as we would with a native DOM event:templateBlogPost ... @enlarge-text=\"postFontSize += 0.1\" /Then the child component can emit an event on itself by calling the built-in $emit method, passing the name of the event:BlogPost.vuevue!-- omitting script -- template div class=\"blog-post\" h4{{ title }}/h4 button @click=\"$emit('enlarge-text')\"Enlarge text/button /div /templateThanks to the @enlarge-text=\"postFontSize += 0.1\" listener, the parent will receive the event and update the value of postFontSize.Try it in the PlaygroundTry it in the PlaygroundWe can optionally declare emitted events using the emits optiondefineEmits macro:BlogPost.vuevuescript export default { props: ['title'], emits: ['enlarge-text'] } /scriptBlogPost.vuevuescript setup defineProps(['title']) defineEmits(['enlarge-text']) /scriptThis documents all the events that a component emits and optionally validates them. It also allows Vue to avoid implicitly applying them as native listeners to the child component's root element.Similar to defineProps, defineEmits is only usable in script setup and doesn't need to be imported. It returns an emit function that is equivalent to the $emit method. It can be used to emit events in the script setup section of a component, where $emit isn't directly accessible:vuescript setup const emit = defineEmits(['enlarge-text']) emit('enlarge-text') /scriptSee also: Typing Component Emits If you are not using script setup, you can declare emitted events using the emits option. You can access the emit function as a property of the setup context (passed to setup() as the second argument):jsexport default { emits: ['enlarge-text'], setup(props, ctx) { ctx.emit('enlarge-text') } }That's all you need to know about custom component events for now, but once you've finished reading this page and feel comfortable with its content, we recommend coming back later to read the full guide on Custom Events.Content Distribution with Slots Just like with HTML elements, it's often useful to be able to pass content to a component, like this:templateAlertBox Something bad happened. /AlertBoxWhich might render something like:This is an Error for Demo PurposesSomething bad happened.This can be achieved using Vue's custom slot element:AlertBox.vuevuetemplate div class=\"alert-box\" strongThis is an Error for Demo Purposes/strong slot / /div /template style scoped .alert-box { /* ... */ } /styleAs you'll see above, we use the slot as a placeholder where we want the content to go  and that's it. We're done!Try it in the PlaygroundTry it in the PlaygroundThat's all you need to know about slots for now, but once you've finished reading this page and feel comfortable with its content, we recommend coming back later to read the full guide on Slots.Dynamic Components Sometimes, it's useful to dynamically switch between components, like in a tabbed interface:Open example in the PlaygroundOpen example in the PlaygroundThe above is made possible by Vue's component element with the special is attribute:template!-- Component changes when currentTab changes -- component :is=\"currentTab\"/componenttemplate!-- Component changes when currentTab changes -- component :is=\"tabs[currentTab]\"/componentIn the example above, the value passed to :is can contain either:the name string of a registered component, ORthe actual imported component objectYou can also use the is attribute to create regular HTML elements.When switching between multiple components with component :is=\"...\", a component will be unmounted when it is switched away from. We can force the inactive components to stay \"alive\" with the built-in KeepAlive component.in-DOM Template Parsing Caveats If you are writing your Vue templates directly in the DOM, Vue will have to retrieve the template string from the DOM. This leads to some caveats due to browsers' native HTML parsing behavior.TIPIt should be noted that the limitations discussed below only apply if you are writing your templates directly in the DOM. They do NOT apply if you are using string templates from the following sources:Single-File ComponentsInlined template strings (e.g. template: '...')script type=\"text/x-template\"Case Insensitivity HTML tags and attribute names are case-insensitive, so browsers will interpret any uppercase characters as lowercase. That means when youre using in-DOM templates, PascalCase component names and camelCased prop names or v-on event names all need to use their kebab-cased (hyphen-delimited) equivalents:js// camelCase in JavaScript const BlogPost = { props: ['postTitle'], emits: ['updatePost'], template:  h3{{ postTitle }}/h3  }template!-- kebab-case in HTML -- blog-post post-title=\"hello!\" @update-post=\"onUpdatePost\"/blog-postSelf Closing Tags We have been using self-closing tags for components in previous code samples:templateMyComponent /This is because Vue's template parser respects / as an indication to end any tag, regardless of its type.In in-DOM templates, however, we must always include explicit closing tags:templatemy-component/my-componentThis is because the HTML spec only allows a few specific elements to omit closing tags, the most common being input and img. For all other elements, if you omit the closing tag, the native HTML parser will think you never terminated the opening tag. For example, the following snippet:templatemy-component / !-- we intend to close the tag here... -- spanhello/spanwill be parsed as:templatemy-component spanhello/span /my-component !-- but the browser will close it here. --Element Placement Restrictions Some HTML elements, such as ul, ol, table and select have restrictions on what elements can appear inside them, and some elements such as li, tr, and option can only appear inside certain other elements.This will lead to issues when using components with elements that have such restrictions. For example:templatetable blog-post-row/blog-post-row /tableThe custom component blog-post-row will be hoisted out as invalid content, causing errors in the eventual rendered output. We can use the special is attribute as a workaround:templatetable tr is=\"vue:blog-post-row\"/tr /tableTIPWhen used on native HTML elements, the value of is must be prefixed with vue: in order to be interpreted as a Vue component. This is required to avoid confusion with native customized built-in elements.That's all you need to know about in-DOM template parsing caveats for now - and actually, the end of Vue's Essentials. Congratulations! There's still more to learn, but first, we recommend taking a break to play with Vue yourself - build something fun, or check out some of the Examples if you haven't already.Once you feel comfortable with the knowledge you've just digested, move on with the guide to learn more about components in depth.Edit this page on GitHub",
    "headings": [
      {
        "level": 1,
        "text": "Components Basics ​",
        "id": "components-basics"
      },
      {
        "level": 2,
        "text": "Defining a Component ​",
        "id": "defining-a-component"
      },
      {
        "level": 2,
        "text": "Using a Component ​",
        "id": "using-a-component"
      },
      {
        "level": 2,
        "text": "Passing Props ​",
        "id": "passing-props"
      },
      {
        "level": 2,
        "text": "Listening to Events ​",
        "id": "listening-to-events"
      },
      {
        "level": 2,
        "text": "Content Distribution with Slots ​",
        "id": "content-distribution-with-slots"
      },
      {
        "level": 2,
        "text": "Dynamic Components ​",
        "id": "dynamic-components"
      },
      {
        "level": 2,
        "text": "in-DOM Template Parsing Caveats ​",
        "id": "in-dom-template-parsing-caveats"
      },
      {
        "level": 3,
        "text": "Case Insensitivity ​",
        "id": "case-insensitivity"
      },
      {
        "level": 3,
        "text": "Self Closing Tags ​",
        "id": "self-closing-tags"
      },
      {
        "level": 3,
        "text": "Element Placement Restrictions ​",
        "id": "element-placement-restrictions"
      }
    ],
    "codeBlocks": [
      {
        "language": "text",
        "code": "<script>\nexport default {\n  data() {\n    return {\n      count: 0\n    }\n  }\n}\n</script>\n\n<template>\n  <button @click=\"count++\">You clicked me {{ count }} times.</button>\n</template>"
      },
      {
        "language": "text",
        "code": "<script>\nexport default {\n  data() {\n    return {\n      count: 0\n    }\n  }\n}\n</script>\n\n<template>\n  <button @click=\"count++\">You clicked me {{ count }} times.</button>\n</template>"
      },
      {
        "language": "text",
        "code": "<script setup>\nimport { ref } from 'vue'\n\nconst count = ref(0)\n</script>\n\n<template>\n  <button @click=\"count++\">You clicked me {{ count }} times.</button>\n</template>"
      },
      {
        "language": "text",
        "code": "<script setup>\nimport { ref } from 'vue'\n\nconst count = ref(0)\n</script>\n\n<template>\n  <button @click=\"count++\">You clicked me {{ count }} times.</button>\n</template>"
      },
      {
        "language": "text",
        "code": "export default {\n  data() {\n    return {\n      count: 0\n    }\n  },\n  template: `\n    <button @click=\"count++\">\n      You clicked me {{ count }} times.\n    </button>`\n}"
      },
      {
        "language": "text",
        "code": "export default {\n  data() {\n    return {\n      count: 0\n    }\n  },\n  template: `\n    <button @click=\"count++\">\n      You clicked me {{ count }} times.\n    </button>`\n}"
      },
      {
        "language": "text",
        "code": "import { ref } from 'vue'\n\nexport default {\n  setup() {\n    const count = ref(0)\n    return { count }\n  },\n  template: `\n    <button @click=\"count++\">\n      You clicked me {{ count }} times.\n    </button>`\n  // Can also target an in-DOM template:\n  // template: '#my-template-element'\n}"
      },
      {
        "language": "text",
        "code": "import { ref } from 'vue'\n\nexport default {\n  setup() {\n    const count = ref(0)\n    return { count }\n  },\n  template: `\n    <button @click=\"count++\">\n      You clicked me {{ count }} times.\n    </button>`\n  // Can also target an in-DOM template:\n  // template: '#my-template-element'\n}"
      },
      {
        "language": "text",
        "code": "ButtonCounter.vue"
      },
      {
        "language": "text",
        "code": "<script>\nimport ButtonCounter from './ButtonCounter.vue'\n\nexport default {\n  components: {\n    ButtonCounter\n  }\n}\n</script>\n\n<template>\n  <h1>Here is a child component!</h1>\n  <ButtonCounter />\n</template>"
      },
      {
        "language": "text",
        "code": "<script>\nimport ButtonCounter from './ButtonCounter.vue'\n\nexport default {\n  components: {\n    ButtonCounter\n  }\n}\n</script>\n\n<template>\n  <h1>Here is a child component!</h1>\n  <ButtonCounter />\n</template>"
      },
      {
        "language": "text",
        "code": "<script setup>\nimport ButtonCounter from './ButtonCounter.vue'\n</script>\n\n<template>\n  <h1>Here is a child component!</h1>\n  <ButtonCounter />\n</template>"
      },
      {
        "language": "text",
        "code": "<script setup>\nimport ButtonCounter from './ButtonCounter.vue'\n</script>\n\n<template>\n  <h1>Here is a child component!</h1>\n  <ButtonCounter />\n</template>"
      },
      {
        "language": "text",
        "code": "<script setup>"
      },
      {
        "language": "text",
        "code": "<h1>Here are many child components!</h1>\n<ButtonCounter />\n<ButtonCounter />\n<ButtonCounter />"
      },
      {
        "language": "text",
        "code": "<h1>Here are many child components!</h1>\n<ButtonCounter />\n<ButtonCounter />\n<ButtonCounter />"
      },
      {
        "language": "text",
        "code": "<!-- if this template is written in the DOM -->\n<button-counter></button-counter>\n<button-counter></button-counter>\n<button-counter></button-counter>"
      },
      {
        "language": "text",
        "code": "<!-- if this template is written in the DOM -->\n<button-counter></button-counter>\n<button-counter></button-counter>\n<button-counter></button-counter>"
      },
      {
        "language": "text",
        "code": "defineProps"
      },
      {
        "language": "text",
        "code": "<script>\nexport default {\n  props: ['title']\n}\n</script>\n\n<template>\n  <h4>{{ title }}</h4>\n</template>"
      },
      {
        "language": "text",
        "code": "<script>\nexport default {\n  props: ['title']\n}\n</script>\n\n<template>\n  <h4>{{ title }}</h4>\n</template>"
      },
      {
        "language": "text",
        "code": "<script setup>\ndefineProps(['title'])\n</script>\n\n<template>\n  <h4>{{ title }}</h4>\n</template>"
      },
      {
        "language": "text",
        "code": "<script setup>\ndefineProps(['title'])\n</script>\n\n<template>\n  <h4>{{ title }}</h4>\n</template>"
      },
      {
        "language": "text",
        "code": "defineProps"
      },
      {
        "language": "text",
        "code": "<script setup>"
      },
      {
        "language": "text",
        "code": "defineProps"
      },
      {
        "language": "text",
        "code": "const props = defineProps(['title'])\nconsole.log(props.title)"
      },
      {
        "language": "text",
        "code": "const props = defineProps(['title'])\nconsole.log(props.title)"
      },
      {
        "language": "text",
        "code": "<script setup>"
      },
      {
        "language": "text",
        "code": "export default {\n  props: ['title'],\n  setup(props) {\n    console.log(props.title)\n  }\n}"
      },
      {
        "language": "text",
        "code": "export default {\n  props: ['title'],\n  setup(props) {\n    console.log(props.title)\n  }\n}"
      },
      {
        "language": "text",
        "code": "<BlogPost title=\"My journey with Vue\" />\n<BlogPost title=\"Blogging with Vue\" />\n<BlogPost title=\"Why Vue is so fun\" />"
      },
      {
        "language": "text",
        "code": "<BlogPost title=\"My journey with Vue\" />\n<BlogPost title=\"Blogging with Vue\" />\n<BlogPost title=\"Why Vue is so fun\" />"
      },
      {
        "language": "text",
        "code": "export default {\n  // ...\n  data() {\n    return {\n      posts: [\n        { id: 1, title: 'My journey with Vue' },\n        { id: 2, title: 'Blogging with Vue' },\n        { id: 3, title: 'Why Vue is so fun' }\n      ]\n    }\n  }\n}"
      },
      {
        "language": "text",
        "code": "export default {\n  // ...\n  data() {\n    return {\n      posts: [\n        { id: 1, title: 'My journey with Vue' },\n        { id: 2, title: 'Blogging with Vue' },\n        { id: 3, title: 'Why Vue is so fun' }\n      ]\n    }\n  }\n}"
      },
      {
        "language": "text",
        "code": "const posts = ref([\n  { id: 1, title: 'My journey with Vue' },\n  { id: 2, title: 'Blogging with Vue' },\n  { id: 3, title: 'Why Vue is so fun' }\n])"
      },
      {
        "language": "text",
        "code": "const posts = ref([\n  { id: 1, title: 'My journey with Vue' },\n  { id: 2, title: 'Blogging with Vue' },\n  { id: 3, title: 'Why Vue is so fun' }\n])"
      },
      {
        "language": "text",
        "code": "<BlogPost\n  v-for=\"post in posts\"\n  :key=\"post.id\"\n  :title=\"post.title\"\n />"
      },
      {
        "language": "text",
        "code": "<BlogPost\n  v-for=\"post in posts\"\n  :key=\"post.id\"\n  :title=\"post.title\"\n />"
      },
      {
        "language": "text",
        "code": ":title=\"post.title\""
      },
      {
        "language": "text",
        "code": "postFontSize"
      },
      {
        "language": "text",
        "code": "data() {\n  return {\n    posts: [\n      /* ... */\n    ],\n    postFontSize: 1\n  }\n}"
      },
      {
        "language": "text",
        "code": "data() {\n  return {\n    posts: [\n      /* ... */\n    ],\n    postFontSize: 1\n  }\n}"
      },
      {
        "language": "text",
        "code": "const posts = ref([\n  /* ... */\n])\n\nconst postFontSize = ref(1)"
      },
      {
        "language": "text",
        "code": "const posts = ref([\n  /* ... */\n])\n\nconst postFontSize = ref(1)"
      },
      {
        "language": "text",
        "code": "<div :style=\"{ fontSize: postFontSize + 'em' }\">\n  <BlogPost\n    v-for=\"post in posts\"\n    :key=\"post.id\"\n    :title=\"post.title\"\n   />\n</div>"
      },
      {
        "language": "text",
        "code": "<div :style=\"{ fontSize: postFontSize + 'em' }\">\n  <BlogPost\n    v-for=\"post in posts\"\n    :key=\"post.id\"\n    :title=\"post.title\"\n   />\n</div>"
      },
      {
        "language": "text",
        "code": "<!-- omitting <script> -->\n<template>\n  <div class=\"blog-post\">\n    <h4>{{ title }}</h4>\n    <button>Enlarge text</button>\n  </div>\n</template>"
      },
      {
        "language": "text",
        "code": "<!-- omitting <script> -->\n<template>\n  <div class=\"blog-post\">\n    <h4>{{ title }}</h4>\n    <button>Enlarge text</button>\n  </div>\n</template>"
      },
      {
        "language": "text",
        "code": "<BlogPost\n  ...\n  @enlarge-text=\"postFontSize += 0.1\"\n />"
      },
      {
        "language": "text",
        "code": "<BlogPost\n  ...\n  @enlarge-text=\"postFontSize += 0.1\"\n />"
      },
      {
        "language": "text",
        "code": "<!-- omitting <script> -->\n<template>\n  <div class=\"blog-post\">\n    <h4>{{ title }}</h4>\n    <button @click=\"$emit('enlarge-text')\">Enlarge text</button>\n  </div>\n</template>"
      },
      {
        "language": "text",
        "code": "<!-- omitting <script> -->\n<template>\n  <div class=\"blog-post\">\n    <h4>{{ title }}</h4>\n    <button @click=\"$emit('enlarge-text')\">Enlarge text</button>\n  </div>\n</template>"
      },
      {
        "language": "text",
        "code": "@enlarge-text=\"postFontSize += 0.1\""
      },
      {
        "language": "text",
        "code": "postFontSize"
      },
      {
        "language": "text",
        "code": "defineEmits"
      },
      {
        "language": "text",
        "code": "<script>\nexport default {\n  props: ['title'],\n  emits: ['enlarge-text']\n}\n</script>"
      },
      {
        "language": "text",
        "code": "<script>\nexport default {\n  props: ['title'],\n  emits: ['enlarge-text']\n}\n</script>"
      },
      {
        "language": "text",
        "code": "<script setup>\ndefineProps(['title'])\ndefineEmits(['enlarge-text'])\n</script>"
      },
      {
        "language": "text",
        "code": "<script setup>\ndefineProps(['title'])\ndefineEmits(['enlarge-text'])\n</script>"
      },
      {
        "language": "text",
        "code": "defineProps"
      },
      {
        "language": "text",
        "code": "defineEmits"
      },
      {
        "language": "text",
        "code": "<script setup>"
      },
      {
        "language": "text",
        "code": "<script setup>"
      },
      {
        "language": "text",
        "code": "<script setup>\nconst emit = defineEmits(['enlarge-text'])\n\nemit('enlarge-text')\n</script>"
      },
      {
        "language": "text",
        "code": "<script setup>\nconst emit = defineEmits(['enlarge-text'])\n\nemit('enlarge-text')\n</script>"
      },
      {
        "language": "text",
        "code": "<script setup>"
      },
      {
        "language": "text",
        "code": "export default {\n  emits: ['enlarge-text'],\n  setup(props, ctx) {\n    ctx.emit('enlarge-text')\n  }\n}"
      },
      {
        "language": "text",
        "code": "export default {\n  emits: ['enlarge-text'],\n  setup(props, ctx) {\n    ctx.emit('enlarge-text')\n  }\n}"
      },
      {
        "language": "text",
        "code": "<AlertBox>\n  Something bad happened.\n</AlertBox>"
      },
      {
        "language": "text",
        "code": "<AlertBox>\n  Something bad happened.\n</AlertBox>"
      },
      {
        "language": "text",
        "code": "<template>\n  <div class=\"alert-box\">\n    <strong>This is an Error for Demo Purposes</strong>\n    <slot />\n  </div>\n</template>\n\n<style scoped>\n.alert-box {\n  /* ... */\n}\n</style>"
      },
      {
        "language": "text",
        "code": "<template>\n  <div class=\"alert-box\">\n    <strong>This is an Error for Demo Purposes</strong>\n    <slot />\n  </div>\n</template>\n\n<style scoped>\n.alert-box {\n  /* ... */\n}\n</style>"
      },
      {
        "language": "text",
        "code": "<component>"
      },
      {
        "language": "text",
        "code": "<!-- Component changes when currentTab changes -->\n<component :is=\"currentTab\"></component>"
      },
      {
        "language": "text",
        "code": "<!-- Component changes when currentTab changes -->\n<component :is=\"currentTab\"></component>"
      },
      {
        "language": "text",
        "code": "<!-- Component changes when currentTab changes -->\n<component :is=\"tabs[currentTab]\"></component>"
      },
      {
        "language": "text",
        "code": "<!-- Component changes when currentTab changes -->\n<component :is=\"tabs[currentTab]\"></component>"
      },
      {
        "language": "text",
        "code": "<component :is=\"...\">"
      },
      {
        "language": "text",
        "code": "<KeepAlive>"
      },
      {
        "language": "text",
        "code": "template: '...'"
      },
      {
        "language": "text",
        "code": "<script type=\"text/x-template\">"
      },
      {
        "language": "text",
        "code": "// camelCase in JavaScript\nconst BlogPost = {\n  props: ['postTitle'],\n  emits: ['updatePost'],\n  template: `\n    <h3>{{ postTitle }}</h3>\n  `\n}"
      },
      {
        "language": "text",
        "code": "// camelCase in JavaScript\nconst BlogPost = {\n  props: ['postTitle'],\n  emits: ['updatePost'],\n  template: `\n    <h3>{{ postTitle }}</h3>\n  `\n}"
      },
      {
        "language": "text",
        "code": "<!-- kebab-case in HTML -->\n<blog-post post-title=\"hello!\" @update-post=\"onUpdatePost\"></blog-post>"
      },
      {
        "language": "text",
        "code": "<!-- kebab-case in HTML -->\n<blog-post post-title=\"hello!\" @update-post=\"onUpdatePost\"></blog-post>"
      },
      {
        "language": "text",
        "code": "<MyComponent />"
      },
      {
        "language": "text",
        "code": "<MyComponent />"
      },
      {
        "language": "text",
        "code": "<my-component></my-component>"
      },
      {
        "language": "text",
        "code": "<my-component></my-component>"
      },
      {
        "language": "text",
        "code": "<my-component /> <!-- we intend to close the tag here... -->\n<span>hello</span>"
      },
      {
        "language": "text",
        "code": "<my-component /> <!-- we intend to close the tag here... -->\n<span>hello</span>"
      },
      {
        "language": "text",
        "code": "<my-component>\n  <span>hello</span>\n</my-component> <!-- but the browser will close it here. -->"
      },
      {
        "language": "text",
        "code": "<my-component>\n  <span>hello</span>\n</my-component> <!-- but the browser will close it here. -->"
      },
      {
        "language": "text",
        "code": "<table>\n  <blog-post-row></blog-post-row>\n</table>"
      },
      {
        "language": "text",
        "code": "<table>\n  <blog-post-row></blog-post-row>\n</table>"
      },
      {
        "language": "text",
        "code": "<blog-post-row>"
      },
      {
        "language": "text",
        "code": "<table>\n  <tr is=\"vue:blog-post-row\"></tr>\n</table>"
      },
      {
        "language": "text",
        "code": "<table>\n  <tr is=\"vue:blog-post-row\"></tr>\n</table>"
      }
    ],
    "links": [
      {
        "text": "Watch an interactive video lesson on Scrimba",
        "href": "https://scrimba.com/links/vue-component-basics"
      },
      {
        "text": "read more here",
        "href": "/guide/extras/web-components"
      },
      {
        "text": "Single-File Component",
        "href": "/guide/scaling-up/sfc"
      },
      {
        "text": "Examples",
        "href": "/examples/"
      },
      {
        "text": "register",
        "href": "/guide/components/registration"
      },
      {
        "text": "Component Registration",
        "href": "/guide/components/registration"
      },
      {
        "text": "Try it in the Playground",
        "href": "https://play.vuejs.org/#eNqVUE1LxDAQ/StjLqusNHotcfHj4l8QcontLBtsJiGdiFL6301SdrEqyEJyeG9m3ps3k3gIoXlPKFqhxi7awDtN1gUfGR4Ts6cnn4gxwj56B5tGrtgyutEEoAk/6lCPe5MGhqmwnc9KhMRjuxCwFi3UrCk/JU/uGTC6MBjGglgdbnfPGBFM/s7QJ3QHO/TfxC+UzD21d72zPItU8uQrrsWvnKsT/ZW2N2wur45BI3KKdETlFlmphZsF58j/RgdQr3UJuO8G273daVFFtlstahngxSeoNezBIUzTYgPzDGwdjk1VkYvMj4jzF0nwsyQ="
      },
      {
        "text": "Try it in the Playground",
        "href": "https://play.vuejs.org/#eNqVj91KAzEQhV/lmJsqlY3eSlr8ufEVhNys6ZQGNz8kE0GWfXez2SJUsdCLuZiZM9+ZM4qnGLvPQuJBqGySjYxMXOJWe+tiSIznwhz8SyieKWGfgsOqkyfTGbDSXsmFUG9rw+Ti0DPNHavD/faVEqGv5Xr/BXOwww4mVBNPnvOVklXTtKeO8qKhkj++4lb8+fL/mCMS7TEdAy6BtDfBZ65fVgA2s+L67uZMUEC9N0s8msGaj40W7Xa91qKtgbdQ0Ha0gyOM45E+TWDrKHeNIhfMr0DTN4U0me8="
      },
      {
        "text": "props",
        "href": "/api/options-state#props"
      },
      {
        "text": "defineProps",
        "href": "/api/sfc-script-setup#defineprops-defineemits"
      },
      {
        "text": "Typing Component Props",
        "href": "/guide/typescript/composition-api#typing-component-props"
      },
      {
        "text": "Try it in the Playground",
        "href": "https://play.vuejs.org/#eNp9UU1rhDAU/CtDLrawVfpxklRo74We2kPtQdaoaTUJ8bmtiP+9ia6uC2VBgjOZeXnz3sCejAkPnWAx4+3eSkNJqmRjtCU817p81S2hsLpBEEYL4Q1BqoBUid9Jmosi62rC4Nm9dn4lFLXxTGAt5dG482eeUXZ1vdxbQZ1VCwKM0zr3x4KBATKPcbsDSapFjOClx5d2JtHjR1KFN9fTsfbWcXdy+CZKqcqL+vuT/r3qvQqyRatRdMrpF/nn/DNhd7iPR+v8HCDRmDoj4RHxbfyUDjeFto8p8yEh1Rw2ZV4JxN+iP96FMvest8RTTws/gdmQ8HUr7ikere+yHduu62y//y3NWG38xIOpeODyXcoE8OohGYZ5VhhHHjl83sD4B3XgyGI="
      },
      {
        "text": "Try it in the Playground",
        "href": "https://play.vuejs.org/#eNp9kU9PhDAUxL/KpBfWBCH+OZEuid5N9qSHrQezFKhC27RlDSF8d1tYQBP1+N78OpN5HciD1sm54yQj1J6M0A6Wu07nTIpWK+MwwPASI0qjWkQejVbpsVHVQVl30ZJ0WQRHjwFMnpT0gPZLi32w2h2DMEAUGW5iOOEaniF66vGuOiN5j0/hajx7B4zxxt5ubIiphKz+IO828qXugw5hYRXKTnqSydcrJmk61/VF/eB4q5s3x8Pk6FJjauDO16Uye0ZCBwg5d2EkkED2wfuLlogibMOTbMpf9tMwP8jpeiMfRdM1l8Tk+/F++Y6Cl0Lyg1Ha7o7R5Bn9WwSg9X0+DPMxMI409fPP1PELlVmwdQ=="
      },
      {
        "text": "v-bind syntax",
        "href": "/api/built-in-directives#v-bind"
      },
      {
        "text": "Props",
        "href": "/guide/components/props"
      },
      {
        "text": "$emit method",
        "href": "/api/component-instance#emit"
      },
      {
        "text": "Try it in the Playground",
        "href": "https://play.vuejs.org/#eNqNUsFOg0AQ/ZUJMaGNbbHqidCmmujNxMRED9IDhYWuhV0CQy0S/t1ZYIEmaiRkw8y8N/vmMZVxl6aLY8EM23ByP+Mprl3Bk1RmCPexjJ5ljhBmMgFzYemEIpiuAHAFOzXQgIVeESNUKutL4gsmMLfbBPStVFTP1Bl46E2mup4xLDKhI4CUsMR+1zFABTywYTkD5BgzG8ynEj4kkVgJnxz38Eqaut5jxvXAUCIiLqI/8TcD/m1fKhTwHHIJYSEIr+HbnqikPkqBL/yLSMs23eDooNexel8pQJaksYeMIgAn4EewcyxjtnKNCsK+zbgpXILJEnW30bCIN7ZTPcd5KDNqoWjARWufa+iyfWBlV13wYJRvJtWVJhiKGyZiL4vYHNkJO8wgaQVXi6UGr51+Ndq5LBqMvhyrH9eYGePtOVu3n3YozWSqFsBsVJmt3SzhzVaYY2nm9l82+7GX5zTGjlTM1SyNmy5SeX+7rqr2r0NdOxbFXWVXIEoBGz/m/oHIF0rB5Pz6KTV6aBOgEo7Vsn51ov4GgAAf2A=="
      },
      {
        "text": "Try it in the Playground",
        "href": "https://play.vuejs.org/#eNp1Uk1PwkAQ/SuTxqQYgYp6ahaiJngzITHRA/UAZQor7W7TnaK16X93th8UEuHEvPdm5s3bls5Tmo4POTq+I0yYyZTAIOXpLFAySXVGUEKGEVQQZToBl6XukXqO9XahDbXc2OsAO5FlAIEKtWJByqCBqR01WFqiBLnxYTIEkhSjD+5rAV86zxQW8C1pB+88Aaphr73rtXbNVqrtBeV9r/zYFZYHacBoiHLFykB9Xgfq1NmLVvQmf7E1OGFaeE0anAMXhEkarwhtRWIjD+AbKmKcBk4JUdvtn8+6ARcTu87hLuCf6NJpSoDDKNIZj7BtIFUTUuB0tL/HomXHcnOC18d1TF305COqeJVtcUT4Q62mtzSF2/GkE8/E8b1qh8Ljw/if8I7nOkPn9En/+Ug2GEmFi0ynZrB0azOujbfB54kki5+aqumL8bING28Yr4xh+2vePrI39CnuHmZl2TwwVJXwuG6ZdU6kFTyGsQz33HyFvH5wvvyaB80bACwgvKbrYgLVH979DQc="
      },
      {
        "text": "emits",
        "href": "/api/options-state#emits"
      },
      {
        "text": "defineEmits",
        "href": "/api/sfc-script-setup#defineprops-defineemits"
      },
      {
        "text": "validates them",
        "href": "/guide/components/events#events-validation"
      },
      {
        "text": "Typing Component Emits",
        "href": "/guide/typescript/composition-api#typing-component-emits"
      },
      {
        "text": "Custom Events",
        "href": "/guide/components/events"
      },
      {
        "text": "Try it in the Playground",
        "href": "https://play.vuejs.org/#eNpVUcFOwzAM/RUTDruwFhCaUCmThsQXcO0lbbKtIo0jx52Kpv07TreWouTynl+en52z2oWQnXqrClXGhtrA28q3XUBi2DlL/IED7Ak7WGX5RKQHq8oDVN4Oo9TYve4dwzmxDcp7bz3HAs5/LpfKyy3zuY0Atl1wmm1CXE5SQeLNX9hZPrb+ALU2cNQhWG9NNkrnLKIt89lGPahlyDTVogVAadoTNE7H+F4pnZTrGodKjUUpRyb0h+0nEdKdRL3CW7GmfNY5ZLiiMhfP/ynG0SL/OAuxwWCNMNncbVqSQyrgfrPZvCVcIxkrxFMYIKJrDZA1i8qatGl72ehLGEY6aGNkNwU8P96YWjffB8Lem/Xkvn9NR6qy+fRd14FSgopvmtQmzTT9Toq9VZdfIpa5jQ=="
      },
      {
        "text": "Try it in the Playground",
        "href": "https://play.vuejs.org/#eNpVUEtOwzAQvcpgFt3QBBCqUAiRisQJ2GbjxG4a4Xis8aQKqnp37PyUyqv3mZn3fBVH55JLr0Umcl9T6xi85t4VpW07h8RwNJr4Cwc4EXawS9KFiGO70ubpNBcmAmDdOSNZR8T5Yg0IoOQf7DSfW9tAJRWcpXPaapWM1nVt8ObpukY8ie29GHNzAiBX7QVqI73/LIWMzn2FQylGMcieCW1TfBMhPYSoE5zFitLVZ5BhQnkadt6nGKt5/jMafI1Oq8Ak6zW4xrEaDVIGj4fD4SPiCknpQLy4ATyaVgFptVH2JFXb+wze3DDSTioV/iaD1+eZqWT92xD2Vu2X7af3+IJ6G7/UToVigpJnTzwTO42eWDnELsTtH/wUqH4="
      },
      {
        "text": "Slots",
        "href": "/guide/components/slots"
      },
      {
        "text": "Open example in the Playground",
        "href": "https://play.vuejs.org/#eNqNVE2PmzAQ/Ssj9kArLSHbrXpwk1X31mMPvS17cIxJrICNbJMmivLfO/7AEG2jRiDkefP85sNmztlr3y8OA89ItjJMi96+VFJ0vdIWfqqOQ6NVB/midIYj5sn9Sxlrkt9b14RXzXbiMElEO5IAKsmPnljzhg6thbNDmcLdkktrSADAJ/IYlj5MXEc9Z1w8VFNLP30ed2luBy1HC4UHrVH2N90QyJ1kHnUALN1gtLeIQu6juEUMkb8H5sXHqiS+qzK1Cw3Lu76llqMFsKrFAVhLjVlXWc07VWUeR89msFbhhhAWDkWjNJIwPgjp06iy5CV7fgrOOTgKv+XoKIIgpnoGyiymSmZ1wnq9dqJweZ8p/GCtYHtUmBMdLXFitgDnc9ju68b0yxDO1WzRTEcFRLiUJsEqSw3wwi+rMpFDj0psEq5W5ax1aBp7at1y4foWzq5R0hYN7UR7ImCoNIXhWjTfnW+jdM01gaf+CEa1ooYHzvnMVWhaiwEP90t/9HBP61rILQJL3POMHw93VG+FLKzqUYx3c2yjsOaOwNeRO2B8zKHlzBKQWJNH1YHrplV/iiMBOliFILYNK5mOKdSTMviGCTyNojFdTKBoeWNT3s8f/Vpsd7cIV61gjHkXnotR6OqVkJbrQKdsv9VqkDWBh2bpnn8VXaDcHPexE4wFzsojO9eDUOSVPF+65wN/EW7sHRsi5XaFqaexn+EH9Xcpe8zG2eWG3O0/NVzUaeJMk+jGhUXlNPXulw5j8w7t2bi8X32cuf/Vv/wF/SL98A=="
      },
      {
        "text": "Open example in the Playground",
        "href": "https://play.vuejs.org/#eNqNVMGOmzAQ/ZURe2BXCiHbrXpwk1X31mMPvS1V5RiTWAEb2SZNhPLvHdvggLZRE6TIM/P8/N5gpk/e2nZ57HhCkrVhWrQWDLdd+1pI0bRKW/iuGg6VVg2ky9wFDp7G8g9lrIl1H80Bb5rtxfFKMcRzUA+aV3AZQKEEhWRKGgus05pL+5NuYeNwj6mTkT4VckRYujVY63GT17twC6/Fr4YjC3kp5DoPNtEgBpY3bU0txwhgXYojsJoasymSkjeqSHweK9vOWoUbXIC/Y1YpjaDH3wt39hMI6TUUSYSQAz8jArPT5Mj+nmIhC6zpAu1TZlEhmXndbBwpXH5NGL6xWrADMsyaMj1lkAzQ92E7mvYe8nCcM24xZApbL5ECiHCSnP73KyseGnvh6V/XedwS2pVjv3C1ziddxNDYc+2WS9fC8E4qJW1W0UbUZwKGSpMZrkX11dW2SpdcE3huT2BULUp44JxPSpmmpegMgU/tyadbWpZC7jCxwj0v+OfTDdU7ITOrWiTjzTS3Vei8IfB5xHZ4PmqoObMEJHryWXXkuqrVn+xEgHZWYRKbh06uLyv4iQq+oIDnkXSQiwKymlc26n75WNdit78FmLWCMeZL+GKMwlKrhLRcBzhlh51WnSwJPFQr9/zLdIZ007w/O6bR4MQe2bseBJMzer5yzwf8MtzbOzYMkNsOY0+HfoZv1d+lZJGMg8fNqdsfbbio4b77uRVv7I0Li8xxZN1PHWbeHdyTWXc/+zgw/8t/+QsROe9h"
      },
      {
        "text": "<KeepAlive> component",
        "href": "/guide/built-ins/keep-alive"
      },
      {
        "text": "a few specific elements",
        "href": "https://html.spec.whatwg.org/multipage/syntax.html#void-elements"
      },
      {
        "text": "is attribute",
        "href": "/api/built-in-special-attributes#is"
      },
      {
        "text": "customized built-in elements",
        "href": "https://html.spec.whatwg.org/multipage/custom-elements.html#custom-elements-customized-builtin-example"
      },
      {
        "text": "Examples",
        "href": "/examples/"
      },
      {
        "text": "Edit this page on GitHub",
        "href": "https://github.com/vuejs/docs/edit/main/src/guide/essentials/component-basics.md"
      }
    ],
    "meta": {
      "description": "Vue.js - The Progressive JavaScript Framework",
      "keywords": ""
    },
    "summary": "Components Basics  Watch an interactive video lesson on Scrimba Components allow us to split the UI into independent and reusable pieces, and think about each piece in isolation",
    "tags": [
      "react",
      "vue",
      "angular",
      "javascript",
      "typescript",
      "css",
      "html",
      "vite",
      "components",
      "basics"
    ],
    "id": "components-basics-componentbasicshtml-part-1",
    "quality": 100
  },
  {
    "title": "Props",
    "url": "https://vuejs.org/guide/components/props.html",
    "category": "vue",
    "content": "Props This page assumes you've already read the Components Basics. Read that first if you are new to components.Watch a free video lesson on Vue SchoolProps Declaration Vue components require explicit props declaration so that Vue knows what external props passed to the component should be treated as fallthrough attributes (which will be discussed in its dedicated section).In SFCs using script setup, props can be declared using the defineProps() macro:vuescript setup const props = defineProps(['foo']) console.log(props.foo) /scriptIn non-script setup components, props are declared using the props option:jsexport default { props: ['foo'], setup(props) { // setup() receives props as the first argument. console.log(props.foo) } }Notice the argument passed to defineProps() is the same as the value provided to the props options: the same props options API is shared between the two declaration styles.Props are declared using the props option:jsexport default { props: ['foo'], created() { // props are exposed on this console.log(this.foo) } }In addition to declaring props using an array of strings, we can also use the object syntax:jsexport default { props: { title: String, likes: Number } }js// in script setup defineProps({ title: String, likes: Number })js// in non-script setup export default { props: { title: String, likes: Number } }For each property in the object declaration syntax, the key is the name of the prop, while the value should be the constructor function of the expected type.This not only documents your component, but will also warn other developers using your component in the browser console if they pass the wrong type. We will discuss more details about prop validation further down this page.See also: Typing Component Props If you are using TypeScript with script setup, it's also possible to declare props using pure type annotations:vuescript setup lang=\"ts\" defineProps{ title?: string likes?: number }() /scriptMore details: Typing Component Props Reactive Props Destructure Vue's reactivity system tracks state usage based on property access. E.g. when you access props.foo in a computed getter or a watcher, the foo prop gets tracked as a dependency.So, given the following code:jsconst { foo } = defineProps(['foo']) watchEffect(() = { // runs only once before 3.5 // re-runs when the \"foo\" prop changes in 3.5+ console.log(foo) })In version 3.4 and below, foo is an actual constant and will never change. In version 3.5 and above, Vue's compiler automatically prepends props. when code in the same script setup block accesses variables destructured from defineProps. Therefore the code above becomes equivalent to the following:jsconst props = defineProps(['foo']) watchEffect(() = { // foo transformed to props.foo by the compiler console.log(props.foo) })In addition, you can use JavaScript's native default value syntax to declare default values for the props. This is particularly useful when using the type-based props declaration:tsconst { foo = 'hello' } = defineProps{ foo?: string }()If you prefer to have more visual distinction between destructured props and normal variables in your IDE, Vue's VSCode extension provides a setting to enable inlay-hints for destructured props.Passing Destructured Props into Functions When we pass a destructured prop into a function, e.g.:jsconst { foo } = defineProps(['foo']) watch(foo, /* ... */)This will not work as expected because it is equivalent to watch(props.foo, ...) - we are passing a value instead of a reactive data source to watch. In fact, Vue's compiler will catch such cases and throw a warning.Similar to how we can watch a normal prop with watch(() = props.foo, ...), we can watch a destructured prop also by wrapping it in a getter:jswatch(() = foo, /* ... */)In addition, this is the recommended approach when we need to pass a destructured prop into an external function while retaining reactivity:jsuseComposable(() = foo)The external function can call the getter (or normalize it with toValue) when it needs to track changes of the provided prop, e.g. in a computed or watcher getter.Prop Passing Details Prop Name Casing We declare long prop names using camelCase because this avoids having to use quotes when using them as property keys, and allows us to reference them directly in template expressions because they are valid JavaScript identifiers:jsdefineProps({ greetingMessage: String })jsexport default { props: { greetingMessage: String } }templatespan{{ greetingMessage }}/spanTechnically, you can also use camelCase when passing props to a child component (except in in-DOM templates). However, the convention is using kebab-case in all cases to align with HTML attributes:templateMyComponent greeting-message=\"hello\" /We use PascalCase for component tags when possible because it improves template readability by differentiating Vue components from native elements. However, there isn't as much practical benefit in using camelCase when passing props, so we choose to follow each language's conventions.Static vs. Dynamic Props So far, you've seen props passed as static values, like in:templateBlogPost title=\"My journey with Vue\" /You've also seen props assigned dynamically with v-bind or its : shortcut, such as in:template!-- Dynamically assign the value of a variable -- BlogPost :title=\"post.title\" / !-- Dynamically assign the value of a complex expression -- BlogPost :title=\"post.title + ' by ' + post.author.name\" /Passing Different Value Types In the two examples above, we happen to pass string values, but any type of value can be passed to a prop.Number template!-- Even though 42 is static, we need v-bind to tell Vue that -- !-- this is a JavaScript expression rather than a string. -- BlogPost :likes=\"42\" / !-- Dynamically assign to the value of a variable. -- BlogPost :likes=\"post.likes\" /Boolean template!-- Including the prop with no value will imply true. -- BlogPost is-published / !-- Even though false is static, we need v-bind to tell Vue that -- !-- this is a JavaScript expression rather than a string. -- BlogPost :is-published=\"false\" / !-- Dynamically assign to the value of a variable. -- BlogPost :is-published=\"post.isPublished\" /Array template!-- Even though the array is static, we need v-bind to tell Vue that -- !-- this is a JavaScript expression rather than a string. -- BlogPost :comment-ids=\"[234, 266, 273]\" / !-- Dynamically assign to the value of a variable. -- BlogPost :comment-ids=\"post.commentIds\" /Object template!-- Even though the object is static, we need v-bind to tell Vue that -- !-- this is a JavaScript expression rather than a string. -- BlogPost :author=\"{ name: 'Veronica', company: 'Veridian Dynamics' }\" / !-- Dynamically assign to the value of a variable. -- BlogPost :author=\"post.author\" /Binding Multiple Properties Using an Object If you want to pass all the properties of an object as props, you can use v-bind without an argument (v-bind instead of :prop-name). For example, given a post object:jsexport default { data() { return { post: { id: 1, title: 'My Journey with Vue' } } } }jsconst post = { id: 1, title: 'My Journey with Vue' }The following template:templateBlogPost v-bind=\"post\" /Will be equivalent to:templateBlogPost :id=\"post.id\" :title=\"post.title\" /One-Way Data Flow All props form a one-way-down binding between the child property and the parent one: when the parent property updates, it will flow down to the child, but not the other way around. This prevents child components from accidentally mutating the parent's state, which can make your app's data flow harder to understand.In addition, every time the parent component is updated, all props in the child component will be refreshed with the latest value. This means you should not attempt to mutate a prop inside a child component. If you do, Vue will warn you in the console:jsconst props = defineProps(['foo']) //  warning, props are readonly! props.foo = 'bar'jsexport default { props: ['foo'], created() { //  warning, props are readonly! this.foo = 'bar' } }There are usually two cases where it's tempting to mutate a prop:The prop is used to pass in an initial value; the child component wants to use it as a local data property afterwards. In this case, it's best to define a local data property that uses the prop as its initial value:jsconst props = defineProps(['initialCounter']) // counter only uses props.initialCounter as the initial value; // it is disconnected from future prop updates. const counter = ref(props.initialCounter)jsexport default { props: ['initialCounter'], data() { return { // counter only uses this.initialCounter as the initial value; // it is disconnected from future prop updates. counter: this.initialCounter } } }The prop is passed in as a raw value that needs to be transformed. In this case, it's best to define a computed property using the prop's value:jsconst props = defineProps(['size']) // computed property that auto-updates when the prop changes const normalizedSize = computed(() = props.size.trim().toLowerCase())jsexport default { props: ['size'], computed: { // computed property that auto-updates when the prop changes normalizedSize() { return this.size.trim().toLowerCase() } } }Mutating Object / Array Props When objects and arrays are passed as props, while the child component cannot mutate the prop binding, it will be able to mutate the object or array's nested properties. This is because in JavaScript objects and arrays are passed by reference, and it is unreasonably expensive for Vue to prevent such mutations.The main drawback of such mutations is that it allows the child component to affect parent state in a way that isn't obvious to the parent component, potentially making it more difficult to reason about the data flow in the future. As a best practice, you should avoid such mutations unless the parent and child are tightly coupled by design. In most cases, the child should emit an event to let the parent perform the mutation.Prop Validation Components can specify requirements for their props, such as the types you've already seen. If a requirement is not met, Vue will warn you in the browser's JavaScript console. This is especially useful when developing a component that is intended to be used by others.To specify prop validations, you can provide an object with validation requirements to the defineProps() macroprops option, instead of an array of strings. For example:jsdefineProps({ // Basic type check // (null and undefined values will allow any type) propA: Number, // Multiple possible types propB: [String, Number], // Required string propC: { type: String, required: true }, // Required but nullable string propD: { type: [String, null], required: true }, // Number with a default value propE: { type: Number, default: 100 }, // Object with a default value propF: { type: Object, // Object or array defaults must be returned from // a factory function. The function receives the raw // props received by the component as the argument. default(rawProps) { return { message: 'hello' } } }, // Custom validator function // full props passed as 2nd argument in 3.4+ propG: { validator(value, props) { // The value must match one of these strings return ['success', 'warning', 'danger'].includes(value) } }, // Function with a default value propH: { type: Function, // Unlike object or array default, this is not a factory // function - this is a function to serve as a default value default() { return 'Default function' } } })TIPCode inside the defineProps() argument cannot access other variables declared in script setup, because the entire expression is moved to an outer function scope when compiled.jsexport default { props: { // Basic type check // (null and undefined values will allow any type) propA: Number, // Multiple possible types propB: [String, Number], // Required string propC: { type: String, required: true }, // Required but nullable string propD: { type: [String, null], required: true }, // Number with a default value propE: { type: Number, default: 100 }, // Object with a default value propF: { type: Object, // Object or array defaults must be returned from // a factory function. The function receives the raw // props received by the component as the argument. default(rawProps) { return { message: 'hello' } } }, // Custom validator function // full props passed as 2nd argument in 3.4+ propG: { validator(value, props) { // The value must match one of these strings return ['success', 'warning', 'danger'].includes(value) } }, // Function with a default value propH: { type: Function, // Unlike object or array default, this is not a factory // function - this is a function to serve as a default value default() { return 'Default function' } } } }Additional details:All props are optional by default, unless required: true is specified.An absent optional prop other than Boolean will have undefined value.The Boolean absent props will be cast to false. You can change this by setting a default for it  i.e.: default: undefined to behave as a non-Boolean prop.If a default value is specified, it will be used if the resolved prop value is undefined - this includes both when the prop is absent, or an explicit undefined value is passed.When prop validation fails, Vue will produce a console warning (if using the development build).If using Type-based props declarations , Vue will try its best to compile the type annotations into equivalent runtime prop declarations. For example, defineProps{ msg: string } will be compiled into { msg: { type: String, required: true }}.NoteNote that props are validated before a component instance is created, so instance properties (e.g. data, computed, etc.) will not be available inside default or validator functions.Runtime Type Checks The type can be one of the following native constructors:StringNumberBooleanArrayObjectDateFunctionSymbolErrorIn addition, type can also be a custom class or constructor function and the assertion will be made with an instanceof check. For example, given the following class:jsclass Person { constructor(firstName, lastName) { this.firstName = firstName this.lastName = lastName } }You could use it as a prop's type:jsdefineProps({ author: Person })jsexport default { props: { author: Person } }Vue will use instanceof Person to validate whether the value of the author prop is indeed an instance of the Person class.Nullable Type If the type is required but nullable, you can use the array syntax that includes null:jsdefineProps({ id: { type: [String, null], required: true } })jsexport default { props: { id: { type: [String, null], required: true } } }Note that if type is just null without using the array syntax, it will allow any type.Boolean Casting Props with Boolean type have special casting rules to mimic the behavior of native boolean attributes. Given a MyComponent with the following declaration:jsdefineProps({ disabled: Boolean })jsexport default { props: { disabled: Boolean } }The component can be used like this:template!-- equivalent of passing :disabled=\"true\" -- MyComponent disabled / !-- equivalent of passing :disabled=\"false\" -- MyComponent /When a prop is declared to allow multiple types, the casting rules for Boolean will also be applied. However, there is an edge when both String and Boolean are allowed - the Boolean casting rule only applies if Boolean appears before String:js// disabled will be casted to true defineProps({ disabled: [Boolean, Number] }) // disabled will be casted to true defineProps({ disabled: [Boolean, String] }) // disabled will be casted to true defineProps({ disabled: [Number, Boolean] }) // disabled will be parsed as an empty string (disabled=\"\") defineProps({ disabled: [String, Boolean] })js// disabled will be casted to true export default { props: { disabled: [Boolean, Number] } } // disabled will be casted to true export default { props: { disabled: [Boolean, String] } } // disabled will be casted to true export default { props: { disabled: [Number, Boolean] } } // disabled will be parsed as an empty string (disabled=\"\") export default { props: { disabled: [String, Boolean] } }Edit this page on GitHub",
    "headings": [
      {
        "level": 1,
        "text": "Props ​",
        "id": "props"
      },
      {
        "level": 2,
        "text": "Props Declaration ​",
        "id": "props-declaration"
      },
      {
        "level": 2,
        "text": "Reactive Props Destructure  ​",
        "id": "reactive-props-destructure"
      },
      {
        "level": 2,
        "text": "Prop Passing Details ​",
        "id": "prop-passing-details"
      },
      {
        "level": 2,
        "text": "One-Way Data Flow ​",
        "id": "one-way-data-flow"
      },
      {
        "level": 2,
        "text": "Prop Validation ​",
        "id": "prop-validation"
      },
      {
        "level": 2,
        "text": "Boolean Casting ​",
        "id": "boolean-casting"
      },
      {
        "level": 3,
        "text": "Passing Destructured Props into Functions ​",
        "id": "passing-destructured-props-into-functions"
      },
      {
        "level": 3,
        "text": "Prop Name Casing ​",
        "id": "prop-name-casing"
      },
      {
        "level": 3,
        "text": "Static vs. Dynamic Props ​",
        "id": "static-vs-dynamic-props"
      },
      {
        "level": 3,
        "text": "Passing Different Value Types ​",
        "id": "passing-different-value-types"
      },
      {
        "level": 3,
        "text": "Binding Multiple Properties Using an Object ​",
        "id": "binding-multiple-properties-using-an-object"
      },
      {
        "level": 3,
        "text": "Mutating Object / Array Props ​",
        "id": "mutating-object-array-props"
      },
      {
        "level": 3,
        "text": "Runtime Type Checks ​",
        "id": "runtime-type-checks"
      },
      {
        "level": 3,
        "text": "Nullable Type ​",
        "id": "nullable-type"
      },
      {
        "level": 4,
        "text": "Number ​",
        "id": "number"
      },
      {
        "level": 4,
        "text": "Boolean ​",
        "id": "boolean"
      },
      {
        "level": 4,
        "text": "Array ​",
        "id": "array"
      },
      {
        "level": 4,
        "text": "Object ​",
        "id": "object"
      }
    ],
    "codeBlocks": [
      {
        "language": "text",
        "code": "<script setup>"
      },
      {
        "language": "text",
        "code": "defineProps()"
      },
      {
        "language": "text",
        "code": "<script setup>\nconst props = defineProps(['foo'])\n\nconsole.log(props.foo)\n</script>"
      },
      {
        "language": "text",
        "code": "<script setup>\nconst props = defineProps(['foo'])\n\nconsole.log(props.foo)\n</script>"
      },
      {
        "language": "text",
        "code": "<script setup>"
      },
      {
        "language": "text",
        "code": "export default {\n  props: ['foo'],\n  setup(props) {\n    // setup() receives props as the first argument.\n    console.log(props.foo)\n  }\n}"
      },
      {
        "language": "text",
        "code": "export default {\n  props: ['foo'],\n  setup(props) {\n    // setup() receives props as the first argument.\n    console.log(props.foo)\n  }\n}"
      },
      {
        "language": "text",
        "code": "defineProps()"
      },
      {
        "language": "text",
        "code": "export default {\n  props: ['foo'],\n  created() {\n    // props are exposed on `this`\n    console.log(this.foo)\n  }\n}"
      },
      {
        "language": "text",
        "code": "export default {\n  props: ['foo'],\n  created() {\n    // props are exposed on `this`\n    console.log(this.foo)\n  }\n}"
      },
      {
        "language": "text",
        "code": "export default {\n  props: {\n    title: String,\n    likes: Number\n  }\n}"
      },
      {
        "language": "text",
        "code": "export default {\n  props: {\n    title: String,\n    likes: Number\n  }\n}"
      },
      {
        "language": "text",
        "code": "// in <script setup>\ndefineProps({\n  title: String,\n  likes: Number\n})"
      },
      {
        "language": "text",
        "code": "// in <script setup>\ndefineProps({\n  title: String,\n  likes: Number\n})"
      },
      {
        "language": "text",
        "code": "// in non-<script setup>\nexport default {\n  props: {\n    title: String,\n    likes: Number\n  }\n}"
      },
      {
        "language": "text",
        "code": "// in non-<script setup>\nexport default {\n  props: {\n    title: String,\n    likes: Number\n  }\n}"
      },
      {
        "language": "text",
        "code": "<script setup>"
      },
      {
        "language": "text",
        "code": "<script setup lang=\"ts\">\ndefineProps<{\n  title?: string\n  likes?: number\n}>()\n</script>"
      },
      {
        "language": "text",
        "code": "<script setup lang=\"ts\">\ndefineProps<{\n  title?: string\n  likes?: number\n}>()\n</script>"
      },
      {
        "language": "text",
        "code": "const { foo } = defineProps(['foo'])\n\nwatchEffect(() => {\n  // runs only once before 3.5\n  // re-runs when the \"foo\" prop changes in 3.5+\n  console.log(foo)\n})"
      },
      {
        "language": "text",
        "code": "const { foo } = defineProps(['foo'])\n\nwatchEffect(() => {\n  // runs only once before 3.5\n  // re-runs when the \"foo\" prop changes in 3.5+\n  console.log(foo)\n})"
      },
      {
        "language": "text",
        "code": "<script setup>"
      },
      {
        "language": "text",
        "code": "defineProps"
      },
      {
        "language": "text",
        "code": "const props = defineProps(['foo'])\n\nwatchEffect(() => {\n  // `foo` transformed to `props.foo` by the compiler\n  console.log(props.foo)\n})"
      },
      {
        "language": "text",
        "code": "const props = defineProps(['foo'])\n\nwatchEffect(() => {\n  // `foo` transformed to `props.foo` by the compiler\n  console.log(props.foo)\n})"
      },
      {
        "language": "text",
        "code": "const { foo = 'hello' } = defineProps<{ foo?: string }>()"
      },
      {
        "language": "text",
        "code": "const { foo = 'hello' } = defineProps<{ foo?: string }>()"
      },
      {
        "language": "text",
        "code": "const { foo } = defineProps(['foo'])\n\nwatch(foo, /* ... */)"
      },
      {
        "language": "text",
        "code": "const { foo } = defineProps(['foo'])\n\nwatch(foo, /* ... */)"
      },
      {
        "language": "text",
        "code": "watch(props.foo, ...)"
      },
      {
        "language": "text",
        "code": "watch(() => props.foo, ...)"
      },
      {
        "language": "text",
        "code": "watch(() => foo, /* ... */)"
      },
      {
        "language": "text",
        "code": "watch(() => foo, /* ... */)"
      },
      {
        "language": "text",
        "code": "useComposable(() => foo)"
      },
      {
        "language": "text",
        "code": "useComposable(() => foo)"
      },
      {
        "language": "text",
        "code": "defineProps({\n  greetingMessage: String\n})"
      },
      {
        "language": "text",
        "code": "defineProps({\n  greetingMessage: String\n})"
      },
      {
        "language": "text",
        "code": "export default {\n  props: {\n    greetingMessage: String\n  }\n}"
      },
      {
        "language": "text",
        "code": "export default {\n  props: {\n    greetingMessage: String\n  }\n}"
      },
      {
        "language": "text",
        "code": "<span>{{ greetingMessage }}</span>"
      },
      {
        "language": "text",
        "code": "<span>{{ greetingMessage }}</span>"
      },
      {
        "language": "text",
        "code": "<MyComponent greeting-message=\"hello\" />"
      },
      {
        "language": "text",
        "code": "<MyComponent greeting-message=\"hello\" />"
      },
      {
        "language": "text",
        "code": "<BlogPost title=\"My journey with Vue\" />"
      },
      {
        "language": "text",
        "code": "<BlogPost title=\"My journey with Vue\" />"
      },
      {
        "language": "text",
        "code": "<!-- Dynamically assign the value of a variable -->\n<BlogPost :title=\"post.title\" />\n\n<!-- Dynamically assign the value of a complex expression -->\n<BlogPost :title=\"post.title + ' by ' + post.author.name\" />"
      },
      {
        "language": "text",
        "code": "<!-- Dynamically assign the value of a variable -->\n<BlogPost :title=\"post.title\" />\n\n<!-- Dynamically assign the value of a complex expression -->\n<BlogPost :title=\"post.title + ' by ' + post.author.name\" />"
      },
      {
        "language": "text",
        "code": "<!-- Even though `42` is static, we need v-bind to tell Vue that -->\n<!-- this is a JavaScript expression rather than a string.       -->\n<BlogPost :likes=\"42\" />\n\n<!-- Dynamically assign to the value of a variable. -->\n<BlogPost :likes=\"post.likes\" />"
      },
      {
        "language": "text",
        "code": "<!-- Even though `42` is static, we need v-bind to tell Vue that -->\n<!-- this is a JavaScript expression rather than a string.       -->\n<BlogPost :likes=\"42\" />\n\n<!-- Dynamically assign to the value of a variable. -->\n<BlogPost :likes=\"post.likes\" />"
      },
      {
        "language": "text",
        "code": "<!-- Including the prop with no value will imply `true`. -->\n<BlogPost is-published />\n\n<!-- Even though `false` is static, we need v-bind to tell Vue that -->\n<!-- this is a JavaScript expression rather than a string.          -->\n<BlogPost :is-published=\"false\" />\n\n<!-- Dynamically assign to the value of a variable. -->\n<BlogPost :is-published=\"post.isPublished\" />"
      },
      {
        "language": "text",
        "code": "<!-- Including the prop with no value will imply `true`. -->\n<BlogPost is-published />\n\n<!-- Even though `false` is static, we need v-bind to tell Vue that -->\n<!-- this is a JavaScript expression rather than a string.          -->\n<BlogPost :is-published=\"false\" />\n\n<!-- Dynamically assign to the value of a variable. -->\n<BlogPost :is-published=\"post.isPublished\" />"
      },
      {
        "language": "text",
        "code": "<!-- Even though the array is static, we need v-bind to tell Vue that -->\n<!-- this is a JavaScript expression rather than a string.            -->\n<BlogPost :comment-ids=\"[234, 266, 273]\" />\n\n<!-- Dynamically assign to the value of a variable. -->\n<BlogPost :comment-ids=\"post.commentIds\" />"
      },
      {
        "language": "text",
        "code": "<!-- Even though the array is static, we need v-bind to tell Vue that -->\n<!-- this is a JavaScript expression rather than a string.            -->\n<BlogPost :comment-ids=\"[234, 266, 273]\" />\n\n<!-- Dynamically assign to the value of a variable. -->\n<BlogPost :comment-ids=\"post.commentIds\" />"
      },
      {
        "language": "text",
        "code": "<!-- Even though the object is static, we need v-bind to tell Vue that -->\n<!-- this is a JavaScript expression rather than a string.             -->\n<BlogPost\n  :author=\"{\n    name: 'Veronica',\n    company: 'Veridian Dynamics'\n  }\"\n />\n\n<!-- Dynamically assign to the value of a variable. -->\n<BlogPost :author=\"post.author\" />"
      },
      {
        "language": "text",
        "code": "<!-- Even though the object is static, we need v-bind to tell Vue that -->\n<!-- this is a JavaScript expression rather than a string.             -->\n<BlogPost\n  :author=\"{\n    name: 'Veronica',\n    company: 'Veridian Dynamics'\n  }\"\n />\n\n<!-- Dynamically assign to the value of a variable. -->\n<BlogPost :author=\"post.author\" />"
      },
      {
        "language": "text",
        "code": "export default {\n  data() {\n    return {\n      post: {\n        id: 1,\n        title: 'My Journey with Vue'\n      }\n    }\n  }\n}"
      },
      {
        "language": "text",
        "code": "export default {\n  data() {\n    return {\n      post: {\n        id: 1,\n        title: 'My Journey with Vue'\n      }\n    }\n  }\n}"
      },
      {
        "language": "text",
        "code": "const post = {\n  id: 1,\n  title: 'My Journey with Vue'\n}"
      },
      {
        "language": "text",
        "code": "const post = {\n  id: 1,\n  title: 'My Journey with Vue'\n}"
      },
      {
        "language": "text",
        "code": "<BlogPost v-bind=\"post\" />"
      },
      {
        "language": "text",
        "code": "<BlogPost v-bind=\"post\" />"
      },
      {
        "language": "text",
        "code": "<BlogPost :id=\"post.id\" :title=\"post.title\" />"
      },
      {
        "language": "text",
        "code": "<BlogPost :id=\"post.id\" :title=\"post.title\" />"
      },
      {
        "language": "text",
        "code": "const props = defineProps(['foo'])\n\n// ❌ warning, props are readonly!\nprops.foo = 'bar'"
      },
      {
        "language": "text",
        "code": "const props = defineProps(['foo'])\n\n// ❌ warning, props are readonly!\nprops.foo = 'bar'"
      },
      {
        "language": "text",
        "code": "export default {\n  props: ['foo'],\n  created() {\n    // ❌ warning, props are readonly!\n    this.foo = 'bar'\n  }\n}"
      },
      {
        "language": "text",
        "code": "export default {\n  props: ['foo'],\n  created() {\n    // ❌ warning, props are readonly!\n    this.foo = 'bar'\n  }\n}"
      },
      {
        "language": "text",
        "code": "const props = defineProps(['initialCounter'])\n\n// counter only uses props.initialCounter as the initial value;\n// it is disconnected from future prop updates.\nconst counter = ref(props.initialCounter)"
      },
      {
        "language": "text",
        "code": "const props = defineProps(['initialCounter'])\n\n// counter only uses props.initialCounter as the initial value;\n// it is disconnected from future prop updates.\nconst counter = ref(props.initialCounter)"
      },
      {
        "language": "text",
        "code": "export default {\n  props: ['initialCounter'],\n  data() {\n    return {\n      // counter only uses this.initialCounter as the initial value;\n      // it is disconnected from future prop updates.\n      counter: this.initialCounter\n    }\n  }\n}"
      },
      {
        "language": "text",
        "code": "export default {\n  props: ['initialCounter'],\n  data() {\n    return {\n      // counter only uses this.initialCounter as the initial value;\n      // it is disconnected from future prop updates.\n      counter: this.initialCounter\n    }\n  }\n}"
      },
      {
        "language": "text",
        "code": "const props = defineProps(['size'])\n\n// computed property that auto-updates when the prop changes\nconst normalizedSize = computed(() => props.size.trim().toLowerCase())"
      },
      {
        "language": "text",
        "code": "const props = defineProps(['size'])\n\n// computed property that auto-updates when the prop changes\nconst normalizedSize = computed(() => props.size.trim().toLowerCase())"
      },
      {
        "language": "text",
        "code": "export default {\n  props: ['size'],\n  computed: {\n    // computed property that auto-updates when the prop changes\n    normalizedSize() {\n      return this.size.trim().toLowerCase()\n    }\n  }\n}"
      },
      {
        "language": "text",
        "code": "export default {\n  props: ['size'],\n  computed: {\n    // computed property that auto-updates when the prop changes\n    normalizedSize() {\n      return this.size.trim().toLowerCase()\n    }\n  }\n}"
      },
      {
        "language": "text",
        "code": "defineProps()"
      },
      {
        "language": "text",
        "code": "defineProps({\n  // Basic type check\n  //  (`null` and `undefined` values will allow any type)\n  propA: Number,\n  // Multiple possible types\n  propB: [String, Number],\n  // Required string\n  propC: {\n    type: String,\n    required: true\n  },\n  // Required but nullable string\n  propD: {\n    type: [String, null],\n    required: true\n  },\n  // Number with a default value\n  propE: {\n    type: Number,\n    default: 100\n  },\n  // Object with a default value\n  propF: {\n    type: Object,\n    // Object or array defaults must be returned from\n    // a factory function. The function receives the raw\n    // props received by the component as the argument.\n    default(rawProps) {\n      return { message: 'hello' }\n    }\n  },\n  // Custom validator function\n  // full props passed as 2nd argument in 3.4+\n  propG: {\n    validator(value, props) {\n      // The value must match one of these strings\n      return ['success', 'warning', 'danger'].includes(value)\n    }\n  },\n  // Function with a default value\n  propH: {\n    type: Function,\n    // Unlike object or array default, this is not a factory\n    // function - this is a function to serve as a default value\n    default() {\n      return 'Default function'\n    }\n  }\n})"
      },
      {
        "language": "text",
        "code": "defineProps({\n  // Basic type check\n  //  (`null` and `undefined` values will allow any type)\n  propA: Number,\n  // Multiple possible types\n  propB: [String, Number],\n  // Required string\n  propC: {\n    type: String,\n    required: true\n  },\n  // Required but nullable string\n  propD: {\n    type: [String, null],\n    required: true\n  },\n  // Number with a default value\n  propE: {\n    type: Number,\n    default: 100\n  },\n  // Object with a default value\n  propF: {\n    type: Object,\n    // Object or array defaults must be returned from\n    // a factory function. The function receives the raw\n    // props received by the component as the argument.\n    default(rawProps) {\n      return { message: 'hello' }\n    }\n  },\n  // Custom validator function\n  // full props passed as 2nd argument in 3.4+\n  propG: {\n    validator(value, props) {\n      // The value must match one of these strings\n      return ['success', 'warning', 'danger'].includes(value)\n    }\n  },\n  // Function with a default value\n  propH: {\n    type: Function,\n    // Unlike object or array default, this is not a factory\n    // function - this is a function to serve as a default value\n    default() {\n      return 'Default function'\n    }\n  }\n})"
      },
      {
        "language": "text",
        "code": "defineProps()"
      },
      {
        "language": "text",
        "code": "<script setup>"
      },
      {
        "language": "text",
        "code": "export default {\n  props: {\n    // Basic type check\n    //  (`null` and `undefined` values will allow any type)\n    propA: Number,\n    // Multiple possible types\n    propB: [String, Number],\n    // Required string\n    propC: {\n      type: String,\n      required: true\n    },\n    // Required but nullable string\n    propD: {\n      type: [String, null],\n      required: true\n    },\n    // Number with a default value\n    propE: {\n      type: Number,\n      default: 100\n    },\n    // Object with a default value\n    propF: {\n      type: Object,\n      // Object or array defaults must be returned from\n      // a factory function. The function receives the raw\n      // props received by the component as the argument.\n      default(rawProps) {\n        return { message: 'hello' }\n      }\n    },\n    // Custom validator function\n    // full props passed as 2nd argument in 3.4+\n    propG: {\n      validator(value, props) {\n        // The value must match one of these strings\n        return ['success', 'warning', 'danger'].includes(value)\n      }\n    },\n    // Function with a default value\n    propH: {\n      type: Function,\n      // Unlike object or array default, this is not a factory\n      // function - this is a function to serve as a default value\n      default() {\n        return 'Default function'\n      }\n    }\n  }\n}"
      },
      {
        "language": "text",
        "code": "export default {\n  props: {\n    // Basic type check\n    //  (`null` and `undefined` values will allow any type)\n    propA: Number,\n    // Multiple possible types\n    propB: [String, Number],\n    // Required string\n    propC: {\n      type: String,\n      required: true\n    },\n    // Required but nullable string\n    propD: {\n      type: [String, null],\n      required: true\n    },\n    // Number with a default value\n    propE: {\n      type: Number,\n      default: 100\n    },\n    // Object with a default value\n    propF: {\n      type: Object,\n      // Object or array defaults must be returned from\n      // a factory function. The function receives the raw\n      // props received by the component as the argument.\n      default(rawProps) {\n        return { message: 'hello' }\n      }\n    },\n    // Custom validator function\n    // full props passed as 2nd argument in 3.4+\n    propG: {\n      validator(value, props) {\n        // The value must match one of these strings\n        return ['success', 'warning', 'danger'].includes(value)\n      }\n    },\n    // Function with a default value\n    propH: {\n      type: Function,\n      // Unlike object or array default, this is not a factory\n      // function - this is a function to serve as a default value\n      default() {\n        return 'Default function'\n      }\n    }\n  }\n}"
      },
      {
        "language": "text",
        "code": "required: true"
      },
      {
        "language": "text",
        "code": "default: undefined"
      },
      {
        "language": "text",
        "code": "defineProps<{ msg: string }>"
      },
      {
        "language": "text",
        "code": "{ msg: { type: String, required: true }}"
      },
      {
        "language": "text",
        "code": "class Person {\n  constructor(firstName, lastName) {\n    this.firstName = firstName\n    this.lastName = lastName\n  }\n}"
      },
      {
        "language": "text",
        "code": "class Person {\n  constructor(firstName, lastName) {\n    this.firstName = firstName\n    this.lastName = lastName\n  }\n}"
      },
      {
        "language": "text",
        "code": "defineProps({\n  author: Person\n})"
      },
      {
        "language": "text",
        "code": "defineProps({\n  author: Person\n})"
      },
      {
        "language": "text",
        "code": "export default {\n  props: {\n    author: Person\n  }\n}"
      },
      {
        "language": "text",
        "code": "export default {\n  props: {\n    author: Person\n  }\n}"
      },
      {
        "language": "text",
        "code": "instanceof Person"
      },
      {
        "language": "text",
        "code": "defineProps({\n  id: {\n    type: [String, null],\n    required: true\n  }\n})"
      },
      {
        "language": "text",
        "code": "defineProps({\n  id: {\n    type: [String, null],\n    required: true\n  }\n})"
      },
      {
        "language": "text",
        "code": "export default {\n  props: {\n    id: {\n      type: [String, null],\n      required: true\n    }\n  }\n}"
      },
      {
        "language": "text",
        "code": "export default {\n  props: {\n    id: {\n      type: [String, null],\n      required: true\n    }\n  }\n}"
      },
      {
        "language": "text",
        "code": "<MyComponent>"
      },
      {
        "language": "text",
        "code": "defineProps({\n  disabled: Boolean\n})"
      },
      {
        "language": "text",
        "code": "defineProps({\n  disabled: Boolean\n})"
      },
      {
        "language": "text",
        "code": "export default {\n  props: {\n    disabled: Boolean\n  }\n}"
      },
      {
        "language": "text",
        "code": "export default {\n  props: {\n    disabled: Boolean\n  }\n}"
      },
      {
        "language": "text",
        "code": "<!-- equivalent of passing :disabled=\"true\" -->\n<MyComponent disabled />\n\n<!-- equivalent of passing :disabled=\"false\" -->\n<MyComponent />"
      },
      {
        "language": "text",
        "code": "<!-- equivalent of passing :disabled=\"true\" -->\n<MyComponent disabled />\n\n<!-- equivalent of passing :disabled=\"false\" -->\n<MyComponent />"
      },
      {
        "language": "text",
        "code": "// disabled will be casted to true\ndefineProps({\n  disabled: [Boolean, Number]\n})\n\n// disabled will be casted to true\ndefineProps({\n  disabled: [Boolean, String]\n})\n\n// disabled will be casted to true\ndefineProps({\n  disabled: [Number, Boolean]\n})\n\n// disabled will be parsed as an empty string (disabled=\"\")\ndefineProps({\n  disabled: [String, Boolean]\n})"
      },
      {
        "language": "text",
        "code": "// disabled will be casted to true\ndefineProps({\n  disabled: [Boolean, Number]\n})\n\n// disabled will be casted to true\ndefineProps({\n  disabled: [Boolean, String]\n})\n\n// disabled will be casted to true\ndefineProps({\n  disabled: [Number, Boolean]\n})\n\n// disabled will be parsed as an empty string (disabled=\"\")\ndefineProps({\n  disabled: [String, Boolean]\n})"
      },
      {
        "language": "text",
        "code": "// disabled will be casted to true\nexport default {\n  props: {\n    disabled: [Boolean, Number]\n  }\n}\n\n// disabled will be casted to true\nexport default {\n  props: {\n    disabled: [Boolean, String]\n  }\n}\n\n// disabled will be casted to true\nexport default {\n  props: {\n    disabled: [Number, Boolean]\n  }\n}\n\n// disabled will be parsed as an empty string (disabled=\"\")\nexport default {\n  props: {\n    disabled: [String, Boolean]\n  }\n}"
      },
      {
        "language": "text",
        "code": "// disabled will be casted to true\nexport default {\n  props: {\n    disabled: [Boolean, Number]\n  }\n}\n\n// disabled will be casted to true\nexport default {\n  props: {\n    disabled: [Boolean, String]\n  }\n}\n\n// disabled will be casted to true\nexport default {\n  props: {\n    disabled: [Number, Boolean]\n  }\n}\n\n// disabled will be parsed as an empty string (disabled=\"\")\nexport default {\n  props: {\n    disabled: [String, Boolean]\n  }\n}"
      }
    ],
    "links": [
      {
        "text": "Components Basics",
        "href": "/guide/essentials/component-basics"
      },
      {
        "text": "Watch a free video lesson on Vue School",
        "href": "https://vueschool.io/lessons/vue-3-reusable-components-with-props?friend=vuejs"
      },
      {
        "text": "its dedicated section",
        "href": "/guide/components/attrs"
      },
      {
        "text": "props",
        "href": "/api/options-state#props"
      },
      {
        "text": "props",
        "href": "/api/options-state#props"
      },
      {
        "text": "Typing Component Props",
        "href": "/guide/typescript/options-api#typing-component-props"
      },
      {
        "text": "Typing Component Props",
        "href": "/guide/typescript/composition-api#typing-component-props"
      },
      {
        "text": "toValue",
        "href": "/api/reactivity-utilities#tovalue"
      },
      {
        "text": "in-DOM templates",
        "href": "/guide/essentials/component-basics#in-dom-template-parsing-caveats"
      },
      {
        "text": "PascalCase for component tags",
        "href": "/guide/components/registration#component-name-casing"
      },
      {
        "text": "v-bind without an argument",
        "href": "/guide/essentials/template-syntax#dynamically-binding-multiple-attributes"
      },
      {
        "text": "emit an event",
        "href": "/guide/components/events"
      },
      {
        "text": "Type-based props declarations",
        "href": "/api/sfc-script-setup#type-only-props-emit-declarations"
      },
      {
        "text": "Edit this page on GitHub",
        "href": "https://github.com/vuejs/docs/edit/main/src/guide/components/props.md"
      }
    ],
    "meta": {
      "description": "Vue.js - The Progressive JavaScript Framework",
      "keywords": ""
    },
    "summary": "Props This page assumes you've already read the Components Basics. Read that first if you are new to components",
    "tags": [
      "react",
      "vue",
      "angular",
      "javascript",
      "typescript",
      "css",
      "html",
      "vite",
      "props",
      "passing"
    ],
    "id": "props-propshtml-part-1",
    "quality": 80
  },
  {
    "title": "Component Events",
    "url": "https://vuejs.org/guide/components/events.html",
    "category": "vue",
    "content": "Component Events This page assumes you've already read the Components Basics. Read that first if you are new to components.Watch a free video lesson on Vue SchoolEmitting and Listening to Events A component can emit custom events directly in template expressions (e.g. in a v-on handler) using the built-in $emit method:template!-- MyComponent -- button @click=\"$emit('someEvent')\"Click Me/buttonThe $emit() method is also available on the component instance as this.$emit():jsexport default { methods: { submit() { this.$emit('someEvent') } } }The parent can then listen to it using v-on:templateMyComponent @some-event=\"callback\" /The .once modifier is also supported on component event listeners:templateMyComponent @some-event.once=\"callback\" /Like components and props, event names provide an automatic case transformation. Notice we emitted a camelCase event, but can listen for it using a kebab-cased listener in the parent. As with props casing, we recommend using kebab-cased event listeners in templates.TIPUnlike native DOM events, component emitted events do not bubble. You can only listen to the events emitted by a direct child component. If there is a need to communicate between sibling or deeply nested components, use an external event bus or a global state management solution.Event Arguments It's sometimes useful to emit a specific value with an event. For example, we may want the BlogPost component to be in charge of how much to enlarge the text by. In those cases, we can pass extra arguments to $emit to provide this value:templatebutton @click=\"$emit('increaseBy', 1)\" Increase by 1 /buttonThen, when we listen to the event in the parent, we can use an inline arrow function as the listener, which allows us to access the event argument:templateMyButton @increase-by=\"(n) = count += n\" /Or, if the event handler is a method:templateMyButton @increase-by=\"increaseCount\" /Then the value will be passed as the first parameter of that method:jsmethods: { increaseCount(n) { this.count += n } }jsfunction increaseCount(n) { count.value += n }TIPAll extra arguments passed to $emit() after the event name will be forwarded to the listener. For example, with $emit('foo', 1, 2, 3) the listener function will receive three arguments.Declaring Emitted Events A component can explicitly declare the events it will emit using the defineEmits() macroemits option:vuescript setup defineEmits(['inFocus', 'submit']) /scriptThe $emit method that we used in the template isn't accessible within the script setup section of a component, but defineEmits() returns an equivalent function that we can use instead:vuescript setup const emit = defineEmits(['inFocus', 'submit']) function buttonClick() { emit('submit') } /scriptThe defineEmits() macro cannot be used inside a function, it must be placed directly within script setup, as in the example above.If you're using an explicit setup function instead of script setup, events should be declared using the emits option, and the emit function is exposed on the setup() context:jsexport default { emits: ['inFocus', 'submit'], setup(props, ctx) { ctx.emit('submit') } }As with other properties of the setup() context, emit can safely be destructured:jsexport default { emits: ['inFocus', 'submit'], setup(props, { emit }) { emit('submit') } }jsexport default { emits: ['inFocus', 'submit'] }The emits option and defineEmits() macro also support an object syntax. If using TypeScript you can type arguments, which allows us to perform runtime validation of the payload of the emitted events:vuescript setup lang=\"ts\" const emit = defineEmits({ submit(payload: { email: string, password: string }) { // return true or false to indicate // validation pass / fail } }) /scriptIf you are using TypeScript with script setup, it's also possible to declare emitted events using pure type annotations:vuescript setup lang=\"ts\" const emit = defineEmits{ (e: 'change', id: number): void (e: 'update', value: string): void }() /scriptMore details: Typing Component Emits jsexport default { emits: { submit(payload: { email: string, password: string }) { // return true or false to indicate // validation pass / fail } } }See also: Typing Component Emits Although optional, it is recommended to define all emitted events in order to better document how a component should work. It also allows Vue to exclude known listeners from fallthrough attributes, avoiding edge cases caused by DOM events manually dispatched by 3rd party code.TIPIf a native event (e.g., click) is defined in the emits option, the listener will now only listen to component-emitted click events and no longer respond to native click events.Events Validation Similar to prop type validation, an emitted event can be validated if it is defined with the object syntax instead of the array syntax.To add validation, the event is assigned a function that receives the arguments passed to the this.$emitemit call and returns a boolean to indicate whether the event is valid or not.vuescript setup const emit = defineEmits({ // No validation click: null, // Validate submit event submit: ({ email, password }) = { if (email && password) { return true } else { console.warn('Invalid submit event payload!') return false } } }) function submitForm(email, password) { emit('submit', { email, password }) } /scriptjsexport default { emits: { // No validation click: null, // Validate submit event submit: ({ email, password }) = { if (email && password) { return true } else { console.warn('Invalid submit event payload!') return false } } }, methods: { submitForm(email, password) { this.$emit('submit', { email, password }) } } }Edit this page on GitHub",
    "headings": [
      {
        "level": 1,
        "text": "Component Events ​",
        "id": "component-events"
      },
      {
        "level": 2,
        "text": "Emitting and Listening to Events ​",
        "id": "emitting-and-listening-to-events"
      },
      {
        "level": 2,
        "text": "Event Arguments ​",
        "id": "event-arguments"
      },
      {
        "level": 2,
        "text": "Declaring Emitted Events ​",
        "id": "declaring-emitted-events"
      },
      {
        "level": 2,
        "text": "Events Validation ​",
        "id": "events-validation"
      }
    ],
    "codeBlocks": [
      {
        "language": "text",
        "code": "<!-- MyComponent -->\n<button @click=\"$emit('someEvent')\">Click Me</button>"
      },
      {
        "language": "text",
        "code": "<!-- MyComponent -->\n<button @click=\"$emit('someEvent')\">Click Me</button>"
      },
      {
        "language": "text",
        "code": "this.$emit()"
      },
      {
        "language": "text",
        "code": "export default {\n  methods: {\n    submit() {\n      this.$emit('someEvent')\n    }\n  }\n}"
      },
      {
        "language": "text",
        "code": "export default {\n  methods: {\n    submit() {\n      this.$emit('someEvent')\n    }\n  }\n}"
      },
      {
        "language": "text",
        "code": "<MyComponent @some-event=\"callback\" />"
      },
      {
        "language": "text",
        "code": "<MyComponent @some-event=\"callback\" />"
      },
      {
        "language": "text",
        "code": "<MyComponent @some-event.once=\"callback\" />"
      },
      {
        "language": "text",
        "code": "<MyComponent @some-event.once=\"callback\" />"
      },
      {
        "language": "text",
        "code": "<button @click=\"$emit('increaseBy', 1)\">\n  Increase by 1\n</button>"
      },
      {
        "language": "text",
        "code": "<button @click=\"$emit('increaseBy', 1)\">\n  Increase by 1\n</button>"
      },
      {
        "language": "text",
        "code": "<MyButton @increase-by=\"(n) => count += n\" />"
      },
      {
        "language": "text",
        "code": "<MyButton @increase-by=\"(n) => count += n\" />"
      },
      {
        "language": "text",
        "code": "<MyButton @increase-by=\"increaseCount\" />"
      },
      {
        "language": "text",
        "code": "<MyButton @increase-by=\"increaseCount\" />"
      },
      {
        "language": "text",
        "code": "methods: {\n  increaseCount(n) {\n    this.count += n\n  }\n}"
      },
      {
        "language": "text",
        "code": "methods: {\n  increaseCount(n) {\n    this.count += n\n  }\n}"
      },
      {
        "language": "text",
        "code": "function increaseCount(n) {\n  count.value += n\n}"
      },
      {
        "language": "text",
        "code": "function increaseCount(n) {\n  count.value += n\n}"
      },
      {
        "language": "text",
        "code": "$emit('foo', 1, 2, 3)"
      },
      {
        "language": "text",
        "code": "defineEmits()"
      },
      {
        "language": "text",
        "code": "<script setup>\ndefineEmits(['inFocus', 'submit'])\n</script>"
      },
      {
        "language": "text",
        "code": "<script setup>\ndefineEmits(['inFocus', 'submit'])\n</script>"
      },
      {
        "language": "text",
        "code": "<script setup>"
      },
      {
        "language": "text",
        "code": "defineEmits()"
      },
      {
        "language": "text",
        "code": "<script setup>\nconst emit = defineEmits(['inFocus', 'submit'])\n\nfunction buttonClick() {\n  emit('submit')\n}\n</script>"
      },
      {
        "language": "text",
        "code": "<script setup>\nconst emit = defineEmits(['inFocus', 'submit'])\n\nfunction buttonClick() {\n  emit('submit')\n}\n</script>"
      },
      {
        "language": "text",
        "code": "defineEmits()"
      },
      {
        "language": "text",
        "code": "<script setup>"
      },
      {
        "language": "text",
        "code": "<script setup>"
      },
      {
        "language": "text",
        "code": "export default {\n  emits: ['inFocus', 'submit'],\n  setup(props, ctx) {\n    ctx.emit('submit')\n  }\n}"
      },
      {
        "language": "text",
        "code": "export default {\n  emits: ['inFocus', 'submit'],\n  setup(props, ctx) {\n    ctx.emit('submit')\n  }\n}"
      },
      {
        "language": "text",
        "code": "export default {\n  emits: ['inFocus', 'submit'],\n  setup(props, { emit }) {\n    emit('submit')\n  }\n}"
      },
      {
        "language": "text",
        "code": "export default {\n  emits: ['inFocus', 'submit'],\n  setup(props, { emit }) {\n    emit('submit')\n  }\n}"
      },
      {
        "language": "text",
        "code": "export default {\n  emits: ['inFocus', 'submit']\n}"
      },
      {
        "language": "text",
        "code": "export default {\n  emits: ['inFocus', 'submit']\n}"
      },
      {
        "language": "text",
        "code": "defineEmits()"
      },
      {
        "language": "text",
        "code": "<script setup lang=\"ts\">\nconst emit = defineEmits({\n  submit(payload: { email: string, password: string }) {\n    // return `true` or `false` to indicate\n    // validation pass / fail\n  }\n})\n</script>"
      },
      {
        "language": "text",
        "code": "<script setup lang=\"ts\">\nconst emit = defineEmits({\n  submit(payload: { email: string, password: string }) {\n    // return `true` or `false` to indicate\n    // validation pass / fail\n  }\n})\n</script>"
      },
      {
        "language": "text",
        "code": "<script setup>"
      },
      {
        "language": "text",
        "code": "<script setup lang=\"ts\">\nconst emit = defineEmits<{\n  (e: 'change', id: number): void\n  (e: 'update', value: string): void\n}>()\n</script>"
      },
      {
        "language": "text",
        "code": "<script setup lang=\"ts\">\nconst emit = defineEmits<{\n  (e: 'change', id: number): void\n  (e: 'update', value: string): void\n}>()\n</script>"
      },
      {
        "language": "text",
        "code": "export default {\n  emits: {\n    submit(payload: { email: string, password: string }) {\n      // return `true` or `false` to indicate\n      // validation pass / fail\n    }\n  }\n}"
      },
      {
        "language": "text",
        "code": "export default {\n  emits: {\n    submit(payload: { email: string, password: string }) {\n      // return `true` or `false` to indicate\n      // validation pass / fail\n    }\n  }\n}"
      },
      {
        "language": "text",
        "code": "<script setup>\nconst emit = defineEmits({\n  // No validation\n  click: null,\n\n  // Validate submit event\n  submit: ({ email, password }) => {\n    if (email && password) {\n      return true\n    } else {\n      console.warn('Invalid submit event payload!')\n      return false\n    }\n  }\n})\n\nfunction submitForm(email, password) {\n  emit('submit', { email, password })\n}\n</script>"
      },
      {
        "language": "text",
        "code": "<script setup>\nconst emit = defineEmits({\n  // No validation\n  click: null,\n\n  // Validate submit event\n  submit: ({ email, password }) => {\n    if (email && password) {\n      return true\n    } else {\n      console.warn('Invalid submit event payload!')\n      return false\n    }\n  }\n})\n\nfunction submitForm(email, password) {\n  emit('submit', { email, password })\n}\n</script>"
      },
      {
        "language": "text",
        "code": "export default {\n  emits: {\n    // No validation\n    click: null,\n\n    // Validate submit event\n    submit: ({ email, password }) => {\n      if (email && password) {\n        return true\n      } else {\n        console.warn('Invalid submit event payload!')\n        return false\n      }\n    }\n  },\n  methods: {\n    submitForm(email, password) {\n      this.$emit('submit', { email, password })\n    }\n  }\n}"
      },
      {
        "language": "text",
        "code": "export default {\n  emits: {\n    // No validation\n    click: null,\n\n    // Validate submit event\n    submit: ({ email, password }) => {\n      if (email && password) {\n        return true\n      } else {\n        console.warn('Invalid submit event payload!')\n        return false\n      }\n    }\n  },\n  methods: {\n    submitForm(email, password) {\n      this.$emit('submit', { email, password })\n    }\n  }\n}"
      }
    ],
    "links": [
      {
        "text": "Components Basics",
        "href": "/guide/essentials/component-basics"
      },
      {
        "text": "Watch a free video lesson on Vue School",
        "href": "https://vueschool.io/lessons/defining-custom-events-emits?friend=vuejs"
      },
      {
        "text": "props casing",
        "href": "/guide/components/props#prop-name-casing"
      },
      {
        "text": "global state management solution",
        "href": "/guide/scaling-up/state-management"
      },
      {
        "text": "defineEmits()",
        "href": "/api/sfc-script-setup#defineprops-defineemits"
      },
      {
        "text": "emits",
        "href": "/api/options-state#emits"
      },
      {
        "text": "emits",
        "href": "/api/options-state#emits"
      },
      {
        "text": "Typing Component Emits",
        "href": "/guide/typescript/composition-api#typing-component-emits"
      },
      {
        "text": "Typing Component Emits",
        "href": "/guide/typescript/options-api#typing-component-emits"
      },
      {
        "text": "fallthrough attributes",
        "href": "/guide/components/attrs#v-on-listener-inheritance"
      },
      {
        "text": "Edit this page on GitHub",
        "href": "https://github.com/vuejs/docs/edit/main/src/guide/components/events.md"
      }
    ],
    "meta": {
      "description": "Vue.js - The Progressive JavaScript Framework",
      "keywords": ""
    },
    "summary": "Component Events This page assumes you've already read the Components Basics. Read that first if you are new to components",
    "tags": [
      "react",
      "vue",
      "angular",
      "javascript",
      "typescript",
      "html",
      "events",
      "component",
      "emitting",
      "listening"
    ],
    "id": "component-events-eventshtml-part-1",
    "quality": 100
  },
  {
    "title": "Slots",
    "url": "https://vuejs.org/guide/components/slots.html",
    "category": "vue",
    "content": "Slots This page assumes you've already read the Components Basics. Read that first if you are new to components.Watch a free video lesson on Vue SchoolSlot Content and Outlet We have learned that components can accept props, which can be JavaScript values of any type. But how about template content? In some cases, we may want to pass a template fragment to a child component, and let the child component render the fragment within its own template.For example, we may have a FancyButton component that supports usage like this:templateFancyButton Click me! !-- slot content -- /FancyButtonThe template of FancyButton looks like this:templatebutton class=\"fancy-btn\" slot/slot !-- slot outlet -- /buttonThe slot element is a slot outlet that indicates where the parent-provided slot content should be rendered.And the final rendered DOM:htmlbutton class=\"fancy-btn\"Click me!/buttonTry it in the PlaygroundTry it in the PlaygroundWith slots, the FancyButton is responsible for rendering the outer button (and its fancy styling), while the inner content is provided by the parent component.Another way to understand slots is by comparing them to JavaScript functions:js// parent component passing slot content FancyButton('Click me!') // FancyButton renders slot content in its own template function FancyButton(slotContent) { return button class=\"fancy-btn\" ${slotContent} /button }Slot content is not just limited to text. It can be any valid template content. For example, we can pass in multiple elements, or even other components:templateFancyButton span style=\"color:red\"Click me!/span AwesomeIcon name=\"plus\" / /FancyButtonTry it in the PlaygroundTry it in the PlaygroundBy using slots, our FancyButton is more flexible and reusable. We can now use it in different places with different inner content, but all with the same fancy styling.Vue components' slot mechanism is inspired by the native Web Component slot element, but with additional capabilities that we will see later.Render Scope Slot content has access to the data scope of the parent component, because it is defined in the parent. For example:templatespan{{ message }}/span FancyButton{{ message }}/FancyButtonHere both {{ message }} interpolations will render the same content.Slot content does not have access to the child component's data. Expressions in Vue templates can only access the scope it is defined in, consistent with JavaScript's lexical scoping. In other words:Expressions in the parent template only have access to the parent scope; expressions in the child template only have access to the child scope.Fallback Content There are cases when it's useful to specify fallback (i.e. default) content for a slot, to be rendered only when no content is provided. For example, in a SubmitButton component:templatebutton type=\"submit\" slot/slot /buttonWe might want the text \"Submit\" to be rendered inside the button if the parent didn't provide any slot content. To make \"Submit\" the fallback content, we can place it in between the slot tags:templatebutton type=\"submit\" slot Submit !-- fallback content -- /slot /buttonNow when we use SubmitButton in a parent component, providing no content for the slot:templateSubmitButton /This will render the fallback content, \"Submit\":htmlbutton type=\"submit\"Submit/buttonBut if we provide content:templateSubmitButtonSave/SubmitButtonThen the provided content will be rendered instead:htmlbutton type=\"submit\"Save/buttonTry it in the PlaygroundTry it in the PlaygroundNamed Slots There are times when it's useful to have multiple slot outlets in a single component. For example, in a BaseLayout component with the following template:templatediv class=\"container\" header !-- We want header content here -- /header main !-- We want main content here -- /main footer !-- We want footer content here -- /footer /divFor these cases, the slot element has a special attribute, name, which can be used to assign a unique ID to different slots so you can determine where content should be rendered:templatediv class=\"container\" header slot name=\"header\"/slot /header main slot/slot /main footer slot name=\"footer\"/slot /footer /divA slot outlet without name implicitly has the name \"default\".In a parent component using BaseLayout, we need a way to pass multiple slot content fragments, each targeting a different slot outlet. This is where named slots come in.To pass a named slot, we need to use a template element with the v-slot directive, and then pass the name of the slot as an argument to v-slot:templateBaseLayout template v-slot:header !-- content for the header slot -- /template /BaseLayoutv-slot has a dedicated shorthand #, so template v-slot:header can be shortened to just template #header. Think of it as \"render this template fragment in the child component's 'header' slot\".Here's the code passing content for all three slots to BaseLayout using the shorthand syntax:templateBaseLayout template #header h1Here might be a page title/h1 /template template #default pA paragraph for the main content./p pAnd another one./p /template template #footer pHere's some contact info/p /template /BaseLayoutWhen a component accepts both a default slot and named slots, all top-level non-template nodes are implicitly treated as content for the default slot. So the above can also be written as:templateBaseLayout template #header h1Here might be a page title/h1 /template !-- implicit default slot -- pA paragraph for the main content./p pAnd another one./p template #footer pHere's some contact info/p /template /BaseLayoutNow everything inside the template elements will be passed to the corresponding slots. The final rendered HTML will be:htmldiv class=\"container\" header h1Here might be a page title/h1 /header main pA paragraph for the main content./p pAnd another one./p /main footer pHere's some contact info/p /footer /divTry it in the PlaygroundTry it in the PlaygroundAgain, it may help you understand named slots better using the JavaScript function analogy:js// passing multiple slot fragments with different names BaseLayout({ header: ..., default: ..., footer: ... }) // BaseLayout renders them in different places function BaseLayout(slots) { return div class=\"container\" header${slots.header}/header main${slots.default}/main footer${slots.footer}/footer /div }Conditional Slots Sometimes you want to render something based on whether or not content has been passed to a slot.You can use the $slots property in combination with a v-if to achieve this.In the example below we define a Card component with three conditional slots: header, footer and the default one. When content for the header / footer / default is present, we want to wrap it to provide additional styling:templatetemplate div class=\"card\" div v-if=\"$slots.header\" class=\"card-header\" slot name=\"header\" / /div div v-if=\"$slots.default\" class=\"card-content\" slot / /div div v-if=\"$slots.footer\" class=\"card-footer\" slot name=\"footer\" / /div /div /templateTry it in the PlaygroundDynamic Slot Names Dynamic directive arguments also work on v-slot, allowing the definition of dynamic slot names:templatebase-layout template v-slot:[dynamicSlotName] ... /template !-- with shorthand -- template #[dynamicSlotName] ... /template /base-layoutDo note the expression is subject to the syntax constraints of dynamic directive arguments.Scoped Slots As discussed in Render Scope, slot content does not have access to state in the child component.However, there are cases where it could be useful if a slot's content can make use of data from both the parent scope and the child scope. To achieve that, we need a way for the child to pass data to a slot when rendering it.In fact, we can do exactly that - we can pass attributes to a slot outlet just like passing props to a component:template!-- MyComponent template -- div slot :text=\"greetingMessage\" :count=\"1\"/slot /divReceiving the slot props is a bit different when using a single default slot vs. using named slots. We are going to show how to receive props using a single default slot first, by using v-slot directly on the child component tag:templateMyComponent v-slot=\"slotProps\" {{ slotProps.text }} {{ slotProps.count }} /MyComponentTry it in the PlaygroundTry it in the PlaygroundThe props passed to the slot by the child are available as the value of the corresponding v-slot directive, which can be accessed by expressions inside the slot.You can think of a scoped slot as a function being passed into the child component. The child component then calls it, passing props as arguments:jsMyComponent({ // passing the default slot, but as a function default: (slotProps) = { return ${slotProps.text} ${slotProps.count} } }) function MyComponent(slots) { const greetingMessage = 'hello' return div${ // call the slot function with props! slots.default({ text: greetingMessage, count: 1 }) }/div }In fact, this is very close to how scoped slots are compiled, and how you would use scoped slots in manual render functions.Notice how v-slot=\"slotProps\" matches the slot function signature. Just like with function arguments, we can use destructuring in v-slot:templateMyComponent v-slot=\"{ text, count }\" {{ text }} {{ count }} /MyComponentNamed Scoped Slots Named scoped slots work similarly - slot props are accessible as the value of the v-slot directive: v-slot:name=\"slotProps\". When using the shorthand, it looks like this:templateMyComponent template #header=\"headerProps\" {{ headerProps }} /template template #default=\"defaultProps\" {{ defaultProps }} /template template #footer=\"footerProps\" {{ footerProps }} /template /MyComponentPassing props to a named slot:templateslot name=\"header\" message=\"hello\"/slotNote the name of a slot won't be included in the props because it is reserved - so the resulting headerProps would be { message: 'hello' }.If you are mixing named slots with the default scoped slot, you need to use an explicit template tag for the default slot. Attempting to place the v-slot directive directly on the component will result in a compilation error. This is to avoid any ambiguity about the scope of the props of the default slot. For example:template!-- MyComponent template -- div slot :message=\"hello\"/slot slot name=\"footer\" / /divtemplate!-- This template won't compile -- MyComponent v-slot=\"{ message }\" p{{ message }}/p template #footer !-- message belongs to the default slot, and is not available here -- p{{ message }}/p /template /MyComponentUsing an explicit template tag for the default slot helps to make it clear that the message prop is not available inside the other slot:templateMyComponent !-- Use explicit default slot -- template #default=\"{ message }\" p{{ message }}/p /template template #footer pHere's some contact info/p /template /MyComponentFancy List Example You may be wondering what would be a good use case for scoped slots. Here's an example: imagine a FancyList component that renders a list of items - it may encapsulate the logic for loading remote data, using the data to display a list, or even advanced features like pagination or infinite scrolling. However, we want it to be flexible with how each item looks and leave the styling of each item to the parent component consuming it. So the desired usage may look like this:templateFancyList :api-url=\"url\" :per-page=\"10\" template #item=\"{ body, username, likes }\" div class=\"item\" p{{ body }}/p pby {{ username }}  {{ likes }} likes/p /div /template /FancyListInside FancyList, we can render the same slot multiple times with different item data (notice we are using v-bind to pass an object as slot props):templateul li v-for=\"item in items\" slot name=\"item\" v-bind=\"item\"/slot /li /ulTry it in the PlaygroundTry it in the PlaygroundRenderless Components The FancyList use case we discussed above encapsulates both reusable logic (data fetching, pagination etc.) and visual output, while delegating part of the visual output to the consumer component via scoped slots.If we push this concept a bit further, we can come up with components that only encapsulate logic and do not render anything by themselves - visual output is fully delegated to the consumer component with scoped slots. We call this type of component a Renderless Component.An example renderless component could be one that encapsulates the logic of tracking the current mouse position:templateMouseTracker v-slot=\"{ x, y }\" Mouse is at: {{ x }}, {{ y }} /MouseTrackerTry it in the PlaygroundTry it in the PlaygroundWhile an interesting pattern, most of what can be achieved with Renderless Components can be achieved in a more efficient fashion with Composition API, without incurring the overhead of extra component nesting. Later, we will see how we can implement the same mouse tracking functionality as a Composable.That said, scoped slots are still useful in cases where we need to both encapsulate logic and compose visual output, like in the FancyList example.Edit this page on GitHub",
    "headings": [
      {
        "level": 1,
        "text": "Slots ​",
        "id": "slots"
      },
      {
        "level": 2,
        "text": "Slot Content and Outlet ​",
        "id": "slot-content-and-outlet"
      },
      {
        "level": 2,
        "text": "Render Scope ​",
        "id": "render-scope"
      },
      {
        "level": 2,
        "text": "Fallback Content ​",
        "id": "fallback-content"
      },
      {
        "level": 2,
        "text": "Named Slots ​",
        "id": "named-slots"
      },
      {
        "level": 2,
        "text": "Conditional Slots ​",
        "id": "conditional-slots"
      },
      {
        "level": 2,
        "text": "Dynamic Slot Names ​",
        "id": "dynamic-slot-names"
      },
      {
        "level": 2,
        "text": "Scoped Slots ​",
        "id": "scoped-slots"
      },
      {
        "level": 3,
        "text": "Named Scoped Slots ​",
        "id": "named-scoped-slots"
      },
      {
        "level": 3,
        "text": "Fancy List Example ​",
        "id": "fancy-list-example"
      },
      {
        "level": 3,
        "text": "Renderless Components ​",
        "id": "renderless-components"
      }
    ],
    "codeBlocks": [
      {
        "language": "text",
        "code": "<FancyButton>"
      },
      {
        "language": "text",
        "code": "<FancyButton>\n  Click me! <!-- slot content -->\n</FancyButton>"
      },
      {
        "language": "text",
        "code": "<FancyButton>\n  Click me! <!-- slot content -->\n</FancyButton>"
      },
      {
        "language": "text",
        "code": "<FancyButton>"
      },
      {
        "language": "text",
        "code": "<button class=\"fancy-btn\">\n  <slot></slot> <!-- slot outlet -->\n</button>"
      },
      {
        "language": "text",
        "code": "<button class=\"fancy-btn\">\n  <slot></slot> <!-- slot outlet -->\n</button>"
      },
      {
        "language": "text",
        "code": "<button class=\"fancy-btn\">Click me!</button>"
      },
      {
        "language": "text",
        "code": "<button class=\"fancy-btn\">Click me!</button>"
      },
      {
        "language": "text",
        "code": "<FancyButton>"
      },
      {
        "language": "text",
        "code": "// parent component passing slot content\nFancyButton('Click me!')\n\n// FancyButton renders slot content in its own template\nfunction FancyButton(slotContent) {\n  return `<button class=\"fancy-btn\">\n      ${slotContent}\n    </button>`\n}"
      },
      {
        "language": "text",
        "code": "// parent component passing slot content\nFancyButton('Click me!')\n\n// FancyButton renders slot content in its own template\nfunction FancyButton(slotContent) {\n  return `<button class=\"fancy-btn\">\n      ${slotContent}\n    </button>`\n}"
      },
      {
        "language": "text",
        "code": "<FancyButton>\n  <span style=\"color:red\">Click me!</span>\n  <AwesomeIcon name=\"plus\" />\n</FancyButton>"
      },
      {
        "language": "text",
        "code": "<FancyButton>\n  <span style=\"color:red\">Click me!</span>\n  <AwesomeIcon name=\"plus\" />\n</FancyButton>"
      },
      {
        "language": "text",
        "code": "<FancyButton>"
      },
      {
        "language": "text",
        "code": "<span>{{ message }}</span>\n<FancyButton>{{ message }}</FancyButton>"
      },
      {
        "language": "text",
        "code": "<span>{{ message }}</span>\n<FancyButton>{{ message }}</FancyButton>"
      },
      {
        "language": "text",
        "code": "{{ message }}"
      },
      {
        "language": "text",
        "code": "<SubmitButton>"
      },
      {
        "language": "text",
        "code": "<button type=\"submit\">\n  <slot></slot>\n</button>"
      },
      {
        "language": "text",
        "code": "<button type=\"submit\">\n  <slot></slot>\n</button>"
      },
      {
        "language": "text",
        "code": "<button type=\"submit\">\n  <slot>\n    Submit <!-- fallback content -->\n  </slot>\n</button>"
      },
      {
        "language": "text",
        "code": "<button type=\"submit\">\n  <slot>\n    Submit <!-- fallback content -->\n  </slot>\n</button>"
      },
      {
        "language": "text",
        "code": "<SubmitButton>"
      },
      {
        "language": "text",
        "code": "<SubmitButton />"
      },
      {
        "language": "text",
        "code": "<SubmitButton />"
      },
      {
        "language": "text",
        "code": "<button type=\"submit\">Submit</button>"
      },
      {
        "language": "text",
        "code": "<button type=\"submit\">Submit</button>"
      },
      {
        "language": "text",
        "code": "<SubmitButton>Save</SubmitButton>"
      },
      {
        "language": "text",
        "code": "<SubmitButton>Save</SubmitButton>"
      },
      {
        "language": "text",
        "code": "<button type=\"submit\">Save</button>"
      },
      {
        "language": "text",
        "code": "<button type=\"submit\">Save</button>"
      },
      {
        "language": "text",
        "code": "<BaseLayout>"
      },
      {
        "language": "text",
        "code": "<div class=\"container\">\n  <header>\n    <!-- We want header content here -->\n  </header>\n  <main>\n    <!-- We want main content here -->\n  </main>\n  <footer>\n    <!-- We want footer content here -->\n  </footer>\n</div>"
      },
      {
        "language": "text",
        "code": "<div class=\"container\">\n  <header>\n    <!-- We want header content here -->\n  </header>\n  <main>\n    <!-- We want main content here -->\n  </main>\n  <footer>\n    <!-- We want footer content here -->\n  </footer>\n</div>"
      },
      {
        "language": "text",
        "code": "<div class=\"container\">\n  <header>\n    <slot name=\"header\"></slot>\n  </header>\n  <main>\n    <slot></slot>\n  </main>\n  <footer>\n    <slot name=\"footer\"></slot>\n  </footer>\n</div>"
      },
      {
        "language": "text",
        "code": "<div class=\"container\">\n  <header>\n    <slot name=\"header\"></slot>\n  </header>\n  <main>\n    <slot></slot>\n  </main>\n  <footer>\n    <slot name=\"footer\"></slot>\n  </footer>\n</div>"
      },
      {
        "language": "text",
        "code": "<BaseLayout>"
      },
      {
        "language": "text",
        "code": "<BaseLayout>\n  <template v-slot:header>\n    <!-- content for the header slot -->\n  </template>\n</BaseLayout>"
      },
      {
        "language": "text",
        "code": "<BaseLayout>\n  <template v-slot:header>\n    <!-- content for the header slot -->\n  </template>\n</BaseLayout>"
      },
      {
        "language": "text",
        "code": "<template v-slot:header>"
      },
      {
        "language": "text",
        "code": "<template #header>"
      },
      {
        "language": "text",
        "code": "<BaseLayout>"
      },
      {
        "language": "text",
        "code": "<BaseLayout>\n  <template #header>\n    <h1>Here might be a page title</h1>\n  </template>\n\n  <template #default>\n    <p>A paragraph for the main content.</p>\n    <p>And another one.</p>\n  </template>\n\n  <template #footer>\n    <p>Here's some contact info</p>\n  </template>\n</BaseLayout>"
      },
      {
        "language": "text",
        "code": "<BaseLayout>\n  <template #header>\n    <h1>Here might be a page title</h1>\n  </template>\n\n  <template #default>\n    <p>A paragraph for the main content.</p>\n    <p>And another one.</p>\n  </template>\n\n  <template #footer>\n    <p>Here's some contact info</p>\n  </template>\n</BaseLayout>"
      },
      {
        "language": "text",
        "code": "<BaseLayout>\n  <template #header>\n    <h1>Here might be a page title</h1>\n  </template>\n\n  <!-- implicit default slot -->\n  <p>A paragraph for the main content.</p>\n  <p>And another one.</p>\n\n  <template #footer>\n    <p>Here's some contact info</p>\n  </template>\n</BaseLayout>"
      },
      {
        "language": "text",
        "code": "<BaseLayout>\n  <template #header>\n    <h1>Here might be a page title</h1>\n  </template>\n\n  <!-- implicit default slot -->\n  <p>A paragraph for the main content.</p>\n  <p>And another one.</p>\n\n  <template #footer>\n    <p>Here's some contact info</p>\n  </template>\n</BaseLayout>"
      },
      {
        "language": "text",
        "code": "<div class=\"container\">\n  <header>\n    <h1>Here might be a page title</h1>\n  </header>\n  <main>\n    <p>A paragraph for the main content.</p>\n    <p>And another one.</p>\n  </main>\n  <footer>\n    <p>Here's some contact info</p>\n  </footer>\n</div>"
      },
      {
        "language": "text",
        "code": "<div class=\"container\">\n  <header>\n    <h1>Here might be a page title</h1>\n  </header>\n  <main>\n    <p>A paragraph for the main content.</p>\n    <p>And another one.</p>\n  </main>\n  <footer>\n    <p>Here's some contact info</p>\n  </footer>\n</div>"
      },
      {
        "language": "text",
        "code": "// passing multiple slot fragments with different names\nBaseLayout({\n  header: `...`,\n  default: `...`,\n  footer: `...`\n})\n\n// <BaseLayout> renders them in different places\nfunction BaseLayout(slots) {\n  return `<div class=\"container\">\n      <header>${slots.header}</header>\n      <main>${slots.default}</main>\n      <footer>${slots.footer}</footer>\n    </div>`\n}"
      },
      {
        "language": "text",
        "code": "// passing multiple slot fragments with different names\nBaseLayout({\n  header: `...`,\n  default: `...`,\n  footer: `...`\n})\n\n// <BaseLayout> renders them in different places\nfunction BaseLayout(slots) {\n  return `<div class=\"container\">\n      <header>${slots.header}</header>\n      <main>${slots.default}</main>\n      <footer>${slots.footer}</footer>\n    </div>`\n}"
      },
      {
        "language": "text",
        "code": "<template>\n  <div class=\"card\">\n    <div v-if=\"$slots.header\" class=\"card-header\">\n      <slot name=\"header\" />\n    </div>\n    \n    <div v-if=\"$slots.default\" class=\"card-content\">\n      <slot />\n    </div>\n    \n    <div v-if=\"$slots.footer\" class=\"card-footer\">\n      <slot name=\"footer\" />\n    </div>\n  </div>\n</template>"
      },
      {
        "language": "text",
        "code": "<template>\n  <div class=\"card\">\n    <div v-if=\"$slots.header\" class=\"card-header\">\n      <slot name=\"header\" />\n    </div>\n    \n    <div v-if=\"$slots.default\" class=\"card-content\">\n      <slot />\n    </div>\n    \n    <div v-if=\"$slots.footer\" class=\"card-footer\">\n      <slot name=\"footer\" />\n    </div>\n  </div>\n</template>"
      },
      {
        "language": "text",
        "code": "<base-layout>\n  <template v-slot:[dynamicSlotName]>\n    ...\n  </template>\n\n  <!-- with shorthand -->\n  <template #[dynamicSlotName]>\n    ...\n  </template>\n</base-layout>"
      },
      {
        "language": "text",
        "code": "<base-layout>\n  <template v-slot:[dynamicSlotName]>\n    ...\n  </template>\n\n  <!-- with shorthand -->\n  <template #[dynamicSlotName]>\n    ...\n  </template>\n</base-layout>"
      },
      {
        "language": "text",
        "code": "<!-- <MyComponent> template -->\n<div>\n  <slot :text=\"greetingMessage\" :count=\"1\"></slot>\n</div>"
      },
      {
        "language": "text",
        "code": "<!-- <MyComponent> template -->\n<div>\n  <slot :text=\"greetingMessage\" :count=\"1\"></slot>\n</div>"
      },
      {
        "language": "text",
        "code": "<MyComponent v-slot=\"slotProps\">\n  {{ slotProps.text }} {{ slotProps.count }}\n</MyComponent>"
      },
      {
        "language": "text",
        "code": "<MyComponent v-slot=\"slotProps\">\n  {{ slotProps.text }} {{ slotProps.count }}\n</MyComponent>"
      },
      {
        "language": "text",
        "code": "MyComponent({\n  // passing the default slot, but as a function\n  default: (slotProps) => {\n    return `${slotProps.text} ${slotProps.count}`\n  }\n})\n\nfunction MyComponent(slots) {\n  const greetingMessage = 'hello'\n  return `<div>${\n    // call the slot function with props!\n    slots.default({ text: greetingMessage, count: 1 })\n  }</div>`\n}"
      },
      {
        "language": "text",
        "code": "MyComponent({\n  // passing the default slot, but as a function\n  default: (slotProps) => {\n    return `${slotProps.text} ${slotProps.count}`\n  }\n})\n\nfunction MyComponent(slots) {\n  const greetingMessage = 'hello'\n  return `<div>${\n    // call the slot function with props!\n    slots.default({ text: greetingMessage, count: 1 })\n  }</div>`\n}"
      },
      {
        "language": "text",
        "code": "v-slot=\"slotProps\""
      },
      {
        "language": "text",
        "code": "<MyComponent v-slot=\"{ text, count }\">\n  {{ text }} {{ count }}\n</MyComponent>"
      },
      {
        "language": "text",
        "code": "<MyComponent v-slot=\"{ text, count }\">\n  {{ text }} {{ count }}\n</MyComponent>"
      },
      {
        "language": "text",
        "code": "v-slot:name=\"slotProps\""
      },
      {
        "language": "text",
        "code": "<MyComponent>\n  <template #header=\"headerProps\">\n    {{ headerProps }}\n  </template>\n\n  <template #default=\"defaultProps\">\n    {{ defaultProps }}\n  </template>\n\n  <template #footer=\"footerProps\">\n    {{ footerProps }}\n  </template>\n</MyComponent>"
      },
      {
        "language": "text",
        "code": "<MyComponent>\n  <template #header=\"headerProps\">\n    {{ headerProps }}\n  </template>\n\n  <template #default=\"defaultProps\">\n    {{ defaultProps }}\n  </template>\n\n  <template #footer=\"footerProps\">\n    {{ footerProps }}\n  </template>\n</MyComponent>"
      },
      {
        "language": "text",
        "code": "<slot name=\"header\" message=\"hello\"></slot>"
      },
      {
        "language": "text",
        "code": "<slot name=\"header\" message=\"hello\"></slot>"
      },
      {
        "language": "text",
        "code": "headerProps"
      },
      {
        "language": "text",
        "code": "{ message: 'hello' }"
      },
      {
        "language": "text",
        "code": "<!-- <MyComponent> template -->\n<div>\n  <slot :message=\"hello\"></slot>\n  <slot name=\"footer\" />\n</div>"
      },
      {
        "language": "text",
        "code": "<!-- <MyComponent> template -->\n<div>\n  <slot :message=\"hello\"></slot>\n  <slot name=\"footer\" />\n</div>"
      },
      {
        "language": "text",
        "code": "<!-- This template won't compile -->\n<MyComponent v-slot=\"{ message }\">\n  <p>{{ message }}</p>\n  <template #footer>\n    <!-- message belongs to the default slot, and is not available here -->\n    <p>{{ message }}</p>\n  </template>\n</MyComponent>"
      },
      {
        "language": "text",
        "code": "<!-- This template won't compile -->\n<MyComponent v-slot=\"{ message }\">\n  <p>{{ message }}</p>\n  <template #footer>\n    <!-- message belongs to the default slot, and is not available here -->\n    <p>{{ message }}</p>\n  </template>\n</MyComponent>"
      },
      {
        "language": "text",
        "code": "<MyComponent>\n  <!-- Use explicit default slot -->\n  <template #default=\"{ message }\">\n    <p>{{ message }}</p>\n  </template>\n\n  <template #footer>\n    <p>Here's some contact info</p>\n  </template>\n</MyComponent>"
      },
      {
        "language": "text",
        "code": "<MyComponent>\n  <!-- Use explicit default slot -->\n  <template #default=\"{ message }\">\n    <p>{{ message }}</p>\n  </template>\n\n  <template #footer>\n    <p>Here's some contact info</p>\n  </template>\n</MyComponent>"
      },
      {
        "language": "text",
        "code": "<FancyList>"
      },
      {
        "language": "text",
        "code": "<FancyList :api-url=\"url\" :per-page=\"10\">\n  <template #item=\"{ body, username, likes }\">\n    <div class=\"item\">\n      <p>{{ body }}</p>\n      <p>by {{ username }} | {{ likes }} likes</p>\n    </div>\n  </template>\n</FancyList>"
      },
      {
        "language": "text",
        "code": "<FancyList :api-url=\"url\" :per-page=\"10\">\n  <template #item=\"{ body, username, likes }\">\n    <div class=\"item\">\n      <p>{{ body }}</p>\n      <p>by {{ username }} | {{ likes }} likes</p>\n    </div>\n  </template>\n</FancyList>"
      },
      {
        "language": "text",
        "code": "<FancyList>"
      },
      {
        "language": "text",
        "code": "<ul>\n  <li v-for=\"item in items\">\n    <slot name=\"item\" v-bind=\"item\"></slot>\n  </li>\n</ul>"
      },
      {
        "language": "text",
        "code": "<ul>\n  <li v-for=\"item in items\">\n    <slot name=\"item\" v-bind=\"item\"></slot>\n  </li>\n</ul>"
      },
      {
        "language": "text",
        "code": "<FancyList>"
      },
      {
        "language": "text",
        "code": "<MouseTracker v-slot=\"{ x, y }\">\n  Mouse is at: {{ x }}, {{ y }}\n</MouseTracker>"
      },
      {
        "language": "text",
        "code": "<MouseTracker v-slot=\"{ x, y }\">\n  Mouse is at: {{ x }}, {{ y }}\n</MouseTracker>"
      },
      {
        "language": "text",
        "code": "<FancyList>"
      }
    ],
    "links": [
      {
        "text": "Components Basics",
        "href": "/guide/essentials/component-basics"
      },
      {
        "text": "Watch a free video lesson on Vue School",
        "href": "https://vueschool.io/lessons/vue-3-component-slots?friend=vuejs"
      },
      {
        "text": "Try it in the Playground",
        "href": "https://play.vuejs.org/#eNpdUdlqAyEU/ZVbQ0kLMdNsXabTQFvoV8yLcRkkjopLSQj596oTwqRvnuM9y9UT+rR2/hs5qlHjqZM2gOch2m2rZW+NC/BDND1+xRCMBuFMD9N5NeKyeNrqphrUSZdA4L1VJPCEAJrRdCEAvpWke+g5NHcYg1cmADU6cB0A4zzThmYckqimupqiGfpXILe/zdwNhaki3n+0SOR5vAu6ReU++efUajtqYGJQ/FIg5w8Wt9FlOx+OKh/nV1c4ZVNqlHE1TIQQ7xnvCN13zkTNalBSc+Jw5wiTac2H1WLDeDeDyXrJVm9LWG7uE3hev3AhHge1cYwnO200L4QljEnd1bCxB1g82UNhe+I6qQs5kuGcE30NrxeaRudzOWtkemeXuHP5tLIKOv8BN+mw3w=="
      },
      {
        "text": "Try it in the Playground",
        "href": "https://play.vuejs.org/#eNpdUdtOwzAM/RUThAbSurIbl1ImARJf0ZesSapoqROlKdo07d9x0jF1SHmIT+xzcY7sw7nZTy9Zwcqu9tqFTYW6ddYH+OZYHz77ECyC8raFySwfYXFsUiFAhXKfBoRUvDcBjhGtLbGgxNAVcLziOlVIp8wvelQE2TrDg6QKoBx1JwDgy+h6B62E8ibLoDM2kAAGoocsiz1VKMfmCCrzCymbsn/GY95rze1grja8694rpmJ/tg1YsfRO/FE134wc2D4YeTYQ9QeKa+mUrgsHE6+zC+vfjoz1Bdwqpd5iveX1rvG2R1GA0Si5zxrPhaaY98v5WshmCrerhVi+LmCxvqPiafUslXoYpq0XkuiQ1p4Ax4XQ2BSwdnuYP7p9QlvuG40JHI1lUaenv3o5w3Xvu2jOWU179oQNn5aisNMvLBvDOg=="
      },
      {
        "text": "Try it in the Playground",
        "href": "https://play.vuejs.org/#eNp1UmtOwkAQvspQYtCEgrx81EqCJibeoX+W7bRZaHc3+1AI4QyewH8ewvN4Aa/gbgtNIfFf5+vMfI/ZXbCQcvBmMYiCWFPFpAGNxsp5wlkphTLwQjjdPlljBIdMiRJ6g2EL88O9pnnxjlqU+EpbzS3s0BwPaypH4gqDpSyIQVcBxK3VFQDwXDC6hhJdlZi4zf3fRKwl4aDNtsDHJKCiECqiW8KTYH5c1gEnwnUdJ9rCh/XeM6Z42AgN+sFZAj6+Ux/LOjFaEK2diMz3h0vjNfj/zokuhPFU3lTdfcpShVOZcJ+DZgHs/HxtCrpZlj34eknoOlfC8jSCgnEkKswVSRlyczkZzVLM+9CdjtPJ/RjGswtX3ExvMcuu6mmhUnTruOBYAZKkKeN5BDO5gdG13FRoSVTOeAW2xkLPY3UEdweYWqW9OCkYN6gctq9uXllx2Z09CJ9dJwzBascI7nBYihWDldUGMqEgdTVIq6TQqCEMfUpNSD+fX7/fH+3b7P8AdGP6wA=="
      },
      {
        "text": "Try it in the Playground",
        "href": "https://play.vuejs.org/#eNptUltu2zAQvMpGQZEWsOzGiftQ1QBpgQK9g35oaikwkUiCj9aGkTPkBPnLIXKeXCBXyJKKBdoIoA/tYGd3doa74tqY+b+ARVXUjltp/FWj5GC09fCHKb79FbzXCoTVA5zNFxkWaWdT8/V/dHrAvzxrzrC3ZoBG4SYRWhQs9B52EeWapihU3lWwyxfPDgbfNYq+ejEppcLjYHrmkSqAOqMmAOB3L/ktDEhV4+v8gMR/l1M7wxQ4v+3xZ1Nw3Wtb8S1TTXG1H3cCJIO69oxc5mLUcrSrXkxSi1lxZGT0//CS9Wg875lzJELE/nLto4bko69dr31cFc8auw+3JHvSEfQ7nwbsHY9HwakQ4kes14zfdlYH1VbQS4XMlp1lraRMPl6cr1rsZnB6uWwvvi9hufpAxZfLryjEp5GtbYs0TlGICTCsbaXqKliZDZx/NpuEDsx2UiUwo5VxT6Dkv73BPFgXxRktlUdL2Jh6OoW8O3pX0buTsoTgaCNQcDjoGwk3wXkQ2tJLGzSYYI126KAso0uTSc8Pjy9P93k2d6+NyRKa"
      },
      {
        "text": "native Web Component <slot> element",
        "href": "https://developer.mozilla.org/en-US/docs/Web/HTML/Element/slot"
      },
      {
        "text": "Try it in the Playground",
        "href": "https://play.vuejs.org/#eNp1kMsKwjAQRX9lzMaNbfcSC/oL3WbT1ikU8yKZFEX8d5MGgi2YVeZxZ86dN7taWy8B2ZlxP7rZEnikYFuhZ2WNI+jCoGa6BSKjYXJGwbFufpNJfhSaN1kflTEgVFb2hDEC4IeqguARpl7KoR8fQPgkqKpc3Wxo1lxRWWeW+Y4wBk9x9V9d2/UL8g1XbOJN4WAntodOnrecQ2agl8WLYH7tFyw5olj10iR3EJ+gPCxDFluj0YS6EAqKR8mi9M3Td1ifLxWShcU="
      },
      {
        "text": "Try it in the Playground",
        "href": "https://play.vuejs.org/#eNp1UEEOwiAQ/MrKxYu1d4Mm+gWvXChuk0YKpCyNxvh3lxIb28SEA8zuDDPzEucQ9mNCcRAymqELdFKu64MfCK6p6Tu6JCLvoB18D9t9/Qtm4lY5AOXwMVFu2OpkCV4ZNZ51HDqKhwLAQjIjb+X4yHr+mh+EfbCakF8AclNVkCJCq61ttLkD4YOgqsp0YbGesJkVBj92NwSTIrH3v7zTVY8oF8F4SdazD7ET69S5rqXPpnigZ8CjEnHaVyInIp5G63O6XIGiIlZMzrGMd8RVfR0q4lIKKV+L+srW+wNTTZq3"
      },
      {
        "text": "Try it in the Playground",
        "href": "https://play.vuejs.org/#eNp9UsFuwjAM/RWrHLgMOi5o6jIkdtphn9BLSF0aKU2ixEVjiH+fm8JoQdvRfu/5xS8+ZVvvl4cOsyITUQXtCSJS5zel1a13geBdRvyUR9cR1MG1MF/mt1YvnZdW5IOWVVwQtt5IQq4AxI2cau5ccZg1KCsMlz4jzWrzgQGh1fuGYIcgwcs9AmkyKHKGLyPykcfD1Apr2ZmrHUN+s+U5Qe6D9A3ULgA1bCK1BeUsoaWlyPuVb3xbgbSOaQGcxRH8v3XtHI0X8mmfeYToWkxmUhFoW7s/JvblJLERmj1l0+T7T5tqK30AZWSMb2WW3LTFUGZXp/u8o3EEVrbI9AFjLn8mt38fN9GIPrSp/p4/Yoj7OMZ+A/boN9KInPeZZpAOLNLRDAsPZDgN4p0L/NQFOV/Ayn9x6EZXMFNKvQ4E5YwLBczW6/WlU3NIi6i/sYDn5Qu2qX1OF51MsvMPkrIEHg=="
      },
      {
        "text": "Try it in the Playground",
        "href": "https://play.vuejs.org/#eNp9UkFuwjAQ/MoqHLiUpFxQlaZI9NRDn5CLSTbEkmNb9oKgiL934wRwQK3ky87O7njGPicba9PDHpM8KXzlpKV1qWVnjSP4FB6/xcnsCRpnOpin2R3qh+alBig1HgO9xkbsFcG5RyvDOzRq8vkAQLSury+l5lNkN1EuCDurBCFXAMWdH2pGrn2YtShqdCPOnXa5/kKH0MldS7BFEGDFDoEkKSwybo8rskjjaevo4L7Wrje8x4mdE7aFxjiglkWE1GxQE9tLi8xO+LoGoQ3THLD/qP2/dGMMxYZs8DP34E2HQUxUBFI35o+NfTlJLOomL8n04frXns7W8gCVEt5/lElQkxpdmVyVHvP2yhBo0SHThx5z+TEZvl1uMlP0oU3nH/kRo3iMI9Ybes960UyRsZ9pBuGDeTqpwfBAvn7NrXF81QUZm8PSHjl0JWuYVVX1PhAqo4zLYbZarUak4ZAWXv5gDq/pG3YBHn50EEkuv5irGBk="
      },
      {
        "text": "$slots",
        "href": "/api/component-instance#slots"
      },
      {
        "text": "v-if",
        "href": "/guide/essentials/conditional#v-if"
      },
      {
        "text": "Try it in the Playground",
        "href": "https://play.vuejs.org/#eNqVVMtu2zAQ/BWCLZBLIjVoTq4aoA1yaA9t0eaoCy2tJcYUSZCUKyPwv2dJioplOw4C+EDuzM4+ONYT/aZ1tumBLmhhK8O1IxZcr29LyTutjCN3zNRkZVRHLrLcXzz9opRFHvnIxIuDTgvmAG+EFJ4WTnhOCPnQAqvBjHFE2uvbh5Zbgj/XAolwkWN4TM33VI/UalixXvjyo5yeqVVKOpCuyP0ob6utlHL7vUE3U4twkWP4hJq/jiPP4vSSOouNrHiTPVolcclPnl3SSnWaCzC/teNK2pIuSEA8xoRQ/3+GmDM9XKZ41UK1PhF/tIOPlfSPAQtmAyWdMMdMAy7C9/9+wYDnCexU3QtknwH/glWi9z1G2vde1tj2Hi90+yNYhcvmwd4PuHabhvKNeuYu8EuK1rk7M/pLu5+zm5BXyh1uMdnOu3S+95pvSCWYtV9xQcgqaXogj2yu+AqBj1YoZ7NosJLOEq5S9OXtPZtI1gFSppx8engUHs+vVhq9eVhq9ORRrXdpRyseSqfo6SmmnONK6XTw9yis24q448wXSG+0VAb3sSDXeiBoDV6TpWDV+ktENatrdMGCfAoBfL1JYNzzpINJjVFoJ9yKUKho19ul6OFQ6UYPx1rjIpPYeXIc/vXCgjetawzbni0dPnhhJ3T3DMVSruI="
      },
      {
        "text": "Dynamic directive arguments",
        "href": "/guide/essentials/template-syntax#dynamic-arguments"
      },
      {
        "text": "syntax constraints",
        "href": "/guide/essentials/template-syntax#dynamic-argument-syntax-constraints"
      },
      {
        "text": "Try it in the Playground",
        "href": "https://play.vuejs.org/#eNp9kMEKgzAMhl8l9OJlU3aVOhg7C3uAXsRlTtC2tFE2pO++dA5xMnZqk+b/8/2dxMnadBxQ5EL62rWWwCMN9qh021vjCMrn2fBNoya4OdNDkmarXhQnSstsVrOOC8LedhVhrEiuHca97wwVSsTj4oz1SvAUgKJpgqWZEj4IQoCvZm0Gtgghzss1BDvIbFkqdmID+CNdbbQnaBwitbop0fuqQSgguWPXmX+JePe1HT/QMtJBHnE51MZOCcjfzPx04JxsydPzp2Szxxo7vABY1I/p"
      },
      {
        "text": "Try it in the Playground",
        "href": "https://play.vuejs.org/#eNqFkNFqxCAQRX9l8CUttAl9DbZQ+rzQD/AlJLNpwKjoJGwJ/nvHpAnusrAg6FzHO567iE/nynlCUQsZWj84+lBmGJ31BKffL8sng4bg7O0IRVllWnpWKAOgDF7WBx2em0kTLElt975QbwLkhkmIyvCS1TGXC8LR6YYwVSTzH8yvQVt6VyJt3966oAR38XhaFjjEkvBCECNcia2d2CLyOACZQ7CDrI6h4kXcAF7lcg+za6h5et4JPdLkzV4B9B6RBtOfMISmxxqKH9TarrGtATxMgf/bDfM/qExEUCdEDuLGXAmoV06+euNs2JK7tyCrzSNHjX9aurQf"
      },
      {
        "text": "render functions",
        "href": "/guide/extras/render-function"
      },
      {
        "text": "Try it in the Playground",
        "href": "https://play.vuejs.org/#eNqFU2Fv0zAQ/StHJtROapNuZTBCNwnQQKBpTGxCQss+uMml8+bYlu2UlZL/zjlp0lQa40sU3/nd3Xv3vA7eax0uSwziYGZTw7UDi67Up4nkhVbGwScm09U5tw5yowoYhFEX8cBBImdRgyQMHRwWWjCHdAKYbdFM83FpxEkS0DcJINZoxpotkCIHkySo7xOixcMep19KrmGustUISotGsgJHIPgDWqg6DKEyvoRUMGsJ4HG9HGX16bqpAlU1izy5baqDFegYweYroMttMwLAHx/Y9Kyan36RWUTN2+mjXfpbrei8k6SjdSuBYFOlMaNI6AeAtcflSrqx5b8xhkl4jMU7H0yVUCaGvVeH8+PjKYWqWnpf5DQYBTtb+fc612Awh2qzzGaBiUyVpBVpo7SFE8gw5xIv/Wl4M9gsbjCCQbuywe3+FuXl9iiqO7xpElEEhUofKFQo2mTGiFiOLr3jcpFImuiaF6hKNxzuw8lpw7kuEy6ZKJGK3TR6NluLYXBVqwRXQjkLn0ueIc3TLonyZ0sm4acqKVovKIbDCVQjGsb1qvyg2telU4Yzz6eHv6ARBWdwjVqUNCbbFjqgQn6aW1J8RKfJhDg+5/lStG4QHJZjnpO5XjT0BMqFu+uZ81yxjEQJw7A1kOA76FyZjaWBy0akvu8tCQKeQ+d7wsy5zLpz1FlzU3kW1QP+x40ApWgWAySEJTv6/NitNMkllcTakwCaZZ5ADEf6cROas/RhYVQps5igEpkZLwzRROmG04OjDBcj7+Js+vYQDo9e0uH1qzeY5/s1vtaaqG969+vTTrsmBTMLLv12nuy7l+d5W673SBzxkzlfhPdWSXokdZMkSFWhuUDzTTtOnk6CuG2fBEwI9etrHXOmRLJUE0/vMH14In5vH30sCS4Nkr+WmARdztHQ6Jr02dUFPtJ/lyxUVgq6/UzyO1olSj9jc+0DcaWxe/fqab/UT51Uu7Znjw6lbUn5QWtR6vtJQM//4zPUt+NOw+lGzCqo/gLm1QS8"
      },
      {
        "text": "Try it in the Playground",
        "href": "https://play.vuejs.org/#eNqNVNtq20AQ/ZWpQnECujhO0qaqY+hD25fQl4RCifKwllbKktXushcT1/W/d1bSSnYJNCCEZmbPmcuZ1S76olS6cTTKo6UpNVN2VQjWKqktfCOi3N4yY6HWsoVZmo0eD5kVAqAQ9KU7XNGaOG5h572lRAZBhTV574CJzJv7QuCzzMaMaFjaKk4sRQtgOeUmiiVO85siwncRQa6oThRpKHrO50XUnUdEwMMJw08M7mAtq20MzlAtSEtj4OyZGkweMIiq2AZKToxBgMcdxDCqVrueBfb7ZaaOQiOspZYgbL0FPBySIQD+eMeQc99/HJIsM0weqs+O258mjfZREE1jt5yCKaWiFXpSX0A/5loKmxj2m+YwT69p+7kXg0udw8nlYn19fYGufvSeZBXF0ZGmR2vwmrJKS4WiPswGWWYxzIIgs8fYH6mIJadnQXdNrdMiWAB+yJ7gsXdgLfjqcK10wtJqgmYZ+spnpGgl6up5oaa2fGKi6U8Yau9ZS6Wzpwi7WU1p7BMzaZcLbuBh0q2XM4fZXTc+uOPSGvjuWEWxlaAexr9uiIBf0qG3Uy6HxXwo9B+mn47CvbNSM+LHccDxAyvmjMA9Vdxh1WQiO0eywBVGEaN3Pj972wVxPKwOZ7BJWI2b+K5rOOVUNPbpYJNvJalwZmmahm3j7AhdSz3sPzDRS3R4SQwOCXxP4yVBzJqJarSzcY8H5mXWFfif1QVwPGjGcQWTLp7YrcLxCfyDdAuMW0cq30AOV+plcK1J+dxoXJkqR6igRCeNxjbxp3N6cX5V0Sb2K19dfFrA4uo9Gh8uP9K6Puvw3eyx9SH3IT/qPCZpiW6Y8Gq9mvekrutAN96o/V99ALPj"
      },
      {
        "text": "Try it in the Playground",
        "href": "https://play.vuejs.org/#eNqNUcFqhDAQ/ZUhF12w2rO4Cz301t5aaCEX0dki1SQko6uI/96J7i4qLPQQmHmZ9+Y9ZhQvxsRdiyIVmStsZQgcUmtOUlWN0ZbgXbcOP2xe/KKFs9UNBHGyBj09kCpLFj4zuSFsTJ0T+o6yjUb35GpNRylG6CMYYJKCpwAkzWNQOcgphZG/YZoiX/DQNAttFjMrS+6LRCT2rh6HGsHiOQKtmKIIS19+qmZpYLrmXIKxM1Vo5Yj9HD0vfD7ckGGF3LDWlOyHP/idYPQCfdzldTtjscl/8MuDww78lsqHVHdTYXjwCpdKlfoS52X52qGit8oRKrRhwHYdNrrDILouPbCNVZCtgJ1n/6Xx8JYAmT8epD3fr5cC0oGLQYpkd4zpD27R0vA="
      },
      {
        "text": "Try it in the Playground",
        "href": "https://play.vuejs.org/#eNqVUU1rwzAM/SvCl7SQJTuHdLDDbttthw18MbW6hjW2seU0oeS/T0lounQfUDBGepaenvxO4tG5rIkoClGGra8cPUhT1c56ghcbA756tf1EDztva0iy/Ds4NCbSAEiD7diicafigeA0oFvLPAYNhWICYEE5IL00fMp8Hs0JYe0OinDIqFyIaO7CwdJGihO0KXTcLriK59NYBlUARTyMn6Hv0yHgIp7ARAvl3FXm8yCRiuu1Fv/x23JakVqtz3t5pOjNOQNoC7hPz0nHyRSzEr7Ghxppb/XlZ6JjRlzhTAlA+ypkLWwAM6c+8G2BdzP+/pPbRkOoL/KOldH2mCmtnxr247kKhAb9KuHKgLVtMEkn2knG+sIVzV9sfmy8hfB/swHKwV0oWja4lQKKjoNOivzKrf4L/JPqaQ=="
      },
      {
        "text": "Composable",
        "href": "/guide/reusability/composables"
      },
      {
        "text": "Edit this page on GitHub",
        "href": "https://github.com/vuejs/docs/edit/main/src/guide/components/slots.md"
      }
    ],
    "meta": {
      "description": "Vue.js - The Progressive JavaScript Framework",
      "keywords": ""
    },
    "summary": "Slots This page assumes you've already read the Components Basics. Read that first if you are new to components",
    "tags": [
      "react",
      "vue",
      "angular",
      "javascript",
      "typescript",
      "css",
      "html",
      "node",
      "slots",
      "slot"
    ],
    "id": "slots-slotshtml-part-1",
    "quality": 80
  },
  {
    "title": "Angular",
    "url": "https://v17.angular.io/guide/component-overview",
    "category": "angular",
    "content": "Angular components overviewlink Contents PrerequisitesCreating a componentCreating a component using the Angular CLICreating a component manuallySpecifying a component's CSS selectorDefining a component's templateDeclaring a component's stylesCreating a component manuallyNext steps Components are the main building blocks for Angular applications. Each component consists of: An HTML template that declares what renders on the page A TypeScript class that defines behavior A CSS selector that defines how the component is used in a template Optionally, CSS styles applied to the template This topic describes how to create and configure an Angular component. To view or download the example code used in this topic, see the live example / download example. Prerequisiteslink To create a component, verify that you have met the following prerequisites: Install the Angular CLI. Create an Angular workspace with initial application. If you don't have a project, create one using ng new project-name, where project-name is the name of your Angular application. Creating a componentlink The best way to create a component is with the Angular CLI. You can also create a component manually. Creating a component using the Angular CLIlink To create a component using the Angular CLI: From a terminal window, navigate to the directory containing your application. Run the ng generate component component-name command, where component-name is the name of your new component. By default, this command creates the following: A directory named after the component A component file, component-name.component.ts A template file, component-name.component.html A CSS file, component-name.component.css A testing specification file, component-name.component.spec.ts Where component-name is the name of your component. You can change how ng generate component creates new components. For more information, see ng generate component in the Angular CLI documentation. Creating a component manuallylink Although the Angular CLI is the best way to create an Angular component, you can also create a component manually. This section describes how to create the core component file within an existing Angular project. To create a new component manually: Navigate to your Angular project directory. Create a new file, component-name.component.ts. At the top of the file, add the following import statement. content_copy import { Component } from '@angular/core'; After the import statement, add a @Component decorator. content_copy @Component({ }) Choose a CSS selector for the component. content_copy @Component({ selector: 'app-component-overview', }) For more information on choosing a selector, see Specifying a component's selector. Define the HTML template that the component uses to display information. In most cases, this template is a separate HTML file. content_copy @Component({ selector: 'app-component-overview', templateUrl: './component-overview.component.html', }) For more information on defining a component's template, see Defining a component's template. Select the styles for the component's template. In most cases, you define the styles for your component's template in a separate file. content_copy @Component({ selector: 'app-component-overview', templateUrl: './component-overview.component.html', styleUrls: ['./component-overview.component.css'] }) Add a class statement that includes the code for the component. content_copy export class ComponentOverviewComponent { } Specifying a component's CSS selectorlink Every component requires a CSS selector. A selector instructs Angular to instantiate this component wherever it finds the corresponding tag in template HTML. For example, consider a component hello-world.component.ts that defines its selector as app-hello-world. This selector instructs Angular to instantiate this component any time the tag app-hello-world appears in a template. Specify a component's selector by adding a selector property to the @Component decorator. content_copy @Component({ selector: 'app-component-overview', }) Defining a component's templatelink A template is a block of HTML that tells Angular how to render the component in your application. Define a template for your component in one of two ways: by referencing an external file, or directly within the component. To define a template as an external file, add a templateUrl property to the @Component decorator. content_copy @Component({ selector: 'app-component-overview', templateUrl: './component-overview.component.html', }) To define a template within the component, add a template property to the @Component decorator that contains the HTML you want to use. content_copy @Component({ selector: 'app-component-overview', template: 'h1Hello World!/h1', }) If you want your template to span multiple lines, use backticks (). For example: content_copy @Component({ selector: 'app-component-overview', template:  h1Hello World!/h1 pThis template definition spans multiple lines./p  }) An Angular component requires a template defined using template or templateUrl. You cannot have both properties in a component. Declaring a component's styleslink Declare component styles used for its template in one of two ways: By referencing an external file, or directly within the component. To declare the styles for a component in a separate file, add a styleUrls property to the @Component decorator. content_copy @Component({ selector: 'app-component-overview', templateUrl: './component-overview.component.html', styleUrls: ['./component-overview.component.css'] }) To declare the styles within the component, add a styles property to the @Component decorator that contains the styles you want to use. content_copy @Component({ selector: 'app-component-overview', template: 'h1Hello World!/h1', styles: ['h1 { font-weight: normal; }'] }) The styles property takes an array of strings that contain the CSS rule declarations. Creating a component manuallylink Our recommendation is to make components standalone using the standalone: true flag in the @Component decorator. content_copy @Component({ selector: 'app-component-overview', template: 'h1Hello World!/h1', styles: ['h1 { font-weight: normal; }'], standalone: true }) However, in the case of working with a NgModule based application, the component needs to be added to the proper @NgModule. To embed a component in a module, embed it in the array of declarations found in the @NgModule decorator. content_copy // Your component path import {ComponentOverviewComponent} from './component-overview.component'; @NgModule({ declarations: [ // Existing Components ComponentOverviewComponent ] // Rest of the Module Content }) With these steps completed, your Angular component is ready for integration and use within your application. Next stepslink For an architectural overview of components, see Introduction to components and templates For additional options to use when creating a component, see Component in the API Reference For more information on styling components, see Component styles For more information on templates, see Template syntax Last reviewed on Sat Jul 29 2023",
    "headings": [
      {
        "level": 1,
        "text": "Angular components overviewlink",
        "id": "angular-components-overview"
      },
      {
        "level": 2,
        "text": "Prerequisiteslink",
        "id": "prerequisites"
      },
      {
        "level": 2,
        "text": "Creating a componentlink",
        "id": "creating-a-component"
      },
      {
        "level": 2,
        "text": "Specifying a component's CSS selectorlink",
        "id": "specifying-a-components-css-selector"
      },
      {
        "level": 2,
        "text": "Defining a component's templatelink",
        "id": "defining-a-components-template"
      },
      {
        "level": 2,
        "text": "Declaring a component's styleslink",
        "id": "declaring-a-components-styles"
      },
      {
        "level": 2,
        "text": "Next stepslink",
        "id": "next-steps"
      },
      {
        "level": 3,
        "text": "Creating a component using the Angular CLIlink",
        "id": "creating-a-component-using-the-angular-cli"
      },
      {
        "level": 3,
        "text": "Creating a component manuallylink",
        "id": "creating-a-component-manually"
      },
      {
        "level": 3,
        "text": "Creating a component manuallylink",
        "id": "creating-a-component-manually-1"
      }
    ],
    "codeBlocks": [
      {
        "language": "text",
        "code": "ng new <project-name>"
      },
      {
        "language": "text",
        "code": "<project-name>"
      },
      {
        "language": "text",
        "code": "ng generate component <component-name>"
      },
      {
        "language": "text",
        "code": "<component-name>"
      },
      {
        "language": "text",
        "code": "<component-name>.component.ts"
      },
      {
        "language": "text",
        "code": "<component-name>.component.html"
      },
      {
        "language": "text",
        "code": "<component-name>.component.css"
      },
      {
        "language": "text",
        "code": "<component-name>.component.spec.ts"
      },
      {
        "language": "text",
        "code": "<component-name>"
      },
      {
        "language": "text",
        "code": "ng generate component"
      },
      {
        "language": "text",
        "code": "<component-name>.component.ts"
      },
      {
        "language": "text",
        "code": "content_copy\n      \n      import { Component } from '@angular/core';"
      },
      {
        "language": "text",
        "code": "import { Component } from '@angular/core';"
      },
      {
        "language": "text",
        "code": "content_copy\n      \n      @Component({\n})"
      },
      {
        "language": "text",
        "code": "@Component({\n})"
      },
      {
        "language": "text",
        "code": "content_copy\n      \n      @Component({\n  selector: 'app-component-overview',\n})"
      },
      {
        "language": "text",
        "code": "@Component({\n  selector: 'app-component-overview',\n})"
      },
      {
        "language": "text",
        "code": "content_copy\n      \n      @Component({\n  selector: 'app-component-overview',\n  templateUrl: './component-overview.component.html',\n})"
      },
      {
        "language": "text",
        "code": "@Component({\n  selector: 'app-component-overview',\n  templateUrl: './component-overview.component.html',\n})"
      },
      {
        "language": "text",
        "code": "content_copy\n      \n      @Component({\n  selector: 'app-component-overview',\n  templateUrl: './component-overview.component.html',\n  styleUrls: ['./component-overview.component.css']\n})"
      },
      {
        "language": "text",
        "code": "@Component({\n  selector: 'app-component-overview',\n  templateUrl: './component-overview.component.html',\n  styleUrls: ['./component-overview.component.css']\n})"
      },
      {
        "language": "text",
        "code": "content_copy\n      \n      export class ComponentOverviewComponent {\n\n}"
      },
      {
        "language": "text",
        "code": "export class ComponentOverviewComponent {\n\n}"
      },
      {
        "language": "text",
        "code": "hello-world.component.ts"
      },
      {
        "language": "text",
        "code": "app-hello-world"
      },
      {
        "language": "text",
        "code": "<app-hello-world>"
      },
      {
        "language": "text",
        "code": "content_copy\n      \n      @Component({\n  selector: 'app-component-overview',\n})"
      },
      {
        "language": "text",
        "code": "@Component({\n  selector: 'app-component-overview',\n})"
      },
      {
        "language": "text",
        "code": "templateUrl"
      },
      {
        "language": "text",
        "code": "content_copy\n      \n      @Component({\n  selector: 'app-component-overview',\n  templateUrl: './component-overview.component.html',\n})"
      },
      {
        "language": "text",
        "code": "@Component({\n  selector: 'app-component-overview',\n  templateUrl: './component-overview.component.html',\n})"
      },
      {
        "language": "text",
        "code": "content_copy\n      \n      @Component({\n  selector: 'app-component-overview',\n  template: '<h1>Hello World!</h1>',\n})"
      },
      {
        "language": "text",
        "code": "@Component({\n  selector: 'app-component-overview',\n  template: '<h1>Hello World!</h1>',\n})"
      },
      {
        "language": "text",
        "code": "content_copy\n      \n      @Component({\n  selector: 'app-component-overview',\n  template: `\n    <h1>Hello World!</h1>\n    <p>This template definition spans multiple lines.</p>\n  `\n})"
      },
      {
        "language": "text",
        "code": "@Component({\n  selector: 'app-component-overview',\n  template: `\n    <h1>Hello World!</h1>\n    <p>This template definition spans multiple lines.</p>\n  `\n})"
      },
      {
        "language": "text",
        "code": "templateUrl"
      },
      {
        "language": "text",
        "code": "content_copy\n      \n      @Component({\n  selector: 'app-component-overview',\n  templateUrl: './component-overview.component.html',\n  styleUrls: ['./component-overview.component.css']\n})"
      },
      {
        "language": "text",
        "code": "@Component({\n  selector: 'app-component-overview',\n  templateUrl: './component-overview.component.html',\n  styleUrls: ['./component-overview.component.css']\n})"
      },
      {
        "language": "text",
        "code": "content_copy\n      \n      @Component({\n  selector: 'app-component-overview',\n  template: '<h1>Hello World!</h1>',\n  styles: ['h1 { font-weight: normal; }']\n})"
      },
      {
        "language": "text",
        "code": "@Component({\n  selector: 'app-component-overview',\n  template: '<h1>Hello World!</h1>',\n  styles: ['h1 { font-weight: normal; }']\n})"
      },
      {
        "language": "text",
        "code": "standalone: true"
      },
      {
        "language": "text",
        "code": "content_copy\n      \n      @Component({\n  selector: 'app-component-overview',\n  template: '<h1>Hello World!</h1>',\n  styles: ['h1 { font-weight: normal; }'],\n  standalone: true\n})"
      },
      {
        "language": "text",
        "code": "@Component({\n  selector: 'app-component-overview',\n  template: '<h1>Hello World!</h1>',\n  styles: ['h1 { font-weight: normal; }'],\n  standalone: true\n})"
      },
      {
        "language": "text",
        "code": "content_copy\n      \n      // Your component path\nimport {ComponentOverviewComponent} from './component-overview.component';\n\n@NgModule({\n  declarations: [\n    // Existing Components\n   ComponentOverviewComponent\n  ]\n  // Rest of the Module Content\n})"
      },
      {
        "language": "text",
        "code": "// Your component path\nimport {ComponentOverviewComponent} from './component-overview.component';\n\n@NgModule({\n  declarations: [\n    // Existing Components\n   ComponentOverviewComponent\n  ]\n  // Rest of the Module Content\n})"
      }
    ],
    "links": [
      {
        "text": "link",
        "href": "guide/component-overview#angular-components-overview"
      },
      {
        "text": "Prerequisites",
        "href": "guide/component-overview#prerequisites"
      },
      {
        "text": "Creating a component",
        "href": "guide/component-overview#creating-a-component"
      },
      {
        "text": "Creating a component using the Angular CLI",
        "href": "guide/component-overview#creating-a-component-using-the-angular-cli"
      },
      {
        "text": "Creating a component manually",
        "href": "guide/component-overview#creating-a-component-manually"
      },
      {
        "text": "Specifying a component's CSS selector",
        "href": "guide/component-overview#specifying-a-components-css-selector"
      },
      {
        "text": "Defining a component's template",
        "href": "guide/component-overview#defining-a-components-template"
      },
      {
        "text": "Declaring a component's styles",
        "href": "guide/component-overview#declaring-a-components-styles"
      },
      {
        "text": "Creating a component manually",
        "href": "guide/component-overview#creating-a-component-manually-1"
      },
      {
        "text": "Next steps",
        "href": "guide/component-overview#next-steps"
      },
      {
        "text": "live example",
        "href": "generated/live-examples/component-overview/stackblitz.html"
      },
      {
        "text": "download example",
        "href": "generated/zips/component-overview/component-overview.zip"
      },
      {
        "text": "link",
        "href": "guide/component-overview#prerequisites"
      },
      {
        "text": "Install the Angular CLI.",
        "href": "guide/setup-local#install-the-angular-cli"
      },
      {
        "text": "Create an Angular workspace",
        "href": "guide/setup-local#create-a-workspace-and-initial-application"
      },
      {
        "text": "link",
        "href": "guide/component-overview#creating-a-component"
      },
      {
        "text": "link",
        "href": "guide/component-overview#creating-a-component-using-the-angular-cli"
      },
      {
        "text": "ng generate component",
        "href": "cli/generate#component-command"
      },
      {
        "text": "link",
        "href": "guide/component-overview#creating-a-component-manually"
      },
      {
        "text": "Component",
        "href": "api/core/Component"
      },
      {
        "text": "Component",
        "href": "api/core/Component"
      },
      {
        "text": "Component",
        "href": "api/core/Component"
      },
      {
        "text": "Component",
        "href": "api/core/Component"
      },
      {
        "text": "Specifying a component's selector",
        "href": "guide/component-overview#specifying-a-components-css-selector"
      },
      {
        "text": "Component",
        "href": "api/core/Component"
      },
      {
        "text": "Defining a component's template",
        "href": "guide/component-overview#defining-a-components-template"
      },
      {
        "text": "Component",
        "href": "api/core/Component"
      },
      {
        "text": "link",
        "href": "guide/component-overview#specifying-a-components-css-selector"
      },
      {
        "text": "Component",
        "href": "api/core/Component"
      },
      {
        "text": "Component",
        "href": "api/core/Component"
      },
      {
        "text": "link",
        "href": "guide/component-overview#defining-a-components-template"
      },
      {
        "text": "Component",
        "href": "api/core/Component"
      },
      {
        "text": "Component",
        "href": "api/core/Component"
      },
      {
        "text": "Component",
        "href": "api/core/Component"
      },
      {
        "text": "Component",
        "href": "api/core/Component"
      },
      {
        "text": "Component",
        "href": "api/core/Component"
      },
      {
        "text": "multiple",
        "href": "api/forms/SelectMultipleControlValueAccessor"
      },
      {
        "text": "link",
        "href": "guide/component-overview#declaring-a-components-styles"
      },
      {
        "text": "Component",
        "href": "api/core/Component"
      },
      {
        "text": "Component",
        "href": "api/core/Component"
      },
      {
        "text": "Component",
        "href": "api/core/Component"
      },
      {
        "text": "Component",
        "href": "api/core/Component"
      },
      {
        "text": "link",
        "href": "guide/component-overview#creating-a-component-manually-1"
      },
      {
        "text": "Component",
        "href": "api/core/Component"
      },
      {
        "text": "Component",
        "href": "api/core/Component"
      },
      {
        "text": "NgModule",
        "href": "api/core/NgModule"
      },
      {
        "text": "NgModule",
        "href": "api/core/NgModule"
      },
      {
        "text": "NgModule",
        "href": "api/core/NgModule"
      },
      {
        "text": "NgModule",
        "href": "api/core/NgModule"
      },
      {
        "text": "link",
        "href": "guide/component-overview#next-steps"
      },
      {
        "text": "Introduction to components and templates",
        "href": "guide/architecture-components"
      },
      {
        "text": "Component",
        "href": "api/core/Component"
      },
      {
        "text": "Component styles",
        "href": "guide/component-styles"
      },
      {
        "text": "Template syntax",
        "href": "guide/template-syntax"
      }
    ],
    "meta": {
      "description": "",
      "keywords": ""
    },
    "summary": "Angular components overviewlink Contents PrerequisitesCreating a componentCreating a component using the Angular CLICreating a component manuallySpecifying a component's CSS selectorDefining a compone...",
    "tags": [
      "react",
      "angular",
      "typescript",
      "css",
      "html",
      "node",
      "vite",
      "component",
      "creating",
      "manuallylink"
    ],
    "id": "angular-componentoverview-part-1",
    "quality": 90
  },
  {
    "title": "Angular",
    "url": "https://v17.angular.io/guide/template-syntax",
    "category": "angular",
    "content": "Template syntaxlink Contents PrerequisitesEmpower your HTMLMore on template syntax In Angular, a template is a chunk of HTML. Use special syntax within a template to build on many of Angular's features. Prerequisiteslink Before learning template syntax, you should be familiar with the following: Angular concepts JavaScript HTML CSS Each Angular template in your application is a section of HTML to include as a part of the page that the browser displays. An Angular HTML template renders a view, or user interface, in the browser, just like regular HTML, but with a lot more functionality. When you generate an Angular application with the Angular CLI, the app.component.html file is the default template containing placeholder HTML. The template syntax guides show you how to control the UX/UI by coordinating data between the class and the template. Most of the Template Syntax guides have dedicated working example applications that demonstrate the individual topic of each guide. To see all of them working together in one application, see the comprehensive Template Syntax Live Code / download example. Empower your HTMLlink Extend the HTML vocabulary of your applications with special Angular syntax in your templates. For example, Angular helps you get and set DOM (Document Object Model) values dynamically with features such as built-in template functions, variables, event listening, and data binding. Almost all HTML syntax is valid template syntax. However, because an Angular template is part of an overall webpage, and not the entire page, you don't need to include elements such as html, body, or base, and can focus exclusively on the part of the page you are developing. To eliminate the risk of script injection attacks, Angular does not support the script element in templates. Angular ignores the script tag and outputs a warning to the browser console. For more information, see the Security page. More on template syntaxlink You might also be interested in the following: Topics Details Interpolation Learn how to use interpolation and expressions in HTML. Template statements Respond to events in your templates. Binding syntax Use binding to coordinate values in your application. Property binding Set properties of target elements or directive @Input() decorators. Attribute, class, and style bindings Set the value of attributes, classes, and styles. Event binding Listen for events and your HTML. Two-way binding Share data between a class and its template. Built-in directives Listen to and modify the behavior and layout of HTML. Template reference variables Use special variables to reference a DOM element within a template. Inputs and Outputs Share data between the parent context and child directives or components Template expression operators Learn about the pipe operator (), and protect against null or undefined values in your HTML. SVG in templates Dynamically generate interactive graphics. Last reviewed on Mon Feb 28 2022",
    "headings": [
      {
        "level": 1,
        "text": "Template syntaxlink",
        "id": "template-syntax"
      },
      {
        "level": 2,
        "text": "Prerequisiteslink",
        "id": "prerequisites"
      },
      {
        "level": 2,
        "text": "Empower your HTMLlink",
        "id": "empower-your-html"
      },
      {
        "level": 2,
        "text": "More on template syntaxlink",
        "id": "more-on-template-syntax"
      }
    ],
    "codeBlocks": [
      {
        "language": "text",
        "code": "app.component.html"
      }
    ],
    "links": [
      {
        "text": "link",
        "href": "guide/template-syntax#template-syntax"
      },
      {
        "text": "Prerequisites",
        "href": "guide/template-syntax#prerequisites"
      },
      {
        "text": "Empower your HTML",
        "href": "guide/template-syntax#empower-your-html"
      },
      {
        "text": "More on template syntax",
        "href": "guide/template-syntax#more-on-template-syntax"
      },
      {
        "text": "link",
        "href": "guide/template-syntax#prerequisites"
      },
      {
        "text": "Angular concepts",
        "href": "guide/architecture"
      },
      {
        "text": "Template Syntax Live Code",
        "href": "generated/live-examples/template-syntax/stackblitz.html"
      },
      {
        "text": "download example",
        "href": "generated/zips/template-syntax/template-syntax.zip"
      },
      {
        "text": "link",
        "href": "guide/template-syntax#empower-your-html"
      },
      {
        "text": "Security",
        "href": "guide/security"
      },
      {
        "text": "link",
        "href": "guide/template-syntax#more-on-template-syntax"
      },
      {
        "text": "Interpolation",
        "href": "guide/interpolation"
      },
      {
        "text": "Template statements",
        "href": "guide/template-statements"
      },
      {
        "text": "Binding syntax",
        "href": "guide/binding-syntax"
      },
      {
        "text": "Property binding",
        "href": "guide/property-binding"
      },
      {
        "text": "Input",
        "href": "api/core/Input"
      },
      {
        "text": "Attribute, class, and style bindings",
        "href": "guide/attribute-binding"
      },
      {
        "text": "Event binding",
        "href": "guide/event-binding"
      },
      {
        "text": "Two-way binding",
        "href": "guide/two-way-binding"
      },
      {
        "text": "Built-in directives",
        "href": "guide/built-in-directives"
      },
      {
        "text": "Template reference variables",
        "href": "guide/template-reference-variables"
      },
      {
        "text": "Inputs and Outputs",
        "href": "guide/inputs-outputs"
      },
      {
        "text": "Template expression operators",
        "href": "guide/template-expression-operators"
      },
      {
        "text": "SVG in templates",
        "href": "guide/svg-in-templates"
      }
    ],
    "meta": {
      "description": "",
      "keywords": ""
    },
    "summary": "Template syntaxlink Contents PrerequisitesEmpower your HTMLMore on template syntax In Angular, a template is a chunk of HTML. Use special syntax within a template to build on many of Angular's features",
    "tags": [
      "react",
      "vue",
      "angular",
      "javascript",
      "typescript",
      "css",
      "html",
      "vite",
      "template",
      "syntaxlink"
    ],
    "id": "angular-templatesyntax-part-1",
    "quality": 90
  },
  {
    "title": "Angular",
    "url": "https://v17.angular.io/guide/lifecycle-hooks",
    "category": "angular",
    "content": "Component Lifecyclelink Contents PrerequisitesResponding to lifecycle eventsLifecycle event sequenceLifecycle example setInitializing a component or directiveCleaning up on instance destructionngOnDestroyDestroyReftakeUntilDestroyedReading and writing the DOMOne-time initializationHandling synchronizationGeneral examplesSequence and frequency of all lifecycle eventsUse directives to watch the DOMUse component and directive hooks togetherUsing change detection hooksResponding to view changesResponding to projected content changesDefining custom change detection A component instance has a lifecycle that starts when Angular instantiates the component class and renders the component view along with its child views. The lifecycle continues with change detection, as Angular checks to see when data-bound properties change, and updates both the view and the component instance as needed. The lifecycle ends when Angular destroys the component instance and removes its rendered template from the DOM. Directives have a similar lifecycle, as Angular creates, updates, and destroys instances in the course of execution. Your application can use lifecycle hook methods to tap into key events in the lifecycle of a component or directive to initialize new instances, initiate change detection when needed, respond to updates during change detection, and clean up before deletion of instances. Prerequisiteslink Before working with lifecycle hooks, you should have a basic understanding of the following: TypeScript programming Angular app-design fundamentals, as described in Angular Concepts Responding to lifecycle eventslink Respond to events in the lifecycle of a component or directive by implementing one or more of the lifecycle hook interfaces in the Angular core library. The hooks give you the opportunity to act on a component or directive instance at the appropriate moment, as Angular creates, updates, or destroys that instance. Each interface defines the prototype for a single hook method, whose name is the interface name prefixed with ng. For example, the OnInit interface has a hook method named ngOnInit(). If you implement this method in your component or directive class, Angular calls it shortly after checking the input properties for that component or directive for the first time. content_copy @Directive({selector: '[appPeekABoo]'}) export class PeekABooDirective implements OnInit { constructor(private logger: LoggerService) { } // implement OnInit's ngOnInit method ngOnInit() { this.logIt('OnInit'); } logIt(msg: string) { this.logger.log(#${nextId++} ${msg}); } } You don't have to implement all (or any) of the lifecycle hooks, just the ones you need. Lifecycle event sequencelink After your application instantiates a component or directive by calling its constructor, Angular calls the hook methods you have implemented at the appropriate point in the lifecycle of that instance. Angular executes hook methods in the following sequence. Use them to perform the following kinds of operations. Hook method Purpose Timing ngOnChanges() Respond when Angular sets or resets data-bound input properties. The method receives a SimpleChanges object of current and previous property values. NOTE: This happens frequently, so any operation you perform here impacts performance significantly. See details in Using change detection hooks in this document. Called before ngOnInit() (if the component has bound inputs) and whenever one or more data-bound input properties change. NOTE: If your component has no inputs or you use it without providing any inputs, the framework will not call ngOnChanges(). ngOnInit() Initialize the directive or component after Angular first displays the data-bound properties and sets the directive or component's input properties. See details in Initializing a component or directive in this document. Called once, after the first ngOnChanges(). ngOnInit() is still called even when ngOnChanges() is not (which is the case when there are no template-bound inputs). ngDoCheck() Detect and act upon changes that Angular can't or won't detect on its own. See details and example in Defining custom change detection in this document. Called immediately after ngOnChanges() on every change detection run, and immediately after ngOnInit() on the first run. ngAfterContentInit() Respond after Angular projects external content into the component's view, or into the view that a directive is in. See details and example in Responding to changes in content in this document. Called once after the first ngDoCheck(). ngAfterContentChecked() Respond after Angular checks the content projected into the directive or component. See details and example in Responding to projected content changes in this document. Called after ngAfterContentInit() and every subsequent ngDoCheck(). ngAfterViewInit() Respond after Angular initializes the component's views and child views, or the view that contains the directive. See details and example in Responding to view changes in this document. Called once after the first ngAfterContentChecked(). ngAfterViewChecked() Respond after Angular checks the component's views and child views, or the view that contains the directive. Called after the ngAfterViewInit() and every subsequent ngAfterContentChecked(). ngOnDestroy() Cleanup just before Angular destroys the directive or component. Unsubscribe Observables and detach event handlers to avoid memory leaks. See details in Cleaning up on instance destruction in this document. Called immediately before Angular destroys the directive or component. Lifecycle example setlink The live example / download example demonstrates the use of lifecycle hooks through a series of exercises presented as components under the control of the root AppComponent. In each case a parent component serves as a test rig for a child component that illustrates one or more of the lifecycle hook methods. The following table lists the exercises with brief descriptions. The sample code is also used to illustrate specific tasks in the following sections. Component Details Peek-a-boo Demonstrates every lifecycle hook. Each hook method writes to the on-screen log. Spy Shows how to use lifecycle hooks with a custom directive. The SpyDirective implements the ngOnInit() and ngOnDestroy() hooks, and uses them to watch and report when an element goes in or out of the current view. OnChanges Demonstrates how Angular calls the ngOnChanges() hook every time one of the component input properties changes, and shows how to interpret the changes object passed to the hook method. DoCheck Implements the ngDoCheck() method with custom change detection. Watch the hook post changes to a log to see how often Angular calls this hook. AfterView Shows what Angular means by a view. Demonstrates the ngAfterViewInit() and ngAfterViewChecked() hooks. AfterContent Shows how to project external content into a component and how to distinguish projected content from a component's view children. Demonstrates the ngAfterContentInit() and ngAfterContentChecked() hooks. Counter Demonstrates a combination of a component and a directive, each with its own hooks. Initializing a component or directivelink Use the ngOnInit() method to perform the following initialization tasks. Initialization tasks Details Perform complex initializations outside of the constructor Components should be cheap and safe to construct. You should not, for example, fetch data in a component constructor. You shouldn't worry that a new component will try to contact a remote server when created under test or before you decide to display it. An ngOnInit() is a good place for a component to fetch its initial data. For an example, see the Tour of Heroes tutorial. Set up the component after Angular sets the input properties Constructors should do no more than set the initial local variables to simple values. Keep in mind that a directive's data-bound input properties are not set until after construction. If you need to initialize the directive based on those properties, set them when ngOnInit() runs. The ngOnChanges() method is your first opportunity to access those properties. Angular calls ngOnChanges() before ngOnInit(), but also many times after that. It only calls ngOnInit() once. Cleaning up on instance destructionlink Angular provides several ways to clean up when an instance is destroyed. ngOnDestroylink You can put cleanup logic in ngOnDestroy(), the logic that must run before Angular destroys the directive. This is the place to free resources that won't be garbage-collected automatically. You risk memory leaks if you neglect to do so. Unsubscribe from Observables and DOM events Stop interval timers Unregister all callbacks that the directive registered with global or application services The ngOnDestroy() method is also the time to notify another part of the application that the component is going away. DestroyReflink In addition to ngOnDestroy(), you can inject Angular's DestroyRef and register callback functions to be called when the enclosing context is destroyed. This can be useful for building reusable utilities that require cleanup. Register a callback with the DestroyRef: content_copy @Component(...) class Counter { count = 0; constructor() { // Start a timer to increment the counter every second. const id = setInterval(() = this.count++, 1000); // Stop the timer when the component is destroyed. const destroyRef = inject(DestroyRef); destroyRef.onDestroy(() = clearInterval(id)); } } Like ngOnDestroy, DestroyRef works in any Angular service, directive, component, or pipe. takeUntilDestroyedlink takeUntilDestroyed is available for developer preview. It's ready for you to try, but it might change before it is stable. When using RxJS Observables in components or directives, you may want to complete any observables when the component or directive is destroyed. Angular's @angular/core/rxjs-interop package provides an operator, takeUntilDestroyed, to simplify this common task: content_copy data$ = http.get('...').pipe(takeUntilDestroyed()); By default, takeUntilDestroyed must be called in an injection context so that it can access DestroyRef. If an injection context isn't available, you can explicitly provide a DestroyRef. Reading and writing the DOMlink Sometimes it's necessary to use browser-only APIs to manually read or write the DOM. This can be challenging to do with the lifecycle events above, as they will also run during server-side rendering and pre-rendering. For this purpose, Angular provides afterRender and afterNextRender. These functions can be used unconditionally, but will only have an effect on the browser. Both functions accept a callback that will run after the next change detection cycle (including any nested cycles) has completed. afterRender and afterNextRender are available for developer preview. They are ready for you to try, but they might change before they are stable. Function Purpose Timing afterNextRender Perform one-time initialization, or observe a single, specific change to the DOM. As a rule of thumb, you should use afterRender instead if you need to manually read or write any layout data such as size or location. See details in One-time initialization in this document. Once after the next change detection cycle. afterRender Synchronize state with the DOM. See details in Handling synchronization in this document. After every change detection cycle that follows. One-time initializationlink Generally, you will want to use afterNextRender to perform any one-time initialization, such as for a third-party library, or for browser-only APIs. content_copy @Component({ selector: 'my-chart-cmp', template: div #chart{{ ... }}/div, }) export class MyChartCmp { @ViewChild('chart') chartRef: ElementRef; chart: MyChartnull; constructor() { afterNextRender(() = { this.chart = new MyChart(this.chartRef.nativeElement); }, {phase: AfterRenderPhase.Write}); } } Instead of attempting to recreate their behaviors with afterRender, you should prefer to use built-in browser APIs like ResizeObserver and IntersectionObserver wherever possible. You can use afterNextRender to safely initialize such APIs on the browser only. content_copy @Component({ selector: 'my-cmp', template: span #content{{ ... }}/span, }) export class MyComponent { resizeObserver: ResizeObservernull = null; @ViewChild('content') contentRef: ElementRef; constructor() { afterNextRender(() = { this.resizeObserver = new ResizeObserver(() = { console.log('Content was resized'); }); this.resizeObserver.observe(this.contentRef.nativeElement); }, {phase: AfterRenderPhase.Write}); } ngOnDestroy() { this.resizeObserver?.disconnect(); this.resizeObserver = null; } } As a rule of thumb, afterNextRender should be used to observe discrete changes to the DOM, such as element creation or deletion. For manually reading or writing data that tends to change frequently, such as size or location, you should generally prefer to use afterRender instead. Handling synchronizationlink As an escape hatch for when the browser does not provide a better API to do so, you can use afterRender to perform any additional read or writes to the DOM every time Angular finishes mutating it. content_copy @Component({ selector: 'my-cmp', template: span #content{{ ... }}/span, }) export class MyComponent { @ViewChild('content') contentRef: ElementRef; constructor() { afterRender(() = { const elem = this.contentRef.nativeElement; console.log(content position: (${elem.offsetLeft}, ${elem.offsetTop})); }, {phase: AfterRenderPhase.Read}); } } General exampleslink The following examples demonstrate the call sequence and relative frequency of the various lifecycle events, and how the hooks can be used separately or together for components and directives. Sequence and frequency of all lifecycle eventslink To show how Angular calls the hooks in the expected order, the PeekABooComponent demonstrates all of the hooks in one component. In practice you would rarely, if ever, implement all of the interfaces the way this demo does. The following snapshot reflects the state of the log after the user clicked the Create button and then the Destroy button. The sequence of log messages follows the prescribed hook calling order: Hook order Log message 1 OnChanges 2 OnInit 3 DoCheck 4 AfterContentInit 5 AfterContentChecked 6 AfterViewInit 7 AfterViewChecked 8 DoCheck 9 AfterContentChecked 10 AfterViewChecked 11 OnDestroy Notice that the log confirms that input properties (the name property in this case) have no assigned values at construction. The input properties are available to the onInit() method for further initialization. Had the user clicked the Update Hero button, the log would show another OnChanges and two more triplets of DoCheck, AfterContentChecked, and AfterViewChecked. Notice that these three hooks fire often, so it is important to keep their logic as lean as possible. Use directives to watch the DOMlink The Spy example demonstrates how to use the hook method for directives as well as components. The SpyDirective implements two hooks, ngOnInit() and ngOnDestroy(), to discover when a watched element is in the current view. This template applies the SpyDirective to a div in the ngFor hero repeater managed by the parent SpyComponent. The example does not perform any initialization or clean-up. It just tracks the appearance and disappearance of an element in the view by recording when the directive itself is instantiated and destroyed. A spy directive like this can provide insight into a DOM object that you cannot change directly. You can't access the implementation of a built-in div, or modify a third party component. You do have the option to watch these elements with a directive. The directive defines ngOnInit() and ngOnDestroy() hooks that log messages to the parent using an injected LoggerService. content_copy let nextId = 1; // Spy on any element to which it is applied. // Usage: div appSpy.../div @Directive({selector: '[appSpy]'}) export class SpyDirective implements OnInit, OnDestroy { private id = nextId++; constructor(private logger: LoggerService) { } ngOnInit() { this.logger.log(Spy #${this.id} onInit); } ngOnDestroy() { this.logger.log(Spy #${this.id} onDestroy); } } Apply the spy to any built-in or component element, and see that it is initialized and destroyed at the same time as that element. Here it is attached to the repeated hero p: content_copy p *ngFor=\"let hero of heroes\" appSpy {{hero}} /p Each spy's creation and destruction marks the appearance and disappearance of the attached hero p with an entry in the Hook Log. Adding a hero results in a new hero p. The spy's ngOnInit() logs that event. The Reset button clears the heroes list. Angular removes all hero p elements from the DOM and destroys their spy directives at the same time. The spy's ngOnDestroy() method reports its last moments. Use component and directive hooks togetherlink In this example, a CounterComponent uses the ngOnChanges() method to log a change every time the parent component increments its input counter property. This example applies the SpyDirective from the previous example to the CounterComponent log, to watch the creation and destruction of log entries. Using change detection hookslink Angular calls the ngOnChanges() method of a component or directive whenever it detects changes to the input properties. The onChanges example demonstrates this by monitoring the OnChanges() hook. content_copy ngOnChanges(changes: SimpleChanges) { for (const propName in changes) { const chng = changes[propName]; const cur = JSON.stringify(chng.currentValue); const prev = JSON.stringify(chng.previousValue); this.changeLog.push(${propName}: currentValue = ${cur}, previousValue = ${prev}); } } The ngOnChanges() method takes an object that maps each changed property name to a SimpleChange object holding the current and previous property values. This hook iterates over the changed properties and logs them. The example component, OnChangesComponent, has two input properties: hero and power. content_copy @Input() hero!: Hero; @Input() power = ''; The host OnChangesParentComponent binds to them as follows. content_copy on-changes [hero]=\"hero\" [power]=\"power\"/on-changes Here's the sample in action as the user makes changes. The log entries appear as the string value of the power property changes. Notice, however, that the ngOnChanges() method does not catch changes to hero.name. This is because Angular calls the hook only when the value of the input property changes. In this case, hero is the input property, and the value of the hero property is the reference to the hero object. The object reference did not change when the value of its own name property changed. Responding to view changeslink As Angular traverses the view hierarchy during change detection, it needs to be sure that a change in a child does not attempt to cause a change in its own parent. Such a change would not be rendered properly, because of how unidirectional data flow works. If you need to make a change that inverts the expected data flow, you must trigger a new change detection cycle to allow that change to be rendered. The examples illustrate how to make such changes safely. The AfterView sample explores the AfterViewInit() and AfterViewChecked() hooks that Angular calls after it creates a component's child views. Here's a child view that displays a hero's name in an input: content_copy @Component({ selector: 'app-child-view', template:  label for=\"hero-name\"Hero name: /label input type=\"text\" id=\"hero-name\" [(ngModel)]=\"hero\"  }) export class ChildViewComponent { hero = 'Magneta'; } The AfterViewComponent displays this child view within its template: content_copy template:  divchild view begins/div app-child-view/app-child-view divchild view ends/div  The following hooks take action based on changing values within the child view, which can only be reached by querying for the child view using the property decorated with @ViewChild. content_copy export class AfterViewComponent implements AfterViewChecked, AfterViewInit { private prevHero = ''; // Query for a VIEW child of type ChildViewComponent @ViewChild(ChildViewComponent) viewChild!: ChildViewComponent; ngAfterViewInit() { // viewChild is set after the view has been initialized this.logIt('AfterViewInit'); this.doSomething(); } ngAfterViewChecked() { // viewChild is updated after the view has been checked if (this.prevHero === this.viewChild.hero) { this.logIt('AfterViewChecked (no change)'); } else { this.prevHero = this.viewChild.hero; this.logIt('AfterViewChecked'); this.doSomething(); } } // ... } Wait before updating the viewlink In this example, the doSomething() method updates the screen when the hero name exceeds 10 characters, but waits a tick before updating comment. content_copy // This surrogate for real business logic sets the comment private doSomething() { const c = this.viewChild.hero.length  10 ? \"That's a long name\" : ''; if (c !== this.comment) { // Wait a tick because the component's view has already been checked this.logger.tick_then(() = this.comment = c); } } Both the AfterViewInit() and AfterViewChecked() hooks fire after the component's view is composed. If you modify the code so that the hook updates the component's data-bound comment property immediately, you can see that Angular throws an error. The LoggerService.tick_then() statement postpones the log update for one turn of the browser's JavaScript cycle, which triggers a new change-detection cycle. Write lean hook methods to avoid performance problemslink When you run the AfterView sample, notice how frequently Angular calls AfterViewChecked() - often when there are no changes of interest. Be careful about how much logic or computation you put into one of these methods. Responding to projected content changeslink Content projection is a way to import HTML content from outside the component and insert that content into the component's template in a designated spot. Identify content projection in a template by looking for the following constructs. HTML between component element tags The presence of ng-content tags in the component's template AngularJS developers know this technique as transclusion. The AfterContent sample explores the AfterContentInit() and AfterContentChecked() hooks that Angular calls after Angular projects external content into the component. Consider this variation on the previous AfterView example. This time, instead of including the child view within the template, it imports the content from the AfterContentComponent hook's parent. The following is the parent's template. content_copy after-content app-child/app-child /after-content Notice that the app-child tag is tucked between the after-content tags. Never put content between a component's element tags unless you intend to project that content into the component. Now look at the component's template. content_copy template:  divprojected content begins/div ng-content/ng-content divprojected content ends/div  The ng-content tag is a placeholder for the external content. It tells Angular where to insert that content. In this case, the projected content is the app-child from the parent. Using AfterContent hookslink AfterContent hooks are similar to the AfterView hooks. The key difference is in the child component. The AfterView hooks concern ViewChildren, the child components whose element tags appear within the component's template The AfterContent hooks concern ContentChildren, the child components that Angular projected into the component The following AfterContent hooks take action based on changing values in a content child, which can only be reached by querying for them using the property decorated with @ContentChild. content_copy export class AfterContentComponent implements AfterContentChecked, AfterContentInit { private prevHero = ''; comment = ''; // Query for a CONTENT child of type ChildComponent @ContentChild(ChildComponent) contentChild!: ChildComponent; ngAfterContentInit() { // contentChild is set after the content has been initialized this.logIt('AfterContentInit'); this.doSomething(); } ngAfterContentChecked() { // contentChild is updated after the content has been checked if (this.prevHero === this.contentChild.hero) { this.logIt('AfterContentChecked (no change)'); } else { this.prevHero = this.contentChild.hero; this.logIt('AfterContentChecked'); this.doSomething(); } } // ... } This component's doSomething() method updates the component's data-bound comment property immediately. There's no need to delay the update to ensure proper rendering. Angular calls both AfterContent hooks before calling either of the AfterView hooks. Angular completes composition of the projected content before finishing the composition of this component's view. There is a small window between the AfterContent... and AfterView... hooks that lets you modify the host view. Defining custom change detectionlink To monitor changes that occur where ngOnChanges() won't catch them, implement your own change check, as shown in the DoCheck example. This example shows how to use the ngDoCheck() hook to detect and act upon changes that Angular doesn't catch on its own. The DoCheck sample extends the OnChanges sample with the following ngDoCheck() hook: content_copy ngDoCheck() { if (this.hero.name !== this.oldHeroName) { this.changeDetected = true; this.changeLog.push(DoCheck: Hero name changed to \"${this.hero.name}\" from \"${this.oldHeroName}\"); this.oldHeroName = this.hero.name; } if (this.power !== this.oldPower) { this.changeDetected = true; this.changeLog.push(DoCheck: Power changed to \"${this.power}\" from \"${this.oldPower}\"); this.oldPower = this.power; } if (this.changeDetected) { this.noChangeCount = 0; } else { // log that hook was called when there was no relevant change. const count = this.noChangeCount += 1; const noChangeMsg = DoCheck called ${count}x when no change to hero or power; if (count === 1) { // add new \"no change\" message this.changeLog.push(noChangeMsg); } else { // update last \"no change\" message this.changeLog[this.changeLog.length - 1] = noChangeMsg; } } this.changeDetected = false; } This code inspects certain values of interest, capturing and comparing their current state against previous values. It writes a special message to the log when there are no substantive changes to the hero or the power so you can see how often DoCheck() is called. The results are illuminating. While the ngDoCheck() hook can detect when the hero's name has changed, it is an expensive hook. This hook is called with enormous frequency after every change detection cycle no matter where the change occurred. It's called over twenty times in this example before the user can do anything. Most of these initial checks are triggered by Angular's first rendering of unrelated data elsewhere on the page. Just moving the cursor into another input triggers a call. Relatively few calls reveal actual changes to pertinent data. If you use this hook, your implementation must be extremely lightweight or the user experience suffers. Last reviewed on Mon Feb 28 2022",
    "headings": [
      {
        "level": 1,
        "text": "Component Lifecyclelink",
        "id": "component-lifecycle"
      },
      {
        "level": 2,
        "text": "Prerequisiteslink",
        "id": "prerequisites"
      },
      {
        "level": 2,
        "text": "Responding to lifecycle eventslink",
        "id": "responding-to-lifecycle-events"
      },
      {
        "level": 2,
        "text": "Initializing a component or directivelink",
        "id": "initializing-a-component-or-directive"
      },
      {
        "level": 2,
        "text": "Cleaning up on instance destructionlink",
        "id": "cleaning-up-on-instance-destruction"
      },
      {
        "level": 2,
        "text": "Reading and writing the DOMlink",
        "id": "reading-and-writing-the-dom"
      },
      {
        "level": 2,
        "text": "General exampleslink",
        "id": "general-examples"
      },
      {
        "level": 2,
        "text": "Using change detection hookslink",
        "id": "using-change-detection-hooks"
      },
      {
        "level": 2,
        "text": "Defining custom change detectionlink",
        "id": "defining-custom-change-detection"
      },
      {
        "level": 3,
        "text": "Lifecycle event sequencelink",
        "id": "lifecycle-event-sequence"
      },
      {
        "level": 3,
        "text": "Lifecycle example setlink",
        "id": "lifecycle-example-set"
      },
      {
        "level": 3,
        "text": "ngOnDestroylink",
        "id": "ngondestroy"
      },
      {
        "level": 3,
        "text": "DestroyReflink",
        "id": "destroyref"
      },
      {
        "level": 3,
        "text": "takeUntilDestroyedlink",
        "id": "takeuntildestroyed"
      },
      {
        "level": 3,
        "text": "One-time initializationlink",
        "id": "one-time-initialization"
      },
      {
        "level": 3,
        "text": "Handling synchronizationlink",
        "id": "handling-synchronization"
      },
      {
        "level": 3,
        "text": "Sequence and frequency of all lifecycle eventslink",
        "id": "sequence-and-frequency-of-all-lifecycle-events"
      },
      {
        "level": 3,
        "text": "Use directives to watch the DOMlink",
        "id": "use-directives-to-watch-the-dom"
      },
      {
        "level": 3,
        "text": "Use component and directive hooks togetherlink",
        "id": "use-component-and-directive-hooks-together"
      },
      {
        "level": 3,
        "text": "Responding to view changeslink",
        "id": "responding-to-view-changes"
      },
      {
        "level": 3,
        "text": "Responding to projected content changeslink",
        "id": "responding-to-projected-content-changes"
      },
      {
        "level": 4,
        "text": "Wait before updating the viewlink",
        "id": "wait-before-updating-the-view"
      },
      {
        "level": 4,
        "text": "Write lean hook methods to avoid performance problemslink",
        "id": "write-lean-hook-methods-to-avoid-performance-problems"
      },
      {
        "level": 4,
        "text": "Using AfterContent hookslink",
        "id": "using-aftercontent-hooks"
      }
    ],
    "codeBlocks": [
      {
        "language": "text",
        "code": "ngOnDestroy"
      },
      {
        "language": "text",
        "code": "takeUntilDestroyed"
      },
      {
        "language": "text",
        "code": "content_copy\n      \n      @Directive({selector: '[appPeekABoo]'})\nexport class PeekABooDirective implements OnInit {\n  constructor(private logger: LoggerService) { }\n\n  // implement OnInit's `ngOnInit` method\n  ngOnInit() {\n    this.logIt('OnInit');\n  }\n\n  logIt(msg: string) {\n    this.logger.log(`#${nextId++} ${msg}`);\n  }\n}"
      },
      {
        "language": "text",
        "code": "@Directive({selector: '[appPeekABoo]'})\nexport class PeekABooDirective implements OnInit {\n  constructor(private logger: LoggerService) { }\n\n  // implement OnInit's `ngOnInit` method\n  ngOnInit() {\n    this.logIt('OnInit');\n  }\n\n  logIt(msg: string) {\n    this.logger.log(`#${nextId++} ${msg}`);\n  }\n}"
      },
      {
        "language": "text",
        "code": "ngOnChanges()"
      },
      {
        "language": "text",
        "code": "SimpleChanges"
      },
      {
        "language": "text",
        "code": "ngOnChanges()"
      },
      {
        "language": "text",
        "code": "ngOnChanges()"
      },
      {
        "language": "text",
        "code": "ngOnChanges()"
      },
      {
        "language": "text",
        "code": "ngDoCheck()"
      },
      {
        "language": "text",
        "code": "ngOnChanges()"
      },
      {
        "language": "text",
        "code": "ngAfterContentInit()"
      },
      {
        "language": "text",
        "code": "ngDoCheck()"
      },
      {
        "language": "text",
        "code": "ngAfterContentChecked()"
      },
      {
        "language": "text",
        "code": "ngAfterContentInit()"
      },
      {
        "language": "text",
        "code": "ngDoCheck()"
      },
      {
        "language": "text",
        "code": "ngAfterViewInit()"
      },
      {
        "language": "text",
        "code": "ngAfterContentChecked()"
      },
      {
        "language": "text",
        "code": "ngAfterViewChecked()"
      },
      {
        "language": "text",
        "code": "ngAfterViewInit()"
      },
      {
        "language": "text",
        "code": "ngAfterContentChecked()"
      },
      {
        "language": "text",
        "code": "ngOnDestroy()"
      },
      {
        "language": "text",
        "code": "AppComponent"
      },
      {
        "language": "text",
        "code": "SpyDirective"
      },
      {
        "language": "text",
        "code": "ngOnDestroy()"
      },
      {
        "language": "text",
        "code": "ngOnChanges()"
      },
      {
        "language": "text",
        "code": "ngDoCheck()"
      },
      {
        "language": "text",
        "code": "ngAfterViewInit()"
      },
      {
        "language": "text",
        "code": "ngAfterViewChecked()"
      },
      {
        "language": "text",
        "code": "ngAfterContentInit()"
      },
      {
        "language": "text",
        "code": "ngAfterContentChecked()"
      },
      {
        "language": "text",
        "code": "ngOnChanges()"
      },
      {
        "language": "text",
        "code": "ngOnChanges()"
      },
      {
        "language": "text",
        "code": "ngOnDestroy"
      },
      {
        "language": "text",
        "code": "ngOnDestroy()"
      },
      {
        "language": "text",
        "code": "ngOnDestroy()"
      },
      {
        "language": "text",
        "code": "ngOnDestroy()"
      },
      {
        "language": "text",
        "code": "content_copy\n      \n      @Component(...)\nclass Counter {\n  count = 0;\n  constructor() {\n    // Start a timer to increment the counter every second.\n    const id = setInterval(() => this.count++, 1000);\n\n    // Stop the timer when the component is destroyed.\n    const destroyRef = inject(DestroyRef);\n    destroyRef.onDestroy(() => clearInterval(id));\n  }\n}"
      },
      {
        "language": "text",
        "code": "@Component(...)\nclass Counter {\n  count = 0;\n  constructor() {\n    // Start a timer to increment the counter every second.\n    const id = setInterval(() => this.count++, 1000);\n\n    // Stop the timer when the component is destroyed.\n    const destroyRef = inject(DestroyRef);\n    destroyRef.onDestroy(() => clearInterval(id));\n  }\n}"
      },
      {
        "language": "text",
        "code": "ngOnDestroy"
      },
      {
        "language": "text",
        "code": "takeUntilDestroyed"
      },
      {
        "language": "text",
        "code": "takeUntilDestroyed"
      },
      {
        "language": "text",
        "code": "@angular/core/rxjs-interop"
      },
      {
        "language": "text",
        "code": "takeUntilDestroyed"
      },
      {
        "language": "text",
        "code": "content_copy\n      \n      data$ = http.get('...').pipe(takeUntilDestroyed());"
      },
      {
        "language": "text",
        "code": "data$ = http.get('...').pipe(takeUntilDestroyed());"
      },
      {
        "language": "text",
        "code": "takeUntilDestroyed"
      },
      {
        "language": "text",
        "code": "afterRender"
      },
      {
        "language": "text",
        "code": "afterNextRender"
      },
      {
        "language": "text",
        "code": "afterRender"
      },
      {
        "language": "text",
        "code": "afterNextRender"
      },
      {
        "language": "text",
        "code": "afterNextRender"
      },
      {
        "language": "text",
        "code": "afterRender"
      },
      {
        "language": "text",
        "code": "afterRender"
      },
      {
        "language": "text",
        "code": "afterNextRender"
      },
      {
        "language": "text",
        "code": "content_copy\n      \n      @Component({\n  selector: 'my-chart-cmp',\n  template: `<div #chart>{{ ... }}</div>`,\n})\nexport class MyChartCmp {\n  @ViewChild('chart') chartRef: ElementRef;\n  chart: MyChart|null;\n\n  constructor() {\n    afterNextRender(() => {\n      this.chart = new MyChart(this.chartRef.nativeElement);\n    }, {phase: AfterRenderPhase.Write});\n  }\n}"
      },
      {
        "language": "text",
        "code": "@Component({\n  selector: 'my-chart-cmp',\n  template: `<div #chart>{{ ... }}</div>`,\n})\nexport class MyChartCmp {\n  @ViewChild('chart') chartRef: ElementRef;\n  chart: MyChart|null;\n\n  constructor() {\n    afterNextRender(() => {\n      this.chart = new MyChart(this.chartRef.nativeElement);\n    }, {phase: AfterRenderPhase.Write});\n  }\n}"
      },
      {
        "language": "text",
        "code": "afterRender"
      },
      {
        "language": "text",
        "code": "ResizeObserver"
      },
      {
        "language": "text",
        "code": "IntersectionObserver"
      },
      {
        "language": "text",
        "code": "afterNextRender"
      },
      {
        "language": "text",
        "code": "content_copy\n      \n      @Component({\n  selector: 'my-cmp',\n  template: `<span #content>{{ ... }}</span>`,\n})\nexport class MyComponent {\n  resizeObserver: ResizeObserver|null = null;\n  @ViewChild('content') contentRef: ElementRef;\n\n  constructor() {\n    afterNextRender(() => {\n      this.resizeObserver = new ResizeObserver(() => {\n        console.log('Content was resized');\n      });\n\n      this.resizeObserver.observe(this.contentRef.nativeElement);\n    }, {phase: AfterRenderPhase.Write});\n  }\n\n  ngOnDestroy() {\n    this.resizeObserver?.disconnect();\n    this.resizeObserver = null;\n  }\n}"
      },
      {
        "language": "text",
        "code": "@Component({\n  selector: 'my-cmp',\n  template: `<span #content>{{ ... }}</span>`,\n})\nexport class MyComponent {\n  resizeObserver: ResizeObserver|null = null;\n  @ViewChild('content') contentRef: ElementRef;\n\n  constructor() {\n    afterNextRender(() => {\n      this.resizeObserver = new ResizeObserver(() => {\n        console.log('Content was resized');\n      });\n\n      this.resizeObserver.observe(this.contentRef.nativeElement);\n    }, {phase: AfterRenderPhase.Write});\n  }\n\n  ngOnDestroy() {\n    this.resizeObserver?.disconnect();\n    this.resizeObserver = null;\n  }\n}"
      },
      {
        "language": "text",
        "code": "afterNextRender"
      },
      {
        "language": "text",
        "code": "afterRender"
      },
      {
        "language": "text",
        "code": "afterRender"
      },
      {
        "language": "text",
        "code": "content_copy\n      \n      @Component({\n  selector: 'my-cmp',\n  template: `<span #content>{{ ... }}</span>`,\n})\nexport class MyComponent {\n  @ViewChild('content') contentRef: ElementRef;\n\n  constructor() {\n    afterRender(() => {\n      const elem = this.contentRef.nativeElement;\n      console.log(`content position: (${elem.offsetLeft}, ${elem.offsetTop})`);\n    }, {phase: AfterRenderPhase.Read});\n  }\n}"
      },
      {
        "language": "text",
        "code": "@Component({\n  selector: 'my-cmp',\n  template: `<span #content>{{ ... }}</span>`,\n})\nexport class MyComponent {\n  @ViewChild('content') contentRef: ElementRef;\n\n  constructor() {\n    afterRender(() => {\n      const elem = this.contentRef.nativeElement;\n      console.log(`content position: (${elem.offsetLeft}, ${elem.offsetTop})`);\n    }, {phase: AfterRenderPhase.Read});\n  }\n}"
      },
      {
        "language": "text",
        "code": "PeekABooComponent"
      },
      {
        "language": "text",
        "code": "AfterContentInit"
      },
      {
        "language": "text",
        "code": "AfterContentChecked"
      },
      {
        "language": "text",
        "code": "AfterViewInit"
      },
      {
        "language": "text",
        "code": "AfterViewChecked"
      },
      {
        "language": "text",
        "code": "AfterContentChecked"
      },
      {
        "language": "text",
        "code": "AfterViewChecked"
      },
      {
        "language": "text",
        "code": "AfterContentChecked"
      },
      {
        "language": "text",
        "code": "AfterViewChecked"
      },
      {
        "language": "text",
        "code": "SpyDirective"
      },
      {
        "language": "text",
        "code": "ngOnDestroy()"
      },
      {
        "language": "text",
        "code": "SpyDirective"
      },
      {
        "language": "text",
        "code": "SpyComponent"
      },
      {
        "language": "text",
        "code": "ngOnDestroy()"
      },
      {
        "language": "text",
        "code": "LoggerService"
      },
      {
        "language": "text",
        "code": "content_copy\n      \n      let nextId = 1;\n\n// Spy on any element to which it is applied.\n// Usage: <div appSpy>...</div>\n@Directive({selector: '[appSpy]'})\nexport class SpyDirective implements OnInit, OnDestroy {\n  private id = nextId++;\n\n  constructor(private logger: LoggerService) { }\n\n  ngOnInit() {\n    this.logger.log(`Spy #${this.id} onInit`);\n  }\n\n  ngOnDestroy() {\n    this.logger.log(`Spy #${this.id} onDestroy`);\n  }\n}"
      },
      {
        "language": "text",
        "code": "let nextId = 1;\n\n// Spy on any element to which it is applied.\n// Usage: <div appSpy>...</div>\n@Directive({selector: '[appSpy]'})\nexport class SpyDirective implements OnInit, OnDestroy {\n  private id = nextId++;\n\n  constructor(private logger: LoggerService) { }\n\n  ngOnInit() {\n    this.logger.log(`Spy #${this.id} onInit`);\n  }\n\n  ngOnDestroy() {\n    this.logger.log(`Spy #${this.id} onDestroy`);\n  }\n}"
      },
      {
        "language": "text",
        "code": "content_copy\n      \n      <p *ngFor=\"let hero of heroes\" appSpy>\n  {{hero}}\n</p>"
      },
      {
        "language": "text",
        "code": "<p *ngFor=\"let hero of heroes\" appSpy>\n  {{hero}}\n</p>"
      },
      {
        "language": "text",
        "code": "ngOnDestroy()"
      },
      {
        "language": "text",
        "code": "CounterComponent"
      },
      {
        "language": "text",
        "code": "ngOnChanges()"
      },
      {
        "language": "text",
        "code": "SpyDirective"
      },
      {
        "language": "text",
        "code": "CounterComponent"
      },
      {
        "language": "text",
        "code": "ngOnChanges()"
      },
      {
        "language": "text",
        "code": "OnChanges()"
      },
      {
        "language": "text",
        "code": "content_copy\n      \n      ngOnChanges(changes: SimpleChanges) {\n  for (const propName in changes) {\n    const chng = changes[propName];\n    const cur  = JSON.stringify(chng.currentValue);\n    const prev = JSON.stringify(chng.previousValue);\n    this.changeLog.push(`${propName}: currentValue = ${cur}, previousValue = ${prev}`);\n  }\n}"
      },
      {
        "language": "text",
        "code": "ngOnChanges(changes: SimpleChanges) {\n  for (const propName in changes) {\n    const chng = changes[propName];\n    const cur  = JSON.stringify(chng.currentValue);\n    const prev = JSON.stringify(chng.previousValue);\n    this.changeLog.push(`${propName}: currentValue = ${cur}, previousValue = ${prev}`);\n  }\n}"
      },
      {
        "language": "text",
        "code": "ngOnChanges()"
      },
      {
        "language": "text",
        "code": "OnChangesComponent"
      },
      {
        "language": "text",
        "code": "content_copy\n      \n      @Input() hero!: Hero;\n@Input() power = '';"
      },
      {
        "language": "text",
        "code": "@Input() hero!: Hero;\n@Input() power = '';"
      },
      {
        "language": "text",
        "code": "OnChangesParentComponent"
      },
      {
        "language": "text",
        "code": "content_copy\n      \n      <on-changes [hero]=\"hero\" [power]=\"power\"></on-changes>"
      },
      {
        "language": "text",
        "code": "<on-changes [hero]=\"hero\" [power]=\"power\"></on-changes>"
      },
      {
        "language": "text",
        "code": "ngOnChanges()"
      },
      {
        "language": "text",
        "code": "AfterViewInit()"
      },
      {
        "language": "text",
        "code": "AfterViewChecked()"
      },
      {
        "language": "text",
        "code": "content_copy\n      \n      @Component({\n  selector: 'app-child-view',\n  template: `\n    <label for=\"hero-name\">Hero name: </label>\n    <input type=\"text\" id=\"hero-name\" [(ngModel)]=\"hero\">\n  `\n})\nexport class ChildViewComponent {\n  hero = 'Magneta';\n}"
      },
      {
        "language": "text",
        "code": "@Component({\n  selector: 'app-child-view',\n  template: `\n    <label for=\"hero-name\">Hero name: </label>\n    <input type=\"text\" id=\"hero-name\" [(ngModel)]=\"hero\">\n  `\n})\nexport class ChildViewComponent {\n  hero = 'Magneta';\n}"
      },
      {
        "language": "text",
        "code": "AfterViewComponent"
      },
      {
        "language": "text",
        "code": "content_copy\n      \n      template: `\n  <div>child view begins</div>\n    <app-child-view></app-child-view>\n  <div>child view ends</div>\n`"
      },
      {
        "language": "text",
        "code": "template: `\n  <div>child view begins</div>\n    <app-child-view></app-child-view>\n  <div>child view ends</div>\n`"
      },
      {
        "language": "text",
        "code": "content_copy\n      \n      export class AfterViewComponent implements  AfterViewChecked, AfterViewInit {\n  private prevHero = '';\n\n  // Query for a VIEW child of type `ChildViewComponent`\n  @ViewChild(ChildViewComponent) viewChild!: ChildViewComponent;\n\n  ngAfterViewInit() {\n    // viewChild is set after the view has been initialized\n    this.logIt('AfterViewInit');\n    this.doSomething();\n  }\n\n  ngAfterViewChecked() {\n    // viewChild is updated after the view has been checked\n    if (this.prevHero === this.viewChild.hero) {\n      this.logIt('AfterViewChecked (no change)');\n    } else {\n      this.prevHero = this.viewChild.hero;\n      this.logIt('AfterViewChecked');\n      this.doSomething();\n    }\n  }\n  // ...\n}"
      },
      {
        "language": "text",
        "code": "export class AfterViewComponent implements  AfterViewChecked, AfterViewInit {\n  private prevHero = '';\n\n  // Query for a VIEW child of type `ChildViewComponent`\n  @ViewChild(ChildViewComponent) viewChild!: ChildViewComponent;\n\n  ngAfterViewInit() {\n    // viewChild is set after the view has been initialized\n    this.logIt('AfterViewInit');\n    this.doSomething();\n  }\n\n  ngAfterViewChecked() {\n    // viewChild is updated after the view has been checked\n    if (this.prevHero === this.viewChild.hero) {\n      this.logIt('AfterViewChecked (no change)');\n    } else {\n      this.prevHero = this.viewChild.hero;\n      this.logIt('AfterViewChecked');\n      this.doSomething();\n    }\n  }\n  // ...\n}"
      },
      {
        "language": "text",
        "code": "doSomething()"
      },
      {
        "language": "text",
        "code": "content_copy\n      \n      // This surrogate for real business logic sets the `comment`\nprivate doSomething() {\n  const c = this.viewChild.hero.length > 10 ? \"That's a long name\" : '';\n  if (c !== this.comment) {\n    // Wait a tick because the component's view has already been checked\n    this.logger.tick_then(() => this.comment = c);\n  }\n}"
      },
      {
        "language": "text",
        "code": "// This surrogate for real business logic sets the `comment`\nprivate doSomething() {\n  const c = this.viewChild.hero.length > 10 ? \"That's a long name\" : '';\n  if (c !== this.comment) {\n    // Wait a tick because the component's view has already been checked\n    this.logger.tick_then(() => this.comment = c);\n  }\n}"
      },
      {
        "language": "text",
        "code": "AfterViewInit()"
      },
      {
        "language": "text",
        "code": "AfterViewChecked()"
      },
      {
        "language": "text",
        "code": "LoggerService.tick_then()"
      },
      {
        "language": "text",
        "code": "AfterViewChecked()"
      },
      {
        "language": "text",
        "code": "<ng-content>"
      },
      {
        "language": "text",
        "code": "AfterContentInit()"
      },
      {
        "language": "text",
        "code": "AfterContentChecked()"
      },
      {
        "language": "text",
        "code": "AfterContentComponent"
      },
      {
        "language": "text",
        "code": "content_copy\n      \n      `<after-content>\n  <app-child></app-child>\n</after-content>`"
      },
      {
        "language": "text",
        "code": "`<after-content>\n  <app-child></app-child>\n</after-content>`"
      },
      {
        "language": "text",
        "code": "<app-child>"
      },
      {
        "language": "text",
        "code": "<after-content>"
      },
      {
        "language": "text",
        "code": "content_copy\n      \n      template: `\n  <div>projected content begins</div>\n    <ng-content></ng-content>\n  <div>projected content ends</div>\n`"
      },
      {
        "language": "text",
        "code": "template: `\n  <div>projected content begins</div>\n    <ng-content></ng-content>\n  <div>projected content ends</div>\n`"
      },
      {
        "language": "text",
        "code": "<ng-content>"
      },
      {
        "language": "text",
        "code": "<app-child>"
      },
      {
        "language": "text",
        "code": "ViewChildren"
      },
      {
        "language": "text",
        "code": "ContentChildren"
      },
      {
        "language": "text",
        "code": "content_copy\n      \n      export class AfterContentComponent implements AfterContentChecked, AfterContentInit {\n  private prevHero = '';\n  comment = '';\n\n  // Query for a CONTENT child of type `ChildComponent`\n  @ContentChild(ChildComponent) contentChild!: ChildComponent;\n\n  ngAfterContentInit() {\n    // contentChild is set after the content has been initialized\n    this.logIt('AfterContentInit');\n    this.doSomething();\n  }\n\n  ngAfterContentChecked() {\n    // contentChild is updated after the content has been checked\n    if (this.prevHero === this.contentChild.hero) {\n      this.logIt('AfterContentChecked (no change)');\n    } else {\n      this.prevHero = this.contentChild.hero;\n      this.logIt('AfterContentChecked');\n      this.doSomething();\n    }\n  }\n  // ...\n}"
      },
      {
        "language": "text",
        "code": "export class AfterContentComponent implements AfterContentChecked, AfterContentInit {\n  private prevHero = '';\n  comment = '';\n\n  // Query for a CONTENT child of type `ChildComponent`\n  @ContentChild(ChildComponent) contentChild!: ChildComponent;\n\n  ngAfterContentInit() {\n    // contentChild is set after the content has been initialized\n    this.logIt('AfterContentInit');\n    this.doSomething();\n  }\n\n  ngAfterContentChecked() {\n    // contentChild is updated after the content has been checked\n    if (this.prevHero === this.contentChild.hero) {\n      this.logIt('AfterContentChecked (no change)');\n    } else {\n      this.prevHero = this.contentChild.hero;\n      this.logIt('AfterContentChecked');\n      this.doSomething();\n    }\n  }\n  // ...\n}"
      },
      {
        "language": "text",
        "code": "doSomething()"
      },
      {
        "language": "text",
        "code": "AfterContent..."
      },
      {
        "language": "text",
        "code": "AfterView..."
      },
      {
        "language": "text",
        "code": "ngOnChanges()"
      },
      {
        "language": "text",
        "code": "ngDoCheck()"
      },
      {
        "language": "text",
        "code": "ngDoCheck()"
      },
      {
        "language": "text",
        "code": "content_copy\n      \n      ngDoCheck() {\n\n  if (this.hero.name !== this.oldHeroName) {\n    this.changeDetected = true;\n    this.changeLog.push(`DoCheck: Hero name changed to \"${this.hero.name}\" from \"${this.oldHeroName}\"`);\n    this.oldHeroName = this.hero.name;\n  }\n\n  if (this.power !== this.oldPower) {\n    this.changeDetected = true;\n    this.changeLog.push(`DoCheck: Power changed to \"${this.power}\" from \"${this.oldPower}\"`);\n    this.oldPower = this.power;\n  }\n\n  if (this.changeDetected) {\n      this.noChangeCount = 0;\n  } else {\n      // log that hook was called when there was no relevant change.\n      const count = this.noChangeCount += 1;\n      const noChangeMsg = `DoCheck called ${count}x when no change to hero or power`;\n      if (count === 1) {\n        // add new \"no change\" message\n        this.changeLog.push(noChangeMsg);\n      } else {\n        // update last \"no change\" message\n        this.changeLog[this.changeLog.length - 1] = noChangeMsg;\n      }\n  }\n\n  this.changeDetected = false;\n}"
      },
      {
        "language": "text",
        "code": "ngDoCheck() {\n\n  if (this.hero.name !== this.oldHeroName) {\n    this.changeDetected = true;\n    this.changeLog.push(`DoCheck: Hero name changed to \"${this.hero.name}\" from \"${this.oldHeroName}\"`);\n    this.oldHeroName = this.hero.name;\n  }\n\n  if (this.power !== this.oldPower) {\n    this.changeDetected = true;\n    this.changeLog.push(`DoCheck: Power changed to \"${this.power}\" from \"${this.oldPower}\"`);\n    this.oldPower = this.power;\n  }\n\n  if (this.changeDetected) {\n      this.noChangeCount = 0;\n  } else {\n      // log that hook was called when there was no relevant change.\n      const count = this.noChangeCount += 1;\n      const noChangeMsg = `DoCheck called ${count}x when no change to hero or power`;\n      if (count === 1) {\n        // add new \"no change\" message\n        this.changeLog.push(noChangeMsg);\n      } else {\n        // update last \"no change\" message\n        this.changeLog[this.changeLog.length - 1] = noChangeMsg;\n      }\n  }\n\n  this.changeDetected = false;\n}"
      },
      {
        "language": "text",
        "code": "ngDoCheck()"
      }
    ],
    "links": [
      {
        "text": "link",
        "href": "guide/lifecycle-hooks#component-lifecycle"
      },
      {
        "text": "Prerequisites",
        "href": "guide/lifecycle-hooks#prerequisites"
      },
      {
        "text": "Responding to lifecycle events",
        "href": "guide/lifecycle-hooks#responding-to-lifecycle-events"
      },
      {
        "text": "Lifecycle event sequence",
        "href": "guide/lifecycle-hooks#lifecycle-event-sequence"
      },
      {
        "text": "Lifecycle example set",
        "href": "guide/lifecycle-hooks#lifecycle-example-set"
      },
      {
        "text": "Initializing a component or directive",
        "href": "guide/lifecycle-hooks#initializing-a-component-or-directive"
      },
      {
        "text": "Cleaning up on instance destruction",
        "href": "guide/lifecycle-hooks#cleaning-up-on-instance-destruction"
      },
      {
        "text": "ngOnDestroy",
        "href": "guide/lifecycle-hooks#ngondestroy"
      },
      {
        "text": "DestroyRef",
        "href": "guide/lifecycle-hooks#destroyref"
      },
      {
        "text": "takeUntilDestroyed",
        "href": "guide/lifecycle-hooks#takeuntildestroyed"
      },
      {
        "text": "Reading and writing the DOM",
        "href": "guide/lifecycle-hooks#reading-and-writing-the-dom"
      },
      {
        "text": "One-time initialization",
        "href": "guide/lifecycle-hooks#one-time-initialization"
      },
      {
        "text": "Handling synchronization",
        "href": "guide/lifecycle-hooks#handling-synchronization"
      },
      {
        "text": "General examples",
        "href": "guide/lifecycle-hooks#general-examples"
      },
      {
        "text": "Sequence and frequency of all lifecycle events",
        "href": "guide/lifecycle-hooks#sequence-and-frequency-of-all-lifecycle-events"
      },
      {
        "text": "Use directives to watch the DOM",
        "href": "guide/lifecycle-hooks#use-directives-to-watch-the-dom"
      },
      {
        "text": "Use component and directive hooks together",
        "href": "guide/lifecycle-hooks#use-component-and-directive-hooks-together"
      },
      {
        "text": "Using change detection hooks",
        "href": "guide/lifecycle-hooks#using-change-detection-hooks"
      },
      {
        "text": "Responding to view changes",
        "href": "guide/lifecycle-hooks#responding-to-view-changes"
      },
      {
        "text": "Responding to projected content changes",
        "href": "guide/lifecycle-hooks#responding-to-projected-content-changes"
      },
      {
        "text": "Defining custom change detection",
        "href": "guide/lifecycle-hooks#defining-custom-change-detection"
      },
      {
        "text": "lifecycle hook methods",
        "href": "guide/glossary#lifecycle-hook"
      },
      {
        "text": "link",
        "href": "guide/lifecycle-hooks#prerequisites"
      },
      {
        "text": "TypeScript programming",
        "href": "https://www.typescriptlang.org"
      },
      {
        "text": "Angular Concepts",
        "href": "guide/architecture"
      },
      {
        "text": "link",
        "href": "guide/lifecycle-hooks#responding-to-lifecycle-events"
      },
      {
        "text": "OnInit",
        "href": "api/core/OnInit"
      },
      {
        "text": "Directive",
        "href": "api/core/Directive"
      },
      {
        "text": "OnInit",
        "href": "api/core/OnInit"
      },
      {
        "text": "OnInit",
        "href": "api/core/OnInit"
      },
      {
        "text": "OnInit",
        "href": "api/core/OnInit"
      },
      {
        "text": "link",
        "href": "guide/lifecycle-hooks#lifecycle-event-sequence"
      },
      {
        "text": "SimpleChanges",
        "href": "api/core/SimpleChanges"
      },
      {
        "text": "Using change detection hooks",
        "href": "guide/lifecycle-hooks#onchanges"
      },
      {
        "text": "Initializing a component or directive",
        "href": "guide/lifecycle-hooks#oninit"
      },
      {
        "text": "Defining custom change detection",
        "href": "guide/lifecycle-hooks#docheck"
      },
      {
        "text": "Responding to changes in content",
        "href": "guide/lifecycle-hooks#aftercontent"
      },
      {
        "text": "Responding to projected content changes",
        "href": "guide/lifecycle-hooks#aftercontent"
      },
      {
        "text": "Responding to view changes",
        "href": "guide/lifecycle-hooks#afterview"
      },
      {
        "text": "Cleaning up on instance destruction",
        "href": "guide/lifecycle-hooks#ondestroy"
      },
      {
        "text": "link",
        "href": "guide/lifecycle-hooks#lifecycle-example-set"
      },
      {
        "text": "live example",
        "href": "generated/live-examples/lifecycle-hooks/stackblitz.html"
      },
      {
        "text": "download example",
        "href": "generated/zips/lifecycle-hooks/lifecycle-hooks.zip"
      },
      {
        "text": "Peek-a-boo",
        "href": "guide/lifecycle-hooks#peek-a-boo"
      },
      {
        "text": "Spy",
        "href": "guide/lifecycle-hooks#spy"
      },
      {
        "text": "OnChanges",
        "href": "guide/lifecycle-hooks#onchanges"
      },
      {
        "text": "DoCheck",
        "href": "guide/lifecycle-hooks#docheck"
      },
      {
        "text": "AfterView",
        "href": "guide/lifecycle-hooks#afterview"
      },
      {
        "text": "view",
        "href": "guide/glossary#view"
      },
      {
        "text": "AfterContent",
        "href": "guide/lifecycle-hooks#aftercontent"
      },
      {
        "text": "Counter",
        "href": "guide/lifecycle-hooks#counter"
      },
      {
        "text": "link",
        "href": "guide/lifecycle-hooks#initializing-a-component-or-directive"
      },
      {
        "text": "Tour of Heroes tutorial",
        "href": "tutorial/tour-of-heroes/toh-pt4#oninit"
      },
      {
        "text": "link",
        "href": "guide/lifecycle-hooks#cleaning-up-on-instance-destruction"
      },
      {
        "text": "link",
        "href": "guide/lifecycle-hooks#ngondestroy"
      },
      {
        "text": "link",
        "href": "guide/lifecycle-hooks#destroyref"
      },
      {
        "text": "DestroyRef",
        "href": "api/core/DestroyRef"
      },
      {
        "text": "DestroyRef",
        "href": "api/core/DestroyRef"
      },
      {
        "text": "Component",
        "href": "api/core/Component"
      },
      {
        "text": "DestroyRef",
        "href": "api/core/DestroyRef"
      },
      {
        "text": "DestroyRef",
        "href": "api/core/DestroyRef"
      },
      {
        "text": "takeUntilDestroyed",
        "href": "api/core/rxjs-interop/takeUntilDestroyed"
      },
      {
        "text": "link",
        "href": "guide/lifecycle-hooks#takeuntildestroyed"
      },
      {
        "text": "takeUntilDestroyed",
        "href": "api/core/rxjs-interop/takeUntilDestroyed"
      },
      {
        "text": "developer preview",
        "href": "/guide/releases#developer-preview"
      },
      {
        "text": "rxjs-interop",
        "href": "api/core/rxjs-interop"
      },
      {
        "text": "takeUntilDestroyed",
        "href": "api/core/rxjs-interop/takeUntilDestroyed"
      },
      {
        "text": "takeUntilDestroyed",
        "href": "api/core/rxjs-interop/takeUntilDestroyed"
      },
      {
        "text": "takeUntilDestroyed",
        "href": "api/core/rxjs-interop/takeUntilDestroyed"
      },
      {
        "text": "injection context",
        "href": "/guide/dependency-injection-context"
      },
      {
        "text": "DestroyRef",
        "href": "api/core/DestroyRef"
      },
      {
        "text": "DestroyRef",
        "href": "api/core/DestroyRef"
      },
      {
        "text": "link",
        "href": "guide/lifecycle-hooks#reading-and-writing-the-dom"
      },
      {
        "text": "lifecycle events",
        "href": "guide/lifecycle-hooks#lifecycle-event-sequence"
      },
      {
        "text": "server-side rendering and pre-rendering",
        "href": "guide/glossary#server-side-rendering"
      },
      {
        "text": "afterRender",
        "href": "api/core/afterRender"
      },
      {
        "text": "afterNextRender",
        "href": "api/core/afterNextRender"
      },
      {
        "text": "change detection",
        "href": "/guide/glossary#change-detection"
      },
      {
        "text": "afterRender",
        "href": "api/core/afterRender"
      },
      {
        "text": "afterNextRender",
        "href": "api/core/afterNextRender"
      },
      {
        "text": "developer preview",
        "href": "/guide/releases#developer-preview"
      },
      {
        "text": "afterNextRender",
        "href": "api/core/afterNextRender"
      },
      {
        "text": "afterRender",
        "href": "api/core/afterRender"
      },
      {
        "text": "One-time initialization",
        "href": "guide/lifecycle-hooks#one-time-initialization"
      },
      {
        "text": "afterRender",
        "href": "api/core/afterRender"
      },
      {
        "text": "Handling synchronization",
        "href": "guide/lifecycle-hooks#handling-synchronization"
      },
      {
        "text": "link",
        "href": "guide/lifecycle-hooks#one-time-initialization"
      },
      {
        "text": "afterNextRender",
        "href": "api/core/afterNextRender"
      },
      {
        "text": "Component",
        "href": "api/core/Component"
      },
      {
        "text": "ViewChild",
        "href": "api/core/ViewChild"
      },
      {
        "text": "ElementRef",
        "href": "api/core/ElementRef"
      },
      {
        "text": "afterNextRender",
        "href": "api/core/afterNextRender"
      },
      {
        "text": "AfterRenderPhase.Write",
        "href": "api/core/AfterRenderPhase#Write"
      },
      {
        "text": "afterRender",
        "href": "api/core/afterRender"
      },
      {
        "text": "afterNextRender",
        "href": "api/core/afterNextRender"
      },
      {
        "text": "Component",
        "href": "api/core/Component"
      },
      {
        "text": "ViewChild",
        "href": "api/core/ViewChild"
      },
      {
        "text": "ElementRef",
        "href": "api/core/ElementRef"
      },
      {
        "text": "afterNextRender",
        "href": "api/core/afterNextRender"
      },
      {
        "text": "AfterRenderPhase.Write",
        "href": "api/core/AfterRenderPhase#Write"
      },
      {
        "text": "afterNextRender",
        "href": "api/core/afterNextRender"
      },
      {
        "text": "afterRender",
        "href": "api/core/afterRender"
      },
      {
        "text": "link",
        "href": "guide/lifecycle-hooks#handling-synchronization"
      },
      {
        "text": "afterRender",
        "href": "api/core/afterRender"
      },
      {
        "text": "Component",
        "href": "api/core/Component"
      },
      {
        "text": "ViewChild",
        "href": "api/core/ViewChild"
      },
      {
        "text": "ElementRef",
        "href": "api/core/ElementRef"
      },
      {
        "text": "afterRender",
        "href": "api/core/afterRender"
      },
      {
        "text": "AfterRenderPhase.Read",
        "href": "api/core/AfterRenderPhase#Read"
      },
      {
        "text": "link",
        "href": "guide/lifecycle-hooks#general-examples"
      },
      {
        "text": "link",
        "href": "guide/lifecycle-hooks#sequence-and-frequency-of-all-lifecycle-events"
      },
      {
        "text": "OnChanges",
        "href": "api/core/OnChanges"
      },
      {
        "text": "OnInit",
        "href": "api/core/OnInit"
      },
      {
        "text": "DoCheck",
        "href": "api/core/DoCheck"
      },
      {
        "text": "AfterContentInit",
        "href": "api/core/AfterContentInit"
      },
      {
        "text": "AfterContentChecked",
        "href": "api/core/AfterContentChecked"
      },
      {
        "text": "AfterViewInit",
        "href": "api/core/AfterViewInit"
      },
      {
        "text": "AfterViewChecked",
        "href": "api/core/AfterViewChecked"
      },
      {
        "text": "DoCheck",
        "href": "api/core/DoCheck"
      },
      {
        "text": "AfterContentChecked",
        "href": "api/core/AfterContentChecked"
      },
      {
        "text": "AfterViewChecked",
        "href": "api/core/AfterViewChecked"
      },
      {
        "text": "OnDestroy",
        "href": "api/core/OnDestroy"
      },
      {
        "text": "OnChanges",
        "href": "api/core/OnChanges"
      },
      {
        "text": "DoCheck",
        "href": "api/core/DoCheck"
      },
      {
        "text": "AfterContentChecked",
        "href": "api/core/AfterContentChecked"
      },
      {
        "text": "AfterViewChecked",
        "href": "api/core/AfterViewChecked"
      },
      {
        "text": "link",
        "href": "guide/lifecycle-hooks#use-directives-to-watch-the-dom"
      },
      {
        "text": "ngFor",
        "href": "api/common/NgFor"
      },
      {
        "text": "Directive",
        "href": "api/core/Directive"
      },
      {
        "text": "OnInit",
        "href": "api/core/OnInit"
      },
      {
        "text": "OnDestroy",
        "href": "api/core/OnDestroy"
      },
      {
        "text": "ngFor",
        "href": "api/common/NgFor"
      },
      {
        "text": "link",
        "href": "guide/lifecycle-hooks#use-component-and-directive-hooks-together"
      },
      {
        "text": "link",
        "href": "guide/lifecycle-hooks#using-change-detection-hooks"
      },
      {
        "text": "OnChanges",
        "href": "api/core/OnChanges"
      },
      {
        "text": "SimpleChanges",
        "href": "api/core/SimpleChanges"
      },
      {
        "text": "SimpleChange",
        "href": "api/core/SimpleChange"
      },
      {
        "text": "Input",
        "href": "api/core/Input"
      },
      {
        "text": "Input",
        "href": "api/core/Input"
      },
      {
        "text": "link",
        "href": "guide/lifecycle-hooks#responding-to-view-changes"
      },
      {
        "text": "view hierarchy",
        "href": "guide/glossary#view-hierarchy"
      },
      {
        "text": "unidirectional data flow",
        "href": "guide/glossary#unidirectional-data-flow"
      },
      {
        "text": "AfterViewInit",
        "href": "api/core/AfterViewInit"
      },
      {
        "text": "AfterViewChecked",
        "href": "api/core/AfterViewChecked"
      },
      {
        "text": "Component",
        "href": "api/core/Component"
      },
      {
        "text": "ngModel",
        "href": "api/forms/NgModel"
      },
      {
        "text": "@ViewChild",
        "href": "api/core/ViewChild"
      },
      {
        "text": "AfterViewChecked",
        "href": "api/core/AfterViewChecked"
      },
      {
        "text": "AfterViewInit",
        "href": "api/core/AfterViewInit"
      },
      {
        "text": "Query",
        "href": "api/core/Query"
      },
      {
        "text": "ViewChild",
        "href": "api/core/ViewChild"
      },
      {
        "text": "viewChild",
        "href": "api/core/viewChild"
      },
      {
        "text": "viewChild",
        "href": "api/core/viewChild"
      },
      {
        "text": "AfterViewInit",
        "href": "api/core/AfterViewInit"
      },
      {
        "text": "viewChild",
        "href": "api/core/viewChild"
      },
      {
        "text": "AfterViewChecked",
        "href": "api/core/AfterViewChecked"
      },
      {
        "text": "AfterViewChecked",
        "href": "api/core/AfterViewChecked"
      },
      {
        "text": "link",
        "href": "guide/lifecycle-hooks#wait-before-updating-the-view"
      },
      {
        "text": "tick",
        "href": "api/core/testing/tick"
      },
      {
        "text": "AfterViewInit",
        "href": "api/core/AfterViewInit"
      },
      {
        "text": "AfterViewChecked",
        "href": "api/core/AfterViewChecked"
      },
      {
        "text": "link",
        "href": "guide/lifecycle-hooks#write-lean-hook-methods-to-avoid-performance-problems"
      },
      {
        "text": "AfterViewChecked",
        "href": "api/core/AfterViewChecked"
      },
      {
        "text": "link",
        "href": "guide/lifecycle-hooks#responding-to-projected-content-changes"
      },
      {
        "text": "<ng-content>",
        "href": "api/core/ng-content"
      },
      {
        "text": "AfterContentInit",
        "href": "api/core/AfterContentInit"
      },
      {
        "text": "AfterContentChecked",
        "href": "api/core/AfterContentChecked"
      },
      {
        "text": "previous AfterView",
        "href": "guide/lifecycle-hooks#afterview"
      },
      {
        "text": "<ng-content>",
        "href": "api/core/ng-content"
      },
      {
        "text": "link",
        "href": "guide/lifecycle-hooks#using-aftercontent-hooks"
      },
      {
        "text": "ViewChildren",
        "href": "api/core/ViewChildren"
      },
      {
        "text": "ContentChildren",
        "href": "api/core/ContentChildren"
      },
      {
        "text": "@ContentChild",
        "href": "api/core/ContentChild"
      },
      {
        "text": "AfterContentChecked",
        "href": "api/core/AfterContentChecked"
      },
      {
        "text": "AfterContentInit",
        "href": "api/core/AfterContentInit"
      },
      {
        "text": "Query",
        "href": "api/core/Query"
      },
      {
        "text": "ContentChild",
        "href": "api/core/ContentChild"
      },
      {
        "text": "contentChild",
        "href": "api/core/contentChild"
      },
      {
        "text": "contentChild",
        "href": "api/core/contentChild"
      },
      {
        "text": "AfterContentInit",
        "href": "api/core/AfterContentInit"
      },
      {
        "text": "contentChild",
        "href": "api/core/contentChild"
      },
      {
        "text": "AfterContentChecked",
        "href": "api/core/AfterContentChecked"
      },
      {
        "text": "AfterContentChecked",
        "href": "api/core/AfterContentChecked"
      },
      {
        "text": "delay the update to ensure proper rendering",
        "href": "guide/lifecycle-hooks#wait-a-tick"
      },
      {
        "text": "link",
        "href": "guide/lifecycle-hooks#defining-custom-change-detection"
      },
      {
        "text": "DoCheck",
        "href": "api/core/DoCheck"
      },
      {
        "text": "DoCheck",
        "href": "api/core/DoCheck"
      },
      {
        "text": "DoCheck",
        "href": "api/core/DoCheck"
      },
      {
        "text": "DoCheck",
        "href": "api/core/DoCheck"
      }
    ],
    "meta": {
      "description": "",
      "keywords": ""
    },
    "summary": "Component Lifecyclelink Contents PrerequisitesResponding to lifecycle eventsLifecycle event sequenceLifecycle example setInitializing a component or directiveCleaning up on instance destructionngOnDes...",
    "tags": [
      "react",
      "vue",
      "angular",
      "javascript",
      "typescript",
      "html",
      "node",
      "vite",
      "lifecycle",
      "component"
    ],
    "id": "angular-lifecyclehooks-part-1",
    "quality": 90
  },
  {
    "title": "Angular",
    "url": "https://v17.angular.io/guide/component-interaction",
    "category": "angular",
    "content": "Component interactionlink Contents Pass data from parent to child with input bindingTest it for Pass data from parent to child with input bindingIntercept input property changes with a setterTest it for Intercept input property changes with a setterIntercept input property changes with ngOnChanges()Test it for Intercept input property changes with ngOnChanges()Parent listens for child eventTest it for Parent listens for child eventParent interacts with child using local variableTest it for Parent interacts with child using local variableParent calls an @ViewChild()Test it for Parent calls an @ViewChild()Parent and children communicate using a serviceTest it for Parent and children communicate using a service This cookbook contains recipes for common component communication scenarios in which two or more components share information. See the live example / download example. Pass data from parent to child with input bindinglink HeroChildComponent has two input properties, typically adorned with @Input() decorator. content_copy import { Component, Input } from '@angular/core'; import { Hero } from './hero'; @Component({ selector: 'app-hero-child', template:  h3{{hero.name}} says:/h3 pI, {{hero.name}}, am at your service, {{masterName}}./p  }) export class HeroChildComponent { @Input() hero!: Hero; @Input('master') masterName = ''; } The second @Input aliases the child component property name masterName as 'master'. The HeroParentComponent nests the child HeroChildComponent inside an *ngFor repeater, binding its master string property to the child's master alias, and each iteration's hero instance to the child's hero property. content_copy import { Component } from '@angular/core'; import { HEROES } from './hero'; @Component({ selector: 'app-hero-parent', template:  h2{{master}} controls {{heroes.length}} heroes/h2 app-hero-child *ngFor=\"let hero of heroes\" [hero]=\"hero\" [master]=\"master\" /app-hero-child  }) export class HeroParentComponent { heroes = HEROES; master = 'Master'; } The running application displays three heroes: Test it for Pass data from parent to child with input bindinglink E2E test that all children were instantiated and displayed as expected: content_copy // ... const heroNames = ['Dr. IQ', 'Magneta', 'Bombasto']; const masterName = 'Master'; it('should pass properties to children properly', async () = { const parent = element(by.tagName('app-hero-parent')); const heroes = parent.all(by.tagName('app-hero-child')); for (let i = 0; i  heroNames.length; i++) { const childTitle = await heroes.get(i).element(by.tagName('h3')).getText(); const childDetail = await heroes.get(i).element(by.tagName('p')).getText(); expect(childTitle).toEqual(heroNames[i] + ' says:'); expect(childDetail).toContain(masterName); } }); // ... Back to top Intercept input property changes with a setterlink Use an input property setter to intercept and act upon a value from the parent. The setter of the name input property in the child NameChildComponent trims the whitespace from a name and replaces an empty value with default text. content_copy import { Component, Input } from '@angular/core'; @Component({ selector: 'app-name-child', template: 'h3\"{{name}}\"/h3' }) export class NameChildComponent { @Input() get name(): string { return this._name; } set name(name: string) { this._name = (name && name.trim())  'no name set'; } private _name = ''; } Here's the NameParentComponent demonstrating name variations including a name with all spaces: content_copy import { Component } from '@angular/core'; @Component({ selector: 'app-name-parent', template:  h2Master controls {{names.length}} names/h2 app-name-child *ngFor=\"let name of names\" [name]=\"name\"/app-name-child  }) export class NameParentComponent { // Displays 'Dr. IQ', 'no name set', 'Bombasto' names = ['Dr. IQ', ' ', ' Bombasto ']; } Test it for Intercept input property changes with a setterlink E2E tests of input property setter with empty and non-empty names: content_copy // ... it('should display trimmed, non-empty names', async () = { const nonEmptyNameIndex = 0; const nonEmptyName = '\"Dr. IQ\"'; const parent = element(by.tagName('app-name-parent')); const hero = parent.all(by.tagName('app-name-child')).get(nonEmptyNameIndex); const displayName = await hero.element(by.tagName('h3')).getText(); expect(displayName).toEqual(nonEmptyName); }); it('should replace empty name with default name', async () = { const emptyNameIndex = 1; const defaultName = '\"no name set\"'; const parent = element(by.tagName('app-name-parent')); const hero = parent.all(by.tagName('app-name-child')).get(emptyNameIndex); const displayName = await hero.element(by.tagName('h3')).getText(); expect(displayName).toEqual(defaultName); }); // ... Back to top Intercept input property changes with ngOnChanges()link Detect and act upon changes to input property values with the ngOnChanges() method of the OnChanges lifecycle hook interface. You might prefer this approach to the property setter when watching multiple, interacting input properties. Learn about ngOnChanges() in the Lifecycle Hooks chapter. This VersionChildComponent detects changes to the major and minor input properties and composes a log message reporting these changes: content_copy import { Component, Input, OnChanges, SimpleChanges } from '@angular/core'; @Component({ selector: 'app-version-child', template:  h3Version {{major}}.{{minor}}/h3 h4Change log:/h4 ul li *ngFor=\"let change of changeLog\"{{change}}/li /ul  }) export class VersionChildComponent implements OnChanges { @Input() major = 0; @Input() minor = 0; changeLog: string[] = []; ngOnChanges(changes: SimpleChanges) { const log: string[] = []; for (const propName in changes) { const changedProp = changes[propName]; const to = JSON.stringify(changedProp.currentValue); if (changedProp.isFirstChange()) { log.push(Initial value of ${propName} set to ${to}); } else { const from = JSON.stringify(changedProp.previousValue); log.push(${propName} changed from ${from} to ${to}); } } this.changeLog.push(log.join(', ')); } } The VersionParentComponent supplies the minor and major values and binds buttons to methods that change them. content_copy import { Component } from '@angular/core'; @Component({ selector: 'app-version-parent', template:  h2Source code version/h2 button type=\"button\" (click)=\"newMinor()\"New minor version/button button type=\"button\" (click)=\"newMajor()\"New major version/button app-version-child [major]=\"major\" [minor]=\"minor\"/app-version-child  }) export class VersionParentComponent { major = 1; minor = 23; newMinor() { this.minor++; } newMajor() { this.major++; this.minor = 0; } } Here's the output of a button-pushing sequence: Test it for Intercept input property changes with ngOnChanges()link Test that both input properties are set initially and that button clicks trigger the expected ngOnChanges calls and values: content_copy // ... // Test must all execute in this exact order it('should set expected initial values', async () = { const actual = await getActual(); const initialLabel = 'Version 1.23'; const initialLog = 'Initial value of major set to 1, Initial value of minor set to 23'; expect(actual.label).toBe(initialLabel); expect(actual.count).toBe(1); expect(await actual.logs.get(0).getText()).toBe(initialLog); }); it(\"should set expected values after clicking 'Minor' twice\", async () = { const repoTag = element(by.tagName('app-version-parent')); const newMinorButton = repoTag.all(by.tagName('button')).get(0); await newMinorButton.click(); await newMinorButton.click(); const actual = await getActual(); const labelAfter2Minor = 'Version 1.25'; const logAfter2Minor = 'minor changed from 24 to 25'; expect(actual.label).toBe(labelAfter2Minor); expect(actual.count).toBe(3); expect(await actual.logs.get(2).getText()).toBe(logAfter2Minor); }); it(\"should set expected values after clicking 'Major' once\", async () = { const repoTag = element(by.tagName('app-version-parent')); const newMajorButton = repoTag.all(by.tagName('button')).get(1); await newMajorButton.click(); const actual = await getActual(); const labelAfterMajor = 'Version 2.0'; const logAfterMajor = 'major changed from 1 to 2, minor changed from 23 to 0'; expect(actual.label).toBe(labelAfterMajor); expect(actual.count).toBe(2); expect(await actual.logs.get(1).getText()).toBe(logAfterMajor); }); async function getActual() { const versionTag = element(by.tagName('app-version-child')); const label = await versionTag.element(by.tagName('h3')).getText(); const ul = versionTag.element((by.tagName('ul'))); const logs = ul.all(by.tagName('li')); return { label, logs, count: await logs.count(), }; } // ... Back to top Parent listens for child eventlink The child component exposes an EventEmitter property with which it emits events when something happens. The parent binds to that event property and reacts to those events. The child's EventEmitter property is an output property, typically adorned with an @Output() decorator as seen in this VoterComponent: content_copy import { Component, EventEmitter, Input, Output } from '@angular/core'; @Component({ selector: 'app-voter', template:  h4{{name}}/h4 button type=\"button\" (click)=\"vote(true)\" [disabled]=\"didVote\"Agree/button button type=\"button\" (click)=\"vote(false)\" [disabled]=\"didVote\"Disagree/button  }) export class VoterComponent { @Input() name = ''; @Output() voted = new EventEmitterboolean(); didVote = false; vote(agreed: boolean) { this.voted.emit(agreed); this.didVote = true; } } Clicking a button triggers emission of a true or false, the boolean payload. The parent VoteTakerComponent binds an event handler called onVoted() that responds to the child event payload $event and updates a counter. content_copy import { Component } from '@angular/core'; @Component({ selector: 'app-vote-taker', template:  h2Should mankind colonize the Universe?/h2 h3Agree: {{agreed}}, Disagree: {{disagreed}}/h3 app-voter *ngFor=\"let voter of voters\" [name]=\"voter\" (voted)=\"onVoted($event)\" /app-voter  }) export class VoteTakerComponent { agreed = 0; disagreed = 0; voters = ['Dr. IQ', 'Celeritas', 'Bombasto']; onVoted(agreed: boolean) { if (agreed) { this.agreed++; } else { this.disagreed++; } } } The framework passes the event argument represented by $event to the handler method, and the method processes it: Test it for Parent listens for child eventlink Test that clicking the Agree and Disagree buttons update the appropriate counters: content_copy // ... it('should not emit the event initially', async () = { const voteLabel = element(by.tagName('app-vote-taker')).element(by.tagName('h3')); expect(await voteLabel.getText()).toBe('Agree: 0, Disagree: 0'); }); it('should process Agree vote', async () = { const voteLabel = element(by.tagName('app-vote-taker')).element(by.tagName('h3')); const agreeButton1 = element.all(by.tagName('app-voter')).get(0) .all(by.tagName('button')).get(0); await agreeButton1.click(); expect(await voteLabel.getText()).toBe('Agree: 1, Disagree: 0'); }); it('should process Disagree vote', async () = { const voteLabel = element(by.tagName('app-vote-taker')).element(by.tagName('h3')); const agreeButton1 = element.all(by.tagName('app-voter')).get(1) .all(by.tagName('button')).get(1); await agreeButton1.click(); expect(await voteLabel.getText()).toBe('Agree: 0, Disagree: 1'); }); // ... Back to top Parent interacts with child using local variablelink A parent component cannot use data binding to read child properties or invoke child methods. Do both by creating a template reference variable for the child element and then reference that variable within the parent template as seen in the following example. The following is a child CountdownTimerComponent that repeatedly counts down to zero and launches a rocket. The start and stop methods control the clock and a countdown status message displays in its own template. content_copy import { Component, OnDestroy } from '@angular/core'; @Component({ selector: 'app-countdown-timer', template: 'p{{message}}/p' }) export class CountdownTimerComponent implements OnDestroy { message = ''; seconds = 11; ngOnDestroy() { this.clearTimer?.(); } start() { this.countDown(); } stop() { this.clearTimer?.(); this.message = Holding at T-${this.seconds} seconds; } private clearTimer: VoidFunction  undefined; private countDown() { this.clearTimer?.(); const interval = setInterval(() = { this.seconds -= 1; if (this.seconds === 0) { this.message = 'Blast off!'; } else { if (this.seconds  0) { this.seconds = 10; } // reset this.message = T-${this.seconds} seconds and counting; } }, 1000); this.clearTimer = () = clearInterval(interval); } } The CountdownLocalVarParentComponent that hosts the timer component is as follows: content_copy import { Component } from '@angular/core'; import { CountdownTimerComponent } from './countdown-timer.component'; @Component({ selector: 'app-countdown-parent-lv', template:  h3Countdown to Liftoff (via local variable)/h3 button type=\"button\" (click)=\"timer.start()\"Start/button button type=\"button\" (click)=\"timer.stop()\"Stop/button div class=\"seconds\"{{timer.seconds}}/div app-countdown-timer #timer/app-countdown-timer , styleUrls: ['../assets/demo.css'] }) export class CountdownLocalVarParentComponent { } The parent component cannot data bind to the child's start and stop methods nor to its seconds property. Place a local variable, #timer, on the tag app-countdown-timer representing the child component. That gives you a reference to the child component and the ability to access any of its properties or methods from within the parent template. This example wires parent buttons to the child's start and stop and uses interpolation to display the child's seconds property. Here, the parent and child are working together. Test it for Parent interacts with child using local variablelink Test that the seconds displayed in the parent template match the seconds displayed in the child's status message. Test also that clicking the Stop button pauses the countdown timer: content_copy // ... // The tests trigger periodic asynchronous operations (via setInterval()), which will prevent // the app from stabilizing. See https://angular.io/api/core/ApplicationRef#is-stable-examples // for more details. // To allow the tests to complete, we will disable automatically waiting for the Angular app to // stabilize. beforeEach(() = browser.waitForAngularEnabled(false)); afterEach(() = browser.waitForAngularEnabled(true)); it('timer and parent seconds should match', async () = { const parent = element(by.tagName(parentTag)); const startButton = parent.element(by.buttonText('Start')); const seconds = parent.element(by.className('seconds')); const timer = parent.element(by.tagName('app-countdown-timer')); await startButton.click(); // Wait for app-countdown-timer to be populated with any text. await browser.wait(() = timer.getText(), 2000); expect(await timer.getText()).toContain(await seconds.getText()); }); it('should stop the countdown', async () = { const parent = element(by.tagName(parentTag)); const startButton = parent.element(by.buttonText('Start')); const stopButton = parent.element(by.buttonText('Stop')); const timer = parent.element(by.tagName('app-countdown-timer')); await startButton.click(); expect(await timer.getText()).not.toContain('Holding'); await stopButton.click(); expect(await timer.getText()).toContain('Holding'); }); // ... Back to top Parent calls an @ViewChild()link The local variable approach is straightforward. But it is limited because the parent-child wiring must be done entirely within the parent template. The parent component itself has no access to the child. You can't use the local variable technique if the parent component's class relies on the child component's class. The parent-child relationship of the components is not established within each component's respective class with the local variable technique. Because the class instances are not connected to one another, the parent class cannot access the child class properties and methods. When the parent component class requires that kind of access, inject the child component into the parent as a ViewChild. The following example illustrates this technique with the same Countdown Timer example. Neither its appearance nor its behavior changes. The child CountdownTimerComponent is the same as well. The switch from the local variable to the ViewChild technique is solely for the purpose of demonstration. Here is the parent, CountdownViewChildParentComponent: content_copy import { AfterViewInit, ViewChild } from '@angular/core'; import { Component } from '@angular/core'; import { CountdownTimerComponent } from './countdown-timer.component'; @Component({ selector: 'app-countdown-parent-vc', template:  h3Countdown to Liftoff (via ViewChild)/h3 button type=\"button\" (click)=\"start()\"Start/button button type=\"button\" (click)=\"stop()\"Stop/button div class=\"seconds\"{{ seconds() }}/div app-countdown-timer/app-countdown-timer , styleUrls: ['../assets/demo.css'] }) export class CountdownViewChildParentComponent implements AfterViewInit { @ViewChild(CountdownTimerComponent) private timerComponent!: CountdownTimerComponent; seconds() { return 0; } ngAfterViewInit() { // Redefine seconds() to get from the CountdownTimerComponent.seconds ... // but wait a tick first to avoid one-time devMode // unidirectional-data-flow-violation error setTimeout(() = this.seconds = () = this.timerComponent.seconds, 0); } start() { this.timerComponent.start(); } stop() { this.timerComponent.stop(); } } It takes a bit more work to get the child view into the parent component class. First, you have to import references to the ViewChild decorator and the AfterViewInit lifecycle hook. Next, inject the child CountdownTimerComponent into the private timerComponent property using the @ViewChild property decoration. The #timer local variable is gone from the component metadata. Instead, bind the buttons to the parent component's own start and stop methods and present the ticking seconds in an interpolation around the parent component's seconds method. These methods access the injected timer component directly. The ngAfterViewInit() lifecycle hook is an important wrinkle. The timer component isn't available until after Angular displays the parent view. So it displays 0 seconds initially. Then Angular calls the ngAfterViewInit lifecycle hook at which time it is too late to update the parent view's display of the countdown seconds. Angular's unidirectional data flow rule prevents updating the parent view's in the same cycle. The application must wait one turn before it can display the seconds. Use setTimeout() to wait one tick and then revise the seconds() method so that it takes future values from the timer component. Test it for Parent calls an @ViewChild()link Use the same countdown timer tests as before. Back to top Parent and children communicate using a servicelink A parent component and its children share a service whose interface enables bidirectional communication within the family. The scope of the service instance is the parent component and its children. Components outside this component subtree have no access to the service or their communications. This MissionService connects the MissionControlComponent to multiple AstronautComponent children. content_copy import { Injectable } from '@angular/core'; import { Subject } from 'rxjs'; @Injectable() export class MissionService { // Observable string sources private missionAnnouncedSource = new Subjectstring(); private missionConfirmedSource = new Subjectstring(); // Observable string streams missionAnnounced$ = this.missionAnnouncedSource.asObservable(); missionConfirmed$ = this.missionConfirmedSource.asObservable(); // Service message commands announceMission(mission: string) { this.missionAnnouncedSource.next(mission); } confirmMission(astronaut: string) { this.missionConfirmedSource.next(astronaut); } } The MissionControlComponent both provides the instance of the service that it shares with its children (through the providers metadata array) and injects that instance into itself through its constructor: content_copy import { Component } from '@angular/core'; import { MissionService } from './mission.service'; @Component({ selector: 'app-mission-control', template:  h2Mission Control/h2 button type=\"button\" (click)=\"announce()\"Announce mission/button app-astronaut *ngFor=\"let astronaut of astronauts\" [astronaut]=\"astronaut\" /app-astronaut h3History/h3 ul li *ngFor=\"let event of history\"{{event}}/li /ul , providers: [MissionService] }) export class MissionControlComponent { astronauts = ['Lovell', 'Swigert', 'Haise']; history: string[] = []; missions = ['Fly to the moon!', 'Fly to mars!', 'Fly to Vegas!']; nextMission = 0; constructor(private missionService: MissionService) { missionService.missionConfirmed$.subscribe( astronaut = { this.history.push(${astronaut} confirmed the mission); }); } announce() { const mission = this.missions[this.nextMission++]; this.missionService.announceMission(mission); this.history.push(Mission \"${mission}\" announced); if (this.nextMission = this.missions.length) { this.nextMission = 0; } } } The AstronautComponent also injects the service in its constructor. Each AstronautComponent is a child of the MissionControlComponent and therefore receives its parent's service instance: content_copy import { Component, Input, OnDestroy } from '@angular/core'; import { MissionService } from './mission.service'; import { Subscription } from 'rxjs'; @Component({ selector: 'app-astronaut', template:  p {{astronaut}}: strong{{mission}}/strong button type=\"button\" (click)=\"confirm()\" [disabled]=\"!announced  confirmed\" Confirm /button /p  }) export class AstronautComponent implements OnDestroy { @Input() astronaut = ''; mission = 'no mission announced'; confirmed = false; announced = false; subscription: Subscription; constructor(private missionService: MissionService) { this.subscription = missionService.missionAnnounced$.subscribe( mission = { this.mission = mission; this.announced = true; this.confirmed = false; }); } confirm() { this.confirmed = true; this.missionService.confirmMission(this.astronaut); } ngOnDestroy() { // prevent memory leak when component destroyed this.subscription.unsubscribe(); } } Notice that this example captures the subscription and unsubscribe() when the AstronautComponent is destroyed. This is a memory-leak guard step. There is no actual risk in this application because the lifetime of a AstronautComponent is the same as the lifetime of the application itself. That would not always be true in a more complex application. You don't add this guard to the MissionControlComponent because, as the parent, it controls the lifetime of the MissionService. The History log demonstrates that messages travel in both directions between the parent MissionControlComponent and the AstronautComponent children, facilitated by the service: Test it for Parent and children communicate using a servicelink Tests click buttons of both the parent MissionControlComponent and the AstronautComponent children and verify that the history meets expectations: content_copy // ... it('should announce a mission', async () = { const missionControl = element(by.tagName('app-mission-control')); const announceButton = missionControl.all(by.tagName('button')).get(0); const history = missionControl.all(by.tagName('li')); await announceButton.click(); expect(await history.count()).toBe(1); expect(await history.get(0).getText()).toMatch(/Mission.* announced/); }); it('should confirm the mission by Lovell', async () = { await testConfirmMission(1, 'Lovell'); }); it('should confirm the mission by Haise', async () = { await testConfirmMission(3, 'Haise'); }); it('should confirm the mission by Swigert', async () = { await testConfirmMission(2, 'Swigert'); }); async function testConfirmMission(buttonIndex: number, astronaut: string) { const missionControl = element(by.tagName('app-mission-control')); const announceButton = missionControl.all(by.tagName('button')).get(0); const confirmButton = missionControl.all(by.tagName('button')).get(buttonIndex); const history = missionControl.all(by.tagName('li')); await announceButton.click(); await confirmButton.click(); expect(await history.count()).toBe(2); expect(await history.get(1).getText()).toBe(${astronaut} confirmed the mission); } // ... Back to top Last reviewed on Mon Feb 28 2022",
    "headings": [
      {
        "level": 1,
        "text": "Component interactionlink",
        "id": "component-interaction"
      },
      {
        "level": 2,
        "text": "Pass data from parent to child with input bindinglink",
        "id": "pass-data-from-parent-to-child-with-input-binding"
      },
      {
        "level": 2,
        "text": "Intercept input property changes with a setterlink",
        "id": "intercept-input-property-changes-with-a-setter"
      },
      {
        "level": 2,
        "text": "Intercept input property changes with ngOnChanges()link",
        "id": "intercept-input-property-changes-with-ngonchanges"
      },
      {
        "level": 2,
        "text": "Parent listens for child eventlink",
        "id": "parent-listens-for-child-event"
      },
      {
        "level": 2,
        "text": "Parent interacts with child using local variablelink",
        "id": "parent-interacts-with-child-using-local-variable"
      },
      {
        "level": 2,
        "text": "Parent calls an @ViewChild()link",
        "id": "parent-calls-an-viewchild"
      },
      {
        "level": 2,
        "text": "Parent and children communicate using a servicelink",
        "id": "parent-and-children-communicate-using-a-service"
      },
      {
        "level": 3,
        "text": "Test it for Pass data from parent to child with input bindinglink",
        "id": "test-it-for-pass-data-from-parent-to-child-with-input-binding"
      },
      {
        "level": 3,
        "text": "Test it for Intercept input property changes with a setterlink",
        "id": "test-it-for-intercept-input-property-changes-with-a-setter"
      },
      {
        "level": 3,
        "text": "Test it for Intercept input property changes with ngOnChanges()link",
        "id": "test-it-for-intercept-input-property-changes-with-ngonchanges"
      },
      {
        "level": 3,
        "text": "Test it for Parent listens for child eventlink",
        "id": "test-it-for-parent-listens-for-child-event"
      },
      {
        "level": 3,
        "text": "Test it for Parent interacts with child using local variablelink",
        "id": "test-it-for-parent-interacts-with-child-using-local-variable"
      },
      {
        "level": 3,
        "text": "Test it for Parent calls an @ViewChild()link",
        "id": "test-it-for-parent-calls-an-viewchild"
      },
      {
        "level": 3,
        "text": "Test it for Parent and children communicate using a servicelink",
        "id": "test-it-for-parent-and-children-communicate-using-a-service"
      }
    ],
    "codeBlocks": [
      {
        "language": "text",
        "code": "ngOnChanges()"
      },
      {
        "language": "text",
        "code": "ngOnChanges()"
      },
      {
        "language": "text",
        "code": "@ViewChild()"
      },
      {
        "language": "text",
        "code": "@ViewChild()"
      },
      {
        "language": "text",
        "code": "HeroChildComponent"
      },
      {
        "language": "text",
        "code": "content_copy\n      \n      import { Component, Input } from '@angular/core';\n\nimport { Hero } from './hero';\n\n@Component({\n  selector: 'app-hero-child',\n  template: `\n    <h3>{{hero.name}} says:</h3>\n    <p>I, {{hero.name}}, am at your service, {{masterName}}.</p>\n  `\n})\nexport class HeroChildComponent {\n  @Input() hero!: Hero;\n  @Input('master') masterName = '';\n}"
      },
      {
        "language": "text",
        "code": "import { Component, Input } from '@angular/core';\n\nimport { Hero } from './hero';\n\n@Component({\n  selector: 'app-hero-child',\n  template: `\n    <h3>{{hero.name}} says:</h3>\n    <p>I, {{hero.name}}, am at your service, {{masterName}}.</p>\n  `\n})\nexport class HeroChildComponent {\n  @Input() hero!: Hero;\n  @Input('master') masterName = '';\n}"
      },
      {
        "language": "text",
        "code": "HeroParentComponent"
      },
      {
        "language": "text",
        "code": "HeroChildComponent"
      },
      {
        "language": "text",
        "code": "content_copy\n      \n      import { Component } from '@angular/core';\n\nimport { HEROES } from './hero';\n\n@Component({\n  selector: 'app-hero-parent',\n  template: `\n    <h2>{{master}} controls {{heroes.length}} heroes</h2>\n\n    <app-hero-child\n      *ngFor=\"let hero of heroes\"\n      [hero]=\"hero\"\n      [master]=\"master\">\n    </app-hero-child>\n  `\n})\nexport class HeroParentComponent {\n  heroes = HEROES;\n  master = 'Master';\n}"
      },
      {
        "language": "text",
        "code": "import { Component } from '@angular/core';\n\nimport { HEROES } from './hero';\n\n@Component({\n  selector: 'app-hero-parent',\n  template: `\n    <h2>{{master}} controls {{heroes.length}} heroes</h2>\n\n    <app-hero-child\n      *ngFor=\"let hero of heroes\"\n      [hero]=\"hero\"\n      [master]=\"master\">\n    </app-hero-child>\n  `\n})\nexport class HeroParentComponent {\n  heroes = HEROES;\n  master = 'Master';\n}"
      },
      {
        "language": "text",
        "code": "content_copy\n      \n      // ...\nconst heroNames = ['Dr. IQ', 'Magneta', 'Bombasto'];\nconst masterName = 'Master';\n\nit('should pass properties to children properly', async () => {\n  const parent = element(by.tagName('app-hero-parent'));\n  const heroes = parent.all(by.tagName('app-hero-child'));\n\n  for (let i = 0; i < heroNames.length; i++) {\n    const childTitle = await heroes.get(i).element(by.tagName('h3')).getText();\n    const childDetail = await heroes.get(i).element(by.tagName('p')).getText();\n    expect(childTitle).toEqual(heroNames[i] + ' says:');\n    expect(childDetail).toContain(masterName);\n  }\n});\n// ..."
      },
      {
        "language": "text",
        "code": "// ...\nconst heroNames = ['Dr. IQ', 'Magneta', 'Bombasto'];\nconst masterName = 'Master';\n\nit('should pass properties to children properly', async () => {\n  const parent = element(by.tagName('app-hero-parent'));\n  const heroes = parent.all(by.tagName('app-hero-child'));\n\n  for (let i = 0; i < heroNames.length; i++) {\n    const childTitle = await heroes.get(i).element(by.tagName('h3')).getText();\n    const childDetail = await heroes.get(i).element(by.tagName('p')).getText();\n    expect(childTitle).toEqual(heroNames[i] + ' says:');\n    expect(childDetail).toContain(masterName);\n  }\n});\n// ..."
      },
      {
        "language": "text",
        "code": "NameChildComponent"
      },
      {
        "language": "text",
        "code": "content_copy\n      \n      import { Component, Input } from '@angular/core';\n\n@Component({\n  selector: 'app-name-child',\n  template: '<h3>\"{{name}}\"</h3>'\n})\nexport class NameChildComponent {\n  @Input()\n  get name(): string { return this._name; }\n  set name(name: string) {\n    this._name = (name && name.trim()) || '<no name set>';\n  }\n  private _name = '';\n}"
      },
      {
        "language": "text",
        "code": "import { Component, Input } from '@angular/core';\n\n@Component({\n  selector: 'app-name-child',\n  template: '<h3>\"{{name}}\"</h3>'\n})\nexport class NameChildComponent {\n  @Input()\n  get name(): string { return this._name; }\n  set name(name: string) {\n    this._name = (name && name.trim()) || '<no name set>';\n  }\n  private _name = '';\n}"
      },
      {
        "language": "text",
        "code": "NameParentComponent"
      },
      {
        "language": "text",
        "code": "content_copy\n      \n      import { Component } from '@angular/core';\n\n@Component({\n  selector: 'app-name-parent',\n  template: `\n    <h2>Master controls {{names.length}} names</h2>\n\n    <app-name-child *ngFor=\"let name of names\" [name]=\"name\"></app-name-child>\n  `\n})\nexport class NameParentComponent {\n  // Displays 'Dr. IQ', '<no name set>', 'Bombasto'\n  names = ['Dr. IQ', '   ', '  Bombasto  '];\n}"
      },
      {
        "language": "text",
        "code": "import { Component } from '@angular/core';\n\n@Component({\n  selector: 'app-name-parent',\n  template: `\n    <h2>Master controls {{names.length}} names</h2>\n\n    <app-name-child *ngFor=\"let name of names\" [name]=\"name\"></app-name-child>\n  `\n})\nexport class NameParentComponent {\n  // Displays 'Dr. IQ', '<no name set>', 'Bombasto'\n  names = ['Dr. IQ', '   ', '  Bombasto  '];\n}"
      },
      {
        "language": "text",
        "code": "content_copy\n      \n      // ...\nit('should display trimmed, non-empty names', async () => {\n  const nonEmptyNameIndex = 0;\n  const nonEmptyName = '\"Dr. IQ\"';\n  const parent = element(by.tagName('app-name-parent'));\n  const hero = parent.all(by.tagName('app-name-child')).get(nonEmptyNameIndex);\n\n  const displayName = await hero.element(by.tagName('h3')).getText();\n  expect(displayName).toEqual(nonEmptyName);\n});\n\nit('should replace empty name with default name', async () => {\n  const emptyNameIndex = 1;\n  const defaultName = '\"<no name set>\"';\n  const parent = element(by.tagName('app-name-parent'));\n  const hero = parent.all(by.tagName('app-name-child')).get(emptyNameIndex);\n\n  const displayName = await hero.element(by.tagName('h3')).getText();\n  expect(displayName).toEqual(defaultName);\n});\n// ..."
      },
      {
        "language": "text",
        "code": "// ...\nit('should display trimmed, non-empty names', async () => {\n  const nonEmptyNameIndex = 0;\n  const nonEmptyName = '\"Dr. IQ\"';\n  const parent = element(by.tagName('app-name-parent'));\n  const hero = parent.all(by.tagName('app-name-child')).get(nonEmptyNameIndex);\n\n  const displayName = await hero.element(by.tagName('h3')).getText();\n  expect(displayName).toEqual(nonEmptyName);\n});\n\nit('should replace empty name with default name', async () => {\n  const emptyNameIndex = 1;\n  const defaultName = '\"<no name set>\"';\n  const parent = element(by.tagName('app-name-parent'));\n  const hero = parent.all(by.tagName('app-name-child')).get(emptyNameIndex);\n\n  const displayName = await hero.element(by.tagName('h3')).getText();\n  expect(displayName).toEqual(defaultName);\n});\n// ..."
      },
      {
        "language": "text",
        "code": "ngOnChanges()"
      },
      {
        "language": "text",
        "code": "ngOnChanges()"
      },
      {
        "language": "text",
        "code": "ngOnChanges()"
      },
      {
        "language": "text",
        "code": "VersionChildComponent"
      },
      {
        "language": "text",
        "code": "content_copy\n      \n      import { Component, Input, OnChanges, SimpleChanges } from '@angular/core';\n\n@Component({\n  selector: 'app-version-child',\n  template: `\n    <h3>Version {{major}}.{{minor}}</h3>\n    <h4>Change log:</h4>\n    <ul>\n      <li *ngFor=\"let change of changeLog\">{{change}}</li>\n    </ul>\n  `\n})\nexport class VersionChildComponent implements OnChanges {\n  @Input() major = 0;\n  @Input() minor = 0;\n  changeLog: string[] = [];\n\n  ngOnChanges(changes: SimpleChanges) {\n    const log: string[] = [];\n    for (const propName in changes) {\n      const changedProp = changes[propName];\n      const to = JSON.stringify(changedProp.currentValue);\n      if (changedProp.isFirstChange()) {\n        log.push(`Initial value of ${propName} set to ${to}`);\n      } else {\n        const from = JSON.stringify(changedProp.previousValue);\n        log.push(`${propName} changed from ${from} to ${to}`);\n      }\n    }\n    this.changeLog.push(log.join(', '));\n  }\n}"
      },
      {
        "language": "text",
        "code": "import { Component, Input, OnChanges, SimpleChanges } from '@angular/core';\n\n@Component({\n  selector: 'app-version-child',\n  template: `\n    <h3>Version {{major}}.{{minor}}</h3>\n    <h4>Change log:</h4>\n    <ul>\n      <li *ngFor=\"let change of changeLog\">{{change}}</li>\n    </ul>\n  `\n})\nexport class VersionChildComponent implements OnChanges {\n  @Input() major = 0;\n  @Input() minor = 0;\n  changeLog: string[] = [];\n\n  ngOnChanges(changes: SimpleChanges) {\n    const log: string[] = [];\n    for (const propName in changes) {\n      const changedProp = changes[propName];\n      const to = JSON.stringify(changedProp.currentValue);\n      if (changedProp.isFirstChange()) {\n        log.push(`Initial value of ${propName} set to ${to}`);\n      } else {\n        const from = JSON.stringify(changedProp.previousValue);\n        log.push(`${propName} changed from ${from} to ${to}`);\n      }\n    }\n    this.changeLog.push(log.join(', '));\n  }\n}"
      },
      {
        "language": "text",
        "code": "VersionParentComponent"
      },
      {
        "language": "text",
        "code": "content_copy\n      \n      import { Component } from '@angular/core';\n\n@Component({\n  selector: 'app-version-parent',\n  template: `\n    <h2>Source code version</h2>\n    <button type=\"button\" (click)=\"newMinor()\">New minor version</button>\n    <button type=\"button\" (click)=\"newMajor()\">New major version</button>\n    <app-version-child [major]=\"major\" [minor]=\"minor\"></app-version-child>\n  `\n})\nexport class VersionParentComponent {\n  major = 1;\n  minor = 23;\n\n  newMinor() {\n    this.minor++;\n  }\n\n  newMajor() {\n    this.major++;\n    this.minor = 0;\n  }\n}"
      },
      {
        "language": "text",
        "code": "import { Component } from '@angular/core';\n\n@Component({\n  selector: 'app-version-parent',\n  template: `\n    <h2>Source code version</h2>\n    <button type=\"button\" (click)=\"newMinor()\">New minor version</button>\n    <button type=\"button\" (click)=\"newMajor()\">New major version</button>\n    <app-version-child [major]=\"major\" [minor]=\"minor\"></app-version-child>\n  `\n})\nexport class VersionParentComponent {\n  major = 1;\n  minor = 23;\n\n  newMinor() {\n    this.minor++;\n  }\n\n  newMajor() {\n    this.major++;\n    this.minor = 0;\n  }\n}"
      },
      {
        "language": "text",
        "code": "ngOnChanges()"
      },
      {
        "language": "text",
        "code": "ngOnChanges"
      },
      {
        "language": "text",
        "code": "content_copy\n      \n      // ...\n// Test must all execute in this exact order\nit('should set expected initial values', async () => {\n  const actual = await getActual();\n\n  const initialLabel = 'Version 1.23';\n  const initialLog = 'Initial value of major set to 1, Initial value of minor set to 23';\n\n  expect(actual.label).toBe(initialLabel);\n  expect(actual.count).toBe(1);\n  expect(await actual.logs.get(0).getText()).toBe(initialLog);\n});\n\nit(\"should set expected values after clicking 'Minor' twice\", async () => {\n  const repoTag = element(by.tagName('app-version-parent'));\n  const newMinorButton = repoTag.all(by.tagName('button')).get(0);\n\n  await newMinorButton.click();\n  await newMinorButton.click();\n\n  const actual = await getActual();\n\n  const labelAfter2Minor = 'Version 1.25';\n  const logAfter2Minor = 'minor changed from 24 to 25';\n\n  expect(actual.label).toBe(labelAfter2Minor);\n  expect(actual.count).toBe(3);\n  expect(await actual.logs.get(2).getText()).toBe(logAfter2Minor);\n});\n\nit(\"should set expected values after clicking 'Major' once\", async () => {\n  const repoTag = element(by.tagName('app-version-parent'));\n  const newMajorButton = repoTag.all(by.tagName('button')).get(1);\n\n  await newMajorButton.click();\n  const actual = await getActual();\n\n  const labelAfterMajor = 'Version 2.0';\n  const logAfterMajor = 'major changed from 1 to 2, minor changed from 23 to 0';\n\n  expect(actual.label).toBe(labelAfterMajor);\n  expect(actual.count).toBe(2);\n  expect(await actual.logs.get(1).getText()).toBe(logAfterMajor);\n});\n\nasync function getActual() {\n  const versionTag = element(by.tagName('app-version-child'));\n  const label = await versionTag.element(by.tagName('h3')).getText();\n  const ul = versionTag.element((by.tagName('ul')));\n  const logs = ul.all(by.tagName('li'));\n\n  return {\n    label,\n    logs,\n    count: await logs.count(),\n  };\n}\n// ..."
      },
      {
        "language": "text",
        "code": "// ...\n// Test must all execute in this exact order\nit('should set expected initial values', async () => {\n  const actual = await getActual();\n\n  const initialLabel = 'Version 1.23';\n  const initialLog = 'Initial value of major set to 1, Initial value of minor set to 23';\n\n  expect(actual.label).toBe(initialLabel);\n  expect(actual.count).toBe(1);\n  expect(await actual.logs.get(0).getText()).toBe(initialLog);\n});\n\nit(\"should set expected values after clicking 'Minor' twice\", async () => {\n  const repoTag = element(by.tagName('app-version-parent'));\n  const newMinorButton = repoTag.all(by.tagName('button')).get(0);\n\n  await newMinorButton.click();\n  await newMinorButton.click();\n\n  const actual = await getActual();\n\n  const labelAfter2Minor = 'Version 1.25';\n  const logAfter2Minor = 'minor changed from 24 to 25';\n\n  expect(actual.label).toBe(labelAfter2Minor);\n  expect(actual.count).toBe(3);\n  expect(await actual.logs.get(2).getText()).toBe(logAfter2Minor);\n});\n\nit(\"should set expected values after clicking 'Major' once\", async () => {\n  const repoTag = element(by.tagName('app-version-parent'));\n  const newMajorButton = repoTag.all(by.tagName('button')).get(1);\n\n  await newMajorButton.click();\n  const actual = await getActual();\n\n  const labelAfterMajor = 'Version 2.0';\n  const logAfterMajor = 'major changed from 1 to 2, minor changed from 23 to 0';\n\n  expect(actual.label).toBe(labelAfterMajor);\n  expect(actual.count).toBe(2);\n  expect(await actual.logs.get(1).getText()).toBe(logAfterMajor);\n});\n\nasync function getActual() {\n  const versionTag = element(by.tagName('app-version-child'));\n  const label = await versionTag.element(by.tagName('h3')).getText();\n  const ul = versionTag.element((by.tagName('ul')));\n  const logs = ul.all(by.tagName('li'));\n\n  return {\n    label,\n    logs,\n    count: await logs.count(),\n  };\n}\n// ..."
      },
      {
        "language": "text",
        "code": "EventEmitter"
      },
      {
        "language": "text",
        "code": "EventEmitter"
      },
      {
        "language": "text",
        "code": "VoterComponent"
      },
      {
        "language": "text",
        "code": "content_copy\n      \n      import { Component, EventEmitter, Input, Output } from '@angular/core';\n\n@Component({\n  selector: 'app-voter',\n  template: `\n    <h4>{{name}}</h4>\n    <button type=\"button\" (click)=\"vote(true)\"  [disabled]=\"didVote\">Agree</button>\n    <button type=\"button\" (click)=\"vote(false)\" [disabled]=\"didVote\">Disagree</button>\n  `\n})\nexport class VoterComponent {\n  @Input()  name = '';\n  @Output() voted = new EventEmitter<boolean>();\n  didVote = false;\n\n  vote(agreed: boolean) {\n    this.voted.emit(agreed);\n    this.didVote = true;\n  }\n}"
      },
      {
        "language": "text",
        "code": "import { Component, EventEmitter, Input, Output } from '@angular/core';\n\n@Component({\n  selector: 'app-voter',\n  template: `\n    <h4>{{name}}</h4>\n    <button type=\"button\" (click)=\"vote(true)\"  [disabled]=\"didVote\">Agree</button>\n    <button type=\"button\" (click)=\"vote(false)\" [disabled]=\"didVote\">Disagree</button>\n  `\n})\nexport class VoterComponent {\n  @Input()  name = '';\n  @Output() voted = new EventEmitter<boolean>();\n  didVote = false;\n\n  vote(agreed: boolean) {\n    this.voted.emit(agreed);\n    this.didVote = true;\n  }\n}"
      },
      {
        "language": "text",
        "code": "VoteTakerComponent"
      },
      {
        "language": "text",
        "code": "content_copy\n      \n      import { Component } from '@angular/core';\n\n@Component({\n  selector: 'app-vote-taker',\n  template: `\n    <h2>Should mankind colonize the Universe?</h2>\n    <h3>Agree: {{agreed}}, Disagree: {{disagreed}}</h3>\n\n    <app-voter\n      *ngFor=\"let voter of voters\"\n      [name]=\"voter\"\n      (voted)=\"onVoted($event)\">\n    </app-voter>\n  `\n})\nexport class VoteTakerComponent {\n  agreed = 0;\n  disagreed = 0;\n  voters = ['Dr. IQ', 'Celeritas', 'Bombasto'];\n\n  onVoted(agreed: boolean) {\n    if (agreed) {\n      this.agreed++;\n    } else {\n      this.disagreed++;\n    }\n  }\n}"
      },
      {
        "language": "text",
        "code": "import { Component } from '@angular/core';\n\n@Component({\n  selector: 'app-vote-taker',\n  template: `\n    <h2>Should mankind colonize the Universe?</h2>\n    <h3>Agree: {{agreed}}, Disagree: {{disagreed}}</h3>\n\n    <app-voter\n      *ngFor=\"let voter of voters\"\n      [name]=\"voter\"\n      (voted)=\"onVoted($event)\">\n    </app-voter>\n  `\n})\nexport class VoteTakerComponent {\n  agreed = 0;\n  disagreed = 0;\n  voters = ['Dr. IQ', 'Celeritas', 'Bombasto'];\n\n  onVoted(agreed: boolean) {\n    if (agreed) {\n      this.agreed++;\n    } else {\n      this.disagreed++;\n    }\n  }\n}"
      },
      {
        "language": "text",
        "code": "content_copy\n      \n      // ...\nit('should not emit the event initially', async () => {\n  const voteLabel = element(by.tagName('app-vote-taker')).element(by.tagName('h3'));\n  expect(await voteLabel.getText()).toBe('Agree: 0, Disagree: 0');\n});\n\nit('should process Agree vote', async () => {\n  const voteLabel = element(by.tagName('app-vote-taker')).element(by.tagName('h3'));\n  const agreeButton1 = element.all(by.tagName('app-voter')).get(0)\n    .all(by.tagName('button')).get(0);\n\n  await agreeButton1.click();\n\n  expect(await voteLabel.getText()).toBe('Agree: 1, Disagree: 0');\n});\n\nit('should process Disagree vote', async () => {\n  const voteLabel = element(by.tagName('app-vote-taker')).element(by.tagName('h3'));\n  const agreeButton1 = element.all(by.tagName('app-voter')).get(1)\n    .all(by.tagName('button')).get(1);\n\n  await agreeButton1.click();\n\n  expect(await voteLabel.getText()).toBe('Agree: 0, Disagree: 1');\n});\n// ..."
      },
      {
        "language": "text",
        "code": "// ...\nit('should not emit the event initially', async () => {\n  const voteLabel = element(by.tagName('app-vote-taker')).element(by.tagName('h3'));\n  expect(await voteLabel.getText()).toBe('Agree: 0, Disagree: 0');\n});\n\nit('should process Agree vote', async () => {\n  const voteLabel = element(by.tagName('app-vote-taker')).element(by.tagName('h3'));\n  const agreeButton1 = element.all(by.tagName('app-voter')).get(0)\n    .all(by.tagName('button')).get(0);\n\n  await agreeButton1.click();\n\n  expect(await voteLabel.getText()).toBe('Agree: 1, Disagree: 0');\n});\n\nit('should process Disagree vote', async () => {\n  const voteLabel = element(by.tagName('app-vote-taker')).element(by.tagName('h3'));\n  const agreeButton1 = element.all(by.tagName('app-voter')).get(1)\n    .all(by.tagName('button')).get(1);\n\n  await agreeButton1.click();\n\n  expect(await voteLabel.getText()).toBe('Agree: 0, Disagree: 1');\n});\n// ..."
      },
      {
        "language": "text",
        "code": "CountdownTimerComponent"
      },
      {
        "language": "text",
        "code": "content_copy\n      \n      import { Component, OnDestroy } from '@angular/core';\n\n@Component({\n  selector: 'app-countdown-timer',\n  template: '<p>{{message}}</p>'\n})\nexport class CountdownTimerComponent implements OnDestroy {\n  message = '';\n  seconds = 11;\n\n  ngOnDestroy() { this.clearTimer?.(); }\n\n  start() { this.countDown(); }\n  stop()  {\n    this.clearTimer?.();\n    this.message = `Holding at T-${this.seconds} seconds`;\n  }\n\n  private clearTimer: VoidFunction | undefined;\n\n  private countDown() {\n    this.clearTimer?.();\n    const interval = setInterval(() => {\n      this.seconds -= 1;\n      if (this.seconds === 0) {\n        this.message = 'Blast off!';\n      } else {\n        if (this.seconds < 0) { this.seconds = 10; } // reset\n        this.message = `T-${this.seconds} seconds and counting`;\n      }\n    }, 1000);\n    this.clearTimer = () => clearInterval(interval);\n  }\n}"
      },
      {
        "language": "text",
        "code": "import { Component, OnDestroy } from '@angular/core';\n\n@Component({\n  selector: 'app-countdown-timer',\n  template: '<p>{{message}}</p>'\n})\nexport class CountdownTimerComponent implements OnDestroy {\n  message = '';\n  seconds = 11;\n\n  ngOnDestroy() { this.clearTimer?.(); }\n\n  start() { this.countDown(); }\n  stop()  {\n    this.clearTimer?.();\n    this.message = `Holding at T-${this.seconds} seconds`;\n  }\n\n  private clearTimer: VoidFunction | undefined;\n\n  private countDown() {\n    this.clearTimer?.();\n    const interval = setInterval(() => {\n      this.seconds -= 1;\n      if (this.seconds === 0) {\n        this.message = 'Blast off!';\n      } else {\n        if (this.seconds < 0) { this.seconds = 10; } // reset\n        this.message = `T-${this.seconds} seconds and counting`;\n      }\n    }, 1000);\n    this.clearTimer = () => clearInterval(interval);\n  }\n}"
      },
      {
        "language": "text",
        "code": "CountdownLocalVarParentComponent"
      },
      {
        "language": "text",
        "code": "content_copy\n      \n      import { Component } from '@angular/core';\nimport { CountdownTimerComponent } from './countdown-timer.component';\n\n@Component({\n  selector: 'app-countdown-parent-lv',\n  template: `\n    <h3>Countdown to Liftoff (via local variable)</h3>\n    <button type=\"button\" (click)=\"timer.start()\">Start</button>\n    <button type=\"button\" (click)=\"timer.stop()\">Stop</button>\n    <div class=\"seconds\">{{timer.seconds}}</div>\n    <app-countdown-timer #timer></app-countdown-timer>\n  `,\n  styleUrls: ['../assets/demo.css']\n})\nexport class CountdownLocalVarParentComponent { }"
      },
      {
        "language": "text",
        "code": "import { Component } from '@angular/core';\nimport { CountdownTimerComponent } from './countdown-timer.component';\n\n@Component({\n  selector: 'app-countdown-parent-lv',\n  template: `\n    <h3>Countdown to Liftoff (via local variable)</h3>\n    <button type=\"button\" (click)=\"timer.start()\">Start</button>\n    <button type=\"button\" (click)=\"timer.stop()\">Stop</button>\n    <div class=\"seconds\">{{timer.seconds}}</div>\n    <app-countdown-timer #timer></app-countdown-timer>\n  `,\n  styleUrls: ['../assets/demo.css']\n})\nexport class CountdownLocalVarParentComponent { }"
      },
      {
        "language": "text",
        "code": "<app-countdown-timer>"
      },
      {
        "language": "text",
        "code": "content_copy\n      \n      // ...\n// The tests trigger periodic asynchronous operations (via `setInterval()`), which will prevent\n// the app from stabilizing. See https://angular.io/api/core/ApplicationRef#is-stable-examples\n// for more details.\n// To allow the tests to complete, we will disable automatically waiting for the Angular app to\n// stabilize.\nbeforeEach(() => browser.waitForAngularEnabled(false));\nafterEach(() => browser.waitForAngularEnabled(true));\n\nit('timer and parent seconds should match', async () => {\n  const parent = element(by.tagName(parentTag));\n  const startButton = parent.element(by.buttonText('Start'));\n  const seconds = parent.element(by.className('seconds'));\n  const timer = parent.element(by.tagName('app-countdown-timer'));\n\n  await startButton.click();\n\n  // Wait for `<app-countdown-timer>` to be populated with any text.\n  await browser.wait(() => timer.getText(), 2000);\n\n  expect(await timer.getText()).toContain(await seconds.getText());\n});\n\nit('should stop the countdown', async () => {\n  const parent = element(by.tagName(parentTag));\n  const startButton = parent.element(by.buttonText('Start'));\n  const stopButton = parent.element(by.buttonText('Stop'));\n  const timer = parent.element(by.tagName('app-countdown-timer'));\n\n  await startButton.click();\n  expect(await timer.getText()).not.toContain('Holding');\n\n  await stopButton.click();\n  expect(await timer.getText()).toContain('Holding');\n});\n// ..."
      },
      {
        "language": "text",
        "code": "// ...\n// The tests trigger periodic asynchronous operations (via `setInterval()`), which will prevent\n// the app from stabilizing. See https://angular.io/api/core/ApplicationRef#is-stable-examples\n// for more details.\n// To allow the tests to complete, we will disable automatically waiting for the Angular app to\n// stabilize.\nbeforeEach(() => browser.waitForAngularEnabled(false));\nafterEach(() => browser.waitForAngularEnabled(true));\n\nit('timer and parent seconds should match', async () => {\n  const parent = element(by.tagName(parentTag));\n  const startButton = parent.element(by.buttonText('Start'));\n  const seconds = parent.element(by.className('seconds'));\n  const timer = parent.element(by.tagName('app-countdown-timer'));\n\n  await startButton.click();\n\n  // Wait for `<app-countdown-timer>` to be populated with any text.\n  await browser.wait(() => timer.getText(), 2000);\n\n  expect(await timer.getText()).toContain(await seconds.getText());\n});\n\nit('should stop the countdown', async () => {\n  const parent = element(by.tagName(parentTag));\n  const startButton = parent.element(by.buttonText('Start'));\n  const stopButton = parent.element(by.buttonText('Stop'));\n  const timer = parent.element(by.tagName('app-countdown-timer'));\n\n  await startButton.click();\n  expect(await timer.getText()).not.toContain('Holding');\n\n  await stopButton.click();\n  expect(await timer.getText()).toContain('Holding');\n});\n// ..."
      },
      {
        "language": "text",
        "code": "@ViewChild()"
      },
      {
        "language": "text",
        "code": "CountdownViewChildParentComponent"
      },
      {
        "language": "text",
        "code": "content_copy\n      \n      import { AfterViewInit, ViewChild } from '@angular/core';\nimport { Component } from '@angular/core';\nimport { CountdownTimerComponent } from './countdown-timer.component';\n\n@Component({\n  selector: 'app-countdown-parent-vc',\n  template: `\n    <h3>Countdown to Liftoff (via ViewChild)</h3>\n    <button type=\"button\" (click)=\"start()\">Start</button>\n    <button type=\"button\" (click)=\"stop()\">Stop</button>\n    <div class=\"seconds\">{{ seconds() }}</div>\n    <app-countdown-timer></app-countdown-timer>\n  `,\n  styleUrls: ['../assets/demo.css']\n})\nexport class CountdownViewChildParentComponent implements AfterViewInit {\n\n  @ViewChild(CountdownTimerComponent)\n  private timerComponent!: CountdownTimerComponent;\n\n  seconds() { return 0; }\n\n  ngAfterViewInit() {\n    // Redefine `seconds()` to get from the `CountdownTimerComponent.seconds` ...\n    // but wait a tick first to avoid one-time devMode\n    // unidirectional-data-flow-violation error\n    setTimeout(() => this.seconds = () => this.timerComponent.seconds, 0);\n  }\n\n  start() { this.timerComponent.start(); }\n  stop() { this.timerComponent.stop(); }\n}"
      },
      {
        "language": "text",
        "code": "import { AfterViewInit, ViewChild } from '@angular/core';\nimport { Component } from '@angular/core';\nimport { CountdownTimerComponent } from './countdown-timer.component';\n\n@Component({\n  selector: 'app-countdown-parent-vc',\n  template: `\n    <h3>Countdown to Liftoff (via ViewChild)</h3>\n    <button type=\"button\" (click)=\"start()\">Start</button>\n    <button type=\"button\" (click)=\"stop()\">Stop</button>\n    <div class=\"seconds\">{{ seconds() }}</div>\n    <app-countdown-timer></app-countdown-timer>\n  `,\n  styleUrls: ['../assets/demo.css']\n})\nexport class CountdownViewChildParentComponent implements AfterViewInit {\n\n  @ViewChild(CountdownTimerComponent)\n  private timerComponent!: CountdownTimerComponent;\n\n  seconds() { return 0; }\n\n  ngAfterViewInit() {\n    // Redefine `seconds()` to get from the `CountdownTimerComponent.seconds` ...\n    // but wait a tick first to avoid one-time devMode\n    // unidirectional-data-flow-violation error\n    setTimeout(() => this.seconds = () => this.timerComponent.seconds, 0);\n  }\n\n  start() { this.timerComponent.start(); }\n  stop() { this.timerComponent.stop(); }\n}"
      },
      {
        "language": "text",
        "code": "AfterViewInit"
      },
      {
        "language": "text",
        "code": "CountdownTimerComponent"
      },
      {
        "language": "text",
        "code": "timerComponent"
      },
      {
        "language": "text",
        "code": "ngAfterViewInit()"
      },
      {
        "language": "text",
        "code": "ngAfterViewInit"
      },
      {
        "language": "text",
        "code": "setTimeout()"
      },
      {
        "language": "text",
        "code": "@ViewChild()"
      },
      {
        "language": "text",
        "code": "MissionService"
      },
      {
        "language": "text",
        "code": "MissionControlComponent"
      },
      {
        "language": "text",
        "code": "AstronautComponent"
      },
      {
        "language": "text",
        "code": "content_copy\n      \n      import { Injectable } from '@angular/core';\nimport { Subject } from 'rxjs';\n\n@Injectable()\nexport class MissionService {\n\n  // Observable string sources\n  private missionAnnouncedSource = new Subject<string>();\n  private missionConfirmedSource = new Subject<string>();\n\n  // Observable string streams\n  missionAnnounced$ = this.missionAnnouncedSource.asObservable();\n  missionConfirmed$ = this.missionConfirmedSource.asObservable();\n\n  // Service message commands\n  announceMission(mission: string) {\n    this.missionAnnouncedSource.next(mission);\n  }\n\n  confirmMission(astronaut: string) {\n    this.missionConfirmedSource.next(astronaut);\n  }\n}"
      },
      {
        "language": "text",
        "code": "import { Injectable } from '@angular/core';\nimport { Subject } from 'rxjs';\n\n@Injectable()\nexport class MissionService {\n\n  // Observable string sources\n  private missionAnnouncedSource = new Subject<string>();\n  private missionConfirmedSource = new Subject<string>();\n\n  // Observable string streams\n  missionAnnounced$ = this.missionAnnouncedSource.asObservable();\n  missionConfirmed$ = this.missionConfirmedSource.asObservable();\n\n  // Service message commands\n  announceMission(mission: string) {\n    this.missionAnnouncedSource.next(mission);\n  }\n\n  confirmMission(astronaut: string) {\n    this.missionConfirmedSource.next(astronaut);\n  }\n}"
      },
      {
        "language": "text",
        "code": "MissionControlComponent"
      },
      {
        "language": "text",
        "code": "content_copy\n      \n      import { Component } from '@angular/core';\n\nimport { MissionService } from './mission.service';\n\n@Component({\n  selector: 'app-mission-control',\n  template: `\n    <h2>Mission Control</h2>\n    <button type=\"button\" (click)=\"announce()\">Announce mission</button>\n\n    <app-astronaut\n      *ngFor=\"let astronaut of astronauts\"\n      [astronaut]=\"astronaut\">\n    </app-astronaut>\n\n    <h3>History</h3>\n    <ul>\n      <li *ngFor=\"let event of history\">{{event}}</li>\n    </ul>\n  `,\n  providers: [MissionService]\n})\nexport class MissionControlComponent {\n  astronauts = ['Lovell', 'Swigert', 'Haise'];\n  history: string[] = [];\n  missions = ['Fly to the moon!',\n              'Fly to mars!',\n              'Fly to Vegas!'];\n  nextMission = 0;\n\n  constructor(private missionService: MissionService) {\n    missionService.missionConfirmed$.subscribe(\n      astronaut => {\n        this.history.push(`${astronaut} confirmed the mission`);\n      });\n  }\n\n  announce() {\n    const mission = this.missions[this.nextMission++];\n    this.missionService.announceMission(mission);\n    this.history.push(`Mission \"${mission}\" announced`);\n    if (this.nextMission >= this.missions.length) { this.nextMission = 0; }\n  }\n}"
      },
      {
        "language": "text",
        "code": "import { Component } from '@angular/core';\n\nimport { MissionService } from './mission.service';\n\n@Component({\n  selector: 'app-mission-control',\n  template: `\n    <h2>Mission Control</h2>\n    <button type=\"button\" (click)=\"announce()\">Announce mission</button>\n\n    <app-astronaut\n      *ngFor=\"let astronaut of astronauts\"\n      [astronaut]=\"astronaut\">\n    </app-astronaut>\n\n    <h3>History</h3>\n    <ul>\n      <li *ngFor=\"let event of history\">{{event}}</li>\n    </ul>\n  `,\n  providers: [MissionService]\n})\nexport class MissionControlComponent {\n  astronauts = ['Lovell', 'Swigert', 'Haise'];\n  history: string[] = [];\n  missions = ['Fly to the moon!',\n              'Fly to mars!',\n              'Fly to Vegas!'];\n  nextMission = 0;\n\n  constructor(private missionService: MissionService) {\n    missionService.missionConfirmed$.subscribe(\n      astronaut => {\n        this.history.push(`${astronaut} confirmed the mission`);\n      });\n  }\n\n  announce() {\n    const mission = this.missions[this.nextMission++];\n    this.missionService.announceMission(mission);\n    this.history.push(`Mission \"${mission}\" announced`);\n    if (this.nextMission >= this.missions.length) { this.nextMission = 0; }\n  }\n}"
      },
      {
        "language": "text",
        "code": "AstronautComponent"
      },
      {
        "language": "text",
        "code": "AstronautComponent"
      },
      {
        "language": "text",
        "code": "MissionControlComponent"
      },
      {
        "language": "text",
        "code": "content_copy\n      \n      import { Component, Input, OnDestroy } from '@angular/core';\n\nimport { MissionService } from './mission.service';\nimport { Subscription } from 'rxjs';\n\n@Component({\n  selector: 'app-astronaut',\n  template: `\n    <p>\n      {{astronaut}}: <strong>{{mission}}</strong>\n      <button\n        type=\"button\"\n        (click)=\"confirm()\"\n        [disabled]=\"!announced || confirmed\">\n        Confirm\n      </button>\n    </p>\n  `\n})\nexport class AstronautComponent implements OnDestroy {\n  @Input() astronaut = '';\n  mission = '<no mission announced>';\n  confirmed = false;\n  announced = false;\n  subscription: Subscription;\n\n  constructor(private missionService: MissionService) {\n    this.subscription = missionService.missionAnnounced$.subscribe(\n      mission => {\n        this.mission = mission;\n        this.announced = true;\n        this.confirmed = false;\n    });\n  }\n\n  confirm() {\n    this.confirmed = true;\n    this.missionService.confirmMission(this.astronaut);\n  }\n\n  ngOnDestroy() {\n    // prevent memory leak when component destroyed\n    this.subscription.unsubscribe();\n  }\n}"
      },
      {
        "language": "text",
        "code": "import { Component, Input, OnDestroy } from '@angular/core';\n\nimport { MissionService } from './mission.service';\nimport { Subscription } from 'rxjs';\n\n@Component({\n  selector: 'app-astronaut',\n  template: `\n    <p>\n      {{astronaut}}: <strong>{{mission}}</strong>\n      <button\n        type=\"button\"\n        (click)=\"confirm()\"\n        [disabled]=\"!announced || confirmed\">\n        Confirm\n      </button>\n    </p>\n  `\n})\nexport class AstronautComponent implements OnDestroy {\n  @Input() astronaut = '';\n  mission = '<no mission announced>';\n  confirmed = false;\n  announced = false;\n  subscription: Subscription;\n\n  constructor(private missionService: MissionService) {\n    this.subscription = missionService.missionAnnounced$.subscribe(\n      mission => {\n        this.mission = mission;\n        this.announced = true;\n        this.confirmed = false;\n    });\n  }\n\n  confirm() {\n    this.confirmed = true;\n    this.missionService.confirmMission(this.astronaut);\n  }\n\n  ngOnDestroy() {\n    // prevent memory leak when component destroyed\n    this.subscription.unsubscribe();\n  }\n}"
      },
      {
        "language": "text",
        "code": "subscription"
      },
      {
        "language": "text",
        "code": "unsubscribe()"
      },
      {
        "language": "text",
        "code": "AstronautComponent"
      },
      {
        "language": "text",
        "code": "AstronautComponent"
      },
      {
        "language": "text",
        "code": "MissionControlComponent"
      },
      {
        "language": "text",
        "code": "MissionService"
      },
      {
        "language": "text",
        "code": "MissionControlComponent"
      },
      {
        "language": "text",
        "code": "AstronautComponent"
      },
      {
        "language": "text",
        "code": "MissionControlComponent"
      },
      {
        "language": "text",
        "code": "AstronautComponent"
      },
      {
        "language": "text",
        "code": "content_copy\n      \n      // ...\nit('should announce a mission', async () => {\n  const missionControl = element(by.tagName('app-mission-control'));\n  const announceButton = missionControl.all(by.tagName('button')).get(0);\n  const history = missionControl.all(by.tagName('li'));\n\n  await announceButton.click();\n\n  expect(await history.count()).toBe(1);\n  expect(await history.get(0).getText()).toMatch(/Mission.* announced/);\n});\n\nit('should confirm the mission by Lovell', async () => {\n  await testConfirmMission(1, 'Lovell');\n});\n\nit('should confirm the mission by Haise', async () => {\n  await testConfirmMission(3, 'Haise');\n});\n\nit('should confirm the mission by Swigert', async () => {\n  await testConfirmMission(2, 'Swigert');\n});\n\nasync function testConfirmMission(buttonIndex: number, astronaut: string) {\n  const missionControl = element(by.tagName('app-mission-control'));\n  const announceButton = missionControl.all(by.tagName('button')).get(0);\n  const confirmButton = missionControl.all(by.tagName('button')).get(buttonIndex);\n  const history = missionControl.all(by.tagName('li'));\n\n  await announceButton.click();\n  await confirmButton.click();\n\n  expect(await history.count()).toBe(2);\n  expect(await history.get(1).getText()).toBe(`${astronaut} confirmed the mission`);\n}\n// ..."
      },
      {
        "language": "text",
        "code": "// ...\nit('should announce a mission', async () => {\n  const missionControl = element(by.tagName('app-mission-control'));\n  const announceButton = missionControl.all(by.tagName('button')).get(0);\n  const history = missionControl.all(by.tagName('li'));\n\n  await announceButton.click();\n\n  expect(await history.count()).toBe(1);\n  expect(await history.get(0).getText()).toMatch(/Mission.* announced/);\n});\n\nit('should confirm the mission by Lovell', async () => {\n  await testConfirmMission(1, 'Lovell');\n});\n\nit('should confirm the mission by Haise', async () => {\n  await testConfirmMission(3, 'Haise');\n});\n\nit('should confirm the mission by Swigert', async () => {\n  await testConfirmMission(2, 'Swigert');\n});\n\nasync function testConfirmMission(buttonIndex: number, astronaut: string) {\n  const missionControl = element(by.tagName('app-mission-control'));\n  const announceButton = missionControl.all(by.tagName('button')).get(0);\n  const confirmButton = missionControl.all(by.tagName('button')).get(buttonIndex);\n  const history = missionControl.all(by.tagName('li'));\n\n  await announceButton.click();\n  await confirmButton.click();\n\n  expect(await history.count()).toBe(2);\n  expect(await history.get(1).getText()).toBe(`${astronaut} confirmed the mission`);\n}\n// ..."
      }
    ],
    "links": [
      {
        "text": "link",
        "href": "guide/component-interaction#component-interaction"
      },
      {
        "text": "Pass data from parent to child with input binding",
        "href": "guide/component-interaction#pass-data-from-parent-to-child-with-input-binding"
      },
      {
        "text": "Test it for Pass data from parent to child with input binding",
        "href": "guide/component-interaction#test-it-for-pass-data-from-parent-to-child-with-input-binding"
      },
      {
        "text": "Intercept input property changes with a setter",
        "href": "guide/component-interaction#intercept-input-property-changes-with-a-setter"
      },
      {
        "text": "Test it for Intercept input property changes with a setter",
        "href": "guide/component-interaction#test-it-for-intercept-input-property-changes-with-a-setter"
      },
      {
        "text": "Intercept input property changes with ngOnChanges()",
        "href": "guide/component-interaction#intercept-input-property-changes-with-ngonchanges"
      },
      {
        "text": "Test it for Intercept input property changes with ngOnChanges()",
        "href": "guide/component-interaction#test-it-for-intercept-input-property-changes-with-ngonchanges"
      },
      {
        "text": "Parent listens for child event",
        "href": "guide/component-interaction#parent-listens-for-child-event"
      },
      {
        "text": "Test it for Parent listens for child event",
        "href": "guide/component-interaction#test-it-for-parent-listens-for-child-event"
      },
      {
        "text": "Parent interacts with child using local variable",
        "href": "guide/component-interaction#parent-interacts-with-child-using-local-variable"
      },
      {
        "text": "Test it for Parent interacts with child using local variable",
        "href": "guide/component-interaction#test-it-for-parent-interacts-with-child-using-local-variable"
      },
      {
        "text": "Parent calls an @ViewChild()",
        "href": "guide/component-interaction#parent-calls-an-viewchild"
      },
      {
        "text": "Test it for Parent calls an @ViewChild()",
        "href": "guide/component-interaction#test-it-for-parent-calls-an-viewchild"
      },
      {
        "text": "Parent and children communicate using a service",
        "href": "guide/component-interaction#parent-and-children-communicate-using-a-service"
      },
      {
        "text": "Test it for Parent and children communicate using a service",
        "href": "guide/component-interaction#test-it-for-parent-and-children-communicate-using-a-service"
      },
      {
        "text": "live example",
        "href": "generated/live-examples/component-interaction/stackblitz.html"
      },
      {
        "text": "download example",
        "href": "generated/zips/component-interaction/component-interaction.zip"
      },
      {
        "text": "link",
        "href": "guide/component-interaction#pass-data-from-parent-to-child-with-input-binding"
      },
      {
        "text": "@Input() decorator",
        "href": "guide/inputs-outputs#input"
      },
      {
        "text": "Component",
        "href": "api/core/Component"
      },
      {
        "text": "Input",
        "href": "api/core/Input"
      },
      {
        "text": "Component",
        "href": "api/core/Component"
      },
      {
        "text": "Input",
        "href": "api/core/Input"
      },
      {
        "text": "Input",
        "href": "api/core/Input"
      },
      {
        "text": "Input",
        "href": "api/core/Input"
      },
      {
        "text": "ngFor",
        "href": "api/common/NgFor"
      },
      {
        "text": "Component",
        "href": "api/core/Component"
      },
      {
        "text": "Component",
        "href": "api/core/Component"
      },
      {
        "text": "ngFor",
        "href": "api/common/NgFor"
      },
      {
        "text": "link",
        "href": "guide/component-interaction#test-it-for-pass-data-from-parent-to-child-with-input-binding"
      },
      {
        "text": "async",
        "href": "api/platform-browser/animations/async"
      },
      {
        "text": "Back to top",
        "href": "guide/component-interaction#top"
      },
      {
        "text": "link",
        "href": "guide/component-interaction#intercept-input-property-changes-with-a-setter"
      },
      {
        "text": "Component",
        "href": "api/core/Component"
      },
      {
        "text": "Input",
        "href": "api/core/Input"
      },
      {
        "text": "Component",
        "href": "api/core/Component"
      },
      {
        "text": "Input",
        "href": "api/core/Input"
      },
      {
        "text": "Component",
        "href": "api/core/Component"
      },
      {
        "text": "Component",
        "href": "api/core/Component"
      },
      {
        "text": "ngFor",
        "href": "api/common/NgFor"
      },
      {
        "text": "link",
        "href": "guide/component-interaction#test-it-for-intercept-input-property-changes-with-a-setter"
      },
      {
        "text": "async",
        "href": "api/platform-browser/animations/async"
      },
      {
        "text": "async",
        "href": "api/platform-browser/animations/async"
      },
      {
        "text": "Back to top",
        "href": "guide/component-interaction#top"
      },
      {
        "text": "link",
        "href": "guide/component-interaction#intercept-input-property-changes-with-ngonchanges"
      },
      {
        "text": "OnChanges",
        "href": "api/core/OnChanges"
      },
      {
        "text": "Lifecycle Hooks",
        "href": "guide/lifecycle-hooks"
      },
      {
        "text": "Component",
        "href": "api/core/Component"
      },
      {
        "text": "Input",
        "href": "api/core/Input"
      },
      {
        "text": "OnChanges",
        "href": "api/core/OnChanges"
      },
      {
        "text": "SimpleChanges",
        "href": "api/core/SimpleChanges"
      },
      {
        "text": "Component",
        "href": "api/core/Component"
      },
      {
        "text": "Version",
        "href": "api/core/Version"
      },
      {
        "text": "ngFor",
        "href": "api/common/NgFor"
      },
      {
        "text": "OnChanges",
        "href": "api/core/OnChanges"
      },
      {
        "text": "Input",
        "href": "api/core/Input"
      },
      {
        "text": "Input",
        "href": "api/core/Input"
      },
      {
        "text": "SimpleChanges",
        "href": "api/core/SimpleChanges"
      },
      {
        "text": "Component",
        "href": "api/core/Component"
      },
      {
        "text": "Component",
        "href": "api/core/Component"
      },
      {
        "text": "link",
        "href": "guide/component-interaction#test-it-for-intercept-input-property-changes-with-ngonchanges"
      },
      {
        "text": "async",
        "href": "api/platform-browser/animations/async"
      },
      {
        "text": "Version",
        "href": "api/core/Version"
      },
      {
        "text": "async",
        "href": "api/platform-browser/animations/async"
      },
      {
        "text": "Version",
        "href": "api/core/Version"
      },
      {
        "text": "async",
        "href": "api/platform-browser/animations/async"
      },
      {
        "text": "Version",
        "href": "api/core/Version"
      },
      {
        "text": "async",
        "href": "api/platform-browser/animations/async"
      },
      {
        "text": "Back to top",
        "href": "guide/component-interaction#top"
      },
      {
        "text": "link",
        "href": "guide/component-interaction#parent-listens-for-child-event"
      },
      {
        "text": "EventEmitter",
        "href": "api/core/EventEmitter"
      },
      {
        "text": "EventEmitter",
        "href": "api/core/EventEmitter"
      },
      {
        "text": "@Output() decorator",
        "href": "guide/inputs-outputs#output"
      },
      {
        "text": "Component",
        "href": "api/core/Component"
      },
      {
        "text": "EventEmitter",
        "href": "api/core/EventEmitter"
      },
      {
        "text": "Input",
        "href": "api/core/Input"
      },
      {
        "text": "Output",
        "href": "api/core/Output"
      },
      {
        "text": "Component",
        "href": "api/core/Component"
      },
      {
        "text": "Input",
        "href": "api/core/Input"
      },
      {
        "text": "Output",
        "href": "api/core/Output"
      },
      {
        "text": "EventEmitter",
        "href": "api/core/EventEmitter"
      },
      {
        "text": "Component",
        "href": "api/core/Component"
      },
      {
        "text": "Component",
        "href": "api/core/Component"
      },
      {
        "text": "ngFor",
        "href": "api/common/NgFor"
      },
      {
        "text": "link",
        "href": "guide/component-interaction#test-it-for-parent-listens-for-child-event"
      },
      {
        "text": "async",
        "href": "api/platform-browser/animations/async"
      },
      {
        "text": "async",
        "href": "api/platform-browser/animations/async"
      },
      {
        "text": "async",
        "href": "api/platform-browser/animations/async"
      },
      {
        "text": "Back to top",
        "href": "guide/component-interaction#top"
      },
      {
        "text": "link",
        "href": "guide/component-interaction#parent-interacts-with-child-using-local-variable"
      },
      {
        "text": "Component",
        "href": "api/core/Component"
      },
      {
        "text": "OnDestroy",
        "href": "api/core/OnDestroy"
      },
      {
        "text": "Component",
        "href": "api/core/Component"
      },
      {
        "text": "OnDestroy",
        "href": "api/core/OnDestroy"
      },
      {
        "text": "Component",
        "href": "api/core/Component"
      },
      {
        "text": "Component",
        "href": "api/core/Component"
      },
      {
        "text": "link",
        "href": "guide/component-interaction#test-it-for-parent-interacts-with-child-using-local-variable"
      },
      {
        "text": "trigger",
        "href": "api/animations/trigger"
      },
      {
        "text": "ApplicationRef",
        "href": "api/core/ApplicationRef"
      },
      {
        "text": "async",
        "href": "api/platform-browser/animations/async"
      },
      {
        "text": "async",
        "href": "api/platform-browser/animations/async"
      },
      {
        "text": "Back to top",
        "href": "guide/component-interaction#top"
      },
      {
        "text": "ViewChild",
        "href": "api/core/ViewChild"
      },
      {
        "text": "link",
        "href": "guide/component-interaction#parent-calls-an-viewchild"
      },
      {
        "text": "Countdown Timer",
        "href": "guide/component-interaction#countdown-timer-example"
      },
      {
        "text": "CountdownTimerComponent",
        "href": "guide/component-interaction#countdown-timer-example"
      },
      {
        "text": "AfterViewInit",
        "href": "api/core/AfterViewInit"
      },
      {
        "text": "ViewChild",
        "href": "api/core/ViewChild"
      },
      {
        "text": "Component",
        "href": "api/core/Component"
      },
      {
        "text": "Component",
        "href": "api/core/Component"
      },
      {
        "text": "ViewChild",
        "href": "api/core/ViewChild"
      },
      {
        "text": "AfterViewInit",
        "href": "api/core/AfterViewInit"
      },
      {
        "text": "ViewChild",
        "href": "api/core/ViewChild"
      },
      {
        "text": "tick",
        "href": "api/core/testing/tick"
      },
      {
        "text": "ViewChild",
        "href": "api/core/ViewChild"
      },
      {
        "text": "AfterViewInit",
        "href": "api/core/AfterViewInit"
      },
      {
        "text": "ViewChild",
        "href": "api/core/ViewChild"
      },
      {
        "text": "ViewChild",
        "href": "api/core/ViewChild"
      },
      {
        "text": "link",
        "href": "guide/component-interaction#test-it-for-parent-calls-an-viewchild"
      },
      {
        "text": "the same countdown timer tests",
        "href": "guide/component-interaction#countdown-tests"
      },
      {
        "text": "Back to top",
        "href": "guide/component-interaction#top"
      },
      {
        "text": "link",
        "href": "guide/component-interaction#parent-and-children-communicate-using-a-service"
      },
      {
        "text": "Injectable",
        "href": "api/core/Injectable"
      },
      {
        "text": "Injectable",
        "href": "api/core/Injectable"
      },
      {
        "text": "Component",
        "href": "api/core/Component"
      },
      {
        "text": "Component",
        "href": "api/core/Component"
      },
      {
        "text": "ngFor",
        "href": "api/common/NgFor"
      },
      {
        "text": "ngFor",
        "href": "api/common/NgFor"
      },
      {
        "text": "Component",
        "href": "api/core/Component"
      },
      {
        "text": "Input",
        "href": "api/core/Input"
      },
      {
        "text": "OnDestroy",
        "href": "api/core/OnDestroy"
      },
      {
        "text": "Component",
        "href": "api/core/Component"
      },
      {
        "text": "OnDestroy",
        "href": "api/core/OnDestroy"
      },
      {
        "text": "Input",
        "href": "api/core/Input"
      },
      {
        "text": "link",
        "href": "guide/component-interaction#test-it-for-parent-and-children-communicate-using-a-service"
      },
      {
        "text": "async",
        "href": "api/platform-browser/animations/async"
      },
      {
        "text": "async",
        "href": "api/platform-browser/animations/async"
      },
      {
        "text": "async",
        "href": "api/platform-browser/animations/async"
      },
      {
        "text": "async",
        "href": "api/platform-browser/animations/async"
      },
      {
        "text": "async",
        "href": "api/platform-browser/animations/async"
      },
      {
        "text": "Back to top",
        "href": "guide/component-interaction#top"
      }
    ],
    "meta": {
      "description": "",
      "keywords": ""
    },
    "summary": "Component interactionlink Contents Pass data from parent to child with input bindingTest it for Pass data from parent to child with input bindingIntercept input property changes with a setterTest it f...",
    "tags": [
      "react",
      "angular",
      "javascript",
      "typescript",
      "css",
      "html",
      "vite",
      "parent",
      "test",
      "child"
    ],
    "id": "angular-componentinteraction-part-1",
    "quality": 90
  },
  {
    "title": "Angular",
    "url": "https://v17.angular.io/guide/dependency-injection",
    "category": "angular",
    "content": "Understanding dependency injectionlink Contents Providing dependencyInjecting a dependencyWhat's next Dependency injection, or DI, is one of the fundamental concepts in Angular. DI is wired into the Angular framework and allows classes with Angular decorators, such as Components, Directives, Pipes, and Injectables, to configure dependencies that they need. Two main roles exist in the DI system: dependency consumer and dependency provider. Angular facilitates the interaction between dependency consumers and dependency providers using an abstraction called Injector. When a dependency is requested, the injector checks its registry to see if there is an instance already available there. If not, a new instance is created and stored in the registry. Angular creates an application-wide injector (also known as \"root\" injector) during the application bootstrap process, as well as any other injectors as needed. In most cases you don't need to manually create injectors, but you should know that there is a layer that connects providers and consumers. This topic covers basic scenarios of how a class can act as a dependency. Angular also allows you to use functions, objects, primitive types such as string or Boolean, or any other types as dependencies. For more information, see Dependency providers. Providing dependencylink Imagine there is a class called HeroService that needs to act as a dependency in a component. The first step is to add the @Injectable decorator to show that the class can be injected. content_copy @Injectable() class HeroService {} The next step is to make it available in the DI by providing it. A dependency can be provided in multiple places: At the Component level, using the providers field of the @Component decorator. In this case the HeroService becomes available to all instances of this component and other components and directives used in the template. For example: content_copy @Component({ standalone: true, selector: 'hero-list', template: '...', providers: [HeroService] }) class HeroListComponent {} When you register a provider at the component level, you get a new instance of the service with each new instance of that component. Use the providers field of the ApplicationConfig object passed to the bootstrapApplication function to provide a service or other Injectable at the application level. In this scenario, the HeroService is available to all components, directives, and pipes declared in this NgModule or other NgModule which is within the same ModuleInjector applicable for this NgModule. When you register a provider in the ApplicationConfig, the same instance of a service is available to all applicable components, directives and pipes. For NgModule based applications, use the providers field of the @NgModule decorator to provide a service or other Injectable available at the application level. To understand all edge-cases, see Hierarchical injectors. For example: content_copy export const appConfig: ApplicationConfig = { providers: [ { provide: HeroService }, ] }; Then, in main.ts: content_copy bootstrapApplication(AppComponent, appConfig) At the application root level, which allows injecting it into other classes in the application. This can be done by adding the providedIn: 'root' field to the @Injectable decorator: content_copy @Injectable({ providedIn: 'root' }) class HeroService {} When you provide the service at the root level, Angular creates a single, shared instance of the HeroService and injects it into any class that asks for it. Registering the provider in the @Injectable metadata also allows Angular to optimize an app by removing the service from the compiled application if it isn't used, a process known as tree-shaking. Injecting a dependencylink The most common way to inject a dependency is to declare it in a class constructor. When Angular creates a new instance of a component, directive, or pipe class, it determines which services or other dependencies that class needs by looking at the constructor parameter types. For example, if the HeroListComponent needs the HeroService, the constructor can look like this: content_copy @Component({  }) class HeroListComponent { constructor(private service: HeroService) {} } Another option is to use the inject method: content_copy @Component({  }) class HeroListComponent { private service = inject(HeroService); } When Angular discovers that a component depends on a service, it first checks if the injector has any existing instances of that service. If a requested service instance doesn't yet exist, the injector creates one using the registered provider, and adds it to the injector before returning the service to Angular. When all requested services have been resolved and returned, Angular can call the component's constructor with those services as arguments. What's nextlink Creating and injecting services Dependency Injection in Action Last reviewed on Tue Aug 29 2023",
    "headings": [
      {
        "level": 1,
        "text": "Understanding dependency injectionlink",
        "id": "understanding-dependency-injection"
      },
      {
        "level": 2,
        "text": "Providing dependencylink",
        "id": "providing-dependency"
      },
      {
        "level": 2,
        "text": "Injecting a dependencylink",
        "id": "injecting-a-dependency"
      },
      {
        "level": 2,
        "text": "What's nextlink",
        "id": "whats-next"
      }
    ],
    "codeBlocks": [
      {
        "language": "text",
        "code": "content_copy\n      \n      @Injectable()\nclass HeroService {}"
      },
      {
        "language": "text",
        "code": "@Injectable()\nclass HeroService {}"
      },
      {
        "language": "text",
        "code": "HeroService"
      },
      {
        "language": "text",
        "code": "content_copy\n      \n      @Component({\n  standalone: true,\n  selector: 'hero-list',\n  template: '...',\n  providers: [HeroService]\n})\nclass HeroListComponent {}"
      },
      {
        "language": "text",
        "code": "@Component({\n  standalone: true,\n  selector: 'hero-list',\n  template: '...',\n  providers: [HeroService]\n})\nclass HeroListComponent {}"
      },
      {
        "language": "text",
        "code": "ApplicationConfig"
      },
      {
        "language": "text",
        "code": "bootstrapApplication"
      },
      {
        "language": "text",
        "code": "HeroService"
      },
      {
        "language": "text",
        "code": "ApplicationConfig"
      },
      {
        "language": "text",
        "code": "content_copy\n      \n      export const appConfig: ApplicationConfig = {\n    providers: [\n      { provide: HeroService },\n    ]\n};"
      },
      {
        "language": "text",
        "code": "export const appConfig: ApplicationConfig = {\n    providers: [\n      { provide: HeroService },\n    ]\n};"
      },
      {
        "language": "text",
        "code": "content_copy\n      \n      bootstrapApplication(AppComponent, appConfig)"
      },
      {
        "language": "text",
        "code": "bootstrapApplication(AppComponent, appConfig)"
      },
      {
        "language": "text",
        "code": "providedIn: 'root'"
      },
      {
        "language": "text",
        "code": "@Injectable"
      },
      {
        "language": "text",
        "code": "content_copy\n      \n      @Injectable({\n  providedIn: 'root'\n})\nclass HeroService {}"
      },
      {
        "language": "text",
        "code": "@Injectable({\n  providedIn: 'root'\n})\nclass HeroService {}"
      },
      {
        "language": "text",
        "code": "HeroService"
      },
      {
        "language": "text",
        "code": "@Injectable"
      },
      {
        "language": "text",
        "code": "HeroListComponent"
      },
      {
        "language": "text",
        "code": "HeroService"
      },
      {
        "language": "text",
        "code": "content_copy\n      \n      @Component({ … })\nclass HeroListComponent {\n  constructor(private service: HeroService) {}\n}"
      },
      {
        "language": "text",
        "code": "@Component({ … })\nclass HeroListComponent {\n  constructor(private service: HeroService) {}\n}"
      },
      {
        "language": "text",
        "code": "content_copy\n      \n      @Component({ … })\nclass HeroListComponent {\n  private service = inject(HeroService);\n}"
      },
      {
        "language": "text",
        "code": "@Component({ … })\nclass HeroListComponent {\n  private service = inject(HeroService);\n}"
      }
    ],
    "links": [
      {
        "text": "link",
        "href": "guide/dependency-injection#understanding-dependency-injection"
      },
      {
        "text": "Providing dependency",
        "href": "guide/dependency-injection#providing-dependency"
      },
      {
        "text": "Injecting a dependency",
        "href": "guide/dependency-injection#injecting-a-dependency"
      },
      {
        "text": "What's next",
        "href": "guide/dependency-injection#whats-next"
      },
      {
        "text": "Injector",
        "href": "guide/glossary#injector"
      },
      {
        "text": "Dependency providers",
        "href": "guide/dependency-injection-providers"
      },
      {
        "text": "link",
        "href": "guide/dependency-injection#providing-dependency"
      },
      {
        "text": "Injectable",
        "href": "api/core/Injectable"
      },
      {
        "text": "Component",
        "href": "api/core/Component"
      },
      {
        "text": "Component",
        "href": "api/core/Component"
      },
      {
        "text": "ApplicationConfig",
        "href": "api/core/ApplicationConfig"
      },
      {
        "text": "bootstrapApplication",
        "href": "api/platform-browser/bootstrapApplication"
      },
      {
        "text": "Injectable",
        "href": "api/core/Injectable"
      },
      {
        "text": "ApplicationConfig",
        "href": "api/core/ApplicationConfig"
      },
      {
        "text": "NgModule",
        "href": "api/core/NgModule"
      },
      {
        "text": "NgModule",
        "href": "api/core/NgModule"
      },
      {
        "text": "Injectable",
        "href": "api/core/Injectable"
      },
      {
        "text": "Hierarchical injectors",
        "href": "guide/hierarchical-dependency-injection"
      },
      {
        "text": "ApplicationConfig",
        "href": "api/core/ApplicationConfig"
      },
      {
        "text": "bootstrapApplication",
        "href": "api/platform-browser/bootstrapApplication"
      },
      {
        "text": "Injectable",
        "href": "api/core/Injectable"
      },
      {
        "text": "Injectable",
        "href": "api/core/Injectable"
      },
      {
        "text": "Injectable",
        "href": "api/core/Injectable"
      },
      {
        "text": "link",
        "href": "guide/dependency-injection#injecting-a-dependency"
      },
      {
        "text": "Component",
        "href": "api/core/Component"
      },
      {
        "text": "inject",
        "href": "api/core/inject"
      },
      {
        "text": "Component",
        "href": "api/core/Component"
      },
      {
        "text": "link",
        "href": "guide/dependency-injection#whats-next"
      },
      {
        "text": "Creating and injecting services",
        "href": "guide/creating-injectable-service"
      },
      {
        "text": "Dependency Injection in Action",
        "href": "guide/dependency-injection-in-action"
      }
    ],
    "meta": {
      "description": "",
      "keywords": ""
    },
    "summary": "Understanding dependency injectionlink Contents Providing dependencyInjecting a dependencyWhat's next Dependency injection, or DI, is one of the fundamental concepts in Angular",
    "tags": [
      "react",
      "vue",
      "angular",
      "javascript",
      "typescript",
      "html",
      "node",
      "dependencylink",
      "understanding",
      "dependency"
    ],
    "id": "angular-dependencyinjection-part-1",
    "quality": 90
  },
  {
    "title": "Angular",
    "url": "https://v17.angular.io/guide/creating-injectable-service",
    "category": "angular",
    "content": "Creating an injectable servicelink Contents Service examplesCreating an injectable serviceInjecting servicesInjecting services in other servicesWhat's next Service is a broad category encompassing any value, function, or feature that an application needs. A service is typically a class with a narrow, well-defined purpose. A component is one type of class that can use DI. Angular distinguishes components from services to increase modularity and reusability. By separating a component's view-related features from other kinds of processing, you can make your component classes lean and efficient. Ideally, a component's job is to enable the user experience and nothing more. A component should present properties and methods for data binding, to mediate between the view (rendered by the template) and the application logic (which often includes some notion of a model). A component can delegate certain tasks to services, such as fetching data from the server, validating user input, or logging directly to the console. By defining such processing tasks in an injectable service class, you make those tasks available to any component. You can also make your application more adaptable by injecting different providers of the same kind of service, as appropriate in different circumstances. Angular does not enforce these principles. Angular helps you follow these principles by making it easy to factor your application logic into services and make those services available to components through DI. Service exampleslink Here's an example of a service class that logs to the browser console. content_copy export class Logger { log(msg: any) { console.log(msg); } error(msg: any) { console.error(msg); } warn(msg: any) { console.warn(msg); } } Services can depend on other services. For example, here's a HeroService that depends on the Logger service, and also uses BackendService to get heroes. That service in turn might depend on the HttpClient service to fetch heroes asynchronously from a server. content_copy export class HeroService { private heroes: Hero[] = []; constructor( private backend: BackendService, private logger: Logger) { } getHeroes() { this.backend.getAll(Hero).then( (heroes: Hero[]) = { this.logger.log(Fetched ${heroes.length} heroes.); this.heroes.push(...heroes); // fill cache }); return this.heroes; } } Creating an injectable servicelink Angular CLI provides a command to create a new service. In the following example, you add a new service to your application, which was created earlier with the ng new command. To generate a new HeroService class in the src/app/heroes folder, follow these steps: Run this Angular CLI command: content_copy ng generate service heroes/hero This command creates the following default HeroService. content_copy import { Injectable } from '@angular/core'; @Injectable({ providedIn: 'root', }) export class HeroService { } The @Injectable() decorator specifies that Angular can use this class in the DI system. The metadata, providedIn: 'root', means that the HeroService is visible throughout the application. Add a getHeroes() method that returns the heroes from mock.heroes.ts to get the hero mock data: content_copy import { Injectable } from '@angular/core'; import { HEROES } from './mock-heroes'; @Injectable({ // declares that this service should be created // by the root application injector. providedIn: 'root', }) export class HeroService { getHeroes() { return HEROES; } } For clarity and maintainability, it is recommended that you define components and services in separate files. Injecting serviceslink To inject a service as a dependency into a component, you can use component's constructor() and supply a constructor argument with the dependency type. The following example specifies the HeroService in the HeroListComponent constructor. The type of the heroService is HeroService. Angular recognizes the HeroService as a dependency, since that class was previously annotated with the @Injectable decorator. content_copy constructor(heroService: HeroService) Injecting services in other serviceslink When a service depends on another service, follow the same pattern as injecting into a component. In the following example HeroService depends on a Logger service to report its activities. First, import the Logger service. Next, inject the Logger service in the HeroService constructor() by specifying private logger: Logger. Here, the constructor() specifies a type of Logger and stores the instance of Logger in a private field called logger. The following code tabs feature the Logger service and two versions of HeroService. The first version of HeroService does not depend on the Logger service. The revised second version does depend on Logger service. src/app/heroes/hero.service (v2)src/app/heroes/hero.service (v1)src/app/logger.service content_copy import { Injectable } from '@angular/core'; import { HEROES } from './mock-heroes'; import { Logger } from '../logger.service'; @Injectable({ providedIn: 'root', }) export class HeroService { constructor(private logger: Logger) { } getHeroes() { this.logger.log('Getting heroes ...'); return HEROES; } } In this example, the getHeroes() method uses the Logger service by logging a message when fetching heroes. What's nextlink How to configure dependencies in DI How to use InjectionTokens to provide and inject values other than services/classes Dependency Injection in Action Last reviewed on Tue Aug 02 2022",
    "headings": [
      {
        "level": 1,
        "text": "Creating an injectable servicelink",
        "id": "creating-an-injectable-service"
      },
      {
        "level": 2,
        "text": "Service exampleslink",
        "id": "service-examples"
      },
      {
        "level": 2,
        "text": "Creating an injectable servicelink",
        "id": "creating-an-injectable-service-1"
      },
      {
        "level": 2,
        "text": "Injecting serviceslink",
        "id": "injecting-services"
      },
      {
        "level": 2,
        "text": "Injecting services in other serviceslink",
        "id": "injecting-services-in-other-services"
      },
      {
        "level": 2,
        "text": "What's nextlink",
        "id": "whats-next"
      }
    ],
    "codeBlocks": [
      {
        "language": "text",
        "code": "content_copy\n      \n      export class Logger {\n  log(msg: any)   { console.log(msg); }\n  error(msg: any) { console.error(msg); }\n  warn(msg: any)  { console.warn(msg); }\n}"
      },
      {
        "language": "text",
        "code": "export class Logger {\n  log(msg: any)   { console.log(msg); }\n  error(msg: any) { console.error(msg); }\n  warn(msg: any)  { console.warn(msg); }\n}"
      },
      {
        "language": "text",
        "code": "HeroService"
      },
      {
        "language": "text",
        "code": "BackendService"
      },
      {
        "language": "text",
        "code": "content_copy\n      \n      export class HeroService {\n  private heroes: Hero[] = [];\n\n  constructor(\n    private backend: BackendService,\n    private logger: Logger) { }\n\n  getHeroes() {\n    this.backend.getAll(Hero).then( (heroes: Hero[]) => {\n      this.logger.log(`Fetched ${heroes.length} heroes.`);\n      this.heroes.push(...heroes); // fill cache\n    });\n    return this.heroes;\n  }\n}"
      },
      {
        "language": "text",
        "code": "export class HeroService {\n  private heroes: Hero[] = [];\n\n  constructor(\n    private backend: BackendService,\n    private logger: Logger) { }\n\n  getHeroes() {\n    this.backend.getAll(Hero).then( (heroes: Hero[]) => {\n      this.logger.log(`Fetched ${heroes.length} heroes.`);\n      this.heroes.push(...heroes); // fill cache\n    });\n    return this.heroes;\n  }\n}"
      },
      {
        "language": "text",
        "code": "HeroService"
      },
      {
        "language": "text",
        "code": "src/app/heroes"
      },
      {
        "language": "text",
        "code": "content_copy\n      \n      ng generate service heroes/hero"
      },
      {
        "language": "text",
        "code": "ng generate service heroes/hero"
      },
      {
        "language": "text",
        "code": "HeroService"
      },
      {
        "language": "text",
        "code": "content_copy\n      \n      import { Injectable } from '@angular/core';\n\n@Injectable({\n  providedIn: 'root',\n})\nexport class HeroService {\n\n}"
      },
      {
        "language": "text",
        "code": "import { Injectable } from '@angular/core';\n\n@Injectable({\n  providedIn: 'root',\n})\nexport class HeroService {\n\n}"
      },
      {
        "language": "text",
        "code": "@Injectable()"
      },
      {
        "language": "text",
        "code": "providedIn: 'root'"
      },
      {
        "language": "text",
        "code": "HeroService"
      },
      {
        "language": "text",
        "code": "getHeroes()"
      },
      {
        "language": "text",
        "code": "mock.heroes.ts"
      },
      {
        "language": "text",
        "code": "content_copy\n      \n      import { Injectable } from '@angular/core';\nimport { HEROES } from './mock-heroes';\n\n@Injectable({\n  // declares that this service should be created\n  // by the root application injector.\n  providedIn: 'root',\n})\nexport class HeroService {\n  getHeroes() { return HEROES; }\n}"
      },
      {
        "language": "text",
        "code": "import { Injectable } from '@angular/core';\nimport { HEROES } from './mock-heroes';\n\n@Injectable({\n  // declares that this service should be created\n  // by the root application injector.\n  providedIn: 'root',\n})\nexport class HeroService {\n  getHeroes() { return HEROES; }\n}"
      },
      {
        "language": "text",
        "code": "constructor()"
      },
      {
        "language": "text",
        "code": "HeroService"
      },
      {
        "language": "text",
        "code": "HeroListComponent"
      },
      {
        "language": "text",
        "code": "heroService"
      },
      {
        "language": "text",
        "code": "HeroService"
      },
      {
        "language": "text",
        "code": "HeroService"
      },
      {
        "language": "text",
        "code": "@Injectable"
      },
      {
        "language": "text",
        "code": "content_copy\n      \n      constructor(heroService: HeroService)"
      },
      {
        "language": "text",
        "code": "constructor(heroService: HeroService)"
      },
      {
        "language": "text",
        "code": "HeroService"
      },
      {
        "language": "text",
        "code": "HeroService"
      },
      {
        "language": "text",
        "code": "constructor()"
      },
      {
        "language": "text",
        "code": "private logger: Logger"
      },
      {
        "language": "text",
        "code": "constructor()"
      },
      {
        "language": "text",
        "code": "HeroService"
      },
      {
        "language": "text",
        "code": "HeroService"
      },
      {
        "language": "text",
        "code": "content_copy\n      \n      import { Injectable } from '@angular/core';\nimport { HEROES } from './mock-heroes';\nimport { Logger } from '../logger.service';\n\n@Injectable({\n  providedIn: 'root',\n})\nexport class HeroService {\n\n  constructor(private logger: Logger) {  }\n\n  getHeroes() {\n    this.logger.log('Getting heroes ...');\n    return HEROES;\n  }\n}"
      },
      {
        "language": "text",
        "code": "import { Injectable } from '@angular/core';\nimport { HEROES } from './mock-heroes';\nimport { Logger } from '../logger.service';\n\n@Injectable({\n  providedIn: 'root',\n})\nexport class HeroService {\n\n  constructor(private logger: Logger) {  }\n\n  getHeroes() {\n    this.logger.log('Getting heroes ...');\n    return HEROES;\n  }\n}"
      },
      {
        "language": "text",
        "code": "getHeroes()"
      },
      {
        "language": "text",
        "code": "InjectionTokens"
      }
    ],
    "links": [
      {
        "text": "link",
        "href": "guide/creating-injectable-service#creating-an-injectable-service"
      },
      {
        "text": "Service examples",
        "href": "guide/creating-injectable-service#service-examples"
      },
      {
        "text": "Creating an injectable service",
        "href": "guide/creating-injectable-service#creating-an-injectable-service-1"
      },
      {
        "text": "Injecting services",
        "href": "guide/creating-injectable-service#injecting-services"
      },
      {
        "text": "Injecting services in other services",
        "href": "guide/creating-injectable-service#injecting-services-in-other-services"
      },
      {
        "text": "What's next",
        "href": "guide/creating-injectable-service#whats-next"
      },
      {
        "text": "link",
        "href": "guide/creating-injectable-service#service-examples"
      },
      {
        "text": "HttpClient",
        "href": "api/common/http/HttpClient"
      },
      {
        "text": "link",
        "href": "guide/creating-injectable-service#creating-an-injectable-service-1"
      },
      {
        "text": "Angular CLI",
        "href": "cli"
      },
      {
        "text": "Injectable",
        "href": "api/core/Injectable"
      },
      {
        "text": "Injectable",
        "href": "api/core/Injectable"
      },
      {
        "text": "Injectable",
        "href": "api/core/Injectable"
      },
      {
        "text": "Injectable",
        "href": "api/core/Injectable"
      },
      {
        "text": "Injectable",
        "href": "api/core/Injectable"
      },
      {
        "text": "link",
        "href": "guide/creating-injectable-service#injecting-services"
      },
      {
        "text": "Injectable",
        "href": "api/core/Injectable"
      },
      {
        "text": "link",
        "href": "guide/creating-injectable-service#injecting-services-in-other-services"
      },
      {
        "text": "Injectable",
        "href": "api/core/Injectable"
      },
      {
        "text": "Injectable",
        "href": "api/core/Injectable"
      },
      {
        "text": "link",
        "href": "guide/creating-injectable-service#whats-next"
      },
      {
        "text": "How to configure dependencies in DI",
        "href": "guide/dependency-injection-providers"
      },
      {
        "text": "How to use InjectionTokens to provide and inject values other than services/classes",
        "href": "guide/dependency-injection-providers#configuring-dependency-providers"
      },
      {
        "text": "Dependency Injection in Action",
        "href": "guide/dependency-injection-in-action"
      }
    ],
    "meta": {
      "description": "",
      "keywords": ""
    },
    "summary": "Creating an injectable servicelink Contents Service examplesCreating an injectable serviceInjecting servicesInjecting services in other servicesWhat's next Service is a broad category encompassing any...",
    "tags": [
      "react",
      "angular",
      "javascript",
      "typescript",
      "node",
      "creating",
      "injectable",
      "servicelink",
      "injecting",
      "serviceslink"
    ],
    "id": "angular-creatinginjectableservice-part-1",
    "quality": 90
  },
  {
    "title": "Angular",
    "url": "https://v17.angular.io/guide/built-in-directives",
    "category": "angular",
    "content": "Built-in directiveslink Contents Built-in attribute directivesAdding and removing classes with NgClassImport CommonModule in the componentUsing NgClass with an expressionUsing NgClass with a methodSetting inline styles with NgStyleImport CommonModule in the componentUsing NgStyle in your componentDisplaying and updating properties with ngModelNgModel and value accessorsBuilt-in structural directivesImport CommonModule in the componentAdding or removing an element with NgIfGuarding against nullListing items with NgForRepeating a component viewGetting the index of *ngForRepeating elements when a condition is trueTracking items with *ngFor trackByHosting a directive without a DOM elementSwitching cases with NgSwitchWhat's next Directives are classes that add additional behavior to elements in your Angular applications. Use Angular's built-in directives to manage forms, lists, styles, and what users see. See the live example / download example for a working example containing the code snippets in this guide. The different types of Angular directives are as follows: Directive Types Details Components Used with a template. This type of directive is the most common directive type. Attribute directives Change the appearance or behavior of an element, component, or another directive. Structural directives Change the DOM layout by adding and removing DOM elements. This guide covers built-in attribute directives and structural directives. Built-in attribute directiveslink Attribute directives listen to and modify the behavior of other HTML elements, attributes, properties, and components. Many attribute directives are defined through modules such as the CommonModule, RouterModule and FormsModule. The most common attribute directives are as follows: Common directives Details NgClass Adds and removes a set of CSS classes. NgStyle Adds and removes a set of HTML styles. NgModel Adds two-way data binding to an HTML form element. Built-in directives use only public APIs. They do not have special access to any private APIs that other directives can't access. Adding and removing classes with NgClasslink Add or remove multiple CSS classes simultaneously with ngClass. To add or remove a single class, use class binding rather than NgClass. Import CommonModule in the componentlink To use NgClass, import CommonModule and add it to the component's imports list. content_copy import {CommonModule} from '@angular/common'; /* . . . */ @Component({ standalone: true, /* . . . */ imports: [ CommonModule, // -- import into the component /* . . . */ ], }) export class AppComponent implements OnInit { /* . . . */ } Using NgClass with an expressionlink On the element you'd like to style, add [ngClass] and set it equal to an expression. In this case, isSpecial is a boolean set to true in app.component.ts. Because isSpecial is true, ngClass applies the class of special to the div. content_copy !-- toggle the \"special\" class on/off with a property -- div [ngClass]=\"isSpecial ? 'special' : ''\"This div is special/div Using NgClass with a methodlink To use NgClass with a method, add the method to the component class. In the following example, setCurrentClasses() sets the property currentClasses with an object that adds or removes three classes based on the true or false state of three other component properties. Each key of the object is a CSS class name. If a key is true, ngClass adds the class. If a key is false, ngClass removes the class. content_copy currentClasses: Recordstring, boolean = {}; /* . . . */ setCurrentClasses() { // CSS classes: added/removed per current state of component properties this.currentClasses = { saveable: this.canSave, modified: !this.isUnchanged, special: this.isSpecial, }; } In the template, add the ngClass property binding to currentClasses to set the element's classes: content_copy div [ngClass]=\"currentClasses\"This div is initially saveable, unchanged, and special./div For this use case, Angular applies the classes on initialization and in case of changes. The full example calls setCurrentClasses() initially with ngOnInit() and when the dependent properties change through a button click. These steps are not necessary to implement ngClass. For more information, see the live example / download example app.component.ts and app.component.html. Setting inline styles with NgStylelink Import CommonModule in the componentlink To use NgStyle, import CommonModule and add it to the component's imports list. content_copy import {CommonModule} from '@angular/common'; /* . . . */ @Component({ standalone: true, /* . . . */ imports: [ CommonModule, // -- import into the component /* . . . */ ], }) export class AppComponent implements OnInit { /* . . . */ } Using NgStyle in your componentlink Use NgStyle to set multiple inline styles simultaneously, based on the state of the component. To use NgStyle, add a method to the component class. In the following example, setCurrentStyles() sets the property currentStyles with an object that defines three styles, based on the state of three other component properties. content_copy currentStyles: Recordstring, string = {}; /* . . . */ setCurrentStyles() { // CSS styles: set per current state of component properties this.currentStyles = { 'font-style': this.canSave ? 'italic' : 'normal', 'font-weight': !this.isUnchanged ? 'bold' : 'normal', 'font-size': this.isSpecial ? '24px' : '12px', }; } To set the element's styles, add an ngStyle property binding to currentStyles. content_copy div [ngStyle]=\"currentStyles\" This div is initially italic, normal weight, and extra large (24px). /div For this use case, Angular applies the styles upon initialization and in case of changes. To do this, the full example calls setCurrentStyles() initially with ngOnInit() and when the dependent properties change through a button click. However, these steps are not necessary to implement ngStyle on its own. See the live example / download example app.component.ts and app.component.html for this optional implementation. Displaying and updating properties with ngModellink Use the NgModel directive to display a data property and update that property when the user makes changes. Import FormsModule and add it to the AppComponent's imports list. content_copy import {FormsModule} from '@angular/forms'; // --- JavaScript import from Angular /* . . . */ @Component({ standalone: true, /* . . . */ imports: [ CommonModule, // -- import into the component FormsModule, // --- import into the component /* . . . */ ], }) export class AppComponent implements OnInit { /* . . . */ } Add an [(ngModel)] binding on an HTML form element and set it equal to the property, here name. content_copy label for=\"example-ngModel\"[(ngModel)]:/label input [(ngModel)]=\"currentItem.name\" id=\"example-ngModel\" This [(ngModel)] syntax can only set a data-bound property. To customize your configuration, write the expanded form, which separates the property and event binding. Use property binding to set the property and event binding to respond to changes. The following example changes the input value to uppercase: content_copy input [ngModel]=\"currentItem.name\" (ngModelChange)=\"setUppercaseName($event)\" id=\"example-uppercase\" Here are all variations in action, including the uppercase version: NgModel and value accessorslink The NgModel directive works for an element supported by a ControlValueAccessor. Angular provides value accessors for all of the basic HTML form elements. For more information, see Forms. To apply [(ngModel)] to a non-form built-in element or a third-party custom component, you have to write a value accessor. For more information, see the API documentation on DefaultValueAccessor. When you write an Angular component, you don't need a value accessor or NgModel if you name the value and event properties according to Angular's two-way binding syntax. Built-in structural directiveslink Structural directives are responsible for HTML layout. They shape or reshape the DOM's structure, typically by adding, removing, and manipulating the host elements to which they are attached. This section introduces the most common built-in structural directives: Common built-in structural directives Details NgIf Conditionally creates or disposes of subviews from the template. NgFor Repeat a node for each item in a list. NgSwitch A set of directives that switch among alternative views. For more information, see Structural Directives. Import CommonModule in the componentlink To use built-in structural directives, import CommonModule and add it to the component's imports list. content_copy import {CommonModule} from '@angular/common'; /* . . . */ @Component({ standalone: true, /* . . . */ imports: [ CommonModule, // -- import into the component /* . . . */ ], }) export class AppComponent implements OnInit { /* . . . */ } Adding or removing an element with NgIflink Add or remove an element by applying an NgIf directive to a host element. When NgIf is false, Angular removes an element and its descendants from the DOM. Angular then disposes of their components, which frees up memory and resources. To add or remove an element, bind *ngIf to a condition expression such as isActive in the following example. content_copy app-item-detail *ngIf=\"isActive\" [item]=\"item\"/app-item-detail When the isActive expression returns a truthy value, NgIf adds the ItemDetailComponent to the DOM. When the expression is falsy, NgIf removes the ItemDetailComponent from the DOM and disposes of the component and all of its subcomponents. For more information on NgIf and NgIfElse, see the NgIf API documentation. Guarding against nulllink By default, NgIf prevents display of an element bound to a null value. To use NgIf to guard a div, add *ngIf=\"yourProperty\" to the div. In the following example, the currentCustomer name appears because there is a currentCustomer. content_copy div *ngIf=\"currentCustomer\"Hello, {{currentCustomer.name}}/div However, if the property is null, Angular does not display the div. In this example, Angular does not display the nullCustomer because it is null. content_copy div *ngIf=\"nullCustomer\"Hello, span{{nullCustomer}}/span/div Listing items with NgForlink Use the NgFor directive to present a list of items. Define a block of HTML that determines how Angular renders a single item. To list your items, assign the shorthand let item of items to *ngFor. content_copy div *ngFor=\"let item of items\"{{item.name}}/div The string \"let item of items\" instructs Angular to do the following: Store each item in the items array in the local item looping variable Make each item available to the templated HTML for each iteration Translate \"let item of items\" into an ng-template around the host element Repeat the ng-template for each item in the list For more information see the Structural directive shorthand section of Structural directives. Repeating a component viewlink To repeat a component element, apply *ngFor to the selector. In the following example, the selector is app-item-detail. content_copy app-item-detail *ngFor=\"let item of items\" [item]=\"item\"/app-item-detail Reference a template input variable, such as item, in the following locations: Within the ngFor host element Within the host element descendants to access the item's properties The following example references item first in an interpolation and then passes in a binding to the item property of the app-item-detail component. content_copy div *ngFor=\"let item of items\"{{item.name}}/div !-- . . . -- app-item-detail *ngFor=\"let item of items\" [item]=\"item\"/app-item-detail For more information about template input variables, see Structural directive shorthand. Getting the index of *ngForlink Get the index of *ngFor in a template input variable and use it in the template. In the *ngFor, add a semicolon and let i=index to the shorthand. The following example gets the index in a variable named i and displays it with the item name. content_copy div *ngFor=\"let item of items; let i=index\"{{i + 1}} - {{item.name}}/div The index property of the NgFor directive context returns the zero-based index of the item in each iteration. Angular translates this instruction into an ng-template around the host element, then uses this template repeatedly to create a new set of elements and bindings for each item in the list. For more information about shorthand, see the Structural Directives guide. Repeating elements when a condition is truelink To repeat a block of HTML when a particular condition is true, put the *ngIf on a container element that wraps an *ngFor element. For more information see one structural directive per element. Tracking items with *ngFor trackBylink Reduce the number of calls your application makes to the server by tracking changes to an item list. With the *ngFor trackBy property, Angular can change and re-render only those items that have changed, rather than reloading the entire list of items. Add a method to the component that returns the value NgFor should track. In this example, the value to track is the item's id. If the browser has already rendered id, Angular keeps track of it and doesn't re-query the server for the same id. content_copy trackByItems(index: number, item: Item): number { return item.id; } In the shorthand expression, set trackBy to the trackByItems() method. content_copy div *ngFor=\"let item of items; trackBy: trackByItems\" ({{item.id}}) {{item.name}} /div Change ids creates new items with new item.ids. In the following illustration of the trackBy effect, Reset items creates new items with the same item.ids. With no trackBy, both buttons trigger complete DOM element replacement. With trackBy, only changing the id triggers element replacement. Hosting a directive without a DOM elementlink The Angular ng-container is a grouping element that doesn't interfere with styles or layout because Angular doesn't put it in the DOM. Use ng-container when there's no single element to host the directive. Here's a conditional paragraph using ng-container. content_copy p I turned the corner ng-container *ngIf=\"hero\" and saw {{hero.name}}. I waved /ng-container and continued on my way. /p Import the ngModel directive from FormsModule. Add FormsModule to the imports section of the relevant Angular module. To conditionally exclude an option, wrap the option in an ng-container. content_copy div Pick your favorite hero (label for=\"showSad\"input id=\"showSad\" type=\"checkbox\" checked (change)=\"showSad = !showSad\"show sad/label) /div select [(ngModel)]=\"hero\" ng-container *ngFor=\"let h of heroes\" ng-container *ngIf=\"showSad  h.emotion !== 'sad'\" option [ngValue]=\"h\"{{h.name}} ({{h.emotion}})/option /ng-container /ng-container /select Switching cases with NgSwitchlink Like the JavaScript switch statement, NgSwitch displays one element from among several possible elements, based on a switch condition. Angular puts only the selected element into the DOM. NgSwitch is a set of three directives: NgSwitch directives Details NgSwitch An attribute directive that changes the behavior of its companion directives. NgSwitchCase Structural directive that adds its element to the DOM when its bound value equals the switch value and removes its bound value when it doesn't equal the switch value. NgSwitchDefault Structural directive that adds its element to the DOM when there is no selected NgSwitchCase. On an element, such as a div, add [ngSwitch] bound to an expression that returns the switch value, such as feature. Though the feature value in this example is a string, the switch value can be of any type. Bind to *ngSwitchCase and *ngSwitchDefault on the elements for the cases. content_copy div [ngSwitch]=\"currentItem.feature\" app-stout-item *ngSwitchCase=\"'stout'\" [item]=\"currentItem\"/app-stout-item app-device-item *ngSwitchCase=\"'slim'\" [item]=\"currentItem\"/app-device-item app-lost-item *ngSwitchCase=\"'vintage'\" [item]=\"currentItem\"/app-lost-item app-best-item *ngSwitchCase=\"'bright'\" [item]=\"currentItem\"/app-best-item !-- . . . -- app-unknown-item *ngSwitchDefault [item]=\"currentItem\"/app-unknown-item /div In the parent component, define currentItem, to use it in the [ngSwitch] expression. content_copy currentItem!: Item; In each child component, add an item input property which is bound to the currentItem of the parent component. The following two snippets show the parent component and one of the child components. The other child components are identical to StoutItemComponent. content_copy export class StoutItemComponent { @Input() item!: Item; } Switch directives also work with built-in HTML elements and web components. For example, you could replace the app-best-item switch case with a div as follows. content_copy div *ngSwitchCase=\"'bright'\" Are you as bright as {{currentItem.name}}?/div What's nextlink For information on how to build your own custom directives, see Attribute Directives and Structural Directives. Last reviewed on Mon Feb 28 2022",
    "headings": [
      {
        "level": 1,
        "text": "Built-in directiveslink",
        "id": "built-in-directives"
      },
      {
        "level": 2,
        "text": "Built-in attribute directiveslink",
        "id": "built-in-attribute-directives"
      },
      {
        "level": 2,
        "text": "Adding and removing classes with NgClasslink",
        "id": "adding-and-removing-classes-with-ngclass"
      },
      {
        "level": 2,
        "text": "Setting inline styles with NgStylelink",
        "id": "setting-inline-styles-with-ngstyle"
      },
      {
        "level": 2,
        "text": "Displaying and updating properties with ngModellink",
        "id": "displaying-and-updating-properties-with-ngmodel"
      },
      {
        "level": 2,
        "text": "Built-in structural directiveslink",
        "id": "built-in-structural-directives"
      },
      {
        "level": 2,
        "text": "Adding or removing an element with NgIflink",
        "id": "adding-or-removing-an-element-with-ngif"
      },
      {
        "level": 2,
        "text": "Listing items with NgForlink",
        "id": "listing-items-with-ngfor"
      },
      {
        "level": 2,
        "text": "Repeating elements when a condition is truelink",
        "id": "repeating-elements-when-a-condition-is-true"
      },
      {
        "level": 2,
        "text": "Hosting a directive without a DOM elementlink",
        "id": "hosting-a-directive-without-a-dom-element"
      },
      {
        "level": 2,
        "text": "Switching cases with NgSwitchlink",
        "id": "switching-cases-with-ngswitch"
      },
      {
        "level": 2,
        "text": "What's nextlink",
        "id": "whats-next"
      },
      {
        "level": 3,
        "text": "Import CommonModule in the componentlink",
        "id": "import-commonmodule-in-the-component"
      },
      {
        "level": 3,
        "text": "Using NgClass with an expressionlink",
        "id": "using-ngclass-with-an-expression"
      },
      {
        "level": 3,
        "text": "Using NgClass with a methodlink",
        "id": "using-ngclass-with-a-method"
      },
      {
        "level": 3,
        "text": "Import CommonModule in the componentlink",
        "id": "import-commonmodule-in-the-component-1"
      },
      {
        "level": 3,
        "text": "Using NgStyle in your componentlink",
        "id": "using-ngstyle-in-your-component"
      },
      {
        "level": 3,
        "text": "NgModel and value accessorslink",
        "id": "ngmodel-and-value-accessors"
      },
      {
        "level": 3,
        "text": "Import CommonModule in the componentlink",
        "id": "import-commonmodule-in-the-component-2"
      },
      {
        "level": 3,
        "text": "Guarding against nulllink",
        "id": "guarding-against-null"
      },
      {
        "level": 3,
        "text": "Repeating a component viewlink",
        "id": "repeating-a-component-view"
      },
      {
        "level": 3,
        "text": "Getting the index of *ngForlink",
        "id": "getting-the-index-of-ngfor"
      },
      {
        "level": 3,
        "text": "Tracking items with *ngFor trackBylink",
        "id": "tracking-items-with-ngfor-trackby"
      }
    ],
    "codeBlocks": [
      {
        "language": "text",
        "code": "CommonModule"
      },
      {
        "language": "text",
        "code": "CommonModule"
      },
      {
        "language": "text",
        "code": "CommonModule"
      },
      {
        "language": "text",
        "code": "CommonModule"
      },
      {
        "language": "text",
        "code": "RouterModule"
      },
      {
        "language": "text",
        "code": "FormsModule"
      },
      {
        "language": "text",
        "code": "CommonModule"
      },
      {
        "language": "text",
        "code": "CommonModule"
      },
      {
        "language": "text",
        "code": "content_copy\n      \n      import {CommonModule} from '@angular/common';\n/* . . . */\n@Component({\n  standalone: true,\n  /* . . . */\n  imports: [\n    CommonModule, // <-- import into the component\n    /* . . . */\n  ],\n})\nexport class AppComponent implements OnInit {\n  /* . . . */\n}"
      },
      {
        "language": "text",
        "code": "import {CommonModule} from '@angular/common';\n/* . . . */\n@Component({\n  standalone: true,\n  /* . . . */\n  imports: [\n    CommonModule, // <-- import into the component\n    /* . . . */\n  ],\n})\nexport class AppComponent implements OnInit {\n  /* . . . */\n}"
      },
      {
        "language": "text",
        "code": "app.component.ts"
      },
      {
        "language": "text",
        "code": "content_copy\n      \n      <!-- toggle the \"special\" class on/off with a property -->\n<div [ngClass]=\"isSpecial ? 'special' : ''\">This div is special</div>"
      },
      {
        "language": "text",
        "code": "<!-- toggle the \"special\" class on/off with a property -->\n<div [ngClass]=\"isSpecial ? 'special' : ''\">This div is special</div>"
      },
      {
        "language": "text",
        "code": "setCurrentClasses()"
      },
      {
        "language": "text",
        "code": "currentClasses"
      },
      {
        "language": "text",
        "code": "content_copy\n      \n      currentClasses: Record<string, boolean> = {};\n/* . . . */\nsetCurrentClasses() {\n  // CSS classes: added/removed per current state of component properties\n  this.currentClasses = {\n    saveable: this.canSave,\n    modified: !this.isUnchanged,\n    special: this.isSpecial,\n  };\n}"
      },
      {
        "language": "text",
        "code": "currentClasses: Record<string, boolean> = {};\n/* . . . */\nsetCurrentClasses() {\n  // CSS classes: added/removed per current state of component properties\n  this.currentClasses = {\n    saveable: this.canSave,\n    modified: !this.isUnchanged,\n    special: this.isSpecial,\n  };\n}"
      },
      {
        "language": "text",
        "code": "currentClasses"
      },
      {
        "language": "text",
        "code": "content_copy\n      \n      <div [ngClass]=\"currentClasses\">This div is initially saveable, unchanged, and special.</div>"
      },
      {
        "language": "text",
        "code": "<div [ngClass]=\"currentClasses\">This div is initially saveable, unchanged, and special.</div>"
      },
      {
        "language": "text",
        "code": "setCurrentClasses()"
      },
      {
        "language": "text",
        "code": "app.component.ts"
      },
      {
        "language": "text",
        "code": "app.component.html"
      },
      {
        "language": "text",
        "code": "CommonModule"
      },
      {
        "language": "text",
        "code": "CommonModule"
      },
      {
        "language": "text",
        "code": "content_copy\n      \n      import {CommonModule} from '@angular/common';\n/* . . . */\n@Component({\n  standalone: true,\n  /* . . . */\n  imports: [\n    CommonModule, // <-- import into the component\n    /* . . . */\n  ],\n})\nexport class AppComponent implements OnInit {\n  /* . . . */\n}"
      },
      {
        "language": "text",
        "code": "import {CommonModule} from '@angular/common';\n/* . . . */\n@Component({\n  standalone: true,\n  /* . . . */\n  imports: [\n    CommonModule, // <-- import into the component\n    /* . . . */\n  ],\n})\nexport class AppComponent implements OnInit {\n  /* . . . */\n}"
      },
      {
        "language": "text",
        "code": "setCurrentStyles()"
      },
      {
        "language": "text",
        "code": "currentStyles"
      },
      {
        "language": "text",
        "code": "content_copy\n      \n      currentStyles: Record<string, string> = {};\n/* . . . */\nsetCurrentStyles() {\n  // CSS styles: set per current state of component properties\n  this.currentStyles = {\n    'font-style': this.canSave ? 'italic' : 'normal',\n    'font-weight': !this.isUnchanged ? 'bold' : 'normal',\n    'font-size': this.isSpecial ? '24px' : '12px',\n  };\n}"
      },
      {
        "language": "text",
        "code": "currentStyles: Record<string, string> = {};\n/* . . . */\nsetCurrentStyles() {\n  // CSS styles: set per current state of component properties\n  this.currentStyles = {\n    'font-style': this.canSave ? 'italic' : 'normal',\n    'font-weight': !this.isUnchanged ? 'bold' : 'normal',\n    'font-size': this.isSpecial ? '24px' : '12px',\n  };\n}"
      },
      {
        "language": "text",
        "code": "currentStyles"
      },
      {
        "language": "text",
        "code": "content_copy\n      \n      <div [ngStyle]=\"currentStyles\">\n  This div is initially italic, normal weight, and extra large (24px).\n</div>"
      },
      {
        "language": "text",
        "code": "<div [ngStyle]=\"currentStyles\">\n  This div is initially italic, normal weight, and extra large (24px).\n</div>"
      },
      {
        "language": "text",
        "code": "setCurrentStyles()"
      },
      {
        "language": "text",
        "code": "app.component.ts"
      },
      {
        "language": "text",
        "code": "app.component.html"
      },
      {
        "language": "text",
        "code": "FormsModule"
      },
      {
        "language": "text",
        "code": "content_copy\n      \n      import {FormsModule} from '@angular/forms'; // <--- JavaScript import from Angular\n/* . . . */\n@Component({\n  standalone: true,\n  /* . . . */\n  imports: [\n    CommonModule, // <-- import into the component\n    FormsModule, // <--- import into the component\n    /* . . . */\n  ],\n})\nexport class AppComponent implements OnInit {\n  /* . . . */\n}"
      },
      {
        "language": "text",
        "code": "import {FormsModule} from '@angular/forms'; // <--- JavaScript import from Angular\n/* . . . */\n@Component({\n  standalone: true,\n  /* . . . */\n  imports: [\n    CommonModule, // <-- import into the component\n    FormsModule, // <--- import into the component\n    /* . . . */\n  ],\n})\nexport class AppComponent implements OnInit {\n  /* . . . */\n}"
      },
      {
        "language": "text",
        "code": "[(ngModel)]"
      },
      {
        "language": "text",
        "code": "content_copy\n      \n      <label for=\"example-ngModel\">[(ngModel)]:</label>\n<input [(ngModel)]=\"currentItem.name\" id=\"example-ngModel\">"
      },
      {
        "language": "text",
        "code": "<label for=\"example-ngModel\">[(ngModel)]:</label>\n<input [(ngModel)]=\"currentItem.name\" id=\"example-ngModel\">"
      },
      {
        "language": "text",
        "code": "[(ngModel)]"
      },
      {
        "language": "text",
        "code": "content_copy\n      \n      <input [ngModel]=\"currentItem.name\" (ngModelChange)=\"setUppercaseName($event)\" id=\"example-uppercase\">"
      },
      {
        "language": "text",
        "code": "<input [ngModel]=\"currentItem.name\" (ngModelChange)=\"setUppercaseName($event)\" id=\"example-uppercase\">"
      },
      {
        "language": "text",
        "code": "[(ngModel)]"
      },
      {
        "language": "text",
        "code": "CommonModule"
      },
      {
        "language": "text",
        "code": "CommonModule"
      },
      {
        "language": "text",
        "code": "content_copy\n      \n      import {CommonModule} from '@angular/common';\n/* . . . */\n@Component({\n  standalone: true,\n  /* . . . */\n  imports: [\n    CommonModule, // <-- import into the component\n    /* . . . */\n  ],\n})\nexport class AppComponent implements OnInit {\n  /* . . . */\n}"
      },
      {
        "language": "text",
        "code": "import {CommonModule} from '@angular/common';\n/* . . . */\n@Component({\n  standalone: true,\n  /* . . . */\n  imports: [\n    CommonModule, // <-- import into the component\n    /* . . . */\n  ],\n})\nexport class AppComponent implements OnInit {\n  /* . . . */\n}"
      },
      {
        "language": "text",
        "code": "content_copy\n      \n      <app-item-detail *ngIf=\"isActive\" [item]=\"item\"></app-item-detail>"
      },
      {
        "language": "text",
        "code": "<app-item-detail *ngIf=\"isActive\" [item]=\"item\"></app-item-detail>"
      },
      {
        "language": "text",
        "code": "ItemDetailComponent"
      },
      {
        "language": "text",
        "code": "ItemDetailComponent"
      },
      {
        "language": "text",
        "code": "*ngIf=\"yourProperty\""
      },
      {
        "language": "text",
        "code": "currentCustomer"
      },
      {
        "language": "text",
        "code": "currentCustomer"
      },
      {
        "language": "text",
        "code": "content_copy\n      \n      <div *ngIf=\"currentCustomer\">Hello, {{currentCustomer.name}}</div>"
      },
      {
        "language": "text",
        "code": "<div *ngIf=\"currentCustomer\">Hello, {{currentCustomer.name}}</div>"
      },
      {
        "language": "text",
        "code": "nullCustomer"
      },
      {
        "language": "text",
        "code": "content_copy\n      \n      <div *ngIf=\"nullCustomer\">Hello, <span>{{nullCustomer}}</span></div>"
      },
      {
        "language": "text",
        "code": "<div *ngIf=\"nullCustomer\">Hello, <span>{{nullCustomer}}</span></div>"
      },
      {
        "language": "text",
        "code": "let item of items"
      },
      {
        "language": "text",
        "code": "content_copy\n      \n      <div *ngFor=\"let item of items\">{{item.name}}</div>"
      },
      {
        "language": "text",
        "code": "<div *ngFor=\"let item of items\">{{item.name}}</div>"
      },
      {
        "language": "text",
        "code": "\"let item of items\""
      },
      {
        "language": "text",
        "code": "\"let item of items\""
      },
      {
        "language": "text",
        "code": "<ng-template>"
      },
      {
        "language": "text",
        "code": "<ng-template>"
      },
      {
        "language": "text",
        "code": "<app-item-detail>"
      },
      {
        "language": "text",
        "code": "content_copy\n      \n      <app-item-detail *ngFor=\"let item of items\" [item]=\"item\"></app-item-detail>"
      },
      {
        "language": "text",
        "code": "<app-item-detail *ngFor=\"let item of items\" [item]=\"item\"></app-item-detail>"
      },
      {
        "language": "text",
        "code": "<app-item-detail>"
      },
      {
        "language": "text",
        "code": "content_copy\n      \n      <div *ngFor=\"let item of items\">{{item.name}}</div>\n<!-- . . . -->\n<app-item-detail *ngFor=\"let item of items\" [item]=\"item\"></app-item-detail>"
      },
      {
        "language": "text",
        "code": "<div *ngFor=\"let item of items\">{{item.name}}</div>\n<!-- . . . -->\n<app-item-detail *ngFor=\"let item of items\" [item]=\"item\"></app-item-detail>"
      },
      {
        "language": "text",
        "code": "let i=index"
      },
      {
        "language": "text",
        "code": "content_copy\n      \n      <div *ngFor=\"let item of items; let i=index\">{{i + 1}} - {{item.name}}</div>"
      },
      {
        "language": "text",
        "code": "<div *ngFor=\"let item of items; let i=index\">{{i + 1}} - {{item.name}}</div>"
      },
      {
        "language": "text",
        "code": "<ng-template>"
      },
      {
        "language": "text",
        "code": "content_copy\n      \n      trackByItems(index: number, item: Item): number {\n  return item.id;\n}"
      },
      {
        "language": "text",
        "code": "trackByItems(index: number, item: Item): number {\n  return item.id;\n}"
      },
      {
        "language": "text",
        "code": "trackByItems()"
      },
      {
        "language": "text",
        "code": "content_copy\n      \n      <div *ngFor=\"let item of items; trackBy: trackByItems\">\n  ({{item.id}}) {{item.name}}\n</div>"
      },
      {
        "language": "text",
        "code": "<div *ngFor=\"let item of items; trackBy: trackByItems\">\n  ({{item.id}}) {{item.name}}\n</div>"
      },
      {
        "language": "text",
        "code": "<ng-container>"
      },
      {
        "language": "text",
        "code": "<ng-container>"
      },
      {
        "language": "text",
        "code": "<ng-container>"
      },
      {
        "language": "text",
        "code": "content_copy\n      \n      <p>\n  I turned the corner\n  <ng-container *ngIf=\"hero\">\n    and saw {{hero.name}}. I waved\n  </ng-container>\n  and continued on my way.\n</p>"
      },
      {
        "language": "text",
        "code": "<p>\n  I turned the corner\n  <ng-container *ngIf=\"hero\">\n    and saw {{hero.name}}. I waved\n  </ng-container>\n  and continued on my way.\n</p>"
      },
      {
        "language": "text",
        "code": "FormsModule"
      },
      {
        "language": "text",
        "code": "FormsModule"
      },
      {
        "language": "text",
        "code": "<ng-container>"
      },
      {
        "language": "text",
        "code": "content_copy\n      \n      <div>\n  Pick your favorite hero\n  (<label for=\"showSad\"><input id=\"showSad\" type=\"checkbox\" checked (change)=\"showSad = !showSad\">show sad</label>)\n</div>\n<select [(ngModel)]=\"hero\">\n  <ng-container *ngFor=\"let h of heroes\">\n    <ng-container *ngIf=\"showSad || h.emotion !== 'sad'\">\n      <option [ngValue]=\"h\">{{h.name}} ({{h.emotion}})</option>\n    </ng-container>\n  </ng-container>\n</select>"
      },
      {
        "language": "text",
        "code": "<div>\n  Pick your favorite hero\n  (<label for=\"showSad\"><input id=\"showSad\" type=\"checkbox\" checked (change)=\"showSad = !showSad\">show sad</label>)\n</div>\n<select [(ngModel)]=\"hero\">\n  <ng-container *ngFor=\"let h of heroes\">\n    <ng-container *ngIf=\"showSad || h.emotion !== 'sad'\">\n      <option [ngValue]=\"h\">{{h.name}} ({{h.emotion}})</option>\n    </ng-container>\n  </ng-container>\n</select>"
      },
      {
        "language": "text",
        "code": "NgSwitchCase"
      },
      {
        "language": "text",
        "code": "NgSwitchDefault"
      },
      {
        "language": "text",
        "code": "NgSwitchCase"
      },
      {
        "language": "text",
        "code": "*ngSwitchCase"
      },
      {
        "language": "text",
        "code": "*ngSwitchDefault"
      },
      {
        "language": "text",
        "code": "content_copy\n      \n      <div [ngSwitch]=\"currentItem.feature\">\n  <app-stout-item    *ngSwitchCase=\"'stout'\"    [item]=\"currentItem\"></app-stout-item>\n  <app-device-item   *ngSwitchCase=\"'slim'\"     [item]=\"currentItem\"></app-device-item>\n  <app-lost-item     *ngSwitchCase=\"'vintage'\"  [item]=\"currentItem\"></app-lost-item>\n  <app-best-item     *ngSwitchCase=\"'bright'\"   [item]=\"currentItem\"></app-best-item>\n<!-- . . . -->\n  <app-unknown-item  *ngSwitchDefault           [item]=\"currentItem\"></app-unknown-item>\n</div>"
      },
      {
        "language": "text",
        "code": "<div [ngSwitch]=\"currentItem.feature\">\n  <app-stout-item    *ngSwitchCase=\"'stout'\"    [item]=\"currentItem\"></app-stout-item>\n  <app-device-item   *ngSwitchCase=\"'slim'\"     [item]=\"currentItem\"></app-device-item>\n  <app-lost-item     *ngSwitchCase=\"'vintage'\"  [item]=\"currentItem\"></app-lost-item>\n  <app-best-item     *ngSwitchCase=\"'bright'\"   [item]=\"currentItem\"></app-best-item>\n<!-- . . . -->\n  <app-unknown-item  *ngSwitchDefault           [item]=\"currentItem\"></app-unknown-item>\n</div>"
      },
      {
        "language": "text",
        "code": "currentItem"
      },
      {
        "language": "text",
        "code": "content_copy\n      \n      currentItem!: Item;"
      },
      {
        "language": "text",
        "code": "currentItem!: Item;"
      },
      {
        "language": "text",
        "code": "currentItem"
      },
      {
        "language": "text",
        "code": "StoutItemComponent"
      },
      {
        "language": "text",
        "code": "content_copy\n      \n      export class StoutItemComponent {\n  @Input() item!: Item;\n}"
      },
      {
        "language": "text",
        "code": "export class StoutItemComponent {\n  @Input() item!: Item;\n}"
      },
      {
        "language": "text",
        "code": "<app-best-item>"
      },
      {
        "language": "text",
        "code": "content_copy\n      \n      <div *ngSwitchCase=\"'bright'\"> Are you as bright as {{currentItem.name}}?</div>"
      },
      {
        "language": "text",
        "code": "<div *ngSwitchCase=\"'bright'\"> Are you as bright as {{currentItem.name}}?</div>"
      }
    ],
    "links": [
      {
        "text": "link",
        "href": "guide/built-in-directives#built-in-directives"
      },
      {
        "text": "Built-in attribute directives",
        "href": "guide/built-in-directives#built-in-attribute-directives"
      },
      {
        "text": "Adding and removing classes with NgClass",
        "href": "guide/built-in-directives#adding-and-removing-classes-with-ngclass"
      },
      {
        "text": "Import CommonModule in the component",
        "href": "guide/built-in-directives#import-commonmodule-in-the-component"
      },
      {
        "text": "Using NgClass with an expression",
        "href": "guide/built-in-directives#using-ngclass-with-an-expression"
      },
      {
        "text": "Using NgClass with a method",
        "href": "guide/built-in-directives#using-ngclass-with-a-method"
      },
      {
        "text": "Setting inline styles with NgStyle",
        "href": "guide/built-in-directives#setting-inline-styles-with-ngstyle"
      },
      {
        "text": "Import CommonModule in the component",
        "href": "guide/built-in-directives#import-commonmodule-in-the-component-1"
      },
      {
        "text": "Using NgStyle in your component",
        "href": "guide/built-in-directives#using-ngstyle-in-your-component"
      },
      {
        "text": "Displaying and updating properties with ngModel",
        "href": "guide/built-in-directives#displaying-and-updating-properties-with-ngmodel"
      },
      {
        "text": "NgModel and value accessors",
        "href": "guide/built-in-directives#ngmodel-and-value-accessors"
      },
      {
        "text": "Built-in structural directives",
        "href": "guide/built-in-directives#built-in-structural-directives"
      },
      {
        "text": "Import CommonModule in the component",
        "href": "guide/built-in-directives#import-commonmodule-in-the-component-2"
      },
      {
        "text": "Adding or removing an element with NgIf",
        "href": "guide/built-in-directives#adding-or-removing-an-element-with-ngif"
      },
      {
        "text": "Guarding against null",
        "href": "guide/built-in-directives#guarding-against-null"
      },
      {
        "text": "Listing items with NgFor",
        "href": "guide/built-in-directives#listing-items-with-ngfor"
      },
      {
        "text": "Repeating a component view",
        "href": "guide/built-in-directives#repeating-a-component-view"
      },
      {
        "text": "Getting the index of *ngFor",
        "href": "guide/built-in-directives#getting-the-index-of-ngfor"
      },
      {
        "text": "Repeating elements when a condition is true",
        "href": "guide/built-in-directives#repeating-elements-when-a-condition-is-true"
      },
      {
        "text": "Tracking items with *ngFor trackBy",
        "href": "guide/built-in-directives#tracking-items-with-ngfor-trackby"
      },
      {
        "text": "Hosting a directive without a DOM element",
        "href": "guide/built-in-directives#hosting-a-directive-without-a-dom-element"
      },
      {
        "text": "Switching cases with NgSwitch",
        "href": "guide/built-in-directives#switching-cases-with-ngswitch"
      },
      {
        "text": "What's next",
        "href": "guide/built-in-directives#whats-next"
      },
      {
        "text": "live example",
        "href": "generated/live-examples/built-in-directives/stackblitz.html"
      },
      {
        "text": "download example",
        "href": "generated/zips/built-in-directives/built-in-directives.zip"
      },
      {
        "text": "Components",
        "href": "guide/component-overview"
      },
      {
        "text": "Attribute directives",
        "href": "guide/built-in-directives#built-in-attribute-directives"
      },
      {
        "text": "Structural directives",
        "href": "guide/built-in-directives#built-in-structural-directives"
      },
      {
        "text": "attribute directives",
        "href": "guide/built-in-directives#built-in-attribute-directives"
      },
      {
        "text": "structural directives",
        "href": "guide/built-in-directives#built-in-structural-directives"
      },
      {
        "text": "link",
        "href": "guide/built-in-directives#built-in-attribute-directives"
      },
      {
        "text": "CommonModule",
        "href": "api/common/CommonModule"
      },
      {
        "text": "RouterModule",
        "href": "guide/router"
      },
      {
        "text": "FormsModule",
        "href": "guide/forms"
      },
      {
        "text": "NgClass",
        "href": "guide/built-in-directives#ngClass"
      },
      {
        "text": "NgStyle",
        "href": "guide/built-in-directives#ngstyle"
      },
      {
        "text": "NgModel",
        "href": "guide/built-in-directives#ngModel"
      },
      {
        "text": "NgClass",
        "href": "api/common/NgClass"
      },
      {
        "text": "link",
        "href": "guide/built-in-directives#adding-and-removing-classes-with-ngclass"
      },
      {
        "text": "ngClass",
        "href": "api/common/NgClass"
      },
      {
        "text": "class binding",
        "href": "guide/class-binding"
      },
      {
        "text": "NgClass",
        "href": "api/common/NgClass"
      },
      {
        "text": "CommonModule",
        "href": "api/common/CommonModule"
      },
      {
        "text": "link",
        "href": "guide/built-in-directives#import-commonmodule-in-the-component"
      },
      {
        "text": "NgClass",
        "href": "api/common/NgClass"
      },
      {
        "text": "CommonModule",
        "href": "api/common/CommonModule"
      },
      {
        "text": "CommonModule",
        "href": "api/common/CommonModule"
      },
      {
        "text": "Component",
        "href": "api/core/Component"
      },
      {
        "text": "CommonModule",
        "href": "api/common/CommonModule"
      },
      {
        "text": "OnInit",
        "href": "api/core/OnInit"
      },
      {
        "text": "NgClass",
        "href": "api/common/NgClass"
      },
      {
        "text": "link",
        "href": "guide/built-in-directives#using-ngclass-with-an-expression"
      },
      {
        "text": "ngClass",
        "href": "api/common/NgClass"
      },
      {
        "text": "ngClass",
        "href": "api/common/NgClass"
      },
      {
        "text": "ngClass",
        "href": "api/common/NgClass"
      },
      {
        "text": "NgClass",
        "href": "api/common/NgClass"
      },
      {
        "text": "link",
        "href": "guide/built-in-directives#using-ngclass-with-a-method"
      },
      {
        "text": "NgClass",
        "href": "api/common/NgClass"
      },
      {
        "text": "ngClass",
        "href": "api/common/NgClass"
      },
      {
        "text": "ngClass",
        "href": "api/common/NgClass"
      },
      {
        "text": "ngClass",
        "href": "api/common/NgClass"
      },
      {
        "text": "ngClass",
        "href": "api/common/NgClass"
      },
      {
        "text": "ngClass",
        "href": "api/common/NgClass"
      },
      {
        "text": "live example",
        "href": "generated/live-examples/built-in-directives/stackblitz.html"
      },
      {
        "text": "download example",
        "href": "generated/zips/built-in-directives/built-in-directives.zip"
      },
      {
        "text": "NgStyle",
        "href": "api/common/NgStyle"
      },
      {
        "text": "link",
        "href": "guide/built-in-directives#setting-inline-styles-with-ngstyle"
      },
      {
        "text": "CommonModule",
        "href": "api/common/CommonModule"
      },
      {
        "text": "link",
        "href": "guide/built-in-directives#import-commonmodule-in-the-component-1"
      },
      {
        "text": "NgStyle",
        "href": "api/common/NgStyle"
      },
      {
        "text": "CommonModule",
        "href": "api/common/CommonModule"
      },
      {
        "text": "CommonModule",
        "href": "api/common/CommonModule"
      },
      {
        "text": "Component",
        "href": "api/core/Component"
      },
      {
        "text": "CommonModule",
        "href": "api/common/CommonModule"
      },
      {
        "text": "OnInit",
        "href": "api/core/OnInit"
      },
      {
        "text": "NgStyle",
        "href": "api/common/NgStyle"
      },
      {
        "text": "link",
        "href": "guide/built-in-directives#using-ngstyle-in-your-component"
      },
      {
        "text": "NgStyle",
        "href": "api/common/NgStyle"
      },
      {
        "text": "NgStyle",
        "href": "api/common/NgStyle"
      },
      {
        "text": "ngStyle",
        "href": "api/common/NgStyle"
      },
      {
        "text": "ngStyle",
        "href": "api/common/NgStyle"
      },
      {
        "text": "ngStyle",
        "href": "api/common/NgStyle"
      },
      {
        "text": "live example",
        "href": "generated/live-examples/built-in-directives/stackblitz.html"
      },
      {
        "text": "download example",
        "href": "generated/zips/built-in-directives/built-in-directives.zip"
      },
      {
        "text": "ngModel",
        "href": "api/forms/NgModel"
      },
      {
        "text": "link",
        "href": "guide/built-in-directives#displaying-and-updating-properties-with-ngmodel"
      },
      {
        "text": "NgModel",
        "href": "api/forms/NgModel"
      },
      {
        "text": "FormsModule",
        "href": "api/forms/FormsModule"
      },
      {
        "text": "FormsModule",
        "href": "api/forms/FormsModule"
      },
      {
        "text": "Component",
        "href": "api/core/Component"
      },
      {
        "text": "CommonModule",
        "href": "api/common/CommonModule"
      },
      {
        "text": "FormsModule",
        "href": "api/forms/FormsModule"
      },
      {
        "text": "OnInit",
        "href": "api/core/OnInit"
      },
      {
        "text": "ngModel",
        "href": "api/forms/NgModel"
      },
      {
        "text": "ngModel",
        "href": "api/forms/NgModel"
      },
      {
        "text": "ngModel",
        "href": "api/forms/NgModel"
      },
      {
        "text": "ngModel",
        "href": "api/forms/NgModel"
      },
      {
        "text": "property binding",
        "href": "guide/property-binding"
      },
      {
        "text": "event binding",
        "href": "guide/event-binding"
      },
      {
        "text": "ngModel",
        "href": "api/forms/NgModel"
      },
      {
        "text": "NgModel",
        "href": "api/forms/NgModel"
      },
      {
        "text": "link",
        "href": "guide/built-in-directives#ngmodel-and-value-accessors"
      },
      {
        "text": "NgModel",
        "href": "api/forms/NgModel"
      },
      {
        "text": "ControlValueAccessor",
        "href": "api/forms/ControlValueAccessor"
      },
      {
        "text": "Forms",
        "href": "guide/forms"
      },
      {
        "text": "ngModel",
        "href": "api/forms/NgModel"
      },
      {
        "text": "DefaultValueAccessor",
        "href": "api/forms/DefaultValueAccessor"
      },
      {
        "text": "NgModel",
        "href": "api/forms/NgModel"
      },
      {
        "text": "two-way binding syntax",
        "href": "guide/two-way-binding#how-two-way-binding-works"
      },
      {
        "text": "link",
        "href": "guide/built-in-directives#built-in-structural-directives"
      },
      {
        "text": "NgIf",
        "href": "guide/built-in-directives#ngIf"
      },
      {
        "text": "NgFor",
        "href": "guide/built-in-directives#ngFor"
      },
      {
        "text": "NgSwitch",
        "href": "guide/built-in-directives#ngSwitch"
      },
      {
        "text": "Structural Directives",
        "href": "guide/structural-directives"
      },
      {
        "text": "CommonModule",
        "href": "api/common/CommonModule"
      },
      {
        "text": "link",
        "href": "guide/built-in-directives#import-commonmodule-in-the-component-2"
      },
      {
        "text": "CommonModule",
        "href": "api/common/CommonModule"
      },
      {
        "text": "CommonModule",
        "href": "api/common/CommonModule"
      },
      {
        "text": "Component",
        "href": "api/core/Component"
      },
      {
        "text": "CommonModule",
        "href": "api/common/CommonModule"
      },
      {
        "text": "OnInit",
        "href": "api/core/OnInit"
      },
      {
        "text": "NgIf",
        "href": "api/common/NgIf"
      },
      {
        "text": "link",
        "href": "guide/built-in-directives#adding-or-removing-an-element-with-ngif"
      },
      {
        "text": "NgIf",
        "href": "api/common/NgIf"
      },
      {
        "text": "NgIf",
        "href": "api/common/NgIf"
      },
      {
        "text": "ngIf",
        "href": "api/common/NgIf"
      },
      {
        "text": "ngIf",
        "href": "api/common/NgIf"
      },
      {
        "text": "NgIf",
        "href": "api/common/NgIf"
      },
      {
        "text": "NgIf",
        "href": "api/common/NgIf"
      },
      {
        "text": "NgIf",
        "href": "api/common/NgIf"
      },
      {
        "text": "NgIf API documentation",
        "href": "api/common/NgIf"
      },
      {
        "text": "link",
        "href": "guide/built-in-directives#guarding-against-null"
      },
      {
        "text": "NgIf",
        "href": "api/common/NgIf"
      },
      {
        "text": "NgIf",
        "href": "api/common/NgIf"
      },
      {
        "text": "ngIf",
        "href": "api/common/NgIf"
      },
      {
        "text": "ngIf",
        "href": "api/common/NgIf"
      },
      {
        "text": "ngIf",
        "href": "api/common/NgIf"
      },
      {
        "text": "NgFor",
        "href": "api/common/NgFor"
      },
      {
        "text": "link",
        "href": "guide/built-in-directives#listing-items-with-ngfor"
      },
      {
        "text": "NgFor",
        "href": "api/common/NgFor"
      },
      {
        "text": "ngFor",
        "href": "api/common/NgFor"
      },
      {
        "text": "ngFor",
        "href": "api/common/NgFor"
      },
      {
        "text": "<ng-template>",
        "href": "api/core/ng-template"
      },
      {
        "text": "<ng-template>",
        "href": "api/core/ng-template"
      },
      {
        "text": "Structural directive shorthand",
        "href": "guide/structural-directives#shorthand"
      },
      {
        "text": "Structural directives",
        "href": "guide/structural-directives"
      },
      {
        "text": "link",
        "href": "guide/built-in-directives#repeating-a-component-view"
      },
      {
        "text": "ngFor",
        "href": "api/common/NgFor"
      },
      {
        "text": "ngFor",
        "href": "api/common/NgFor"
      },
      {
        "text": "ngFor",
        "href": "api/common/NgFor"
      },
      {
        "text": "ngFor",
        "href": "api/common/NgFor"
      },
      {
        "text": "ngFor",
        "href": "api/common/NgFor"
      },
      {
        "text": "Structural directive shorthand",
        "href": "guide/structural-directives#shorthand"
      },
      {
        "text": "ngFor",
        "href": "api/common/NgFor"
      },
      {
        "text": "link",
        "href": "guide/built-in-directives#getting-the-index-of-ngfor"
      },
      {
        "text": "ngFor",
        "href": "api/common/NgFor"
      },
      {
        "text": "ngFor",
        "href": "api/common/NgFor"
      },
      {
        "text": "ngFor",
        "href": "api/common/NgFor"
      },
      {
        "text": "NgFor",
        "href": "api/common/NgFor"
      },
      {
        "text": "<ng-template>",
        "href": "api/core/ng-template"
      },
      {
        "text": "Structural Directives",
        "href": "guide/structural-directives#shorthand"
      },
      {
        "text": "link",
        "href": "guide/built-in-directives#repeating-elements-when-a-condition-is-true"
      },
      {
        "text": "ngIf",
        "href": "api/common/NgIf"
      },
      {
        "text": "ngFor",
        "href": "api/common/NgFor"
      },
      {
        "text": "one structural directive per element",
        "href": "guide/structural-directives#one-per-element"
      },
      {
        "text": "ngFor",
        "href": "api/common/NgFor"
      },
      {
        "text": "link",
        "href": "guide/built-in-directives#tracking-items-with-ngfor-trackby"
      },
      {
        "text": "ngFor",
        "href": "api/common/NgFor"
      },
      {
        "text": "NgFor",
        "href": "api/common/NgFor"
      },
      {
        "text": "ngFor",
        "href": "api/common/NgFor"
      },
      {
        "text": "link",
        "href": "guide/built-in-directives#hosting-a-directive-without-a-dom-element"
      },
      {
        "text": "<ng-container>",
        "href": "api/core/ng-container"
      },
      {
        "text": "<ng-container>",
        "href": "api/core/ng-container"
      },
      {
        "text": "<ng-container>",
        "href": "api/core/ng-container"
      },
      {
        "text": "ngIf",
        "href": "api/common/NgIf"
      },
      {
        "text": "ngModel",
        "href": "api/forms/NgModel"
      },
      {
        "text": "FormsModule",
        "href": "api/forms/FormsModule"
      },
      {
        "text": "FormsModule",
        "href": "api/forms/FormsModule"
      },
      {
        "text": "<ng-container>",
        "href": "api/core/ng-container"
      },
      {
        "text": "ngModel",
        "href": "api/forms/NgModel"
      },
      {
        "text": "ngFor",
        "href": "api/common/NgFor"
      },
      {
        "text": "ngIf",
        "href": "api/common/NgIf"
      },
      {
        "text": "NgSwitch",
        "href": "api/common/NgSwitch"
      },
      {
        "text": "link",
        "href": "guide/built-in-directives#switching-cases-with-ngswitch"
      },
      {
        "text": "NgSwitch",
        "href": "api/common/NgSwitch"
      },
      {
        "text": "NgSwitch",
        "href": "api/common/NgSwitch"
      },
      {
        "text": "NgSwitch",
        "href": "api/common/NgSwitch"
      },
      {
        "text": "NgSwitch",
        "href": "api/common/NgSwitch"
      },
      {
        "text": "NgSwitchCase",
        "href": "api/common/NgSwitchCase"
      },
      {
        "text": "NgSwitchDefault",
        "href": "api/common/NgSwitchDefault"
      },
      {
        "text": "NgSwitchCase",
        "href": "api/common/NgSwitchCase"
      },
      {
        "text": "ngSwitch",
        "href": "api/common/NgSwitch"
      },
      {
        "text": "ngSwitchCase",
        "href": "api/common/NgSwitchCase"
      },
      {
        "text": "ngSwitchDefault",
        "href": "api/common/NgSwitchDefault"
      },
      {
        "text": "ngSwitch",
        "href": "api/common/NgSwitch"
      },
      {
        "text": "ngSwitchCase",
        "href": "api/common/NgSwitchCase"
      },
      {
        "text": "ngSwitchCase",
        "href": "api/common/NgSwitchCase"
      },
      {
        "text": "ngSwitchCase",
        "href": "api/common/NgSwitchCase"
      },
      {
        "text": "ngSwitchCase",
        "href": "api/common/NgSwitchCase"
      },
      {
        "text": "ngSwitchDefault",
        "href": "api/common/NgSwitchDefault"
      },
      {
        "text": "ngSwitch",
        "href": "api/common/NgSwitch"
      },
      {
        "text": "input property",
        "href": "guide/inputs-outputs#input"
      },
      {
        "text": "Input",
        "href": "api/core/Input"
      },
      {
        "text": "ngSwitchCase",
        "href": "api/common/NgSwitchCase"
      },
      {
        "text": "link",
        "href": "guide/built-in-directives#whats-next"
      },
      {
        "text": "Attribute Directives",
        "href": "guide/attribute-directives"
      },
      {
        "text": "Structural Directives",
        "href": "guide/structural-directives"
      }
    ],
    "meta": {
      "description": "",
      "keywords": ""
    },
    "summary": "Built-in directiveslink Contents Built-in attribute directivesAdding and removing classes with NgClassImport CommonModule in the componentUsing NgClass with an expressionUsing NgClass with a methodSet...",
    "tags": [
      "react",
      "vue",
      "angular",
      "javascript",
      "typescript",
      "css",
      "html",
      "node",
      "vite",
      "componentlink"
    ],
    "id": "angular-builtindirectives-part-1",
    "quality": 90
  },
  {
    "title": "Angular",
    "url": "https://v17.angular.io/guide/forms-overview",
    "category": "angular",
    "content": "Introduction to forms in Angularlink Contents PrerequisitesChoosing an approachKey differencesScalabilitySetting up the form modelCommon form foundation classesSetup in reactive formsSetup in template-driven formsData flow in formsData flow in reactive formsData flow in template-driven formsMutability of the data modelForm validationTestingTesting reactive formsTesting template-driven formsNext steps Handling user input with forms is the cornerstone of many common applications. Applications use forms to enable users to log in, to update a profile, to enter sensitive information, and to perform many other data-entry tasks. Angular provides two different approaches to handling user input through forms: reactive and template-driven. Both capture user input events from the view, validate the user input, create a form model and data model to update, and provide a way to track changes. This guide provides information to help you decide which type of form works best for your situation. It introduces the common building blocks used by both approaches. It also summarizes the key differences between the two approaches, and demonstrates those differences in the context of setup, data flow, and testing. Prerequisiteslink This guide assumes that you have a basic understanding of the following. TypeScript and HTML5 programming Angular app-design fundamentals, as described in Angular Concepts The basics of Angular template syntax Choosing an approachlink Reactive forms and template-driven forms process and manage form data differently. Each approach offers different advantages. Forms Details Reactive forms Provide direct, explicit access to the underlying form's object model. Compared to template-driven forms, they are more robust: they're more scalable, reusable, and testable. If forms are a key part of your application, or you're already using reactive patterns for building your application, use reactive forms. Template-driven forms Rely on directives in the template to create and manipulate the underlying object model. They are useful for adding a simple form to an app, such as an email list signup form. They're straightforward to add to an app, but they don't scale as well as reactive forms. If you have very basic form requirements and logic that can be managed solely in the template, template-driven forms could be a good fit. Key differenceslink The following table summarizes the key differences between reactive and template-driven forms. Reactive Template-driven Setup of form model Explicit, created in component class Implicit, created by directives Data model Structured and immutable Unstructured and mutable Data flow Synchronous Asynchronous Form validation Functions Directives Scalabilitylink If forms are a central part of your application, scalability is very important. Being able to reuse form models across components is critical. Reactive forms are more scalable than template-driven forms. They provide direct access to the underlying form API, and use synchronous data flow between the view and the data model, which makes creating large-scale forms easier. Reactive forms require less setup for testing, and testing does not require deep understanding of change detection to properly test form updates and validation. Template-driven forms focus on simple scenarios and are not as reusable. They abstract away the underlying form API, and use asynchronous data flow between the view and the data model. The abstraction of template-driven forms also affects testing. Tests are deeply reliant on manual change detection execution to run properly, and require more setup. Setting up the form modellink Both reactive and template-driven forms track value changes between the form input elements that users interact with and the form data in your component model. The two approaches share underlying building blocks, but differ in how you create and manage the common form-control instances. Common form foundation classeslink Both reactive and template-driven forms are built on the following base classes. Base classes Details FormControl Tracks the value and validation status of an individual form control. FormGroup Tracks the same values and status for a collection of form controls. FormArray Tracks the same values and status for an array of form controls. ControlValueAccessor Creates a bridge between Angular FormControl instances and built-in DOM elements. Setup in reactive formslink With reactive forms, you define the form model directly in the component class. The [formControl] directive links the explicitly created FormControl instance to a specific form element in the view, using an internal value accessor. The following component implements an input field for a single control, using reactive forms. In this example, the form model is the FormControl instance. content_copy import { Component } from '@angular/core'; import { FormControl, ReactiveFormsModule } from '@angular/forms'; @Component({ standalone: true, selector: 'app-reactive-favorite-color', template:  Favorite Color: input type=\"text\" [formControl]=\"favoriteColorControl\" / , imports: [ReactiveFormsModule], }) export class FavoriteColorComponent { favoriteColorControl = new FormControl(''); } Figure 1 shows how, in reactive forms, the form model is the source of truth; it provides the value and status of the form element at any given point in time, through the [formControl] directive on the input element. Figure 1. Direct access to forms model in a reactive form. Setup in template-driven formslink In template-driven forms, the form model is implicit, rather than explicit. The directive NgModel creates and manages a FormControl instance for a given form element. The following component implements the same input field for a single control, using template-driven forms. content_copy import { Component } from '@angular/core'; import { FormsModule } from '@angular/forms'; @Component({ standalone: true, selector: 'app-template-favorite-color', template:  Favorite Color: input type=\"text\" [(ngModel)]=\"favoriteColor\" / , imports: [FormsModule], }) export class FavoriteColorComponent { favoriteColor = ''; } In a template-driven form the source of truth is the template. You do not have direct programmatic access to the FormControl instance, as shown in Figure 2. Figure 2. Indirect access to forms model in a template-driven form. Data flow in formslink When an application contains a form, Angular must keep the view in sync with the component model and the component model in sync with the view. As users change values and make selections through the view, the new values must be reflected in the data model. Similarly, when the program logic changes values in the data model, those values must be reflected in the view. Reactive and template-driven forms differ in how they handle data flowing from the user or from programmatic changes. The following diagrams illustrate both kinds of data flow for each type of form, using the favorite-color input field defined above. Data flow in reactive formslink In reactive forms each form element in the view is directly linked to the form model (a FormControl instance). Updates from the view to the model and from the model to the view are synchronous and do not depend on how the UI is rendered. The view-to-model diagram shows how data flows when an input field's value is changed from the view through the following steps. The user types a value into the input element, in this case the favorite color Blue. The form input element emits an \"input\" event with the latest value. The control value accessor listening for events on the form input element immediately relays the new value to the FormControl instance. The FormControl instance emits the new value through the valueChanges observable. Any subscribers to the valueChanges observable receive the new value. The model-to-view diagram shows how a programmatic change to the model is propagated to the view through the following steps. The user calls the favoriteColorControl.setValue() method, which updates the FormControl value. The FormControl instance emits the new value through the valueChanges observable. Any subscribers to the valueChanges observable receive the new value. The control value accessor on the form input element updates the element with the new value. Data flow in template-driven formslink In template-driven forms, each form element is linked to a directive that manages the form model internally. The view-to-model diagram shows how data flows when an input field's value is changed from the view through the following steps. The user types Blue into the input element. The input element emits an \"input\" event with the value Blue. The control value accessor attached to the input triggers the setValue() method on the FormControl instance. The FormControl instance emits the new value through the valueChanges observable. Any subscribers to the valueChanges observable receive the new value. The control value accessor also calls the NgModel.viewToModelUpdate() method which emits an ngModelChange event. Because the component template uses two-way data binding for the favoriteColor property, the favoriteColor property in the component is updated to the value emitted by the ngModelChange event (Blue). The model-to-view diagram shows how data flows from model to view when the favoriteColor changes from Blue to Red, through the following steps The favoriteColor value is updated in the component. Change detection begins. During change detection, the ngOnChanges lifecycle hook is called on the NgModel directive instance because the value of one of its inputs has changed. The ngOnChanges() method queues an async task to set the value for the internal FormControl instance. Change detection completes. On the next tick, the task to set the FormControl instance value is executed. The FormControl instance emits the latest value through the valueChanges observable. Any subscribers to the valueChanges observable receive the new value. The control value accessor updates the form input element in the view with the latest favoriteColor value. Mutability of the data modellink The change-tracking method plays a role in the efficiency of your application. Forms Details Reactive forms Keep the data model pure by providing it as an immutable data structure. Each time a change is triggered on the data model, the FormControl instance returns a new data model rather than updating the existing data model. This gives you the ability to track unique changes to the data model through the control's observable. Change detection is more efficient because it only needs to update on unique changes. Because data updates follow reactive patterns, you can integrate with observable operators to transform data. Template-driven forms Rely on mutability with two-way data binding to update the data model in the component as changes are made in the template. Because there are no unique changes to track on the data model when using two-way data binding, change detection is less efficient at determining when updates are required. The difference is demonstrated in the previous examples that use the favorite-color input element. With reactive forms, the FormControl instance always returns a new value when the control's value is updated With template-driven forms, the favorite color property is always modified to its new value Form validationlink Validation is an integral part of managing any set of forms. Whether you're checking for required fields or querying an external API for an existing username, Angular provides a set of built-in validators as well as the ability to create custom validators. Forms Details Reactive forms Define custom validators as functions that receive a control to validate Template-driven forms Tied to template directives, and must provide custom validator directives that wrap validation functions For more information, see Form Validation. Testinglink Testing plays a large part in complex applications. A simpler testing strategy is useful when validating that your forms function correctly. Reactive forms and template-driven forms have different levels of reliance on rendering the UI to perform assertions based on form control and form field changes. The following examples demonstrate the process of testing forms with reactive and template-driven forms. Testing reactive formslink Reactive forms provide a relatively straightforward testing strategy because they provide synchronous access to the form and data models, and they can be tested without rendering the UI. In these tests, status and data are queried and manipulated through the control without interacting with the change detection cycle. The following tests use the favorite-color components from previous examples to verify the view-to-model and model-to-view data flows for a reactive form. Verifying view-to-model data flow The first example performs the following steps to verify the view-to-model data flow. Query the view for the form input element, and create a custom \"input\" event for the test. Set the new value for the input to Red, and dispatch the \"input\" event on the form input element. Assert that the component's favoriteColorControl value matches the value from the input. content_copy it('should update the value of the input field', () = { const input = fixture.nativeElement.querySelector('input'); const event = createNewEvent('input'); input.value = 'Red'; input.dispatchEvent(event); expect(fixture.componentInstance.favoriteColorControl.value).toEqual('Red'); }); The next example performs the following steps to verify the model-to-view data flow. Use the favoriteColorControl, a FormControl instance, to set the new value. Query the view for the form input element. Assert that the new value set on the control matches the value in the input. content_copy it('should update the value in the control', () = { component.favoriteColorControl.setValue('Blue'); const input = fixture.nativeElement.querySelector('input'); expect(input.value).toBe('Blue'); }); Testing template-driven formslink Writing tests with template-driven forms requires a detailed knowledge of the change detection process and an understanding of how directives run on each cycle to ensure that elements are queried, tested, or changed at the correct time. The following tests use the favorite color components mentioned earlier to verify the data flows from view to model and model to view for a template-driven form. The following test verifies the data flow from view to model. content_copy it('should update the favorite color in the component', fakeAsync(() = { const input = fixture.nativeElement.querySelector('input'); const event = createNewEvent('input'); input.value = 'Red'; input.dispatchEvent(event); fixture.detectChanges(); expect(component.favoriteColor).toEqual('Red'); })); Here are the steps performed in the view to model test. Query the view for the form input element, and create a custom \"input\" event for the test. Set the new value for the input to Red, and dispatch the \"input\" event on the form input element. Run change detection through the test fixture. Assert that the component favoriteColor property value matches the value from the input. The following test verifies the data flow from model to view. content_copy it('should update the favorite color on the input field', fakeAsync(() = { component.favoriteColor = 'Blue'; fixture.detectChanges(); tick(); const input = fixture.nativeElement.querySelector('input'); expect(input.value).toBe('Blue'); })); Here are the steps performed in the model to view test. Use the component instance to set the value of the favoriteColor property. Run change detection through the test fixture. Use the tick() method to simulate the passage of time within the fakeAsync() task. Query the view for the form input element. Assert that the input value matches the value of the favoriteColor property in the component instance. Next stepslink To learn more about reactive forms, see the following guides: Reactive forms Form validation Dynamic forms To learn more about template-driven forms, see the following guides: Building a template-driven form tutorial Form validation NgForm directive API reference Last reviewed on Thu Sep 07 2023",
    "headings": [
      {
        "level": 1,
        "text": "Introduction to forms in Angularlink",
        "id": "introduction-to-forms-in-angular"
      },
      {
        "level": 2,
        "text": "Prerequisiteslink",
        "id": "prerequisites"
      },
      {
        "level": 2,
        "text": "Choosing an approachlink",
        "id": "choosing-an-approach"
      },
      {
        "level": 2,
        "text": "Setting up the form modellink",
        "id": "setting-up-the-form-model"
      },
      {
        "level": 2,
        "text": "Data flow in formslink",
        "id": "data-flow-in-forms"
      },
      {
        "level": 2,
        "text": "Form validationlink",
        "id": "form-validation"
      },
      {
        "level": 2,
        "text": "Testinglink",
        "id": "testing"
      },
      {
        "level": 2,
        "text": "Next stepslink",
        "id": "next-steps"
      },
      {
        "level": 3,
        "text": "Key differenceslink",
        "id": "key-differences"
      },
      {
        "level": 3,
        "text": "Scalabilitylink",
        "id": "scalability"
      },
      {
        "level": 3,
        "text": "Common form foundation classeslink",
        "id": "common-form-foundation-classes"
      },
      {
        "level": 3,
        "text": "Setup in reactive formslink",
        "id": "setup-in-reactive-forms"
      },
      {
        "level": 3,
        "text": "Setup in template-driven formslink",
        "id": "setup-in-template-driven-forms"
      },
      {
        "level": 3,
        "text": "Data flow in reactive formslink",
        "id": "data-flow-in-reactive-forms"
      },
      {
        "level": 3,
        "text": "Data flow in template-driven formslink",
        "id": "data-flow-in-template-driven-forms"
      },
      {
        "level": 3,
        "text": "Mutability of the data modellink",
        "id": "mutability-of-the-data-model"
      },
      {
        "level": 3,
        "text": "Testing reactive formslink",
        "id": "testing-reactive-forms"
      },
      {
        "level": 3,
        "text": "Testing template-driven formslink",
        "id": "testing-template-driven-forms"
      }
    ],
    "codeBlocks": [
      {
        "language": "text",
        "code": "FormControl"
      },
      {
        "language": "text",
        "code": "ControlValueAccessor"
      },
      {
        "language": "text",
        "code": "FormControl"
      },
      {
        "language": "text",
        "code": "[formControl]"
      },
      {
        "language": "text",
        "code": "FormControl"
      },
      {
        "language": "text",
        "code": "FormControl"
      },
      {
        "language": "text",
        "code": "content_copy\n      \n      import { Component } from '@angular/core';\nimport { FormControl, ReactiveFormsModule } from '@angular/forms';\n\n@Component({\n  standalone: true,\n  selector: 'app-reactive-favorite-color',\n  template: `\n    Favorite Color: <input type=\"text\" [formControl]=\"favoriteColorControl\" />\n  `,\n  imports: [ReactiveFormsModule],\n})\nexport class FavoriteColorComponent {\n  favoriteColorControl = new FormControl('');\n}"
      },
      {
        "language": "text",
        "code": "import { Component } from '@angular/core';\nimport { FormControl, ReactiveFormsModule } from '@angular/forms';\n\n@Component({\n  standalone: true,\n  selector: 'app-reactive-favorite-color',\n  template: `\n    Favorite Color: <input type=\"text\" [formControl]=\"favoriteColorControl\" />\n  `,\n  imports: [ReactiveFormsModule],\n})\nexport class FavoriteColorComponent {\n  favoriteColorControl = new FormControl('');\n}"
      },
      {
        "language": "text",
        "code": "[formControl]"
      },
      {
        "language": "text",
        "code": "FormControl"
      },
      {
        "language": "text",
        "code": "content_copy\n      \n      import { Component } from '@angular/core';\nimport { FormsModule } from '@angular/forms';\n\n@Component({\n  standalone: true,\n  selector: 'app-template-favorite-color',\n  template: `\n    Favorite Color: <input type=\"text\" [(ngModel)]=\"favoriteColor\" />\n  `,\n  imports: [FormsModule],\n})\nexport class FavoriteColorComponent {\n  favoriteColor = '';\n}"
      },
      {
        "language": "text",
        "code": "import { Component } from '@angular/core';\nimport { FormsModule } from '@angular/forms';\n\n@Component({\n  standalone: true,\n  selector: 'app-template-favorite-color',\n  template: `\n    Favorite Color: <input type=\"text\" [(ngModel)]=\"favoriteColor\" />\n  `,\n  imports: [FormsModule],\n})\nexport class FavoriteColorComponent {\n  favoriteColor = '';\n}"
      },
      {
        "language": "text",
        "code": "FormControl"
      },
      {
        "language": "text",
        "code": "FormControl"
      },
      {
        "language": "text",
        "code": "FormControl"
      },
      {
        "language": "text",
        "code": "FormControl"
      },
      {
        "language": "text",
        "code": "valueChanges"
      },
      {
        "language": "text",
        "code": "valueChanges"
      },
      {
        "language": "text",
        "code": "favoriteColorControl.setValue()"
      },
      {
        "language": "text",
        "code": "FormControl"
      },
      {
        "language": "text",
        "code": "FormControl"
      },
      {
        "language": "text",
        "code": "valueChanges"
      },
      {
        "language": "text",
        "code": "valueChanges"
      },
      {
        "language": "text",
        "code": "FormControl"
      },
      {
        "language": "text",
        "code": "FormControl"
      },
      {
        "language": "text",
        "code": "valueChanges"
      },
      {
        "language": "text",
        "code": "valueChanges"
      },
      {
        "language": "text",
        "code": "NgModel.viewToModelUpdate()"
      },
      {
        "language": "text",
        "code": "ngModelChange"
      },
      {
        "language": "text",
        "code": "favoriteColor"
      },
      {
        "language": "text",
        "code": "favoriteColor"
      },
      {
        "language": "text",
        "code": "ngModelChange"
      },
      {
        "language": "text",
        "code": "favoriteColor"
      },
      {
        "language": "text",
        "code": "favoriteColor"
      },
      {
        "language": "text",
        "code": "ngOnChanges"
      },
      {
        "language": "text",
        "code": "ngOnChanges()"
      },
      {
        "language": "text",
        "code": "FormControl"
      },
      {
        "language": "text",
        "code": "FormControl"
      },
      {
        "language": "text",
        "code": "FormControl"
      },
      {
        "language": "text",
        "code": "valueChanges"
      },
      {
        "language": "text",
        "code": "valueChanges"
      },
      {
        "language": "text",
        "code": "favoriteColor"
      },
      {
        "language": "text",
        "code": "FormControl"
      },
      {
        "language": "text",
        "code": "FormControl"
      },
      {
        "language": "text",
        "code": "favoriteColorControl"
      },
      {
        "language": "text",
        "code": "content_copy\n      \n      it('should update the value of the input field', () => {\n  const input = fixture.nativeElement.querySelector('input');\n  const event = createNewEvent('input');\n\n  input.value = 'Red';\n  input.dispatchEvent(event);\n\n  expect(fixture.componentInstance.favoriteColorControl.value).toEqual('Red');\n});"
      },
      {
        "language": "text",
        "code": "it('should update the value of the input field', () => {\n  const input = fixture.nativeElement.querySelector('input');\n  const event = createNewEvent('input');\n\n  input.value = 'Red';\n  input.dispatchEvent(event);\n\n  expect(fixture.componentInstance.favoriteColorControl.value).toEqual('Red');\n});"
      },
      {
        "language": "text",
        "code": "favoriteColorControl"
      },
      {
        "language": "text",
        "code": "FormControl"
      },
      {
        "language": "text",
        "code": "content_copy\n      \n      it('should update the value in the control', () => {\n  component.favoriteColorControl.setValue('Blue');\n\n  const input = fixture.nativeElement.querySelector('input');\n\n  expect(input.value).toBe('Blue');\n});"
      },
      {
        "language": "text",
        "code": "it('should update the value in the control', () => {\n  component.favoriteColorControl.setValue('Blue');\n\n  const input = fixture.nativeElement.querySelector('input');\n\n  expect(input.value).toBe('Blue');\n});"
      },
      {
        "language": "text",
        "code": "content_copy\n      \n      it('should update the favorite color in the component', fakeAsync(() => {\n  const input = fixture.nativeElement.querySelector('input');\n  const event = createNewEvent('input');\n\n  input.value = 'Red';\n  input.dispatchEvent(event);\n\n  fixture.detectChanges();\n\n  expect(component.favoriteColor).toEqual('Red');\n}));"
      },
      {
        "language": "text",
        "code": "it('should update the favorite color in the component', fakeAsync(() => {\n  const input = fixture.nativeElement.querySelector('input');\n  const event = createNewEvent('input');\n\n  input.value = 'Red';\n  input.dispatchEvent(event);\n\n  fixture.detectChanges();\n\n  expect(component.favoriteColor).toEqual('Red');\n}));"
      },
      {
        "language": "text",
        "code": "favoriteColor"
      },
      {
        "language": "text",
        "code": "content_copy\n      \n      it('should update the favorite color on the input field', fakeAsync(() => {\n  component.favoriteColor = 'Blue';\n\n  fixture.detectChanges();\n\n  tick();\n\n  const input = fixture.nativeElement.querySelector('input');\n\n  expect(input.value).toBe('Blue');\n}));"
      },
      {
        "language": "text",
        "code": "it('should update the favorite color on the input field', fakeAsync(() => {\n  component.favoriteColor = 'Blue';\n\n  fixture.detectChanges();\n\n  tick();\n\n  const input = fixture.nativeElement.querySelector('input');\n\n  expect(input.value).toBe('Blue');\n}));"
      },
      {
        "language": "text",
        "code": "favoriteColor"
      },
      {
        "language": "text",
        "code": "fakeAsync()"
      },
      {
        "language": "text",
        "code": "favoriteColor"
      }
    ],
    "links": [
      {
        "text": "link",
        "href": "guide/forms-overview#introduction-to-forms-in-angular"
      },
      {
        "text": "Prerequisites",
        "href": "guide/forms-overview#prerequisites"
      },
      {
        "text": "Choosing an approach",
        "href": "guide/forms-overview#choosing-an-approach"
      },
      {
        "text": "Key differences",
        "href": "guide/forms-overview#key-differences"
      },
      {
        "text": "Scalability",
        "href": "guide/forms-overview#scalability"
      },
      {
        "text": "Setting up the form model",
        "href": "guide/forms-overview#setting-up-the-form-model"
      },
      {
        "text": "Common form foundation classes",
        "href": "guide/forms-overview#common-form-foundation-classes"
      },
      {
        "text": "Setup in reactive forms",
        "href": "guide/forms-overview#setup-in-reactive-forms"
      },
      {
        "text": "Setup in template-driven forms",
        "href": "guide/forms-overview#setup-in-template-driven-forms"
      },
      {
        "text": "Data flow in forms",
        "href": "guide/forms-overview#data-flow-in-forms"
      },
      {
        "text": "Data flow in reactive forms",
        "href": "guide/forms-overview#data-flow-in-reactive-forms"
      },
      {
        "text": "Data flow in template-driven forms",
        "href": "guide/forms-overview#data-flow-in-template-driven-forms"
      },
      {
        "text": "Mutability of the data model",
        "href": "guide/forms-overview#mutability-of-the-data-model"
      },
      {
        "text": "Form validation",
        "href": "guide/forms-overview#form-validation"
      },
      {
        "text": "Testing",
        "href": "guide/forms-overview#testing"
      },
      {
        "text": "Testing reactive forms",
        "href": "guide/forms-overview#testing-reactive-forms"
      },
      {
        "text": "Testing template-driven forms",
        "href": "guide/forms-overview#testing-template-driven-forms"
      },
      {
        "text": "Next steps",
        "href": "guide/forms-overview#next-steps"
      },
      {
        "text": "link",
        "href": "guide/forms-overview#prerequisites"
      },
      {
        "text": "TypeScript",
        "href": "https://www.typescriptlang.org/"
      },
      {
        "text": "Angular Concepts",
        "href": "guide/architecture"
      },
      {
        "text": "Angular template syntax",
        "href": "guide/architecture-components#template-syntax"
      },
      {
        "text": "link",
        "href": "guide/forms-overview#choosing-an-approach"
      },
      {
        "text": "link",
        "href": "guide/forms-overview#key-differences"
      },
      {
        "text": "Setup of form model",
        "href": "guide/forms-overview#setup"
      },
      {
        "text": "Data model",
        "href": "guide/forms-overview#mutability-of-the-data-model"
      },
      {
        "text": "Data flow",
        "href": "guide/forms-overview#data-flow-in-forms"
      },
      {
        "text": "Form validation",
        "href": "guide/forms-overview#validation"
      },
      {
        "text": "link",
        "href": "guide/forms-overview#scalability"
      },
      {
        "text": "synchronous data flow",
        "href": "guide/forms-overview#data-flow-in-reactive-forms"
      },
      {
        "text": "asynchronous data flow",
        "href": "guide/forms-overview#data-flow-in-template-driven-forms"
      },
      {
        "text": "link",
        "href": "guide/forms-overview#setting-up-the-form-model"
      },
      {
        "text": "link",
        "href": "guide/forms-overview#common-form-foundation-classes"
      },
      {
        "text": "FormControl",
        "href": "api/forms/FormControl"
      },
      {
        "text": "FormGroup",
        "href": "api/forms/FormGroup"
      },
      {
        "text": "FormArray",
        "href": "api/forms/FormArray"
      },
      {
        "text": "ControlValueAccessor",
        "href": "api/forms/ControlValueAccessor"
      },
      {
        "text": "FormControl",
        "href": "api/forms/FormControl"
      },
      {
        "text": "link",
        "href": "guide/forms-overview#setup-in-reactive-forms"
      },
      {
        "text": "FormControl",
        "href": "api/forms/FormControl"
      },
      {
        "text": "FormControl",
        "href": "api/forms/FormControl"
      },
      {
        "text": "Component",
        "href": "api/core/Component"
      },
      {
        "text": "FormControl",
        "href": "api/forms/FormControl"
      },
      {
        "text": "ReactiveFormsModule",
        "href": "api/forms/ReactiveFormsModule"
      },
      {
        "text": "Component",
        "href": "api/core/Component"
      },
      {
        "text": "ReactiveFormsModule",
        "href": "api/forms/ReactiveFormsModule"
      },
      {
        "text": "FormControl",
        "href": "api/forms/FormControl"
      },
      {
        "text": "link",
        "href": "guide/forms-overview#setup-in-template-driven-forms"
      },
      {
        "text": "NgModel",
        "href": "api/forms/NgModel"
      },
      {
        "text": "FormControl",
        "href": "api/forms/FormControl"
      },
      {
        "text": "Component",
        "href": "api/core/Component"
      },
      {
        "text": "FormsModule",
        "href": "api/forms/FormsModule"
      },
      {
        "text": "Component",
        "href": "api/core/Component"
      },
      {
        "text": "ngModel",
        "href": "api/forms/NgModel"
      },
      {
        "text": "FormsModule",
        "href": "api/forms/FormsModule"
      },
      {
        "text": "FormControl",
        "href": "api/forms/FormControl"
      },
      {
        "text": "link",
        "href": "guide/forms-overview#data-flow-in-forms"
      },
      {
        "text": "link",
        "href": "guide/forms-overview#data-flow-in-reactive-forms"
      },
      {
        "text": "FormControl",
        "href": "api/forms/FormControl"
      },
      {
        "text": "FormControl",
        "href": "api/forms/FormControl"
      },
      {
        "text": "FormControl",
        "href": "api/forms/FormControl"
      },
      {
        "text": "FormControl",
        "href": "api/forms/FormControl"
      },
      {
        "text": "FormControl",
        "href": "api/forms/FormControl"
      },
      {
        "text": "link",
        "href": "guide/forms-overview#data-flow-in-template-driven-forms"
      },
      {
        "text": "FormControl",
        "href": "api/forms/FormControl"
      },
      {
        "text": "FormControl",
        "href": "api/forms/FormControl"
      },
      {
        "text": "NgModel.viewToModelUpdate()",
        "href": "api/forms/NgModel#viewToModelUpdate"
      },
      {
        "text": "NgModel",
        "href": "api/forms/NgModel"
      },
      {
        "text": "FormControl",
        "href": "api/forms/FormControl"
      },
      {
        "text": "FormControl",
        "href": "api/forms/FormControl"
      },
      {
        "text": "FormControl",
        "href": "api/forms/FormControl"
      },
      {
        "text": "link",
        "href": "guide/forms-overview#mutability-of-the-data-model"
      },
      {
        "text": "FormControl",
        "href": "api/forms/FormControl"
      },
      {
        "text": "FormControl",
        "href": "api/forms/FormControl"
      },
      {
        "text": "link",
        "href": "guide/forms-overview#form-validation"
      },
      {
        "text": "Form Validation",
        "href": "guide/form-validation"
      },
      {
        "text": "link",
        "href": "guide/forms-overview#testing"
      },
      {
        "text": "link",
        "href": "guide/forms-overview#testing-reactive-forms"
      },
      {
        "text": "FormControl",
        "href": "api/forms/FormControl"
      },
      {
        "text": "link",
        "href": "guide/forms-overview#testing-template-driven-forms"
      },
      {
        "text": "fakeAsync",
        "href": "api/core/testing/fakeAsync"
      },
      {
        "text": "fakeAsync",
        "href": "api/core/testing/fakeAsync"
      },
      {
        "text": "tick",
        "href": "api/core/testing/tick"
      },
      {
        "text": "tick",
        "href": "api/core/testing/tick"
      },
      {
        "text": "fakeAsync",
        "href": "api/core/testing/fakeAsync"
      },
      {
        "text": "link",
        "href": "guide/forms-overview#next-steps"
      },
      {
        "text": "Reactive forms",
        "href": "guide/reactive-forms"
      },
      {
        "text": "Form validation",
        "href": "guide/form-validation#reactive-form-validation"
      },
      {
        "text": "Dynamic forms",
        "href": "guide/dynamic-form"
      },
      {
        "text": "Building a template-driven form",
        "href": "guide/forms"
      },
      {
        "text": "Form validation",
        "href": "guide/form-validation#template-driven-validation"
      },
      {
        "text": "NgForm",
        "href": "api/forms/NgForm"
      }
    ],
    "meta": {
      "description": "",
      "keywords": ""
    },
    "summary": "Introduction to forms in Angularlink Contents PrerequisitesChoosing an approachKey differencesScalabilitySetting up the form modelCommon form foundation classesSetup in reactive formsSetup in template...",
    "tags": [
      "react",
      "vue",
      "angular",
      "javascript",
      "typescript",
      "html",
      "node",
      "vite",
      "formslink",
      "data"
    ],
    "id": "angular-formsoverview-part-1",
    "quality": 90
  },
  {
    "title": "Angular",
    "url": "https://v17.angular.io/guide/reactive-forms",
    "category": "angular",
    "content": "Reactive formslink Contents PrerequisitesOverview of reactive formsAdding a basic form controlDisplaying a form control valueReplacing a form control valueGrouping form controlsCreating nested form groupsUpdating parts of the data modelUsing the FormBuilder service to generate controlsValidating form inputCreating dynamic formsReactive forms API summary Reactive forms provide a model-driven approach to handling form inputs whose values change over time. This guide shows you how to create and update a basic form control, progress to using multiple controls in a group, validate form values, and create dynamic forms where you can add or remove controls at run time. Try this Reactive Forms live-exampleReactive Forms live-example / download example. Prerequisiteslink Before going further into reactive forms, you should have a basic understanding of the following: TypeScript programming Angular application-design fundamentals, as described in Angular Concepts The form-design concepts that are presented in Introduction to Forms Overview of reactive formslink Reactive forms use an explicit and immutable approach to managing the state of a form at a given point in time. Each change to the form state returns a new state, which maintains the integrity of the model between changes. Reactive forms are built around observable streams, where form inputs and values are provided as streams of input values, which can be accessed synchronously. Reactive forms also provide a straightforward path to testing because you are assured that your data is consistent and predictable when requested. Any consumers of the streams have access to manipulate that data safely. Reactive forms differ from template-driven forms in distinct ways. Reactive forms provide synchronous access to the data model, immutability with observable operators, and change tracking through observable streams. Template-driven forms let direct access modify data in your template, but are less explicit than reactive forms because they rely on directives embedded in the template, along with mutable data to track changes asynchronously. See the Forms Overview for detailed comparisons between the two paradigms. Adding a basic form controllink There are three steps to using form controls. Generate a new component to import the reactive forms module and instantiate a new FormControl. Register the FormControl in the template. You can then display the form by adding the component to the template. The following examples show how to add a single form control. In the example, the user enters their name into an input field, captures that input value, and displays the current value of the form control element. Action Details Generate a new FormControl Use the CLI command ng generate to generate a component in your project to register and host the FormControl and ReactiveFormsModule. content_copy import { Component } from '@angular/core'; import { FormControl, ReactiveFormsModule } from '@angular/forms'; @Component({ standalone: true, selector: 'app-name-editor', templateUrl: './name-editor.component.html', styleUrls: ['./name-editor.component.css'], imports: [ReactiveFormsModule], }) export class NameEditorComponent { name = new FormControl(''); } Use the constructor of FormControl to set its initial value, which in this case is an empty string. By creating these controls in your component class, you get immediate access to listen for, update, and validate the state of the form input. Register the control in the template After you create the control in the component class, you must associate it with a form control element in the template. Update the template with the form control using the formControl binding provided by FormControlDirective, which is also included in the ReactiveFormsModule. content_copy label for=\"name\"Name: /label input id=\"name\" type=\"text\" [formControl]=\"name\" For a summary of the classes and directives provided by ReactiveFormsModule, see the following Reactive forms API section For complete syntax details of these classes and directives, see the API reference documentation for the Forms package Using the template binding syntax, the form control is now registered to the name input element in the template. The form control and DOM element communicate with each other: the view reflects changes in the model, and the model reflects changes in the view. Display the component The FormControl assigned to the name property is displayed when the property's host component is added to a template. content_copy app-name-editor/app-name-editor Displaying a form control valuelink You can display the value in the following ways. Through the valueChanges observable where you can listen for changes in the form's value in the template using AsyncPipe or in the component class using the subscribe() method With the value property, which gives you a snapshot of the current value The following example shows you how to display the current value using interpolation in the template. content_copy pValue: {{ name.value }}/p The displayed value changes as you update the form control element. Reactive forms provide access to information about a given control through properties and methods provided with each instance. These properties and methods of the underlying AbstractControl class are used to control form state and determine when to display messages when handling input validation. Read about other FormControl properties and methods in the API Reference. Replacing a form control valuelink Reactive forms have methods to change a control's value programmatically, which gives you the flexibility to update the value without user interaction. A form control instance provides a setValue() method that updates the value of the form control and validates the structure of the value provided against the control's structure. For example, when retrieving form data from a backend API or service, use the setValue() method to update the control to its new value, replacing the old value entirely. The following example adds a method to the component class to update the value of the control to Nancy using the setValue() method. content_copy updateName() { this.name.setValue('Nancy'); } Update the template with a button to simulate a name update. When you click the Update Name button, the value entered in the form control element is reflected as its current value. content_copy button type=\"button\" (click)=\"updateName()\"Update Name/button The form model is the source of truth for the control, so when you click the button, the value of the input is changed within the component class, overriding its current value. NOTE: In this example, you're using a single control. When using the setValue() method with a form group or form array instance, the value needs to match the structure of the group or array. Grouping form controlslink Forms typically contain several related controls. Reactive forms provide two ways of grouping multiple related controls into a single input form. Form groups Details Form group Defines a form with a fixed set of controls that you can manage together. Form group basics are discussed in this section. You can also nest form groups to create more complex forms. Form array Defines a dynamic form, where you can add and remove controls at run time. You can also nest form arrays to create more complex forms. For more about this option, see Creating dynamic forms. Just as a form control instance gives you control over a single input field, a form group instance tracks the form state of a group of form control instances (for example, a form). Each control in a form group instance is tracked by name when creating the form group. The following example shows how to manage multiple form control instances in a single group. Generate a ProfileEditor component and import the FormGroup and FormControl classes from the @angular/forms package. content_copy ng generate component ProfileEditor content_copy import { FormGroup, FormControl } from '@angular/forms'; To add a form group to this component, take the following steps. Create a FormGroup instance. Associate the FormGroup model and view. Save the form data. Action Details Create a FormGroup instance Create a property in the component class named profileForm and set the property to a new form group instance. To initialize the form group, provide the constructor with an object of named keys mapped to their control. For the profile form, add two form control instances with the names firstName and lastName. content_copy import { Component } from '@angular/core'; import { FormGroup, FormControl } from '@angular/forms'; @Component({ standalone: true, selector: 'app-profile-editor', templateUrl: './profile-editor.component.html', styleUrls: ['./profile-editor.component.css'], }) export class ProfileEditorComponent { profileForm = new FormGroup({ firstName: new FormControl(''), lastName: new FormControl(''), }); } The individual form controls are now collected within a group. A FormGroup instance provides its model value as an object reduced from the values of each control in the group. A form group instance has the same properties (such as value and untouched) and methods (such as setValue()) as a form control instance. Associate the FormGroup model and view A form group tracks the status and changes for each of its controls, so if one of the controls changes, the parent control also emits a new status or value change. The model for the group is maintained from its members. After you define the model, you must update the template to reflect the model in the view. content_copy form [formGroup]=\"profileForm\" label for=\"first-name\"First Name: /label input id=\"first-name\" type=\"text\" formControlName=\"firstName\" label for=\"last-name\"Last Name: /label input id=\"last-name\" type=\"text\" formControlName=\"lastName\" /form NOTE: Just as a form group contains a group of controls, the profileForm FormGroup is bound to the form element with the FormGroup directive, creating a communication layer between the model and the form containing the inputs. The formControlName input provided by the FormControlName directive binds each individual input to the form control defined in FormGroup. The form controls communicate with their respective elements. They also communicate changes to the form group instance, which provides the source of truth for the model value. Save form data The ProfileEditor component accepts input from the user, but in a real scenario you want to capture the form value and make it available for further processing outside the component. The FormGroup directive listens for the submit event emitted by the form element and emits an ngSubmit event that you can bind to a callback function. Add an ngSubmit event listener to the form tag with the onSubmit() callback method. content_copy form [formGroup]=\"profileForm\" (ngSubmit)=\"onSubmit()\" The onSubmit() method in the ProfileEditor component captures the current value of profileForm. Use EventEmitter to keep the form encapsulated and to provide the form value outside the component. The following example uses console.warn to log a message to the browser console. content_copy onSubmit() { // TODO: Use EventEmitter with form value console.warn(this.profileForm.value); } The submit event is emitted by the form tag using the built-in DOM event. You trigger the event by clicking a button with submit type. This lets the user press the Enter key to submit the completed form. Use a button element to add a button to the bottom of the form to trigger the form submission. content_copy pComplete the form to enable button./p button type=\"submit\" [disabled]=\"!profileForm.valid\"Submit/button NOTE: The button in the preceding snippet also has a disabled binding attached to it to disable the button when profileForm is invalid. You aren't performing any validation yet, so the button is always enabled. Basic form validation is covered in the Validating form input section. Display the component To display the ProfileEditor component that contains the form, add it to a component template. content_copy app-profile-editor/app-profile-editor ProfileEditor lets you manage the form control instances for the firstName and lastName controls within the form group instance. Creating nested form groupslink Form groups can accept both individual form control instances and other form group instances as children. This makes composing complex form models easier to maintain and logically group together. When building complex forms, managing the different areas of information is easier in smaller sections. Using a nested form group instance lets you break large forms groups into smaller, more manageable ones. To make more complex forms, use the following steps. Create a nested group. Group the nested form in the template. Some types of information naturally fall into the same group. A name and address are typical examples of such nested groups, and are used in the following examples. Action Details Create a nested group To create a nested group in profileForm, add a nested address element to the form group instance. content_copy import { Component } from '@angular/core'; import { FormGroup, FormControl } from '@angular/forms'; @Component({ standalone: true, selector: 'app-profile-editor', templateUrl: './profile-editor.component.html', styleUrls: ['./profile-editor.component.css'], }) export class ProfileEditorComponent { profileForm = new FormGroup({ firstName: new FormControl(''), lastName: new FormControl(''), address: new FormGroup({ street: new FormControl(''), city: new FormControl(''), state: new FormControl(''), zip: new FormControl(''), }), }); } In this example, address group combines the current firstName and lastName controls with the new street, city, state, and zip controls. Even though the address element in the form group is a child of the overall profileForm element in the form group, the same rules apply with value and status changes. Changes in status and value from the nested form group propagate to the parent form group, maintaining consistency with the overall model. Group the nested form in the template After you update the model in the component class, update the template to connect the form group instance and its input elements. Add the address form group containing the street, city, state, and zip fields to the ProfileEditor template. content_copy div formGroupName=\"address\" h2Address/h2 label for=\"street\"Street: /label input id=\"street\" type=\"text\" formControlName=\"street\" label for=\"city\"City: /label input id=\"city\" type=\"text\" formControlName=\"city\" label for=\"state\"State: /label input id=\"state\" type=\"text\" formControlName=\"state\" label for=\"zip\"Zip Code: /label input id=\"zip\" type=\"text\" formControlName=\"zip\" /div The ProfileEditor form is displayed as one group, but the model is broken down further to represent the logical grouping areas. TIP: Display the value for the form group instance in the component template using the value property and JsonPipe. Updating parts of the data modellink When updating the value for a form group instance that contains multiple controls, you might only want to update parts of the model. This section covers how to update specific parts of a form control data model. There are two ways to update the model value: Methods Details setValue() Set a new value for an individual control. The setValue() method strictly adheres to the structure of the form group and replaces the entire value for the control. patchValue() Replace any properties defined in the object that have changed in the form model. The strict checks of the setValue() method help catch nesting errors in complex forms, while patchValue() fails silently on those errors. In ProfileEditorComponent, use the updateProfile method with the following example to update the first name and street address for the user. content_copy updateProfile() { this.profileForm.patchValue({ firstName: 'Nancy', address: { street: '123 Drew Street', }, }); } Simulate an update by adding a button to the template to update the user profile on demand. content_copy button type=\"button\" (click)=\"updateProfile()\"Update Profile/button When a user clicks the button, the profileForm model is updated with new values for firstName and street. Notice that street is provided in an object inside the address property. This is necessary because the patchValue() method applies the update against the model structure. PatchValue() only updates properties that the form model defines. Using the FormBuilder service to generate controlslink Creating form control instances manually can become repetitive when dealing with multiple forms. The FormBuilder service provides convenient methods for generating controls. Use the following steps to take advantage of this service. Import the FormBuilder class. Inject the FormBuilder service. Generate the form contents. The following examples show how to refactor the ProfileEditor component to use the form builder service to create form control and form group instances. Action Details Import the FormBuilder class Import the FormBuilder class from the @angular/forms package. content_copy import { FormBuilder } from '@angular/forms'; Inject the FormBuilder service The FormBuilder service is an injectable provider that is provided with the reactive forms module. Inject this dependency by adding it to the component constructor. content_copy constructor(private formBuilder: FormBuilder) {} Generate form controls The FormBuilder service has three methods: control(), group(), and array(). These are factory methods for generating instances in your component classes including form controls, form groups, and form arrays. Use the group method to create the profileForm controls. content_copy import { Component } from '@angular/core'; import { FormBuilder } from '@angular/forms'; @Component({ standalone: true, selector: 'app-profile-editor', templateUrl: './profile-editor.component.html', styleUrls: ['./profile-editor.component.css'], }) export class ProfileEditorComponent { profileForm = this.formBuilder.group({ firstName: [''], lastName: [''], address: this.formBuilder.group({ street: [''], city: [''], state: [''], zip: [''], }), }); constructor(private formBuilder: FormBuilder) {} } In the preceding example, you use the group() method with the same object to define the properties in the model. The value for each control name is an array containing the initial value as the first item in the array. TIP: You can define the control with just the initial value, but if your controls need sync or async validation, add sync and async validators as the second and third items in the array. Compare using the form builder to creating the instances manually. src/app/profile-editor/profile-editor.component.ts (instances)src/app/profile-editor/profile-editor.component.ts (form builder) content_copy profileForm = new FormGroup({ firstName: new FormControl(''), lastName: new FormControl(''), address: new FormGroup({ street: new FormControl(''), city: new FormControl(''), state: new FormControl(''), zip: new FormControl(''), }), }); Validating form inputlink Form validation is used to ensure that user input is complete and correct. This section covers adding a single validator to a form control and displaying the overall form status. Form validation is covered more extensively in the Form Validation guide. Use the following steps to add form validation. Import a validator function in your form component. Add the validator to the field in the form. Add logic to handle the validation status. The most common validation is making a field required. The following example shows how to add a required validation to the firstName control and display the result of validation. Action Details Import a validator function Reactive forms include a set of validator functions for common use cases. These functions receive a control to validate against and return an error object or a null value based on the validation check. Import the Validators class from the @angular/forms package. content_copy import { Validators } from '@angular/forms'; Make a field required In the ProfileEditor component, add the Validators.required static method as the second item in the array for the firstName control. content_copy profileForm = this.formBuilder.group({ firstName: ['', Validators.required], lastName: [''], address: this.formBuilder.group({ street: [''], city: [''], state: [''], zip: [''], }), }); Display form status When you add a required field to the form control, its initial status is invalid. This invalid status propagates to the parent form group element, making its status invalid. Access the current status of the form group instance through its status property. Display the current status of profileForm using interpolation. content_copy pForm Status: {{ profileForm.status }}/p The Submit button is disabled because profileForm is invalid due to the required firstName form control. After you fill out the firstName input, the form becomes valid and the Submit button is enabled. For more on form validation, visit the Form Validation guide. Creating dynamic formslink FormArray is an alternative to FormGroup for managing any number of unnamed controls. As with form group instances, you can dynamically insert and remove controls from form array instances, and the form array instance value and validation status is calculated from its child controls. However, you don't need to define a key for each control by name, so this is a great option if you don't know the number of child values in advance. To define a dynamic form, take the following steps. Import the FormArray class. Define a FormArray control. Access the FormArray control with a getter method. Display the form array in a template. The following example shows you how to manage an array of aliases in ProfileEditor. Action Details Import the FormArray class Import the FormArray class from @angular/forms to use for type information. The FormBuilder service is ready to create a FormArray instance. content_copy import { FormArray } from '@angular/forms'; Define a FormArray control You can initialize a form array with any number of controls, from zero to many, by defining them in an array. Add an aliases property to the form group instance for profileForm to define the form array. Use the FormBuilder.array() method to define the array, and the FormBuilder.control() method to populate the array with an initial control. content_copy profileForm = this.formBuilder.group({ firstName: ['', Validators.required], lastName: [''], address: this.formBuilder.group({ street: [''], city: [''], state: [''], zip: [''], }), aliases: this.formBuilder.array([this.formBuilder.control('')]), }); The aliases control in the form group instance is now populated with a single control until more controls are added dynamically. Access the FormArray control A getter provides access to the aliases in the form array instance compared to repeating the profileForm.get() method to get each instance. The form array instance represents an undefined number of controls in an array. It's convenient to access a control through a getter, and this approach is straightforward to repeat for additional controls. Use the getter syntax to create an aliases class property to retrieve the alias's form array control from the parent form group. content_copy get aliases() { return this.profileForm.get('aliases') as FormArray; } NOTE: Because the returned control is of the type AbstractControl, you need to provide an explicit type to access the method syntax for the form array instance. Define a method to dynamically insert an alias control into the alias's form array. The FormArray.push() method inserts the control as a new item in the array. content_copy addAlias() { this.aliases.push(this.formBuilder.control('')); } In the template, each control is displayed as a separate input field. Display the form array in the template To attach the aliases from your form model, you must add it to the template. Similar to the formGroupName input provided by FormGroupNameDirective, formArrayName binds communication from the form array instance to the template with FormArrayNameDirective. Add the following template HTML after the div closing the formGroupName element. content_copy div formArrayName=\"aliases\" h2Aliases/h2 button type=\"button\" (click)=\"addAlias()\"+ Add another alias/button div *ngFor=\"let alias of aliases.controls; let i=index\" !-- The repeated alias template -- label for=\"alias-{{ i }}\"Alias:/label input id=\"alias-{{ i }}\" type=\"text\" [formControlName]=\"i\" /div /div The *ngFor directive iterates over each form control instance provided by the aliases form array instance. Because form array elements are unnamed, you assign the index to the i variable and pass it to each control to bind it to the formControlName input. Each time a new alias instance is added, the new form array instance is provided its control based on the index. This lets you track each individual control when calculating the status and value of the root control. Add an alias Initially, the form contains one Alias field. To add another field, click the Add Alias button. You can also validate the array of aliases reported by the form model displayed by Form Value at the bottom of the template. NOTE: Instead of a form control instance for each alias, you can compose another form group instance with additional fields. The process of defining a control for each item is the same. Reactive forms API summarylink The following table lists the base classes and services used to create and manage reactive form controls. For complete syntax details, see the API reference documentation for the Forms package. Classeslink Class Details AbstractControl The abstract base class for the concrete form control classes FormControl, FormGroup, and FormArray. It provides their common behaviors and properties. FormControl Manages the value and validity status of an individual form control. It corresponds to an HTML form control such as input or select. FormGroup Manages the value and validity state of a group of AbstractControl instances. The group's properties include its child controls. The top-level form in your component is FormGroup. FormArray Manages the value and validity state of a numerically indexed array of AbstractControl instances. FormBuilder An injectable service that provides factory methods for creating control instances. FormRecord Tracks the value and validity state of a collection of FormControl instances, each of which has the same value type. Directiveslink Directive Details FormControlDirective Syncs a standalone FormControl instance to a form control element. FormControlName Syncs FormControl in an existing FormGroup instance to a form control element by name. FormGroupDirective Syncs an existing FormGroup instance to a DOM element. FormGroupName Syncs a nested FormGroup instance to a DOM element. FormArrayName Syncs a nested FormArray instance to a DOM element. Last reviewed on Fri Sep 08 2023",
    "headings": [
      {
        "level": 1,
        "text": "Reactive formslink",
        "id": "reactive-forms"
      },
      {
        "level": 2,
        "text": "Prerequisiteslink",
        "id": "prerequisites"
      },
      {
        "level": 2,
        "text": "Overview of reactive formslink",
        "id": "overview-of-reactive-forms"
      },
      {
        "level": 2,
        "text": "Adding a basic form controllink",
        "id": "adding-a-basic-form-control"
      },
      {
        "level": 2,
        "text": "Grouping form controlslink",
        "id": "grouping-form-controls"
      },
      {
        "level": 2,
        "text": "Using the FormBuilder service to generate controlslink",
        "id": "using-the-formbuilder-service-to-generate-controls"
      },
      {
        "level": 2,
        "text": "Validating form inputlink",
        "id": "validating-form-input"
      },
      {
        "level": 2,
        "text": "Creating dynamic formslink",
        "id": "creating-dynamic-forms"
      },
      {
        "level": 2,
        "text": "Reactive forms API summarylink",
        "id": "reactive-forms-api-summary"
      },
      {
        "level": 3,
        "text": "Displaying a form control valuelink",
        "id": "displaying-a-form-control-value"
      },
      {
        "level": 3,
        "text": "Replacing a form control valuelink",
        "id": "replacing-a-form-control-value"
      },
      {
        "level": 3,
        "text": "Creating nested form groupslink",
        "id": "creating-nested-form-groups"
      },
      {
        "level": 3,
        "text": "Updating parts of the data modellink",
        "id": "updating-parts-of-the-data-model"
      },
      {
        "level": 4,
        "text": "Classeslink",
        "id": "classes"
      },
      {
        "level": 4,
        "text": "Directiveslink",
        "id": "directives"
      }
    ],
    "codeBlocks": [
      {
        "language": "text",
        "code": "FormControl"
      },
      {
        "language": "text",
        "code": "FormControl"
      },
      {
        "language": "text",
        "code": "FormControl"
      },
      {
        "language": "text",
        "code": "ng generate"
      },
      {
        "language": "text",
        "code": "FormControl"
      },
      {
        "language": "text",
        "code": "ReactiveFormsModule"
      },
      {
        "language": "text",
        "code": "content_copy\n      \n      import { Component } from '@angular/core';\nimport { FormControl, ReactiveFormsModule } from '@angular/forms';\n\n@Component({\n  standalone: true,\n  selector: 'app-name-editor',\n  templateUrl: './name-editor.component.html',\n  styleUrls: ['./name-editor.component.css'],\n  imports: [ReactiveFormsModule],\n})\nexport class NameEditorComponent {\n  name = new FormControl('');\n}"
      },
      {
        "language": "text",
        "code": "import { Component } from '@angular/core';\nimport { FormControl, ReactiveFormsModule } from '@angular/forms';\n\n@Component({\n  standalone: true,\n  selector: 'app-name-editor',\n  templateUrl: './name-editor.component.html',\n  styleUrls: ['./name-editor.component.css'],\n  imports: [ReactiveFormsModule],\n})\nexport class NameEditorComponent {\n  name = new FormControl('');\n}"
      },
      {
        "language": "text",
        "code": "FormControl"
      },
      {
        "language": "text",
        "code": "formControl"
      },
      {
        "language": "text",
        "code": "FormControlDirective"
      },
      {
        "language": "text",
        "code": "ReactiveFormsModule"
      },
      {
        "language": "text",
        "code": "content_copy\n      \n      <label for=\"name\">Name: </label>\n<input id=\"name\" type=\"text\" [formControl]=\"name\">"
      },
      {
        "language": "text",
        "code": "<label for=\"name\">Name: </label>\n<input id=\"name\" type=\"text\" [formControl]=\"name\">"
      },
      {
        "language": "text",
        "code": "ReactiveFormsModule"
      },
      {
        "language": "text",
        "code": "FormControl"
      },
      {
        "language": "text",
        "code": "content_copy\n      \n      <app-name-editor></app-name-editor>"
      },
      {
        "language": "text",
        "code": "<app-name-editor></app-name-editor>"
      },
      {
        "language": "text",
        "code": "valueChanges"
      },
      {
        "language": "text",
        "code": "subscribe()"
      },
      {
        "language": "text",
        "code": "content_copy\n      \n      <p>Value: {{ name.value }}</p>"
      },
      {
        "language": "text",
        "code": "<p>Value: {{ name.value }}</p>"
      },
      {
        "language": "text",
        "code": "FormControl"
      },
      {
        "language": "text",
        "code": "content_copy\n      \n      updateName() {\n  this.name.setValue('Nancy');\n}"
      },
      {
        "language": "text",
        "code": "updateName() {\n  this.name.setValue('Nancy');\n}"
      },
      {
        "language": "text",
        "code": "content_copy\n      \n      <button type=\"button\" (click)=\"updateName()\">Update Name</button>"
      },
      {
        "language": "text",
        "code": "<button type=\"button\" (click)=\"updateName()\">Update Name</button>"
      },
      {
        "language": "text",
        "code": "ProfileEditor"
      },
      {
        "language": "text",
        "code": "FormControl"
      },
      {
        "language": "text",
        "code": "@angular/forms"
      },
      {
        "language": "text",
        "code": "content_copy\n      \n      ng generate component ProfileEditor"
      },
      {
        "language": "text",
        "code": "ng generate component ProfileEditor"
      },
      {
        "language": "text",
        "code": "content_copy\n      \n      import { FormGroup, FormControl } from '@angular/forms';"
      },
      {
        "language": "text",
        "code": "import { FormGroup, FormControl } from '@angular/forms';"
      },
      {
        "language": "text",
        "code": "profileForm"
      },
      {
        "language": "text",
        "code": "content_copy\n      \n      import { Component } from '@angular/core';\nimport { FormGroup, FormControl } from '@angular/forms';\n\n@Component({\n  standalone: true,\n  selector: 'app-profile-editor',\n  templateUrl: './profile-editor.component.html',\n  styleUrls: ['./profile-editor.component.css'],\n})\nexport class ProfileEditorComponent {\n  profileForm = new FormGroup({\n    firstName: new FormControl(''),\n    lastName: new FormControl(''),\n  });\n}"
      },
      {
        "language": "text",
        "code": "import { Component } from '@angular/core';\nimport { FormGroup, FormControl } from '@angular/forms';\n\n@Component({\n  standalone: true,\n  selector: 'app-profile-editor',\n  templateUrl: './profile-editor.component.html',\n  styleUrls: ['./profile-editor.component.css'],\n})\nexport class ProfileEditorComponent {\n  profileForm = new FormGroup({\n    firstName: new FormControl(''),\n    lastName: new FormControl(''),\n  });\n}"
      },
      {
        "language": "text",
        "code": "content_copy\n      \n      <form [formGroup]=\"profileForm\">\n\n  <label for=\"first-name\">First Name: </label>\n  <input id=\"first-name\" type=\"text\" formControlName=\"firstName\">\n\n  <label for=\"last-name\">Last Name: </label>\n  <input id=\"last-name\" type=\"text\" formControlName=\"lastName\">\n\n</form>"
      },
      {
        "language": "text",
        "code": "<form [formGroup]=\"profileForm\">\n\n  <label for=\"first-name\">First Name: </label>\n  <input id=\"first-name\" type=\"text\" formControlName=\"firstName\">\n\n  <label for=\"last-name\">Last Name: </label>\n  <input id=\"last-name\" type=\"text\" formControlName=\"lastName\">\n\n</form>"
      },
      {
        "language": "text",
        "code": "formControlName"
      },
      {
        "language": "text",
        "code": "FormControlName"
      },
      {
        "language": "text",
        "code": "ProfileEditor"
      },
      {
        "language": "text",
        "code": "content_copy\n      \n      <form [formGroup]=\"profileForm\" (ngSubmit)=\"onSubmit()\">"
      },
      {
        "language": "text",
        "code": "<form [formGroup]=\"profileForm\" (ngSubmit)=\"onSubmit()\">"
      },
      {
        "language": "text",
        "code": "ProfileEditor"
      },
      {
        "language": "text",
        "code": "profileForm"
      },
      {
        "language": "text",
        "code": "EventEmitter"
      },
      {
        "language": "text",
        "code": "console.warn"
      },
      {
        "language": "text",
        "code": "content_copy\n      \n      onSubmit() {\n  // TODO: Use EventEmitter with form value\n  console.warn(this.profileForm.value);\n}"
      },
      {
        "language": "text",
        "code": "onSubmit() {\n  // TODO: Use EventEmitter with form value\n  console.warn(this.profileForm.value);\n}"
      },
      {
        "language": "text",
        "code": "content_copy\n      \n      <p>Complete the form to enable button.</p>\n<button type=\"submit\" [disabled]=\"!profileForm.valid\">Submit</button>"
      },
      {
        "language": "text",
        "code": "<p>Complete the form to enable button.</p>\n<button type=\"submit\" [disabled]=\"!profileForm.valid\">Submit</button>"
      },
      {
        "language": "text",
        "code": "profileForm"
      },
      {
        "language": "text",
        "code": "ProfileEditor"
      },
      {
        "language": "text",
        "code": "content_copy\n      \n      <app-profile-editor></app-profile-editor>"
      },
      {
        "language": "text",
        "code": "<app-profile-editor></app-profile-editor>"
      },
      {
        "language": "text",
        "code": "ProfileEditor"
      },
      {
        "language": "text",
        "code": "profileForm"
      },
      {
        "language": "text",
        "code": "content_copy\n      \n      import { Component } from '@angular/core';\nimport { FormGroup, FormControl } from '@angular/forms';\n\n@Component({\n  standalone: true,\n  selector: 'app-profile-editor',\n  templateUrl: './profile-editor.component.html',\n  styleUrls: ['./profile-editor.component.css'],\n})\nexport class ProfileEditorComponent {\n  profileForm = new FormGroup({\n    firstName: new FormControl(''),\n    lastName: new FormControl(''),\n    address: new FormGroup({\n      street: new FormControl(''),\n      city: new FormControl(''),\n      state: new FormControl(''),\n      zip: new FormControl(''),\n    }),\n  });\n}"
      },
      {
        "language": "text",
        "code": "import { Component } from '@angular/core';\nimport { FormGroup, FormControl } from '@angular/forms';\n\n@Component({\n  standalone: true,\n  selector: 'app-profile-editor',\n  templateUrl: './profile-editor.component.html',\n  styleUrls: ['./profile-editor.component.css'],\n})\nexport class ProfileEditorComponent {\n  profileForm = new FormGroup({\n    firstName: new FormControl(''),\n    lastName: new FormControl(''),\n    address: new FormGroup({\n      street: new FormControl(''),\n      city: new FormControl(''),\n      state: new FormControl(''),\n      zip: new FormControl(''),\n    }),\n  });\n}"
      },
      {
        "language": "text",
        "code": "address group"
      },
      {
        "language": "text",
        "code": "profileForm"
      },
      {
        "language": "text",
        "code": "ProfileEditor"
      },
      {
        "language": "text",
        "code": "content_copy\n      \n      <div formGroupName=\"address\">\n  <h2>Address</h2>\n\n  <label for=\"street\">Street: </label>\n  <input id=\"street\" type=\"text\" formControlName=\"street\">\n\n  <label for=\"city\">City: </label>\n  <input id=\"city\" type=\"text\" formControlName=\"city\">\n\n  <label for=\"state\">State: </label>\n  <input id=\"state\" type=\"text\" formControlName=\"state\">\n\n  <label for=\"zip\">Zip Code: </label>\n  <input id=\"zip\" type=\"text\" formControlName=\"zip\">\n</div>"
      },
      {
        "language": "text",
        "code": "<div formGroupName=\"address\">\n  <h2>Address</h2>\n\n  <label for=\"street\">Street: </label>\n  <input id=\"street\" type=\"text\" formControlName=\"street\">\n\n  <label for=\"city\">City: </label>\n  <input id=\"city\" type=\"text\" formControlName=\"city\">\n\n  <label for=\"state\">State: </label>\n  <input id=\"state\" type=\"text\" formControlName=\"state\">\n\n  <label for=\"zip\">Zip Code: </label>\n  <input id=\"zip\" type=\"text\" formControlName=\"zip\">\n</div>"
      },
      {
        "language": "text",
        "code": "ProfileEditor"
      },
      {
        "language": "text",
        "code": "patchValue()"
      },
      {
        "language": "text",
        "code": "patchValue()"
      },
      {
        "language": "text",
        "code": "ProfileEditorComponent"
      },
      {
        "language": "text",
        "code": "updateProfile"
      },
      {
        "language": "text",
        "code": "content_copy\n      \n      updateProfile() {\n  this.profileForm.patchValue({\n    firstName: 'Nancy',\n    address: {\n      street: '123 Drew Street',\n    },\n  });\n}"
      },
      {
        "language": "text",
        "code": "updateProfile() {\n  this.profileForm.patchValue({\n    firstName: 'Nancy',\n    address: {\n      street: '123 Drew Street',\n    },\n  });\n}"
      },
      {
        "language": "text",
        "code": "content_copy\n      \n      <button type=\"button\" (click)=\"updateProfile()\">Update Profile</button>"
      },
      {
        "language": "text",
        "code": "<button type=\"button\" (click)=\"updateProfile()\">Update Profile</button>"
      },
      {
        "language": "text",
        "code": "profileForm"
      },
      {
        "language": "text",
        "code": "patchValue()"
      },
      {
        "language": "text",
        "code": "PatchValue()"
      },
      {
        "language": "text",
        "code": "FormBuilder"
      },
      {
        "language": "text",
        "code": "FormBuilder"
      },
      {
        "language": "text",
        "code": "FormBuilder"
      },
      {
        "language": "text",
        "code": "ProfileEditor"
      },
      {
        "language": "text",
        "code": "FormBuilder"
      },
      {
        "language": "text",
        "code": "@angular/forms"
      },
      {
        "language": "text",
        "code": "content_copy\n      \n      import { FormBuilder } from '@angular/forms';"
      },
      {
        "language": "text",
        "code": "import { FormBuilder } from '@angular/forms';"
      },
      {
        "language": "text",
        "code": "FormBuilder"
      },
      {
        "language": "text",
        "code": "content_copy\n      \n      constructor(private formBuilder: FormBuilder) {}"
      },
      {
        "language": "text",
        "code": "constructor(private formBuilder: FormBuilder) {}"
      },
      {
        "language": "text",
        "code": "FormBuilder"
      },
      {
        "language": "text",
        "code": "profileForm"
      },
      {
        "language": "text",
        "code": "content_copy\n      \n      import { Component } from '@angular/core';\nimport { FormBuilder } from '@angular/forms';\n\n@Component({\n  standalone: true,\n  selector: 'app-profile-editor',\n  templateUrl: './profile-editor.component.html',\n  styleUrls: ['./profile-editor.component.css'],\n})\nexport class ProfileEditorComponent {\n  profileForm = this.formBuilder.group({\n    firstName: [''],\n    lastName: [''],\n    address: this.formBuilder.group({\n      street: [''],\n      city: [''],\n      state: [''],\n      zip: [''],\n    }),\n  });\n\n  constructor(private formBuilder: FormBuilder) {}\n}"
      },
      {
        "language": "text",
        "code": "import { Component } from '@angular/core';\nimport { FormBuilder } from '@angular/forms';\n\n@Component({\n  standalone: true,\n  selector: 'app-profile-editor',\n  templateUrl: './profile-editor.component.html',\n  styleUrls: ['./profile-editor.component.css'],\n})\nexport class ProfileEditorComponent {\n  profileForm = this.formBuilder.group({\n    firstName: [''],\n    lastName: [''],\n    address: this.formBuilder.group({\n      street: [''],\n      city: [''],\n      state: [''],\n      zip: [''],\n    }),\n  });\n\n  constructor(private formBuilder: FormBuilder) {}\n}"
      },
      {
        "language": "text",
        "code": "content_copy\n      \n      profileForm = new FormGroup({\n  firstName: new FormControl(''),\n  lastName: new FormControl(''),\n  address: new FormGroup({\n    street: new FormControl(''),\n    city: new FormControl(''),\n    state: new FormControl(''),\n    zip: new FormControl(''),\n  }),\n});"
      },
      {
        "language": "text",
        "code": "profileForm = new FormGroup({\n  firstName: new FormControl(''),\n  lastName: new FormControl(''),\n  address: new FormGroup({\n    street: new FormControl(''),\n    city: new FormControl(''),\n    state: new FormControl(''),\n    zip: new FormControl(''),\n  }),\n});"
      },
      {
        "language": "text",
        "code": "@angular/forms"
      },
      {
        "language": "text",
        "code": "content_copy\n      \n      import { Validators } from '@angular/forms';"
      },
      {
        "language": "text",
        "code": "import { Validators } from '@angular/forms';"
      },
      {
        "language": "text",
        "code": "ProfileEditor"
      },
      {
        "language": "text",
        "code": "Validators.required"
      },
      {
        "language": "text",
        "code": "content_copy\n      \n      profileForm = this.formBuilder.group({\n  firstName: ['', Validators.required],\n  lastName: [''],\n  address: this.formBuilder.group({\n    street: [''],\n    city: [''],\n    state: [''],\n    zip: [''],\n  }),\n});"
      },
      {
        "language": "text",
        "code": "profileForm = this.formBuilder.group({\n  firstName: ['', Validators.required],\n  lastName: [''],\n  address: this.formBuilder.group({\n    street: [''],\n    city: [''],\n    state: [''],\n    zip: [''],\n  }),\n});"
      },
      {
        "language": "text",
        "code": "profileForm"
      },
      {
        "language": "text",
        "code": "content_copy\n      \n      <p>Form Status: {{ profileForm.status }}</p>"
      },
      {
        "language": "text",
        "code": "<p>Form Status: {{ profileForm.status }}</p>"
      },
      {
        "language": "text",
        "code": "profileForm"
      },
      {
        "language": "text",
        "code": "ProfileEditor"
      },
      {
        "language": "text",
        "code": "@angular/forms"
      },
      {
        "language": "text",
        "code": "FormBuilder"
      },
      {
        "language": "text",
        "code": "content_copy\n      \n      import { FormArray } from '@angular/forms';"
      },
      {
        "language": "text",
        "code": "import { FormArray } from '@angular/forms';"
      },
      {
        "language": "text",
        "code": "profileForm"
      },
      {
        "language": "text",
        "code": "FormBuilder.array()"
      },
      {
        "language": "text",
        "code": "FormBuilder.control()"
      },
      {
        "language": "text",
        "code": "content_copy\n      \n      profileForm = this.formBuilder.group({\n  firstName: ['', Validators.required],\n  lastName: [''],\n  address: this.formBuilder.group({\n    street: [''],\n    city: [''],\n    state: [''],\n    zip: [''],\n  }),\n  aliases: this.formBuilder.array([this.formBuilder.control('')]),\n});"
      },
      {
        "language": "text",
        "code": "profileForm = this.formBuilder.group({\n  firstName: ['', Validators.required],\n  lastName: [''],\n  address: this.formBuilder.group({\n    street: [''],\n    city: [''],\n    state: [''],\n    zip: [''],\n  }),\n  aliases: this.formBuilder.array([this.formBuilder.control('')]),\n});"
      },
      {
        "language": "text",
        "code": "profileForm.get()"
      },
      {
        "language": "text",
        "code": "content_copy\n      \n      get aliases() {\n  return this.profileForm.get('aliases') as FormArray;\n}"
      },
      {
        "language": "text",
        "code": "get aliases() {\n  return this.profileForm.get('aliases') as FormArray;\n}"
      },
      {
        "language": "text",
        "code": "AbstractControl"
      },
      {
        "language": "text",
        "code": "FormArray.push()"
      },
      {
        "language": "text",
        "code": "content_copy\n      \n      addAlias() {\n  this.aliases.push(this.formBuilder.control(''));\n}"
      },
      {
        "language": "text",
        "code": "addAlias() {\n  this.aliases.push(this.formBuilder.control(''));\n}"
      },
      {
        "language": "text",
        "code": "formGroupName"
      },
      {
        "language": "text",
        "code": "FormGroupNameDirective"
      },
      {
        "language": "text",
        "code": "formArrayName"
      },
      {
        "language": "text",
        "code": "FormArrayNameDirective"
      },
      {
        "language": "text",
        "code": "formGroupName"
      },
      {
        "language": "text",
        "code": "content_copy\n      \n      <div formArrayName=\"aliases\">\n  <h2>Aliases</h2>\n  <button type=\"button\" (click)=\"addAlias()\">+ Add another alias</button>\n\n  <div *ngFor=\"let alias of aliases.controls; let i=index\">\n    <!-- The repeated alias template -->\n    <label for=\"alias-{{ i }}\">Alias:</label>\n    <input id=\"alias-{{ i }}\" type=\"text\" [formControlName]=\"i\">\n  </div>\n</div>"
      },
      {
        "language": "text",
        "code": "<div formArrayName=\"aliases\">\n  <h2>Aliases</h2>\n  <button type=\"button\" (click)=\"addAlias()\">+ Add another alias</button>\n\n  <div *ngFor=\"let alias of aliases.controls; let i=index\">\n    <!-- The repeated alias template -->\n    <label for=\"alias-{{ i }}\">Alias:</label>\n    <input id=\"alias-{{ i }}\" type=\"text\" [formControlName]=\"i\">\n  </div>\n</div>"
      },
      {
        "language": "text",
        "code": "formControlName"
      },
      {
        "language": "text",
        "code": "AbstractControl"
      },
      {
        "language": "text",
        "code": "FormControl"
      },
      {
        "language": "text",
        "code": "FormControl"
      },
      {
        "language": "text",
        "code": "AbstractControl"
      },
      {
        "language": "text",
        "code": "AbstractControl"
      },
      {
        "language": "text",
        "code": "FormBuilder"
      },
      {
        "language": "text",
        "code": "FormControl"
      },
      {
        "language": "text",
        "code": "FormControlDirective"
      },
      {
        "language": "text",
        "code": "FormControl"
      },
      {
        "language": "text",
        "code": "FormControlName"
      },
      {
        "language": "text",
        "code": "FormControl"
      },
      {
        "language": "text",
        "code": "FormGroupDirective"
      },
      {
        "language": "text",
        "code": "FormGroupName"
      },
      {
        "language": "text",
        "code": "FormArrayName"
      }
    ],
    "links": [
      {
        "text": "link",
        "href": "guide/reactive-forms#reactive-forms"
      },
      {
        "text": "Prerequisites",
        "href": "guide/reactive-forms#prerequisites"
      },
      {
        "text": "Overview of reactive forms",
        "href": "guide/reactive-forms#overview-of-reactive-forms"
      },
      {
        "text": "Adding a basic form control",
        "href": "guide/reactive-forms#adding-a-basic-form-control"
      },
      {
        "text": "Displaying a form control value",
        "href": "guide/reactive-forms#displaying-a-form-control-value"
      },
      {
        "text": "Replacing a form control value",
        "href": "guide/reactive-forms#replacing-a-form-control-value"
      },
      {
        "text": "Grouping form controls",
        "href": "guide/reactive-forms#grouping-form-controls"
      },
      {
        "text": "Creating nested form groups",
        "href": "guide/reactive-forms#creating-nested-form-groups"
      },
      {
        "text": "Updating parts of the data model",
        "href": "guide/reactive-forms#updating-parts-of-the-data-model"
      },
      {
        "text": "Using the FormBuilder service to generate controls",
        "href": "guide/reactive-forms#using-the-formbuilder-service-to-generate-controls"
      },
      {
        "text": "Validating form input",
        "href": "guide/reactive-forms#validating-form-input"
      },
      {
        "text": "Creating dynamic forms",
        "href": "guide/reactive-forms#creating-dynamic-forms"
      },
      {
        "text": "Reactive forms API summary",
        "href": "guide/reactive-forms#reactive-forms-api-summary"
      },
      {
        "text": "Reactive Forms live-example",
        "href": "generated/live-examples/reactive-forms/stackblitz.html"
      },
      {
        "text": "download example",
        "href": "generated/zips/reactive-forms/reactive-forms.zip"
      },
      {
        "text": "link",
        "href": "guide/reactive-forms#prerequisites"
      },
      {
        "text": "TypeScript",
        "href": "https://www.typescriptlang.org/"
      },
      {
        "text": "Angular Concepts",
        "href": "guide/architecture"
      },
      {
        "text": "Introduction to Forms",
        "href": "guide/forms-overview"
      },
      {
        "text": "link",
        "href": "guide/reactive-forms#overview-of-reactive-forms"
      },
      {
        "text": "observable",
        "href": "guide/glossary#observable"
      },
      {
        "text": "template-driven forms",
        "href": "guide/forms"
      },
      {
        "text": "Forms Overview",
        "href": "guide/forms-overview"
      },
      {
        "text": "link",
        "href": "guide/reactive-forms#adding-a-basic-form-control"
      },
      {
        "text": "FormControl",
        "href": "api/forms/FormControl"
      },
      {
        "text": "FormControl",
        "href": "api/forms/FormControl"
      },
      {
        "text": "FormControl",
        "href": "api/forms/FormControl"
      },
      {
        "text": "CLI command",
        "href": "cli/generate#component-command"
      },
      {
        "text": "FormControl",
        "href": "api/forms/FormControl"
      },
      {
        "text": "ReactiveFormsModule",
        "href": "api/forms/ReactiveFormsModule"
      },
      {
        "text": "Component",
        "href": "api/core/Component"
      },
      {
        "text": "FormControl",
        "href": "api/forms/FormControl"
      },
      {
        "text": "ReactiveFormsModule",
        "href": "api/forms/ReactiveFormsModule"
      },
      {
        "text": "Component",
        "href": "api/core/Component"
      },
      {
        "text": "ReactiveFormsModule",
        "href": "api/forms/ReactiveFormsModule"
      },
      {
        "text": "FormControl",
        "href": "api/forms/FormControl"
      },
      {
        "text": "FormControl",
        "href": "api/forms/FormControl"
      },
      {
        "text": "FormControlDirective",
        "href": "api/forms/FormControlDirective"
      },
      {
        "text": "ReactiveFormsModule",
        "href": "api/forms/ReactiveFormsModule"
      },
      {
        "text": "ReactiveFormsModule",
        "href": "api/forms/ReactiveFormsModule"
      },
      {
        "text": "Reactive forms API",
        "href": "guide/reactive-forms#reactive-forms-api"
      },
      {
        "text": "Forms package",
        "href": "api/forms"
      },
      {
        "text": "FormControl",
        "href": "api/forms/FormControl"
      },
      {
        "text": "link",
        "href": "guide/reactive-forms#displaying-a-form-control-value"
      },
      {
        "text": "AsyncPipe",
        "href": "api/common/AsyncPipe"
      },
      {
        "text": "AbstractControl",
        "href": "api/forms/AbstractControl"
      },
      {
        "text": "input validation",
        "href": "guide/reactive-forms#basic-form-validation"
      },
      {
        "text": "FormControl",
        "href": "api/forms/FormControl"
      },
      {
        "text": "API Reference",
        "href": "api/forms/FormControl"
      },
      {
        "text": "link",
        "href": "guide/reactive-forms#replacing-a-form-control-value"
      },
      {
        "text": "form group",
        "href": "guide/reactive-forms#grouping-form-controls"
      },
      {
        "text": "form array",
        "href": "guide/reactive-forms#creating-dynamic-forms"
      },
      {
        "text": "link",
        "href": "guide/reactive-forms#grouping-form-controls"
      },
      {
        "text": "nest form groups",
        "href": "guide/reactive-forms#nested-groups"
      },
      {
        "text": "Creating dynamic forms",
        "href": "guide/reactive-forms#dynamic-forms"
      },
      {
        "text": "FormGroup",
        "href": "api/forms/FormGroup"
      },
      {
        "text": "FormControl",
        "href": "api/forms/FormControl"
      },
      {
        "text": "FormGroup",
        "href": "api/forms/FormGroup"
      },
      {
        "text": "FormControl",
        "href": "api/forms/FormControl"
      },
      {
        "text": "FormGroup",
        "href": "api/forms/FormGroup"
      },
      {
        "text": "FormGroup",
        "href": "api/forms/FormGroup"
      },
      {
        "text": "FormGroup",
        "href": "api/forms/FormGroup"
      },
      {
        "text": "Component",
        "href": "api/core/Component"
      },
      {
        "text": "FormGroup",
        "href": "api/forms/FormGroup"
      },
      {
        "text": "FormControl",
        "href": "api/forms/FormControl"
      },
      {
        "text": "Component",
        "href": "api/core/Component"
      },
      {
        "text": "FormGroup",
        "href": "api/forms/FormGroup"
      },
      {
        "text": "FormControl",
        "href": "api/forms/FormControl"
      },
      {
        "text": "FormControl",
        "href": "api/forms/FormControl"
      },
      {
        "text": "FormGroup",
        "href": "api/forms/FormGroup"
      },
      {
        "text": "FormGroup",
        "href": "api/forms/FormGroup"
      },
      {
        "text": "formControlName",
        "href": "api/forms/FormControlName"
      },
      {
        "text": "formControlName",
        "href": "api/forms/FormControlName"
      },
      {
        "text": "FormGroup",
        "href": "api/forms/FormGroup"
      },
      {
        "text": "FormGroup",
        "href": "api/forms/FormGroup"
      },
      {
        "text": "formControlName",
        "href": "api/forms/FormControlName"
      },
      {
        "text": "FormControlName",
        "href": "api/forms/FormControlName"
      },
      {
        "text": "FormGroup",
        "href": "api/forms/FormGroup"
      },
      {
        "text": "FormGroup",
        "href": "api/forms/FormGroup"
      },
      {
        "text": "EventEmitter",
        "href": "api/core/EventEmitter"
      },
      {
        "text": "EventEmitter",
        "href": "api/core/EventEmitter"
      },
      {
        "text": "Validating form input",
        "href": "guide/reactive-forms#basic-form-validation"
      },
      {
        "text": "link",
        "href": "guide/reactive-forms#creating-nested-form-groups"
      },
      {
        "text": "Component",
        "href": "api/core/Component"
      },
      {
        "text": "FormGroup",
        "href": "api/forms/FormGroup"
      },
      {
        "text": "FormControl",
        "href": "api/forms/FormControl"
      },
      {
        "text": "Component",
        "href": "api/core/Component"
      },
      {
        "text": "FormGroup",
        "href": "api/forms/FormGroup"
      },
      {
        "text": "FormControl",
        "href": "api/forms/FormControl"
      },
      {
        "text": "FormControl",
        "href": "api/forms/FormControl"
      },
      {
        "text": "FormGroup",
        "href": "api/forms/FormGroup"
      },
      {
        "text": "FormControl",
        "href": "api/forms/FormControl"
      },
      {
        "text": "FormControl",
        "href": "api/forms/FormControl"
      },
      {
        "text": "FormControl",
        "href": "api/forms/FormControl"
      },
      {
        "text": "FormControl",
        "href": "api/forms/FormControl"
      },
      {
        "text": "formGroupName",
        "href": "api/forms/FormGroupName"
      },
      {
        "text": "formControlName",
        "href": "api/forms/FormControlName"
      },
      {
        "text": "formControlName",
        "href": "api/forms/FormControlName"
      },
      {
        "text": "formControlName",
        "href": "api/forms/FormControlName"
      },
      {
        "text": "formControlName",
        "href": "api/forms/FormControlName"
      },
      {
        "text": "JsonPipe",
        "href": "api/common/JsonPipe"
      },
      {
        "text": "link",
        "href": "guide/reactive-forms#updating-parts-of-the-data-model"
      },
      {
        "text": "link",
        "href": "guide/reactive-forms#using-the-formbuilder-service-to-generate-controls"
      },
      {
        "text": "FormBuilder",
        "href": "api/forms/FormBuilder"
      },
      {
        "text": "FormBuilder",
        "href": "api/forms/FormBuilder"
      },
      {
        "text": "FormBuilder",
        "href": "api/forms/FormBuilder"
      },
      {
        "text": "FormBuilder",
        "href": "api/forms/FormBuilder"
      },
      {
        "text": "FormBuilder",
        "href": "api/forms/FormBuilder"
      },
      {
        "text": "FormBuilder",
        "href": "api/forms/FormBuilder"
      },
      {
        "text": "FormBuilder",
        "href": "api/forms/FormBuilder"
      },
      {
        "text": "FormBuilder",
        "href": "api/forms/FormBuilder"
      },
      {
        "text": "Component",
        "href": "api/core/Component"
      },
      {
        "text": "FormBuilder",
        "href": "api/forms/FormBuilder"
      },
      {
        "text": "Component",
        "href": "api/core/Component"
      },
      {
        "text": "FormBuilder",
        "href": "api/forms/FormBuilder"
      },
      {
        "text": "FormGroup",
        "href": "api/forms/FormGroup"
      },
      {
        "text": "FormControl",
        "href": "api/forms/FormControl"
      },
      {
        "text": "FormControl",
        "href": "api/forms/FormControl"
      },
      {
        "text": "FormGroup",
        "href": "api/forms/FormGroup"
      },
      {
        "text": "FormControl",
        "href": "api/forms/FormControl"
      },
      {
        "text": "FormControl",
        "href": "api/forms/FormControl"
      },
      {
        "text": "FormControl",
        "href": "api/forms/FormControl"
      },
      {
        "text": "FormControl",
        "href": "api/forms/FormControl"
      },
      {
        "text": "link",
        "href": "guide/reactive-forms#validating-form-input"
      },
      {
        "text": "Form Validation",
        "href": "guide/form-validation"
      },
      {
        "text": "Validators",
        "href": "api/forms/Validators"
      },
      {
        "text": "Validators",
        "href": "api/forms/Validators"
      },
      {
        "text": "Form",
        "href": "api/forms/Form"
      },
      {
        "text": "Form Validation",
        "href": "guide/form-validation"
      },
      {
        "text": "link",
        "href": "guide/reactive-forms#creating-dynamic-forms"
      },
      {
        "text": "FormArray",
        "href": "api/forms/FormArray"
      },
      {
        "text": "FormGroup",
        "href": "api/forms/FormGroup"
      },
      {
        "text": "FormArray",
        "href": "api/forms/FormArray"
      },
      {
        "text": "FormArray",
        "href": "api/forms/FormArray"
      },
      {
        "text": "FormArray",
        "href": "api/forms/FormArray"
      },
      {
        "text": "FormArray",
        "href": "api/forms/FormArray"
      },
      {
        "text": "FormArray",
        "href": "api/forms/FormArray"
      },
      {
        "text": "FormBuilder",
        "href": "api/forms/FormBuilder"
      },
      {
        "text": "FormArray",
        "href": "api/forms/FormArray"
      },
      {
        "text": "FormArray",
        "href": "api/forms/FormArray"
      },
      {
        "text": "FormArray",
        "href": "api/forms/FormArray"
      },
      {
        "text": "FormBuilder.array()",
        "href": "api/forms/FormBuilder#array"
      },
      {
        "text": "FormBuilder.control()",
        "href": "api/forms/FormBuilder#control"
      },
      {
        "text": "FormArray",
        "href": "api/forms/FormArray"
      },
      {
        "text": "FormArray",
        "href": "api/forms/FormArray"
      },
      {
        "text": "AbstractControl",
        "href": "api/forms/AbstractControl"
      },
      {
        "text": "FormArray.push()",
        "href": "api/forms/FormArray#push"
      },
      {
        "text": "formGroupName",
        "href": "api/forms/FormGroupName"
      },
      {
        "text": "formArrayName",
        "href": "api/forms/FormArrayName"
      },
      {
        "text": "formGroupName",
        "href": "api/forms/FormGroupName"
      },
      {
        "text": "formArrayName",
        "href": "api/forms/FormArrayName"
      },
      {
        "text": "ngFor",
        "href": "api/common/NgFor"
      },
      {
        "text": "formControlName",
        "href": "api/forms/FormControlName"
      },
      {
        "text": "ngFor",
        "href": "api/common/NgFor"
      },
      {
        "text": "formControlName",
        "href": "api/forms/FormControlName"
      },
      {
        "text": "Form",
        "href": "api/forms/Form"
      },
      {
        "text": "link",
        "href": "guide/reactive-forms#reactive-forms-api-summary"
      },
      {
        "text": "Forms package",
        "href": "api/forms"
      },
      {
        "text": "link",
        "href": "guide/reactive-forms#classes"
      },
      {
        "text": "AbstractControl",
        "href": "api/forms/AbstractControl"
      },
      {
        "text": "FormControl",
        "href": "api/forms/FormControl"
      },
      {
        "text": "FormGroup",
        "href": "api/forms/FormGroup"
      },
      {
        "text": "FormArray",
        "href": "api/forms/FormArray"
      },
      {
        "text": "FormControl",
        "href": "api/forms/FormControl"
      },
      {
        "text": "FormGroup",
        "href": "api/forms/FormGroup"
      },
      {
        "text": "AbstractControl",
        "href": "api/forms/AbstractControl"
      },
      {
        "text": "FormGroup",
        "href": "api/forms/FormGroup"
      },
      {
        "text": "FormArray",
        "href": "api/forms/FormArray"
      },
      {
        "text": "AbstractControl",
        "href": "api/forms/AbstractControl"
      },
      {
        "text": "FormBuilder",
        "href": "api/forms/FormBuilder"
      },
      {
        "text": "FormRecord",
        "href": "api/forms/FormRecord"
      },
      {
        "text": "FormControl",
        "href": "api/forms/FormControl"
      },
      {
        "text": "link",
        "href": "guide/reactive-forms#directives"
      },
      {
        "text": "FormControlDirective",
        "href": "api/forms/FormControlDirective"
      },
      {
        "text": "FormControl",
        "href": "api/forms/FormControl"
      },
      {
        "text": "FormControlName",
        "href": "api/forms/FormControlName"
      },
      {
        "text": "FormControl",
        "href": "api/forms/FormControl"
      },
      {
        "text": "FormGroup",
        "href": "api/forms/FormGroup"
      },
      {
        "text": "FormGroupDirective",
        "href": "api/forms/FormGroupDirective"
      },
      {
        "text": "FormGroup",
        "href": "api/forms/FormGroup"
      },
      {
        "text": "FormGroupName",
        "href": "api/forms/FormGroupName"
      },
      {
        "text": "FormGroup",
        "href": "api/forms/FormGroup"
      },
      {
        "text": "FormArrayName",
        "href": "api/forms/FormArrayName"
      },
      {
        "text": "FormArray",
        "href": "api/forms/FormArray"
      }
    ],
    "meta": {
      "description": "",
      "keywords": ""
    },
    "summary": "Reactive formslink Contents PrerequisitesOverview of reactive formsAdding a basic form controlDisplaying a form control valueReplacing a form control valueGrouping form controlsCreating nested form gr...",
    "tags": [
      "react",
      "vue",
      "angular",
      "javascript",
      "typescript",
      "css",
      "html",
      "node",
      "vite",
      "form"
    ],
    "id": "angular-reactiveforms-part-1",
    "quality": 90
  },
  {
    "title": "Angular",
    "url": "https://v17.angular.io/guide/form-validation",
    "category": "angular",
    "content": "Validating form inputlink Contents PrerequisitesValidating input in template-driven formsValidating input in reactive formsValidator functionsBuilt-in validator functionsDefining custom validatorsAdding custom validators to reactive formsAdding custom validators to template-driven formsControl status CSS classesCross-field validationAdding cross-validation to reactive formsAdding cross-validation to template-driven formsCreating asynchronous validatorsImplementing a custom async validatorAdding async validators to reactive formsAdding async validators to template-driven formsOptimizing performance of async validatorsInteraction with native HTML form validation You can improve overall data quality by validating user input for accuracy and completeness. This page shows how to validate user input from the UI and display useful validation messages, in both reactive and template-driven forms. Prerequisiteslink Before reading about form validation, you should have a basic understanding of the following. TypeScript and HTML5 programming Fundamental concepts of Angular application design The two types of forms that Angular supports Basics of either Template-driven Forms or Reactive Forms Get the complete example code for the reactive and template-driven forms used here to illustrate form validation. Run the live example / download example. Validating input in template-driven formslink To add validation to a template-driven form, you add the same validation attributes as you would with native HTML form validation. Angular uses directives to match these attributes with validator functions in the framework. Every time the value of a form control changes, Angular runs validation and generates either a list of validation errors that results in an INVALID status, or null, which results in a VALID status. You can then inspect the control's state by exporting ngModel to a local template variable. The following example exports NgModel into a variable called name: content_copy input type=\"text\" id=\"name\" name=\"name\" class=\"form-control\" required minlength=\"4\" appForbiddenName=\"bob\" [(ngModel)]=\"hero.name\" #name=\"ngModel\" / div *ngIf=\"name.invalid && (name.dirty  name.touched)\" class=\"alert\"  div *ngIf=\"name.errors?.['required']\"Name is required./div div *ngIf=\"name.errors?.['minlength']\" Name must be at least 4 characters long. /div div *ngIf=\"name.errors?.['forbiddenName']\" Name cannot be Bob. /div /div Notice the following features illustrated by the example. The input element carries the HTML validation attributes: required and minlength. It also carries a custom validator directive, forbiddenName. For more information, see the Custom validators section. #name=\"ngModel\" exports NgModel into a local variable called name. NgModel mirrors many of the properties of its underlying FormControl instance, so you can use this in the template to check for control states such as valid and dirty. For a full list of control properties, see the AbstractControl API reference. The *ngIf on the div element reveals a set of nested message divs but only if the name is invalid and the control is either dirty or touched. Each nested div can present a custom message for one of the possible validation errors. There are messages for required, minlength, and forbiddenName. To prevent the validator from displaying errors before the user has a chance to edit the form, you should check for either the dirty or touched states in a control. When the user changes the value in the watched field, the control is marked as \"dirty\" When the user blurs the form control element, the control is marked as \"touched\" Validating input in reactive formslink In a reactive form, the source of truth is the component class. Instead of adding validators through attributes in the template, you add validator functions directly to the form control model in the component class. Angular then calls these functions whenever the value of the control changes. Validator functionslink Validator functions can be either synchronous or asynchronous. Validator type Details Sync validators Synchronous functions that take a control instance and immediately return either a set of validation errors or null. Pass these in as the second argument when you instantiate a FormControl. Async validators Asynchronous functions that take a control instance and return a Promise or Observable that later emits a set of validation errors or null. Pass these in as the third argument when you instantiate a FormControl. For performance reasons, Angular only runs async validators if all sync validators pass. Each must complete before errors are set. Built-in validator functionslink You can choose to write your own validator functions, or you can use some of Angular's built-in validators. The same built-in validators that are available as attributes in template-driven forms, such as required and minlength, are all available to use as functions from the Validators class. For a full list of built-in validators, see the Validators API reference. To update the hero form to be a reactive form, use some of the same built-in validators this time, in function form, as in the following example. content_copy ngOnInit(): void { this.heroForm = new FormGroup({ name: new FormControl(this.hero.name, [ Validators.required, Validators.minLength(4), forbiddenNameValidator(/bob/i), // -- Here's how you pass in the custom validator. ]), alterEgo: new FormControl(this.hero.alterEgo), power: new FormControl(this.hero.power, Validators.required), }); } get name() { return this.heroForm.get('name'); } get power() { return this.heroForm.get('power'); } In this example, the name control sets up two built-in validators Validators.required and Validators.minLength(4) and one custom validator, forbiddenNameValidator. (For more details see custom validators.) All of these validators are synchronous, so they are passed as the second argument. Notice that you can support multiple validators by passing the functions in as an array. This example also adds a few getter methods. In a reactive form, you can always access any form control through the get method on its parent group, but sometimes it's useful to define getters as shorthand for the template. If you look at the template for the name input again, it is fairly similar to the template-driven example. content_copy input type=\"text\" id=\"name\" class=\"form-control\" formControlName=\"name\" required / div *ngIf=\"name.invalid && (name.dirty  name.touched)\" class=\"alert alert-danger\"  div *ngIf=\"name.errors?.['required']\"Name is required./div div *ngIf=\"name.errors?.['minlength']\" Name must be at least 4 characters long. /div div *ngIf=\"name.errors?.['forbiddenName']\" Name cannot be Bob. /div /div This form differs from the template-driven version in that it no longer exports any directives. Instead, it uses the name getter defined in the component class. Notice that the required attribute is still present in the template. Although it's not necessary for validation, it should be retained for accessibility purposes. Defining custom validatorslink The built-in validators don't always match the exact use case of your application, so you sometimes need to create a custom validator. Consider the forbiddenNameValidator function from previous reactive-form examples. Here's what the definition of that function looks like. content_copy /** A hero's name can't match the given regular expression */ export function forbiddenNameValidator(nameRe: RegExp): ValidatorFn { return (control: AbstractControl): ValidationErrors  null = { const forbidden = nameRe.test(control.value); return forbidden ? { forbiddenName: { value: control.value } } : null; }; } The function is a factory that takes a regular expression to detect a specific forbidden name and returns a validator function. In this sample, the forbidden name is \"bob\", so the validator rejects any hero name containing \"bob\". Elsewhere it could reject \"alice\" or any name that the configuring regular expression matches. The forbiddenNameValidator factory returns the configured validator function. That function takes an Angular control object and returns either null if the control value is valid or a validation error object. The validation error object typically has a property whose name is the validation key, 'forbiddenName', and whose value is an arbitrary dictionary of values that you could insert into an error message, {name}. Custom async validators are similar to sync validators, but they must instead return a Promise or observable that later emits null or a validation error object. In the case of an observable, the observable must complete, at which point the form uses the last value emitted for validation. Adding custom validators to reactive formslink In reactive forms, add a custom validator by passing the function directly to the FormControl. content_copy this.heroForm = new FormGroup({ name: new FormControl(this.hero.name, [ Validators.required, Validators.minLength(4), forbiddenNameValidator(/bob/i), // -- Here's how you pass in the custom validator. ]), alterEgo: new FormControl(this.hero.alterEgo), power: new FormControl(this.hero.power, Validators.required), }); Adding custom validators to template-driven formslink In template-driven forms, add a directive to the template, where the directive wraps the validator function. For example, the corresponding ForbiddenValidatorDirective serves as a wrapper around the forbiddenNameValidator. Angular recognizes the directive's role in the validation process because the directive registers itself with the NG_VALIDATORS provider, as shown in the following example. NG_VALIDATORS is a predefined provider with an extensible collection of validators. content_copy providers: [ { provide: NG_VALIDATORS, useExisting: ForbiddenValidatorDirective, multi: true, }, ], The directive class then implements the Validator interface, so that it can easily integrate with Angular forms. Here is the rest of the directive to help you get an idea of how it all comes together. content_copy @Directive({ selector: '[appForbiddenName]', providers: [ { provide: NG_VALIDATORS, useExisting: ForbiddenValidatorDirective, multi: true, }, ], standalone: true, }) export class ForbiddenValidatorDirective implements Validator { @Input('appForbiddenName') forbiddenName = ''; validate(control: AbstractControl): ValidationErrors  null { return this.forbiddenName ? forbiddenNameValidator(new RegExp(this.forbiddenName, 'i'))(control) : null; } } Once the ForbiddenValidatorDirective is ready, you can add its selector, appForbiddenName, to any input element to activate it. For example: content_copy input type=\"text\" id=\"name\" name=\"name\" class=\"form-control\" required minlength=\"4\" appForbiddenName=\"bob\" [(ngModel)]=\"hero.name\" #name=\"ngModel\" / Notice that the custom validation directive is instantiated with useExisting rather than useClass. The registered validator must be this instance of the ForbiddenValidatorDirective the instance in the form with its forbiddenName property bound to \"bob\". If you were to replace useExisting with useClass, then you'd be registering a new class instance, one that doesn't have a forbiddenName. Control status CSS classeslink Angular automatically mirrors many control properties onto the form control element as CSS classes. Use these classes to style form control elements according to the state of the form. The following classes are currently supported. .ng-valid .ng-invalid .ng-pending .ng-pristine .ng-dirty .ng-untouched .ng-touched .ng-submitted (enclosing form element only) In the following example, the hero form uses the .ng-valid and .ng-invalid classes to set the color of each form control's border. content_copy .ng-valid[required], .ng-valid.required { border-left: 5px solid #42A948; /* green */ } .ng-invalid:not(form) { border-left: 5px solid #a94442; /* red */ } .alert div { background-color: #fed3d3; color: #820000; padding: 1rem; margin-bottom: 1rem; } .form-group { margin-bottom: 1rem; } label { display: block; margin-bottom: .5rem; } select { width: 100%; padding: .5rem; } Cross-field validationlink A cross-field validator is a custom validator that compares the values of different fields in a form and accepts or rejects them in combination. For example, you might have a form that offers mutually incompatible options, so that if the user can choose A or B, but not both. Some field values might also depend on others; a user might be allowed to choose B only if A is also chosen. The following cross validation examples show how to do the following: Validate reactive or template-based form input based on the values of two sibling controls, Show a descriptive error message after the user interacted with the form and the validation failed. The examples use cross-validation to ensure that heroes do not reveal their true identities by filling out the Hero Form. The validators do this by checking that the hero names and alter egos do not match. Adding cross-validation to reactive formslink The form has the following structure: content_copy const heroForm = new FormGroup({ 'name': new FormControl(), 'alterEgo': new FormControl(), 'power': new FormControl() }); Notice that the name and alterEgo are sibling controls. To evaluate both controls in a single custom validator, you must perform the validation in a common ancestor control: the FormGroup. You query the FormGroup for its child controls so that you can compare their values. To add a validator to the FormGroup, pass the new validator in as the second argument on creation. content_copy const heroForm = new FormGroup({ 'name': new FormControl(), 'alterEgo': new FormControl(), 'power': new FormControl() }, { validators: identityRevealedValidator }); The validator code is as follows. content_copy /** A hero's name can't match the hero's alter ego */ export const identityRevealedValidator: ValidatorFn = ( control: AbstractControl, ): ValidationErrors  null = { const name = control.get('name'); const alterEgo = control.get('alterEgo'); return name && alterEgo && name.value === alterEgo.value ? { identityRevealed: true } : null; }; The identity validator implements the ValidatorFn interface. It takes an Angular control object as an argument and returns either null if the form is valid, or ValidationErrors otherwise. The validator retrieves the child controls by calling the FormGroup's get method, then compares the values of the name and alterEgo controls. If the values do not match, the hero's identity remains secret, both are valid, and the validator returns null. If they do match, the hero's identity is revealed and the validator must mark the form as invalid by returning an error object. To provide better user experience, the template shows an appropriate error message when the form is invalid. content_copy div *ngIf=\" heroForm.errors?.['identityRevealed'] && (heroForm.touched  heroForm.dirty) \" class=\"cross-validation-error-message alert alert-danger\"  Name cannot match alter ego. /div This *ngIf displays the error if the FormGroup has the cross validation error returned by the identityRevealed validator, but only if the user finished interacting with the form. Adding cross-validation to template-driven formslink For a template-driven form, you must create a directive to wrap the validator function. You provide that directive as the validator using the NG_VALIDATORS token, as shown in the following example. content_copy @Directive({ selector: '[appIdentityRevealed]', providers: [ { provide: NG_VALIDATORS, useExisting: IdentityRevealedValidatorDirective, multi: true, }, ], standalone: true, }) export class IdentityRevealedValidatorDirective implements Validator { validate(control: AbstractControl): ValidationErrors  null { return identityRevealedValidator(control); } } You must add the new directive to the HTML template. Because the validator must be registered at the highest level in the form, the following template puts the directive on the form tag. content_copy form #heroForm=\"ngForm\" appIdentityRevealed To provide better user experience, an appropriate error message appears when the form is invalid. content_copy div *ngIf=\" heroForm.errors?.['identityRevealed'] && (heroForm.touched  heroForm.dirty) \" class=\"cross-validation-error-message alert\"  Name cannot match alter ego. /div This is the same in both template-driven and reactive forms. Creating asynchronous validatorslink Asynchronous validators implement the AsyncValidatorFn and AsyncValidator interfaces. These are very similar to their synchronous counterparts, with the following differences. The validate() functions must return a Promise or an observable, The observable returned must be finite, meaning it must complete at some point. To convert an infinite observable into a finite one, pipe the observable through a filtering operator such as first, last, take, or takeUntil. Asynchronous validation happens after the synchronous validation, and is performed only if the synchronous validation is successful. This check lets forms avoid potentially expensive async validation processes (such as an HTTP request) if the more basic validation methods have already found invalid input. After asynchronous validation begins, the form control enters a pending state. Inspect the control's pending property and use it to give visual feedback about the ongoing validation operation. A common UI pattern is to show a spinner while the async validation is being performed. The following example shows how to achieve this in a template-driven form. content_copy input [(ngModel)]=\"name\" #model=\"ngModel\" appSomeAsyncValidator app-spinner *ngIf=\"model.pending\"/app-spinner Implementing a custom async validatorlink In the following example, an async validator ensures that heroes pick an alter ego that is not already taken. New heroes are constantly enlisting and old heroes are leaving the service, so the list of available alter egos cannot be retrieved ahead of time. To validate the potential alter ego entry, the validator must initiate an asynchronous operation to consult a central database of all currently enlisted heroes. The following code creates the validator class, UniqueAlterEgoValidator, which implements the AsyncValidator interface. content_copy @Injectable({ providedIn: 'root' }) export class UniqueAlterEgoValidator implements AsyncValidator { constructor(private heroesService: HeroesService) {} validate(control: AbstractControl): ObservableValidationErrors  null { return this.heroesService.isAlterEgoTaken(control.value).pipe( map((isTaken) = (isTaken ? { uniqueAlterEgo: true } : null)), catchError(() = of(null)), ); } } The constructor injects the HeroesService, which defines the following interface. content_copy interface HeroesService { isAlterEgoTaken: (alterEgo: string) = Observableboolean; } In a real world application, the HeroesService would be responsible for making an HTTP request to the hero database to check if the alter ego is available. From the validator's point of view, the actual implementation of the service is not important, so the example can just code against the HeroesService interface. As the validation begins, the UniqueAlterEgoValidator delegates to the HeroesService isAlterEgoTaken() method with the current control value. At this point the control is marked as pending and remains in this state until the observable chain returned from the validate() method completes. The isAlterEgoTaken() method dispatches an HTTP request that checks if the alter ego is available, and returns Observableboolean as the result. The validate() method pipes the response through the map operator and transforms it into a validation result. The method then, like any validator, returns null if the form is valid, and ValidationErrors if it is not. This validator handles any potential errors with the catchError operator. In this case, the validator treats the isAlterEgoTaken() error as a successful validation, because failure to make a validation request does not necessarily mean that the alter ego is invalid. You could handle the error differently and return the ValidationError object instead. After some time passes, the observable chain completes and the asynchronous validation is done. The pending flag is set to false, and the form validity is updated. Adding async validators to reactive formslink To use an async validator in reactive forms, begin by injecting the validator into the constructor of the component class. content_copy constructor(private alterEgoValidator: UniqueAlterEgoValidator) {} Then, pass the validator function directly to the FormControl to apply it. In the following example, the validate function of UniqueAlterEgoValidator is applied to alterEgoControl by passing it to the control's asyncValidators option and binding it to the instance of UniqueAlterEgoValidator that was injected into HeroFormReactiveComponent. The value of asyncValidators can be either a single async validator function, or an array of functions. To learn more about FormControl options, see the AbstractControlOptions API reference. content_copy const alterEgoControl = new FormControl('', { asyncValidators: [ this.alterEgoValidator.validate.bind(this.alterEgoValidator), ], updateOn: 'blur', }); Adding async validators to template-driven formslink To use an async validator in template-driven forms, create a new directive and register the NG_ASYNC_VALIDATORS provider on it. In the example below, the directive injects the UniqueAlterEgoValidator class that contains the actual validation logic and invokes it in the validate function, triggered by Angular when validation should happen. content_copy @Directive({ selector: '[appUniqueAlterEgo]', providers: [ { provide: NG_ASYNC_VALIDATORS, useExisting: forwardRef(() = UniqueAlterEgoValidatorDirective), multi: true, }, ], standalone: true, }) export class UniqueAlterEgoValidatorDirective implements AsyncValidator { constructor(private validator: UniqueAlterEgoValidator) {} validate(control: AbstractControl): ObservableValidationErrors  null { return this.validator.validate(control); } } Then, as with synchronous validators, add the directive's selector to an input to activate it. content_copy input type=\"text\" id=\"alterEgo\" name=\"alterEgo\" #alterEgo=\"ngModel\" [(ngModel)]=\"hero.alterEgo\" [ngModelOptions]=\"{ updateOn: 'blur' }\" appUniqueAlterEgo / Optimizing performance of async validatorslink By default, all validators run after every form value change. With synchronous validators, this does not normally have a noticeable impact on application performance. Async validators, however, commonly perform some kind of HTTP request to validate the control. Dispatching an HTTP request after every keystroke could put a strain on the backend API, and should be avoided if possible. You can delay updating the form validity by changing the updateOn property from change (default) to submit or blur. With template-driven forms, set the property in the template. content_copy input [(ngModel)]=\"name\" [ngModelOptions]=\"{updateOn: 'blur'}\" With reactive forms, set the property in the FormControl instance. content_copy new FormControl('', {updateOn: 'blur'}); Interaction with native HTML form validationlink By default, Angular disables native HTML form validation by adding the novalidate attribute on the enclosing form and uses directives to match these attributes with validator functions in the framework. If you want to use native validation in combination with Angular-based validation, you can re-enable it with the ngNativeValidate directive. See the API docs for details. Last reviewed on Tue Sep 12 2023",
    "headings": [
      {
        "level": 1,
        "text": "Validating form inputlink",
        "id": "validating-form-input"
      },
      {
        "level": 2,
        "text": "Prerequisiteslink",
        "id": "prerequisites"
      },
      {
        "level": 2,
        "text": "Validating input in template-driven formslink",
        "id": "validating-input-in-template-driven-forms"
      },
      {
        "level": 2,
        "text": "Validating input in reactive formslink",
        "id": "validating-input-in-reactive-forms"
      },
      {
        "level": 2,
        "text": "Defining custom validatorslink",
        "id": "defining-custom-validators"
      },
      {
        "level": 2,
        "text": "Control status CSS classeslink",
        "id": "control-status-css-classes"
      },
      {
        "level": 2,
        "text": "Cross-field validationlink",
        "id": "cross-field-validation"
      },
      {
        "level": 2,
        "text": "Creating asynchronous validatorslink",
        "id": "creating-asynchronous-validators"
      },
      {
        "level": 2,
        "text": "Interaction with native HTML form validationlink",
        "id": "interaction-with-native-html-form-validation"
      },
      {
        "level": 3,
        "text": "Validator functionslink",
        "id": "validator-functions"
      },
      {
        "level": 3,
        "text": "Built-in validator functionslink",
        "id": "built-in-validator-functions"
      },
      {
        "level": 3,
        "text": "Adding custom validators to reactive formslink",
        "id": "adding-custom-validators-to-reactive-forms"
      },
      {
        "level": 3,
        "text": "Adding custom validators to template-driven formslink",
        "id": "adding-custom-validators-to-template-driven-forms"
      },
      {
        "level": 3,
        "text": "Adding cross-validation to reactive formslink",
        "id": "adding-cross-validation-to-reactive-forms"
      },
      {
        "level": 3,
        "text": "Adding cross-validation to template-driven formslink",
        "id": "adding-cross-validation-to-template-driven-forms"
      },
      {
        "level": 3,
        "text": "Implementing a custom async validatorlink",
        "id": "implementing-a-custom-async-validator"
      },
      {
        "level": 3,
        "text": "Adding async validators to reactive formslink",
        "id": "adding-async-validators-to-reactive-forms"
      },
      {
        "level": 3,
        "text": "Adding async validators to template-driven formslink",
        "id": "adding-async-validators-to-template-driven-forms"
      },
      {
        "level": 3,
        "text": "Optimizing performance of async validatorslink",
        "id": "optimizing-performance-of-async-validators"
      }
    ],
    "codeBlocks": [
      {
        "language": "text",
        "code": "content_copy\n      \n      <input\n  type=\"text\"\n  id=\"name\"\n  name=\"name\"\n  class=\"form-control\"\n  required\n  minlength=\"4\"\n  appForbiddenName=\"bob\"\n  [(ngModel)]=\"hero.name\"\n  #name=\"ngModel\"\n/>\n\n<div\n  *ngIf=\"name.invalid && (name.dirty || name.touched)\"\n  class=\"alert\"\n>\n  <div *ngIf=\"name.errors?.['required']\">Name is required.</div>\n  <div *ngIf=\"name.errors?.['minlength']\">\n    Name must be at least 4 characters long.\n  </div>\n  <div *ngIf=\"name.errors?.['forbiddenName']\">\n    Name cannot be Bob.\n  </div>\n</div>"
      },
      {
        "language": "text",
        "code": "<input\n  type=\"text\"\n  id=\"name\"\n  name=\"name\"\n  class=\"form-control\"\n  required\n  minlength=\"4\"\n  appForbiddenName=\"bob\"\n  [(ngModel)]=\"hero.name\"\n  #name=\"ngModel\"\n/>\n\n<div\n  *ngIf=\"name.invalid && (name.dirty || name.touched)\"\n  class=\"alert\"\n>\n  <div *ngIf=\"name.errors?.['required']\">Name is required.</div>\n  <div *ngIf=\"name.errors?.['minlength']\">\n    Name must be at least 4 characters long.\n  </div>\n  <div *ngIf=\"name.errors?.['forbiddenName']\">\n    Name cannot be Bob.\n  </div>\n</div>"
      },
      {
        "language": "text",
        "code": "forbiddenName"
      },
      {
        "language": "text",
        "code": "#name=\"ngModel\""
      },
      {
        "language": "text",
        "code": "FormControl"
      },
      {
        "language": "text",
        "code": "forbiddenName"
      },
      {
        "language": "text",
        "code": "FormControl"
      },
      {
        "language": "text",
        "code": "FormControl"
      },
      {
        "language": "text",
        "code": "content_copy\n      \n      ngOnInit(): void {\n  this.heroForm = new FormGroup({\n    name: new FormControl(this.hero.name, [\n      Validators.required,\n      Validators.minLength(4),\n      forbiddenNameValidator(/bob/i), // <-- Here's how you pass in the custom validator.\n    ]),\n    alterEgo: new FormControl(this.hero.alterEgo),\n    power: new FormControl(this.hero.power, Validators.required),\n  });\n}\n\nget name() {\n  return this.heroForm.get('name');\n}\n\nget power() {\n  return this.heroForm.get('power');\n}"
      },
      {
        "language": "text",
        "code": "ngOnInit(): void {\n  this.heroForm = new FormGroup({\n    name: new FormControl(this.hero.name, [\n      Validators.required,\n      Validators.minLength(4),\n      forbiddenNameValidator(/bob/i), // <-- Here's how you pass in the custom validator.\n    ]),\n    alterEgo: new FormControl(this.hero.alterEgo),\n    power: new FormControl(this.hero.power, Validators.required),\n  });\n}\n\nget name() {\n  return this.heroForm.get('name');\n}\n\nget power() {\n  return this.heroForm.get('power');\n}"
      },
      {
        "language": "text",
        "code": "Validators.required"
      },
      {
        "language": "text",
        "code": "Validators.minLength(4)"
      },
      {
        "language": "text",
        "code": "forbiddenNameValidator"
      },
      {
        "language": "text",
        "code": "content_copy\n      \n      <input\n  type=\"text\"\n  id=\"name\"\n  class=\"form-control\"\n  formControlName=\"name\"\n  required\n/>\n\n<div\n  *ngIf=\"name.invalid && (name.dirty || name.touched)\"\n  class=\"alert alert-danger\"\n>\n  <div *ngIf=\"name.errors?.['required']\">Name is required.</div>\n  <div *ngIf=\"name.errors?.['minlength']\">\n    Name must be at least 4 characters long.\n  </div>\n  <div *ngIf=\"name.errors?.['forbiddenName']\">\n    Name cannot be Bob.\n  </div>\n</div>"
      },
      {
        "language": "text",
        "code": "<input\n  type=\"text\"\n  id=\"name\"\n  class=\"form-control\"\n  formControlName=\"name\"\n  required\n/>\n\n<div\n  *ngIf=\"name.invalid && (name.dirty || name.touched)\"\n  class=\"alert alert-danger\"\n>\n  <div *ngIf=\"name.errors?.['required']\">Name is required.</div>\n  <div *ngIf=\"name.errors?.['minlength']\">\n    Name must be at least 4 characters long.\n  </div>\n  <div *ngIf=\"name.errors?.['forbiddenName']\">\n    Name cannot be Bob.\n  </div>\n</div>"
      },
      {
        "language": "text",
        "code": "forbiddenNameValidator"
      },
      {
        "language": "text",
        "code": "content_copy\n      \n      /** A hero's name can't match the given regular expression */\nexport function forbiddenNameValidator(nameRe: RegExp): ValidatorFn {\n  return (control: AbstractControl): ValidationErrors | null => {\n    const forbidden = nameRe.test(control.value);\n    return forbidden ? { forbiddenName: { value: control.value } } : null;\n  };\n}"
      },
      {
        "language": "text",
        "code": "/** A hero's name can't match the given regular expression */\nexport function forbiddenNameValidator(nameRe: RegExp): ValidatorFn {\n  return (control: AbstractControl): ValidationErrors | null => {\n    const forbidden = nameRe.test(control.value);\n    return forbidden ? { forbiddenName: { value: control.value } } : null;\n  };\n}"
      },
      {
        "language": "text",
        "code": "forbiddenNameValidator"
      },
      {
        "language": "text",
        "code": "'forbiddenName'"
      },
      {
        "language": "text",
        "code": "FormControl"
      },
      {
        "language": "text",
        "code": "content_copy\n      \n      this.heroForm = new FormGroup({\n  name: new FormControl(this.hero.name, [\n    Validators.required,\n    Validators.minLength(4),\n    forbiddenNameValidator(/bob/i), // <-- Here's how you pass in the custom validator.\n  ]),\n  alterEgo: new FormControl(this.hero.alterEgo),\n  power: new FormControl(this.hero.power, Validators.required),\n});"
      },
      {
        "language": "text",
        "code": "this.heroForm = new FormGroup({\n  name: new FormControl(this.hero.name, [\n    Validators.required,\n    Validators.minLength(4),\n    forbiddenNameValidator(/bob/i), // <-- Here's how you pass in the custom validator.\n  ]),\n  alterEgo: new FormControl(this.hero.alterEgo),\n  power: new FormControl(this.hero.power, Validators.required),\n});"
      },
      {
        "language": "text",
        "code": "ForbiddenValidatorDirective"
      },
      {
        "language": "text",
        "code": "forbiddenNameValidator"
      },
      {
        "language": "text",
        "code": "NG_VALIDATORS"
      },
      {
        "language": "text",
        "code": "NG_VALIDATORS"
      },
      {
        "language": "text",
        "code": "content_copy\n      \n      providers: [\n  {\n    provide: NG_VALIDATORS,\n    useExisting: ForbiddenValidatorDirective,\n    multi: true,\n  },\n],"
      },
      {
        "language": "text",
        "code": "providers: [\n  {\n    provide: NG_VALIDATORS,\n    useExisting: ForbiddenValidatorDirective,\n    multi: true,\n  },\n],"
      },
      {
        "language": "text",
        "code": "content_copy\n      \n      @Directive({\n  selector: '[appForbiddenName]',\n  providers: [\n    {\n      provide: NG_VALIDATORS,\n      useExisting: ForbiddenValidatorDirective,\n      multi: true,\n    },\n  ],\n  standalone: true,\n})\nexport class ForbiddenValidatorDirective implements Validator {\n  @Input('appForbiddenName') forbiddenName = '';\n\n  validate(control: AbstractControl): ValidationErrors | null {\n    return this.forbiddenName\n      ? forbiddenNameValidator(new RegExp(this.forbiddenName, 'i'))(control)\n      : null;\n  }\n}"
      },
      {
        "language": "text",
        "code": "@Directive({\n  selector: '[appForbiddenName]',\n  providers: [\n    {\n      provide: NG_VALIDATORS,\n      useExisting: ForbiddenValidatorDirective,\n      multi: true,\n    },\n  ],\n  standalone: true,\n})\nexport class ForbiddenValidatorDirective implements Validator {\n  @Input('appForbiddenName') forbiddenName = '';\n\n  validate(control: AbstractControl): ValidationErrors | null {\n    return this.forbiddenName\n      ? forbiddenNameValidator(new RegExp(this.forbiddenName, 'i'))(control)\n      : null;\n  }\n}"
      },
      {
        "language": "text",
        "code": "ForbiddenValidatorDirective"
      },
      {
        "language": "text",
        "code": "appForbiddenName"
      },
      {
        "language": "text",
        "code": "content_copy\n      \n      <input\n  type=\"text\"\n  id=\"name\"\n  name=\"name\"\n  class=\"form-control\"\n  required\n  minlength=\"4\"\n  appForbiddenName=\"bob\"\n  [(ngModel)]=\"hero.name\"\n  #name=\"ngModel\"\n/>"
      },
      {
        "language": "text",
        "code": "<input\n  type=\"text\"\n  id=\"name\"\n  name=\"name\"\n  class=\"form-control\"\n  required\n  minlength=\"4\"\n  appForbiddenName=\"bob\"\n  [(ngModel)]=\"hero.name\"\n  #name=\"ngModel\"\n/>"
      },
      {
        "language": "text",
        "code": "useExisting"
      },
      {
        "language": "text",
        "code": "ForbiddenValidatorDirective"
      },
      {
        "language": "text",
        "code": "forbiddenName"
      },
      {
        "language": "text",
        "code": "useExisting"
      },
      {
        "language": "text",
        "code": "forbiddenName"
      },
      {
        "language": "text",
        "code": ".ng-invalid"
      },
      {
        "language": "text",
        "code": ".ng-pending"
      },
      {
        "language": "text",
        "code": ".ng-pristine"
      },
      {
        "language": "text",
        "code": ".ng-untouched"
      },
      {
        "language": "text",
        "code": ".ng-touched"
      },
      {
        "language": "text",
        "code": ".ng-submitted"
      },
      {
        "language": "text",
        "code": ".ng-invalid"
      },
      {
        "language": "text",
        "code": "content_copy\n      \n      .ng-valid[required], .ng-valid.required  {\n  border-left: 5px solid #42A948; /* green */\n}\n\n.ng-invalid:not(form)  {\n  border-left: 5px solid #a94442; /* red */\n}\n\n.alert div {\n  background-color: #fed3d3;\n  color: #820000;\n  padding: 1rem;\n  margin-bottom: 1rem;\n}\n\n.form-group {\n  margin-bottom: 1rem;\n}\n\nlabel {\n  display: block;\n  margin-bottom: .5rem;\n}\n\nselect {\n  width: 100%;\n  padding: .5rem;\n}"
      },
      {
        "language": "text",
        "code": ".ng-valid[required], .ng-valid.required  {\n  border-left: 5px solid #42A948; /* green */\n}\n\n.ng-invalid:not(form)  {\n  border-left: 5px solid #a94442; /* red */\n}\n\n.alert div {\n  background-color: #fed3d3;\n  color: #820000;\n  padding: 1rem;\n  margin-bottom: 1rem;\n}\n\n.form-group {\n  margin-bottom: 1rem;\n}\n\nlabel {\n  display: block;\n  margin-bottom: .5rem;\n}\n\nselect {\n  width: 100%;\n  padding: .5rem;\n}"
      },
      {
        "language": "text",
        "code": "content_copy\n      \n      const heroForm = new FormGroup({\n  'name': new FormControl(),\n  'alterEgo': new FormControl(),\n  'power': new FormControl()\n});"
      },
      {
        "language": "text",
        "code": "const heroForm = new FormGroup({\n  'name': new FormControl(),\n  'alterEgo': new FormControl(),\n  'power': new FormControl()\n});"
      },
      {
        "language": "text",
        "code": "content_copy\n      \n      const heroForm = new FormGroup({\n  'name': new FormControl(),\n  'alterEgo': new FormControl(),\n  'power': new FormControl()\n}, { validators: identityRevealedValidator });"
      },
      {
        "language": "text",
        "code": "const heroForm = new FormGroup({\n  'name': new FormControl(),\n  'alterEgo': new FormControl(),\n  'power': new FormControl()\n}, { validators: identityRevealedValidator });"
      },
      {
        "language": "text",
        "code": "content_copy\n      \n      /** A hero's name can't match the hero's alter ego */\nexport const identityRevealedValidator: ValidatorFn = (\n  control: AbstractControl,\n): ValidationErrors | null => {\n  const name = control.get('name');\n  const alterEgo = control.get('alterEgo');\n\n  return name && alterEgo && name.value === alterEgo.value\n    ? { identityRevealed: true }\n    : null;\n};"
      },
      {
        "language": "text",
        "code": "/** A hero's name can't match the hero's alter ego */\nexport const identityRevealedValidator: ValidatorFn = (\n  control: AbstractControl,\n): ValidationErrors | null => {\n  const name = control.get('name');\n  const alterEgo = control.get('alterEgo');\n\n  return name && alterEgo && name.value === alterEgo.value\n    ? { identityRevealed: true }\n    : null;\n};"
      },
      {
        "language": "text",
        "code": "ValidatorFn"
      },
      {
        "language": "text",
        "code": "ValidationErrors"
      },
      {
        "language": "text",
        "code": "content_copy\n      \n      <div\n  *ngIf=\"\n    heroForm.errors?.['identityRevealed'] &&\n    (heroForm.touched || heroForm.dirty)\n  \"\n  class=\"cross-validation-error-message alert alert-danger\"\n>\n  Name cannot match alter ego.\n</div>"
      },
      {
        "language": "text",
        "code": "<div\n  *ngIf=\"\n    heroForm.errors?.['identityRevealed'] &&\n    (heroForm.touched || heroForm.dirty)\n  \"\n  class=\"cross-validation-error-message alert alert-danger\"\n>\n  Name cannot match alter ego.\n</div>"
      },
      {
        "language": "text",
        "code": "identityRevealed"
      },
      {
        "language": "text",
        "code": "NG_VALIDATORS"
      },
      {
        "language": "text",
        "code": "content_copy\n      \n      @Directive({\n  selector: '[appIdentityRevealed]',\n  providers: [\n    {\n      provide: NG_VALIDATORS,\n      useExisting: IdentityRevealedValidatorDirective,\n      multi: true,\n    },\n  ],\n  standalone: true,\n})\nexport class IdentityRevealedValidatorDirective implements Validator {\n  validate(control: AbstractControl): ValidationErrors | null {\n    return identityRevealedValidator(control);\n  }\n}"
      },
      {
        "language": "text",
        "code": "@Directive({\n  selector: '[appIdentityRevealed]',\n  providers: [\n    {\n      provide: NG_VALIDATORS,\n      useExisting: IdentityRevealedValidatorDirective,\n      multi: true,\n    },\n  ],\n  standalone: true,\n})\nexport class IdentityRevealedValidatorDirective implements Validator {\n  validate(control: AbstractControl): ValidationErrors | null {\n    return identityRevealedValidator(control);\n  }\n}"
      },
      {
        "language": "text",
        "code": "content_copy\n      \n      <form #heroForm=\"ngForm\" appIdentityRevealed>"
      },
      {
        "language": "text",
        "code": "<form #heroForm=\"ngForm\" appIdentityRevealed>"
      },
      {
        "language": "text",
        "code": "content_copy\n      \n      <div\n  *ngIf=\"\n    heroForm.errors?.['identityRevealed'] &&\n    (heroForm.touched || heroForm.dirty)\n  \"\n  class=\"cross-validation-error-message alert\"\n>\n  Name cannot match alter ego.\n</div>"
      },
      {
        "language": "text",
        "code": "<div\n  *ngIf=\"\n    heroForm.errors?.['identityRevealed'] &&\n    (heroForm.touched || heroForm.dirty)\n  \"\n  class=\"cross-validation-error-message alert\"\n>\n  Name cannot match alter ego.\n</div>"
      },
      {
        "language": "text",
        "code": "AsyncValidatorFn"
      },
      {
        "language": "text",
        "code": "AsyncValidator"
      },
      {
        "language": "text",
        "code": "content_copy\n      \n      <input [(ngModel)]=\"name\" #model=\"ngModel\" appSomeAsyncValidator>\n<app-spinner *ngIf=\"model.pending\"></app-spinner>"
      },
      {
        "language": "text",
        "code": "<input [(ngModel)]=\"name\" #model=\"ngModel\" appSomeAsyncValidator>\n<app-spinner *ngIf=\"model.pending\"></app-spinner>"
      },
      {
        "language": "text",
        "code": "UniqueAlterEgoValidator"
      },
      {
        "language": "text",
        "code": "AsyncValidator"
      },
      {
        "language": "text",
        "code": "content_copy\n      \n      @Injectable({ providedIn: 'root' })\nexport class UniqueAlterEgoValidator implements AsyncValidator {\n  constructor(private heroesService: HeroesService) {}\n\n  validate(control: AbstractControl): Observable<ValidationErrors | null> {\n    return this.heroesService.isAlterEgoTaken(control.value).pipe(\n      map((isTaken) => (isTaken ? { uniqueAlterEgo: true } : null)),\n      catchError(() => of(null)),\n    );\n  }\n}"
      },
      {
        "language": "text",
        "code": "@Injectable({ providedIn: 'root' })\nexport class UniqueAlterEgoValidator implements AsyncValidator {\n  constructor(private heroesService: HeroesService) {}\n\n  validate(control: AbstractControl): Observable<ValidationErrors | null> {\n    return this.heroesService.isAlterEgoTaken(control.value).pipe(\n      map((isTaken) => (isTaken ? { uniqueAlterEgo: true } : null)),\n      catchError(() => of(null)),\n    );\n  }\n}"
      },
      {
        "language": "text",
        "code": "HeroesService"
      },
      {
        "language": "text",
        "code": "content_copy\n      \n      interface HeroesService {\n  isAlterEgoTaken: (alterEgo: string) => Observable<boolean>;\n}"
      },
      {
        "language": "text",
        "code": "interface HeroesService {\n  isAlterEgoTaken: (alterEgo: string) => Observable<boolean>;\n}"
      },
      {
        "language": "text",
        "code": "HeroesService"
      },
      {
        "language": "text",
        "code": "HeroesService"
      },
      {
        "language": "text",
        "code": "UniqueAlterEgoValidator"
      },
      {
        "language": "text",
        "code": "HeroesService"
      },
      {
        "language": "text",
        "code": "isAlterEgoTaken()"
      },
      {
        "language": "text",
        "code": "isAlterEgoTaken()"
      },
      {
        "language": "text",
        "code": "Observable<boolean>"
      },
      {
        "language": "text",
        "code": "ValidationErrors"
      },
      {
        "language": "text",
        "code": "isAlterEgoTaken()"
      },
      {
        "language": "text",
        "code": "ValidationError"
      },
      {
        "language": "text",
        "code": "content_copy\n      \n      constructor(private alterEgoValidator: UniqueAlterEgoValidator) {}"
      },
      {
        "language": "text",
        "code": "constructor(private alterEgoValidator: UniqueAlterEgoValidator) {}"
      },
      {
        "language": "text",
        "code": "FormControl"
      },
      {
        "language": "text",
        "code": "UniqueAlterEgoValidator"
      },
      {
        "language": "text",
        "code": "alterEgoControl"
      },
      {
        "language": "text",
        "code": "asyncValidators"
      },
      {
        "language": "text",
        "code": "UniqueAlterEgoValidator"
      },
      {
        "language": "text",
        "code": "HeroFormReactiveComponent"
      },
      {
        "language": "text",
        "code": "asyncValidators"
      },
      {
        "language": "text",
        "code": "FormControl"
      },
      {
        "language": "text",
        "code": "content_copy\n      \n      const alterEgoControl = new FormControl('', {\n  asyncValidators: [\n    this.alterEgoValidator.validate.bind(this.alterEgoValidator),\n  ],\n  updateOn: 'blur',\n});"
      },
      {
        "language": "text",
        "code": "const alterEgoControl = new FormControl('', {\n  asyncValidators: [\n    this.alterEgoValidator.validate.bind(this.alterEgoValidator),\n  ],\n  updateOn: 'blur',\n});"
      },
      {
        "language": "text",
        "code": "NG_ASYNC_VALIDATORS"
      },
      {
        "language": "text",
        "code": "UniqueAlterEgoValidator"
      },
      {
        "language": "text",
        "code": "content_copy\n      \n      @Directive({\n  selector: '[appUniqueAlterEgo]',\n  providers: [\n    {\n      provide: NG_ASYNC_VALIDATORS,\n      useExisting: forwardRef(() => UniqueAlterEgoValidatorDirective),\n      multi: true,\n    },\n  ],\n  standalone: true,\n})\nexport class UniqueAlterEgoValidatorDirective implements AsyncValidator {\n  constructor(private validator: UniqueAlterEgoValidator) {}\n\n  validate(control: AbstractControl): Observable<ValidationErrors | null> {\n    return this.validator.validate(control);\n  }\n}"
      },
      {
        "language": "text",
        "code": "@Directive({\n  selector: '[appUniqueAlterEgo]',\n  providers: [\n    {\n      provide: NG_ASYNC_VALIDATORS,\n      useExisting: forwardRef(() => UniqueAlterEgoValidatorDirective),\n      multi: true,\n    },\n  ],\n  standalone: true,\n})\nexport class UniqueAlterEgoValidatorDirective implements AsyncValidator {\n  constructor(private validator: UniqueAlterEgoValidator) {}\n\n  validate(control: AbstractControl): Observable<ValidationErrors | null> {\n    return this.validator.validate(control);\n  }\n}"
      },
      {
        "language": "text",
        "code": "content_copy\n      \n      <input\n  type=\"text\"\n  id=\"alterEgo\"\n  name=\"alterEgo\"\n  #alterEgo=\"ngModel\"\n  [(ngModel)]=\"hero.alterEgo\"\n  [ngModelOptions]=\"{ updateOn: 'blur' }\"\n  appUniqueAlterEgo\n/>"
      },
      {
        "language": "text",
        "code": "<input\n  type=\"text\"\n  id=\"alterEgo\"\n  name=\"alterEgo\"\n  #alterEgo=\"ngModel\"\n  [(ngModel)]=\"hero.alterEgo\"\n  [ngModelOptions]=\"{ updateOn: 'blur' }\"\n  appUniqueAlterEgo\n/>"
      },
      {
        "language": "text",
        "code": "content_copy\n      \n      <input [(ngModel)]=\"name\" [ngModelOptions]=\"{updateOn: 'blur'}\">"
      },
      {
        "language": "text",
        "code": "<input [(ngModel)]=\"name\" [ngModelOptions]=\"{updateOn: 'blur'}\">"
      },
      {
        "language": "text",
        "code": "FormControl"
      },
      {
        "language": "text",
        "code": "content_copy\n      \n      new FormControl('', {updateOn: 'blur'});"
      },
      {
        "language": "text",
        "code": "new FormControl('', {updateOn: 'blur'});"
      },
      {
        "language": "text",
        "code": "ngNativeValidate"
      }
    ],
    "links": [
      {
        "text": "link",
        "href": "guide/form-validation#validating-form-input"
      },
      {
        "text": "Prerequisites",
        "href": "guide/form-validation#prerequisites"
      },
      {
        "text": "Validating input in template-driven forms",
        "href": "guide/form-validation#validating-input-in-template-driven-forms"
      },
      {
        "text": "Validating input in reactive forms",
        "href": "guide/form-validation#validating-input-in-reactive-forms"
      },
      {
        "text": "Validator functions",
        "href": "guide/form-validation#validator-functions"
      },
      {
        "text": "Built-in validator functions",
        "href": "guide/form-validation#built-in-validator-functions"
      },
      {
        "text": "Defining custom validators",
        "href": "guide/form-validation#defining-custom-validators"
      },
      {
        "text": "Adding custom validators to reactive forms",
        "href": "guide/form-validation#adding-custom-validators-to-reactive-forms"
      },
      {
        "text": "Adding custom validators to template-driven forms",
        "href": "guide/form-validation#adding-custom-validators-to-template-driven-forms"
      },
      {
        "text": "Control status CSS classes",
        "href": "guide/form-validation#control-status-css-classes"
      },
      {
        "text": "Cross-field validation",
        "href": "guide/form-validation#cross-field-validation"
      },
      {
        "text": "Adding cross-validation to reactive forms",
        "href": "guide/form-validation#adding-cross-validation-to-reactive-forms"
      },
      {
        "text": "Adding cross-validation to template-driven forms",
        "href": "guide/form-validation#adding-cross-validation-to-template-driven-forms"
      },
      {
        "text": "Creating asynchronous validators",
        "href": "guide/form-validation#creating-asynchronous-validators"
      },
      {
        "text": "Implementing a custom async validator",
        "href": "guide/form-validation#implementing-a-custom-async-validator"
      },
      {
        "text": "Adding async validators to reactive forms",
        "href": "guide/form-validation#adding-async-validators-to-reactive-forms"
      },
      {
        "text": "Adding async validators to template-driven forms",
        "href": "guide/form-validation#adding-async-validators-to-template-driven-forms"
      },
      {
        "text": "Optimizing performance of async validators",
        "href": "guide/form-validation#optimizing-performance-of-async-validators"
      },
      {
        "text": "Interaction with native HTML form validation",
        "href": "guide/form-validation#interaction-with-native-html-form-validation"
      },
      {
        "text": "link",
        "href": "guide/form-validation#prerequisites"
      },
      {
        "text": "TypeScript",
        "href": "https://www.typescriptlang.org/"
      },
      {
        "text": "Angular application design",
        "href": "guide/architecture"
      },
      {
        "text": "two types of forms that Angular supports",
        "href": "guide/forms-overview"
      },
      {
        "text": "Template-driven Forms",
        "href": "guide/forms"
      },
      {
        "text": "Reactive Forms",
        "href": "guide/reactive-forms"
      },
      {
        "text": "live example",
        "href": "generated/live-examples/form-validation/stackblitz.html"
      },
      {
        "text": "download example",
        "href": "generated/zips/form-validation/form-validation.zip"
      },
      {
        "text": "link",
        "href": "guide/form-validation#validating-input-in-template-driven-forms"
      },
      {
        "text": "native HTML form validation",
        "href": "https://developer.mozilla.org/docs/Web/Guide/HTML/HTML5/Constraint_validation"
      },
      {
        "text": "ngModel",
        "href": "api/forms/NgModel"
      },
      {
        "text": "NgModel",
        "href": "api/forms/NgModel"
      },
      {
        "text": "minlength",
        "href": "api/forms/MinLengthValidator"
      },
      {
        "text": "ngModel",
        "href": "api/forms/NgModel"
      },
      {
        "text": "ngModel",
        "href": "api/forms/NgModel"
      },
      {
        "text": "ngIf",
        "href": "api/common/NgIf"
      },
      {
        "text": "ngIf",
        "href": "api/common/NgIf"
      },
      {
        "text": "ngIf",
        "href": "api/common/NgIf"
      },
      {
        "text": "minlength",
        "href": "api/forms/MinLengthValidator"
      },
      {
        "text": "ngIf",
        "href": "api/common/NgIf"
      },
      {
        "text": "minlength",
        "href": "api/forms/MinLengthValidator"
      },
      {
        "text": "Custom validators",
        "href": "guide/form-validation#custom-validators"
      },
      {
        "text": "ngModel",
        "href": "api/forms/NgModel"
      },
      {
        "text": "NgModel",
        "href": "api/forms/NgModel"
      },
      {
        "text": "NgModel",
        "href": "api/forms/NgModel"
      },
      {
        "text": "FormControl",
        "href": "api/forms/FormControl"
      },
      {
        "text": "AbstractControl",
        "href": "api/forms/AbstractControl"
      },
      {
        "text": "ngIf",
        "href": "api/common/NgIf"
      },
      {
        "text": "minlength",
        "href": "api/forms/MinLengthValidator"
      },
      {
        "text": "link",
        "href": "guide/form-validation#validating-input-in-reactive-forms"
      },
      {
        "text": "link",
        "href": "guide/form-validation#validator-functions"
      },
      {
        "text": "FormControl",
        "href": "api/forms/FormControl"
      },
      {
        "text": "FormControl",
        "href": "api/forms/FormControl"
      },
      {
        "text": "link",
        "href": "guide/form-validation#built-in-validator-functions"
      },
      {
        "text": "write your own validator functions",
        "href": "guide/form-validation#custom-validators"
      },
      {
        "text": "minlength",
        "href": "api/forms/MinLengthValidator"
      },
      {
        "text": "Validators",
        "href": "api/forms/Validators"
      },
      {
        "text": "Validators",
        "href": "api/forms/Validators"
      },
      {
        "text": "FormGroup",
        "href": "api/forms/FormGroup"
      },
      {
        "text": "FormControl",
        "href": "api/forms/FormControl"
      },
      {
        "text": "FormControl",
        "href": "api/forms/FormControl"
      },
      {
        "text": "FormControl",
        "href": "api/forms/FormControl"
      },
      {
        "text": "custom validators",
        "href": "guide/form-validation#custom-validators"
      },
      {
        "text": "formControlName",
        "href": "api/forms/FormControlName"
      },
      {
        "text": "ngIf",
        "href": "api/common/NgIf"
      },
      {
        "text": "ngIf",
        "href": "api/common/NgIf"
      },
      {
        "text": "ngIf",
        "href": "api/common/NgIf"
      },
      {
        "text": "minlength",
        "href": "api/forms/MinLengthValidator"
      },
      {
        "text": "ngIf",
        "href": "api/common/NgIf"
      },
      {
        "text": "link",
        "href": "guide/form-validation#defining-custom-validators"
      },
      {
        "text": "reactive-form examples",
        "href": "guide/form-validation#reactive-component-class"
      },
      {
        "text": "ValidatorFn",
        "href": "api/forms/ValidatorFn"
      },
      {
        "text": "AbstractControl",
        "href": "api/forms/AbstractControl"
      },
      {
        "text": "ValidationErrors",
        "href": "api/forms/ValidationErrors"
      },
      {
        "text": "link",
        "href": "guide/form-validation#adding-custom-validators-to-reactive-forms"
      },
      {
        "text": "FormControl",
        "href": "api/forms/FormControl"
      },
      {
        "text": "FormGroup",
        "href": "api/forms/FormGroup"
      },
      {
        "text": "FormControl",
        "href": "api/forms/FormControl"
      },
      {
        "text": "FormControl",
        "href": "api/forms/FormControl"
      },
      {
        "text": "FormControl",
        "href": "api/forms/FormControl"
      },
      {
        "text": "link",
        "href": "guide/form-validation#adding-custom-validators-to-template-driven-forms"
      },
      {
        "text": "NG_VALIDATORS",
        "href": "api/forms/NG_VALIDATORS"
      },
      {
        "text": "NG_VALIDATORS",
        "href": "api/forms/NG_VALIDATORS"
      },
      {
        "text": "NG_VALIDATORS",
        "href": "api/forms/NG_VALIDATORS"
      },
      {
        "text": "Validator",
        "href": "api/forms/Validator"
      },
      {
        "text": "Directive",
        "href": "api/core/Directive"
      },
      {
        "text": "NG_VALIDATORS",
        "href": "api/forms/NG_VALIDATORS"
      },
      {
        "text": "Validator",
        "href": "api/forms/Validator"
      },
      {
        "text": "Input",
        "href": "api/core/Input"
      },
      {
        "text": "AbstractControl",
        "href": "api/forms/AbstractControl"
      },
      {
        "text": "ValidationErrors",
        "href": "api/forms/ValidationErrors"
      },
      {
        "text": "minlength",
        "href": "api/forms/MinLengthValidator"
      },
      {
        "text": "ngModel",
        "href": "api/forms/NgModel"
      },
      {
        "text": "ngModel",
        "href": "api/forms/NgModel"
      },
      {
        "text": "link",
        "href": "guide/form-validation#control-status-css-classes"
      },
      {
        "text": "link",
        "href": "guide/form-validation#cross-field-validation"
      },
      {
        "text": "custom validator",
        "href": "guide/form-validation#custom-validators"
      },
      {
        "text": "link",
        "href": "guide/form-validation#adding-cross-validation-to-reactive-forms"
      },
      {
        "text": "FormGroup",
        "href": "api/forms/FormGroup"
      },
      {
        "text": "FormControl",
        "href": "api/forms/FormControl"
      },
      {
        "text": "FormControl",
        "href": "api/forms/FormControl"
      },
      {
        "text": "FormControl",
        "href": "api/forms/FormControl"
      },
      {
        "text": "FormGroup",
        "href": "api/forms/FormGroup"
      },
      {
        "text": "FormGroup",
        "href": "api/forms/FormGroup"
      },
      {
        "text": "FormGroup",
        "href": "api/forms/FormGroup"
      },
      {
        "text": "FormGroup",
        "href": "api/forms/FormGroup"
      },
      {
        "text": "FormControl",
        "href": "api/forms/FormControl"
      },
      {
        "text": "FormControl",
        "href": "api/forms/FormControl"
      },
      {
        "text": "FormControl",
        "href": "api/forms/FormControl"
      },
      {
        "text": "ValidatorFn",
        "href": "api/forms/ValidatorFn"
      },
      {
        "text": "AbstractControl",
        "href": "api/forms/AbstractControl"
      },
      {
        "text": "ValidationErrors",
        "href": "api/forms/ValidationErrors"
      },
      {
        "text": "ValidatorFn",
        "href": "api/forms/ValidatorFn"
      },
      {
        "text": "ValidationErrors",
        "href": "api/forms/ValidationErrors"
      },
      {
        "text": "FormGroup",
        "href": "api/forms/FormGroup"
      },
      {
        "text": "get",
        "href": "api/forms/AbstractControl#get"
      },
      {
        "text": "ngIf",
        "href": "api/common/NgIf"
      },
      {
        "text": "ngIf",
        "href": "api/common/NgIf"
      },
      {
        "text": "FormGroup",
        "href": "api/forms/FormGroup"
      },
      {
        "text": "interacting with the form",
        "href": "guide/form-validation#dirty-or-touched"
      },
      {
        "text": "link",
        "href": "guide/form-validation#adding-cross-validation-to-template-driven-forms"
      },
      {
        "text": "NG_VALIDATORS token",
        "href": "guide/form-validation#adding-to-template-driven-forms"
      },
      {
        "text": "Directive",
        "href": "api/core/Directive"
      },
      {
        "text": "NG_VALIDATORS",
        "href": "api/forms/NG_VALIDATORS"
      },
      {
        "text": "Validator",
        "href": "api/forms/Validator"
      },
      {
        "text": "AbstractControl",
        "href": "api/forms/AbstractControl"
      },
      {
        "text": "ValidationErrors",
        "href": "api/forms/ValidationErrors"
      },
      {
        "text": "ngForm",
        "href": "api/forms/NgForm"
      },
      {
        "text": "ngIf",
        "href": "api/common/NgIf"
      },
      {
        "text": "link",
        "href": "guide/form-validation#creating-asynchronous-validators"
      },
      {
        "text": "AsyncValidatorFn",
        "href": "api/forms/AsyncValidatorFn"
      },
      {
        "text": "AsyncValidator",
        "href": "api/forms/AsyncValidator"
      },
      {
        "text": "ngModel",
        "href": "api/forms/NgModel"
      },
      {
        "text": "model",
        "href": "api/core/model"
      },
      {
        "text": "ngModel",
        "href": "api/forms/NgModel"
      },
      {
        "text": "ngIf",
        "href": "api/common/NgIf"
      },
      {
        "text": "link",
        "href": "guide/form-validation#implementing-a-custom-async-validator"
      },
      {
        "text": "AsyncValidator",
        "href": "api/forms/AsyncValidator"
      },
      {
        "text": "Injectable",
        "href": "api/core/Injectable"
      },
      {
        "text": "AsyncValidator",
        "href": "api/forms/AsyncValidator"
      },
      {
        "text": "AbstractControl",
        "href": "api/forms/AbstractControl"
      },
      {
        "text": "ValidationErrors",
        "href": "api/forms/ValidationErrors"
      },
      {
        "text": "ValidationErrors",
        "href": "api/forms/ValidationErrors"
      },
      {
        "text": "link",
        "href": "guide/form-validation#adding-async-validators-to-reactive-forms"
      },
      {
        "text": "FormControl",
        "href": "api/forms/FormControl"
      },
      {
        "text": "FormControl",
        "href": "api/forms/FormControl"
      },
      {
        "text": "AbstractControlOptions",
        "href": "api/forms/AbstractControlOptions"
      },
      {
        "text": "FormControl",
        "href": "api/forms/FormControl"
      },
      {
        "text": "link",
        "href": "guide/form-validation#adding-async-validators-to-template-driven-forms"
      },
      {
        "text": "NG_ASYNC_VALIDATORS",
        "href": "api/forms/NG_ASYNC_VALIDATORS"
      },
      {
        "text": "Directive",
        "href": "api/core/Directive"
      },
      {
        "text": "NG_ASYNC_VALIDATORS",
        "href": "api/forms/NG_ASYNC_VALIDATORS"
      },
      {
        "text": "forwardRef",
        "href": "api/core/forwardRef"
      },
      {
        "text": "AsyncValidator",
        "href": "api/forms/AsyncValidator"
      },
      {
        "text": "AbstractControl",
        "href": "api/forms/AbstractControl"
      },
      {
        "text": "ValidationErrors",
        "href": "api/forms/ValidationErrors"
      },
      {
        "text": "ngModel",
        "href": "api/forms/NgModel"
      },
      {
        "text": "ngModel",
        "href": "api/forms/NgModel"
      },
      {
        "text": "link",
        "href": "guide/form-validation#optimizing-performance-of-async-validators"
      },
      {
        "text": "ngModel",
        "href": "api/forms/NgModel"
      },
      {
        "text": "FormControl",
        "href": "api/forms/FormControl"
      },
      {
        "text": "FormControl",
        "href": "api/forms/FormControl"
      },
      {
        "text": "link",
        "href": "guide/form-validation#interaction-with-native-html-form-validation"
      },
      {
        "text": "native HTML form validation",
        "href": "https://developer.mozilla.org/docs/Web/Guide/HTML/Constraint_validation"
      },
      {
        "text": "API docs",
        "href": "api/forms/NgForm#native-dom-validation-ui"
      }
    ],
    "meta": {
      "description": "",
      "keywords": ""
    },
    "summary": "Validating form inputlink Contents PrerequisitesValidating input in template-driven formsValidating input in reactive formsValidator functionsBuilt-in validator functionsDefining custom validatorsAddi...",
    "tags": [
      "react",
      "vue",
      "angular",
      "javascript",
      "typescript",
      "css",
      "html",
      "formslink",
      "adding",
      "template"
    ],
    "id": "angular-formvalidation-part-1",
    "quality": 90
  },
  {
    "title": "Angular",
    "url": "https://v17.angular.io/guide/understanding-communicating-with-http",
    "category": "angular",
    "content": "Understanding communicating with backend services using HTTPlink Contents PrerequisitesHTTP client service featuresWhat's next Most front-end applications need to communicate with a server over the HTTP protocol, to download or upload data and access other back-end services. Angular provides a client HTTP API for Angular applications, the HttpClient service class in @angular/common/http. Prerequisiteslink Before working with the HttpClientModule, you should have a basic understanding of the following: TypeScript programming Usage of the HTTP protocol Angular application-design fundamentals, as described in Angular Concepts Observable techniques and operators. See the Observables guide. HTTP client service featureslink The HTTP client service offers the following major features. The ability to request typed response objects Streamlined error handling Testability features Request and response interception What's nextlink Setup for server communication Last reviewed on Wed Aug 16 2023",
    "headings": [
      {
        "level": 1,
        "text": "Understanding communicating with backend services using HTTPlink",
        "id": "understanding-communicating-with-backend-services-using-http"
      },
      {
        "level": 2,
        "text": "Prerequisiteslink",
        "id": "prerequisites"
      },
      {
        "level": 2,
        "text": "HTTP client service featureslink",
        "id": "http-client-service-features"
      },
      {
        "level": 2,
        "text": "What's nextlink",
        "id": "whats-next"
      }
    ],
    "codeBlocks": [
      {
        "language": "text",
        "code": "@angular/common/http"
      },
      {
        "language": "text",
        "code": "HttpClientModule"
      }
    ],
    "links": [
      {
        "text": "link",
        "href": "guide/understanding-communicating-with-http#understanding-communicating-with-backend-services-using-http"
      },
      {
        "text": "Prerequisites",
        "href": "guide/understanding-communicating-with-http#prerequisites"
      },
      {
        "text": "HTTP client service features",
        "href": "guide/understanding-communicating-with-http#http-client-service-features"
      },
      {
        "text": "What's next",
        "href": "guide/understanding-communicating-with-http#whats-next"
      },
      {
        "text": "HttpClient",
        "href": "api/common/http/HttpClient"
      },
      {
        "text": "http",
        "href": "api/common/http"
      },
      {
        "text": "link",
        "href": "guide/understanding-communicating-with-http#prerequisites"
      },
      {
        "text": "HttpClientModule",
        "href": "api/common/http/HttpClientModule"
      },
      {
        "text": "Angular Concepts",
        "href": "guide/architecture"
      },
      {
        "text": "Observables guide",
        "href": "guide/observables"
      },
      {
        "text": "link",
        "href": "guide/understanding-communicating-with-http#http-client-service-features"
      },
      {
        "text": "typed response objects",
        "href": "guide/http-request-data-from-server"
      },
      {
        "text": "error handling",
        "href": "guide/http-handle-request-errors"
      },
      {
        "text": "Testability",
        "href": "guide/http-test-requests"
      },
      {
        "text": "interception",
        "href": "guide/http-intercept-requests-and-responses"
      },
      {
        "text": "link",
        "href": "guide/understanding-communicating-with-http#whats-next"
      },
      {
        "text": "Setup for server communication",
        "href": "guide/http-setup-server-communication"
      }
    ],
    "meta": {
      "description": "",
      "keywords": ""
    },
    "summary": "Understanding communicating with backend services using HTTPlink Contents PrerequisitesHTTP client service featuresWhat's next Most front-end applications need to communicate with a server over the HT...",
    "tags": [
      "angular",
      "typescript",
      "node",
      "understanding",
      "communicating",
      "backend",
      "services"
    ],
    "id": "angular-understandingcommunicatingwithhttp",
    "quality": 90
  },
  {
    "title": "Angular",
    "url": "https://v17.angular.io/guide/router",
    "category": "angular",
    "content": "Common Routing Taskslink Contents Generate an applicationAdding components for routingImporting your new componentsDefining a basic routeRoute orderGetting route informationSetting up wildcard routesDisplaying a 404 pageSetting up redirectsNesting routesSetting the page titleUsing relative pathsSpecifying a relative routeAccessing query parameters and fragmentsLazy loadingPreventing unauthorized accessLink parameters arrayLocationStrategy and browser URL stylesChoosing a routing strategybase hrefHTML5 URLs and the base hrefHashLocationStrategy This topic describes how to implement many of the common tasks associated with adding the Angular router to your application. Generate an applicationlink The following command uses the Angular CLI to generate a basic Angular application with application routes. The application name in the following example is routing-app. content_copy ng new routing-app Adding components for routinglink To use the Angular router, an application needs to have at least two components so that it can navigate from one to the other. To create a component using the CLI, enter the following at the command line where first is the name of your component: content_copy ng generate component first Repeat this step for a second component but give it a different name. Here, the new name is second. content_copy ng generate component second The CLI automatically appends Component, so if you were to write first-component, your component would be FirstComponentComponent. This guide works with a CLI-generated Angular application. Importing your new componentslink To use your new components, import them into app.routes.ts at the top of the file, as follows: content_copy import {FirstComponent} from './first/first.component'; import {SecondComponent} from './second/second.component'; Defining a basic routelink There are three fundamental building blocks to creating a route. Import the routes into app.config.ts and add it to the provideRouter function. The Angular CLI performs this step for you. However, if you are creating an application manually or working with an existing, non-CLI application, verify that the imports and configuration are correct. The following is the default ApplicationConfig using the CLI. content_copy export const appConfig: ApplicationConfig = { providers: [provideRouter(routes)] }; Set up a Routes array for your routes The Angular CLI performs this step automatically. content_copy import { Routes } from '@angular/router'; export const routes: Routes = []; Define your routes in your Routes array. Each route in this array is a JavaScript object that contains two properties. The first property, path, defines the URL path for the route. The second property, component, defines the component Angular should use for the corresponding path. content_copy const routes: Routes = [ { path: 'first-component', component: FirstComponent }, { path: 'second-component', component: SecondComponent }, ]; Add your routes to your application. Now that you have defined your routes, add them to your application. First, add links to the two components. Assign the anchor tag that you want to add the route to the routerLink attribute. Set the value of the attribute to the component to show when a user clicks on each link. Next, update your component template to include router-outlet. This element informs Angular to update the application view with the component for the selected route. content_copy h1Angular Router App/h1 nav ul lia routerLink=\"/first-component\" routerLinkActive=\"active\" ariaCurrentWhenActive=\"page\"First Component/a/li lia routerLink=\"/second-component\" routerLinkActive=\"active\" ariaCurrentWhenActive=\"page\"Second Component/a/li /ul /nav !-- The routed views render in the router-outlet-- router-outlet/router-outlet You also need to add the RouterLink, RouterLinkActive, and RouterOutlet to the imports array of AppComponent. content_copy @Component({ selector: 'app-root', standalone: true, imports: [CommonModule, RouterOutlet, RouterLink, RouterLinkActive], templateUrl: './app.component.html', styleUrls: ['./app.component.css'] }) export class AppComponent { title = 'routing-app'; } Route orderlink The order of routes is important because the Router uses a first-match wins strategy when matching routes, so more specific routes should be placed above less specific routes. List routes with a static path first, followed by an empty path route, which matches the default route. The wildcard route comes last because it matches every URL and the Router selects it only if no other routes match first. Getting route informationlink Often, as a user navigates your application, you want to pass information from one component to another. For example, consider an application that displays a shopping list of grocery items. Each item in the list has a unique id. To edit an item, users click an Edit button, which opens an EditGroceryItem component. You want that component to retrieve the id for the grocery item so it can display the right information to the user. Use a route to pass this type of information to your application components. To do so, you use the withComponentInputBinding feature with provideRouter or the bindToComponentInputs option of RouterModule.forRoot. To get information from a route: Add the withComponentInputBinding feature to the provideRouter method. content_copy providers: [ provideRouter(appRoutes, withComponentInputBinding()), ] Update the component to have an Input matching the name of the parameter. content_copy @Input() set id(heroId: string) { this.hero$ = this.service.getHero(heroId); } NOTE: You can bind all route data with key, value pairs to component inputs: static or resolved route data, path parameters, matrix parameters, and query parameters. If you want to use the parent components route info you will need to set the router paramsInheritanceStrategy option: withRouterConfig({paramsInheritanceStrategy: 'always'}) Setting up wildcard routeslink A well-functioning application should gracefully handle when users attempt to navigate to a part of your application that does not exist. To add this functionality to your application, you set up a wildcard route. The Angular router selects this route any time the requested URL doesn't match any router paths. To set up a wildcard route, add the following code to your routes definition. content_copy { path: '**', component: PageNotFoundComponent } The two asterisks, **, indicate to Angular that this routes definition is a wildcard route. For the component property, you can define any component in your application. Common choices include an application-specific PageNotFoundComponent, which you can define to display a 404 page to your users; or a redirect to your application's main component. A wildcard route is the last route because it matches any URL. For more detail on why order matters for routes, see Route order. Displaying a 404 pagelink To display a 404 page, set up a wildcard route with the component property set to the component you'd like to use for your 404 page as follows: content_copy const routes: Routes = [ { path: 'first-component', component: FirstComponent }, { path: 'second-component', component: SecondComponent }, { path: '**', component: PageNotFoundComponent }, // Wildcard route for a 404 page ]; The last route with the path of ** is a wildcard route. The router selects this route if the requested URL doesn't match any of the paths earlier in the list and sends the user to the PageNotFoundComponent. Setting up redirectslink To set up a redirect, configure a route with the path you want to redirect from, the component you want to redirect to, and a pathMatch value that tells the router how to match the URL. content_copy const routes: Routes = [ { path: 'first-component', component: FirstComponent }, { path: 'second-component', component: SecondComponent }, { path: '', redirectTo: '/first-component', pathMatch: 'full' }, // redirect to first-component { path: '**', component: PageNotFoundComponent }, // Wildcard route for a 404 page ]; In this example, the third route is a redirect so that the router defaults to the first-component route. Notice that this redirect precedes the wildcard route. Here, path: '' means to use the initial relative URL (''). For more details on pathMatch see Spotlight on pathMatch. Nesting routeslink As your application grows more complex, you might want to create routes that are relative to a component other than your root component. These types of nested routes are called child routes. This means you're adding a second router-outlet to your app, because it is in addition to the router-outlet in AppComponent. In this example, there are two additional child components, child-a, and child-b. Here, FirstComponent has its own nav and a second router-outlet in addition to the one in AppComponent. content_copy h2First Component/h2 nav ul lia routerLink=\"child-a\"Child A/a/li lia routerLink=\"child-b\"Child B/a/li /ul /nav router-outlet/router-outlet A child route is like any other route, in that it needs both a path and a component. The one difference is that you place child routes in a children array within the parent route. content_copy const routes: Routes = [ { path: 'first-component', component: FirstComponent, // this is the component with the router-outlet in the template children: [ { path: 'child-a', // child route path component: ChildAComponent, // child route component that the router renders }, { path: 'child-b', component: ChildBComponent, // another child route component that the router renders }, ], }, ]; Setting the page titlelink Each page in your application should have a unique title so that they can be identified in the browser history. The Router sets the document's title using the title property from the Route config. content_copy const routes: Routes = [ { path: 'first-component', title: 'First component', component: FirstComponent, // this is the component with the router-outlet in the template children: [ { path: 'child-a', // child route path title: resolvedChildATitle, component: ChildAComponent, // child route component that the router renders }, { path: 'child-b', title: 'child b', component: ChildBComponent, // another child route component that the router renders }, ], }, ]; const resolvedChildATitle: ResolveFnstring = () = Promise.resolve('child a'); NOTE: The title property follows the same rules as static route data and dynamic values that implement ResolveFn. You can also provide a custom title strategy by extending the TitleStrategy. content_copy @Injectable({providedIn: 'root'}) export class TemplatePageTitleStrategy extends TitleStrategy { constructor(private readonly title: Title) { super(); } override updateTitle(routerState: RouterStateSnapshot) { const title = this.buildTitle(routerState); if (title !== undefined) { this.title.setTitle(My Application  ${title}); } } } export const appConfig: ApplicationConfig = { providers: [ provideRouter(routes), {provide: TitleStrategy, useClass: TemplatePageTitleStrategy}, ] }; Using relative pathslink Relative paths let you define paths that are relative to the current URL segment. The following example shows a relative route to another component, second-component. FirstComponent and SecondComponent are at the same level in the tree, however, the link to SecondComponent is situated within the FirstComponent, meaning that the router has to go up a level and then into the second directory to find the SecondComponent. Rather than writing out the whole path to get to SecondComponent, use the ../ notation to go up a level. content_copy h2First Component/h2 nav ul lia routerLink=\"../second-component\"Relative Route to second component/a/li /ul /nav router-outlet/router-outlet In addition to ../, use ./ or no leading slash to specify the current level. Specifying a relative routelink To specify a relative route, use the NavigationExtras relativeTo property. In the component class, import NavigationExtras from the @angular/router. Then use relativeTo in your navigation method. After the link parameters array, which here contains items, add an object with the relativeTo property set to the ActivatedRoute, which is this.route. content_copy goToItems() { this.router.navigate(['items'], { relativeTo: this.route }); } The navigate() arguments configure the router to use the current route as a basis upon which to append items. The goToItems() method interprets the destination URI as relative to the activated route and navigates to the items route. Accessing query parameters and fragmentslink Sometimes, a feature of your application requires accessing a part of a route, such as a query parameter or a fragment. The Tour of Heroes application at this stage in the tutorial uses a list view in which you can click on a hero to see details. The router uses an id to show the correct hero's details. First, import the following members in the component you want to navigate from. content_copy import { ActivatedRoute } from '@angular/router'; import { Observable } from 'rxjs'; import { switchMap } from 'rxjs/operators'; Next inject the activated route service: content_copy constructor(private route: ActivatedRoute) {} Configure the class so that you have an observable, heroes$, a selectedId to hold the id number of the hero, and the heroes in the ngOnInit(), add the following code to get the id of the selected hero. This code snippet assumes that you have a heroes list, a hero service, a function to get your heroes, and the HTML to render your list and details, just as in the Tour of Heroes example. content_copy heroes$: ObservableHero[]; selectedId: number; heroes = HEROES; ngOnInit() { this.heroes$ = this.route.paramMap.pipe( switchMap(params = { this.selectedId = Number(params.get('id')); return this.service.getHeroes(); }) ); } Next, in the component that you want to navigate to, import the following members. content_copy import { Router, ActivatedRoute, ParamMap } from '@angular/router'; import { Observable } from 'rxjs'; Inject ActivatedRoute and Router in the constructor of the component class so they are available to this component: content_copy hero$: ObservableHero; constructor( private route: ActivatedRoute, private router: Router ) {} ngOnInit() { const heroId = this.route.snapshot.paramMap.get('id'); this.hero$ = this.service.getHero(heroId); } gotoItems(hero: Hero) { const heroId = hero ? hero.id : null; // Pass along the hero id if available // so that the HeroList component can select that item. this.router.navigate(['/heroes', { id: heroId }]); } Lazy loadinglink You can configure your routes to be lazy loaded, which means that Angular only loads routes as needed, rather than loading all routes when the application launches. Additionally, preload parts of your application in the background to improve the user experience. For more information on lazy loading and preloading see the dedicated guide Lazy loading. Preventing unauthorized accesslink Use route guards to prevent users from navigating to parts of an application without authorization. The following route guards are available in Angular: canActivate canActivateChild canDeactivate canMatch resolve canLoad To use route guards, consider using component-less routes as this facilitates guarding child routes. Create a file for your guard: content_copy ng generate guard your-guard In your guard file, add the guard functions you want to use. The following example uses canActivateFn to guard the route. content_copy export const yourGuardFunction: CanActivateFn = ( next: ActivatedRouteSnapshot, state: RouterStateSnapshot) = { // your logic goes here } In your routing module, use the appropriate property in your routes configuration. Here, canActivate tells the router to mediate navigation to this particular route. content_copy { path: '/your-path', component: YourComponent, canActivate: [yourGuardFunction], } For more information with a working example, see the routing tutorial section on route guards. Link parameters arraylink A link parameters array holds the following ingredients for router navigation: The path of the route to the destination component Required and optional route parameters that go into the route URL Bind the RouterLink directive to such an array like this: content_copy a [routerLink]=\"['/heroes']\"Heroes/a The following is a two-element array when specifying a route parameter: content_copy a [routerLink]=\"['/hero', hero.id]\" span class=\"badge\"{{ hero.id }}/span{{ hero.name }} /a Provide optional route parameters in an object, as in { foo: 'foo' }: content_copy a [routerLink]=\"['/crisis-center', { foo: 'foo' }]\"Crisis Center/a These three examples cover the needs of an application with one level of routing. However, with a child router, such as in the crisis center, you create new link array possibilities. The following minimal RouterLink example builds upon a specified default child route for the crisis center. content_copy a [routerLink]=\"['/crisis-center']\"Crisis Center/a Review the following: The first item in the array identifies the parent route (/crisis-center) There are no parameters for this parent route There is no default for the child route so you need to pick one You're navigating to the CrisisListComponent, whose route path is /, but you don't need to explicitly add the slash Consider the following router link that navigates from the root of the application down to the Dragon Crisis: content_copy a [routerLink]=\"['/crisis-center', 1]\"Dragon Crisis/a The first item in the array identifies the parent route (/crisis-center) There are no parameters for this parent route The second item identifies the child route details about a particular crisis (/:id) The details child route requires an id route parameter You added the id of the Dragon Crisis as the second item in the array (1) The resulting path is /crisis-center/1 You could also redefine the AppComponent template with Crisis Center routes exclusively: content_copy template:  h1 class=\"title\"Angular Router/h1 nav a [routerLink]=\"['/crisis-center']\"Crisis Center/a a [routerLink]=\"['/crisis-center/1', { foo: 'foo' }]\"Dragon Crisis/a a [routerLink]=\"['/crisis-center/2']\"Shark Crisis/a /nav router-outlet/router-outlet  In summary, you can write applications with one, two or more levels of routing. The link parameters array affords the flexibility to represent any routing depth and any legal sequence of route paths, (required) router parameters, and (optional) route parameter objects. LocationStrategy and browser URL styleslink When the router navigates to a new component view, it updates the browser's location and history with a URL for that view. Modern HTML5 browsers support history.pushState, a technique that changes a browser's location and history without triggering a server page request. The router can compose a \"natural\" URL that is indistinguishable from one that would otherwise require a page load. Here's the Crisis Center URL in this \"HTML5 pushState\" style: content_copy localhost:3002/crisis-center Older browsers send page requests to the server when the location URL changes unless the change occurs after a \"#\" (called the \"hash\"). Routers can take advantage of this exception by composing in-application route URLs with hashes. Here's a \"hash URL\" that routes to the Crisis Center. content_copy localhost:3002/src/#/crisis-center The router supports both styles with two LocationStrategy providers: Providers Details PathLocationStrategy The default \"HTML5 pushState\" style. HashLocationStrategy The \"hash URL\" style. The provideRouter function sets the LocationStrategy to the PathLocationStrategy, which makes it the default strategy. You also have the option of switching to the HashLocationStrategy with an override during the bootstrapping process. For more information on providers and the bootstrap process, see Dependency Injection. Choosing a routing strategylink You must choose a routing strategy early in the development of your project because once the application is in production, visitors to your site use and depend on application URL references. Almost all Angular projects should use the default HTML5 style. It produces URLs that are easier for users to understand and it preserves the option to do server-side rendering. Rendering critical pages on the server is a technique that can greatly improve perceived responsiveness when the application first loads. An application that would otherwise take ten or more seconds to start could be rendered on the server and delivered to the user's device in less than a second. This option is only available if application URLs look like normal web URLs without hash (#) characters in the middle. base hreflink The router uses the browser's history.pushState for navigation. pushState lets you customize in-application URL paths; for example, localhost:4200/crisis-center. The in-application URLs can be indistinguishable from server URLs. Modern HTML5 browsers were the first to support pushState which is why many people refer to these URLs as \"HTML5 style\" URLs. HTML5 style navigation is the router default. In the LocationStrategy and browser URL styles section, learn why HTML5 style is preferable, how to adjust its behavior, and how to switch to the older hash (#) style, if necessary. You must add a base href element to the application's index.html for pushState routing to work. The browser uses the base href value to prefix relative URLs when referencing CSS files, scripts, and images. Add the base element just after the head tag. If the app folder is the application root, as it is for this application, set the href value in index.html as shown here. content_copy base href=\"/\" HTML5 URLs and the base hreflink The guidelines that follow will refer to different parts of a URL. This diagram outlines what those parts refer to: foo://example.com:8042/over/there?name=ferret#nose _/ ______________/_________/ _________/ __/      scheme authority path query fragment While the router uses the HTML5 pushState style by default, you must configure that strategy with a base href. The preferred way to configure the strategy is to add a base href element tag in the head of the index.html. content_copy base href=\"/\" Without that tag, the browser might not be able to load resources (images, CSS, scripts) when \"deep linking\" into the application. Some developers might not be able to add the base element, perhaps because they don't have access to head or the index.html. Those developers can still use HTML5 URLs by taking the following two steps: Provide the router with an appropriate APP_BASE_HREF value. Use root URLs (URLs with an authority) for all web resources: CSS, images, scripts, and template HTML files. The base href path should end with a \"/\", as browsers ignore characters in the path that follow the right-most \"/\" If the base href includes a query part, the query is only used if the path of a link in the page is empty and has no query. This means that a query in the base href is only included when using HashLocationStrategy. If a link in the page is a root URL (has an authority), the base href is not used. In this way, an APP_BASE_HREF with an authority will cause all links created by Angular to ignore the base href value. A fragment in the base href is never persisted For more complete information on how base href is used to construct target URIs, see the RFC section on transforming references. HashLocationStrategylink Use HashLocationStrategy by adding the withHashLocation feature to the provideRouter function of the provideRouter in the ApplicationConfiguration. content_copy providers: [ provideRouter(appRoutes, withHashLocation()) ] When using RouterModule.forRoot, this is configured with the useHash: true in the second argument: RouterModule.forRoot(routes, {useHash: true}). Last reviewed on Tue Oct 24 2023",
    "headings": [
      {
        "level": 1,
        "text": "Common Routing Taskslink",
        "id": "common-routing-tasks"
      },
      {
        "level": 2,
        "text": "Generate an applicationlink",
        "id": "generate-an-application"
      },
      {
        "level": 2,
        "text": "Defining a basic routelink",
        "id": "defining-a-basic-route"
      },
      {
        "level": 2,
        "text": "Getting route informationlink",
        "id": "getting-route-information"
      },
      {
        "level": 2,
        "text": "Setting up wildcard routeslink",
        "id": "setting-up-wildcard-routes"
      },
      {
        "level": 2,
        "text": "Displaying a 404 pagelink",
        "id": "displaying-a-404-page"
      },
      {
        "level": 2,
        "text": "Setting up redirectslink",
        "id": "setting-up-redirects"
      },
      {
        "level": 2,
        "text": "Nesting routeslink",
        "id": "nesting-routes"
      },
      {
        "level": 2,
        "text": "Setting the page titlelink",
        "id": "setting-the-page-title"
      },
      {
        "level": 2,
        "text": "Using relative pathslink",
        "id": "using-relative-paths"
      },
      {
        "level": 2,
        "text": "Accessing query parameters and fragmentslink",
        "id": "accessing-query-parameters-and-fragments"
      },
      {
        "level": 2,
        "text": "Lazy loadinglink",
        "id": "lazy-loading"
      },
      {
        "level": 2,
        "text": "Preventing unauthorized accesslink",
        "id": "preventing-unauthorized-access"
      },
      {
        "level": 2,
        "text": "Link parameters arraylink",
        "id": "link-parameters-array"
      },
      {
        "level": 2,
        "text": "LocationStrategy and browser URL styleslink",
        "id": "locationstrategy-and-browser-url-styles"
      },
      {
        "level": 2,
        "text": "Choosing a routing strategylink",
        "id": "choosing-a-routing-strategy"
      },
      {
        "level": 2,
        "text": "<base href>link",
        "id": "base-href"
      },
      {
        "level": 3,
        "text": "Adding components for routinglink",
        "id": "adding-components-for-routing"
      },
      {
        "level": 3,
        "text": "Importing your new componentslink",
        "id": "importing-your-new-components"
      },
      {
        "level": 3,
        "text": "Route orderlink",
        "id": "route-order"
      },
      {
        "level": 3,
        "text": "Specifying a relative routelink",
        "id": "specifying-a-relative-route"
      },
      {
        "level": 3,
        "text": "HTML5 URLs and the <base href>link",
        "id": "html5-urls-and-the-base-href"
      },
      {
        "level": 3,
        "text": "HashLocationStrategylink",
        "id": "hashlocationstrategy"
      }
    ],
    "codeBlocks": [
      {
        "language": "text",
        "code": "LocationStrategy"
      },
      {
        "language": "text",
        "code": "<base href>"
      },
      {
        "language": "text",
        "code": "<base href>"
      },
      {
        "language": "text",
        "code": "HashLocationStrategy"
      },
      {
        "language": "text",
        "code": "routing-app"
      },
      {
        "language": "text",
        "code": "content_copy\n      \n      ng new routing-app"
      },
      {
        "language": "text",
        "code": "ng new routing-app"
      },
      {
        "language": "text",
        "code": "content_copy\n      \n      ng generate component first"
      },
      {
        "language": "text",
        "code": "ng generate component first"
      },
      {
        "language": "text",
        "code": "content_copy\n      \n      ng generate component second"
      },
      {
        "language": "text",
        "code": "ng generate component second"
      },
      {
        "language": "text",
        "code": "first-component"
      },
      {
        "language": "text",
        "code": "FirstComponentComponent"
      },
      {
        "language": "text",
        "code": "app.routes.ts"
      },
      {
        "language": "text",
        "code": "content_copy\n      \n      import {FirstComponent} from './first/first.component';\nimport {SecondComponent} from './second/second.component';"
      },
      {
        "language": "text",
        "code": "import {FirstComponent} from './first/first.component';\nimport {SecondComponent} from './second/second.component';"
      },
      {
        "language": "text",
        "code": "app.config.ts"
      },
      {
        "language": "text",
        "code": "provideRouter"
      },
      {
        "language": "text",
        "code": "ApplicationConfig"
      },
      {
        "language": "text",
        "code": "content_copy\n      \n      export const appConfig: ApplicationConfig = {\n  providers: [provideRouter(routes)]\n};"
      },
      {
        "language": "text",
        "code": "export const appConfig: ApplicationConfig = {\n  providers: [provideRouter(routes)]\n};"
      },
      {
        "language": "text",
        "code": "content_copy\n      \n      import { Routes } from '@angular/router';\n\nexport const routes: Routes = [];"
      },
      {
        "language": "text",
        "code": "import { Routes } from '@angular/router';\n\nexport const routes: Routes = [];"
      },
      {
        "language": "text",
        "code": "content_copy\n      \n      const routes: Routes = [\n  { path: 'first-component', component: FirstComponent },\n  { path: 'second-component', component: SecondComponent },\n];"
      },
      {
        "language": "text",
        "code": "const routes: Routes = [\n  { path: 'first-component', component: FirstComponent },\n  { path: 'second-component', component: SecondComponent },\n];"
      },
      {
        "language": "text",
        "code": "<router-outlet>"
      },
      {
        "language": "text",
        "code": "content_copy\n      \n      <h1>Angular Router App</h1>\n<nav>\n  <ul>\n    <li><a routerLink=\"/first-component\" routerLinkActive=\"active\" ariaCurrentWhenActive=\"page\">First Component</a></li>\n    <li><a routerLink=\"/second-component\" routerLinkActive=\"active\" ariaCurrentWhenActive=\"page\">Second Component</a></li>\n  </ul>\n</nav>\n<!-- The routed views render in the <router-outlet>-->\n<router-outlet></router-outlet>"
      },
      {
        "language": "text",
        "code": "<h1>Angular Router App</h1>\n<nav>\n  <ul>\n    <li><a routerLink=\"/first-component\" routerLinkActive=\"active\" ariaCurrentWhenActive=\"page\">First Component</a></li>\n    <li><a routerLink=\"/second-component\" routerLinkActive=\"active\" ariaCurrentWhenActive=\"page\">Second Component</a></li>\n  </ul>\n</nav>\n<!-- The routed views render in the <router-outlet>-->\n<router-outlet></router-outlet>"
      },
      {
        "language": "text",
        "code": "RouterLinkActive"
      },
      {
        "language": "text",
        "code": "RouterOutlet"
      },
      {
        "language": "text",
        "code": "AppComponent"
      },
      {
        "language": "text",
        "code": "content_copy\n      \n      @Component({\n  selector: 'app-root',\n  standalone: true,\n  imports: [CommonModule, RouterOutlet, RouterLink, RouterLinkActive],\n  templateUrl: './app.component.html',\n  styleUrls: ['./app.component.css']\n})\nexport class AppComponent {\n  title = 'routing-app';\n}"
      },
      {
        "language": "text",
        "code": "@Component({\n  selector: 'app-root',\n  standalone: true,\n  imports: [CommonModule, RouterOutlet, RouterLink, RouterLinkActive],\n  templateUrl: './app.component.html',\n  styleUrls: ['./app.component.css']\n})\nexport class AppComponent {\n  title = 'routing-app';\n}"
      },
      {
        "language": "text",
        "code": "EditGroceryItem"
      },
      {
        "language": "text",
        "code": "provideRouter"
      },
      {
        "language": "text",
        "code": "bindToComponentInputs"
      },
      {
        "language": "text",
        "code": "RouterModule.forRoot"
      },
      {
        "language": "text",
        "code": "withComponentInputBinding"
      },
      {
        "language": "text",
        "code": "provideRouter"
      },
      {
        "language": "text",
        "code": "content_copy\n      \n      providers: [\n  provideRouter(appRoutes, withComponentInputBinding()),\n]"
      },
      {
        "language": "text",
        "code": "providers: [\n  provideRouter(appRoutes, withComponentInputBinding()),\n]"
      },
      {
        "language": "text",
        "code": "content_copy\n      \n      @Input()\nset id(heroId: string) {\n  this.hero$ = this.service.getHero(heroId);\n}"
      },
      {
        "language": "text",
        "code": "@Input()\nset id(heroId: string) {\n  this.hero$ = this.service.getHero(heroId);\n}"
      },
      {
        "language": "text",
        "code": "paramsInheritanceStrategy"
      },
      {
        "language": "text",
        "code": "withRouterConfig({paramsInheritanceStrategy: 'always'})"
      },
      {
        "language": "text",
        "code": "content_copy\n      \n      { path: '**', component: PageNotFoundComponent }"
      },
      {
        "language": "text",
        "code": "{ path: '**', component: PageNotFoundComponent }"
      },
      {
        "language": "text",
        "code": "PageNotFoundComponent"
      },
      {
        "language": "text",
        "code": "content_copy\n      \n      const routes: Routes = [\n  { path: 'first-component', component: FirstComponent },\n  { path: 'second-component', component: SecondComponent },\n  { path: '**', component: PageNotFoundComponent },  // Wildcard route for a 404 page\n];"
      },
      {
        "language": "text",
        "code": "const routes: Routes = [\n  { path: 'first-component', component: FirstComponent },\n  { path: 'second-component', component: SecondComponent },\n  { path: '**', component: PageNotFoundComponent },  // Wildcard route for a 404 page\n];"
      },
      {
        "language": "text",
        "code": "PageNotFoundComponent"
      },
      {
        "language": "text",
        "code": "content_copy\n      \n      const routes: Routes = [\n  { path: 'first-component', component: FirstComponent },\n  { path: 'second-component', component: SecondComponent },\n  { path: '',   redirectTo: '/first-component', pathMatch: 'full' }, // redirect to `first-component`\n  { path: '**', component: PageNotFoundComponent },  // Wildcard route for a 404 page\n];"
      },
      {
        "language": "text",
        "code": "const routes: Routes = [\n  { path: 'first-component', component: FirstComponent },\n  { path: 'second-component', component: SecondComponent },\n  { path: '',   redirectTo: '/first-component', pathMatch: 'full' }, // redirect to `first-component`\n  { path: '**', component: PageNotFoundComponent },  // Wildcard route for a 404 page\n];"
      },
      {
        "language": "text",
        "code": "first-component"
      },
      {
        "language": "text",
        "code": "<router-outlet>"
      },
      {
        "language": "text",
        "code": "<router-outlet>"
      },
      {
        "language": "text",
        "code": "AppComponent"
      },
      {
        "language": "text",
        "code": "FirstComponent"
      },
      {
        "language": "text",
        "code": "<router-outlet>"
      },
      {
        "language": "text",
        "code": "AppComponent"
      },
      {
        "language": "text",
        "code": "content_copy\n      \n      <h2>First Component</h2>\n\n<nav>\n  <ul>\n    <li><a routerLink=\"child-a\">Child A</a></li>\n    <li><a routerLink=\"child-b\">Child B</a></li>\n  </ul>\n</nav>\n\n<router-outlet></router-outlet>"
      },
      {
        "language": "text",
        "code": "<h2>First Component</h2>\n\n<nav>\n  <ul>\n    <li><a routerLink=\"child-a\">Child A</a></li>\n    <li><a routerLink=\"child-b\">Child B</a></li>\n  </ul>\n</nav>\n\n<router-outlet></router-outlet>"
      },
      {
        "language": "text",
        "code": "content_copy\n      \n      const routes: Routes = [\n  {\n    path: 'first-component',\n    component: FirstComponent, // this is the component with the <router-outlet> in the template\n    children: [\n      {\n        path: 'child-a', // child route path\n        component: ChildAComponent, // child route component that the router renders\n      },\n      {\n        path: 'child-b',\n        component: ChildBComponent, // another child route component that the router renders\n      },\n    ],\n  },\n];"
      },
      {
        "language": "text",
        "code": "const routes: Routes = [\n  {\n    path: 'first-component',\n    component: FirstComponent, // this is the component with the <router-outlet> in the template\n    children: [\n      {\n        path: 'child-a', // child route path\n        component: ChildAComponent, // child route component that the router renders\n      },\n      {\n        path: 'child-b',\n        component: ChildBComponent, // another child route component that the router renders\n      },\n    ],\n  },\n];"
      },
      {
        "language": "text",
        "code": "content_copy\n      \n      const routes: Routes = [\n  {\n    path: 'first-component',\n    title: 'First component',\n    component: FirstComponent,  // this is the component with the <router-outlet> in the template\n    children: [\n      {\n        path: 'child-a',  // child route path\n        title: resolvedChildATitle,\n        component: ChildAComponent,  // child route component that the router renders\n      },\n      {\n        path: 'child-b',\n        title: 'child b',\n        component: ChildBComponent,  // another child route component that the router renders\n      },\n    ],\n  },\n];\n\nconst resolvedChildATitle: ResolveFn<string> = () => Promise.resolve('child a');"
      },
      {
        "language": "text",
        "code": "const routes: Routes = [\n  {\n    path: 'first-component',\n    title: 'First component',\n    component: FirstComponent,  // this is the component with the <router-outlet> in the template\n    children: [\n      {\n        path: 'child-a',  // child route path\n        title: resolvedChildATitle,\n        component: ChildAComponent,  // child route component that the router renders\n      },\n      {\n        path: 'child-b',\n        title: 'child b',\n        component: ChildBComponent,  // another child route component that the router renders\n      },\n    ],\n  },\n];\n\nconst resolvedChildATitle: ResolveFn<string> = () => Promise.resolve('child a');"
      },
      {
        "language": "text",
        "code": "TitleStrategy"
      },
      {
        "language": "text",
        "code": "content_copy\n      \n      @Injectable({providedIn: 'root'})\nexport class TemplatePageTitleStrategy extends TitleStrategy {\n  constructor(private readonly title: Title) {\n    super();\n  }\n\n  override updateTitle(routerState: RouterStateSnapshot) {\n    const title = this.buildTitle(routerState);\n    if (title !== undefined) {\n      this.title.setTitle(`My Application | ${title}`);\n    }\n  }\n}\n\n\nexport const appConfig: ApplicationConfig = {\n  providers: [\n    provideRouter(routes),\n    {provide: TitleStrategy, useClass: TemplatePageTitleStrategy},\n  ]\n};"
      },
      {
        "language": "text",
        "code": "@Injectable({providedIn: 'root'})\nexport class TemplatePageTitleStrategy extends TitleStrategy {\n  constructor(private readonly title: Title) {\n    super();\n  }\n\n  override updateTitle(routerState: RouterStateSnapshot) {\n    const title = this.buildTitle(routerState);\n    if (title !== undefined) {\n      this.title.setTitle(`My Application | ${title}`);\n    }\n  }\n}\n\n\nexport const appConfig: ApplicationConfig = {\n  providers: [\n    provideRouter(routes),\n    {provide: TitleStrategy, useClass: TemplatePageTitleStrategy},\n  ]\n};"
      },
      {
        "language": "text",
        "code": "second-component"
      },
      {
        "language": "text",
        "code": "FirstComponent"
      },
      {
        "language": "text",
        "code": "SecondComponent"
      },
      {
        "language": "text",
        "code": "SecondComponent"
      },
      {
        "language": "text",
        "code": "FirstComponent"
      },
      {
        "language": "text",
        "code": "SecondComponent"
      },
      {
        "language": "text",
        "code": "SecondComponent"
      },
      {
        "language": "text",
        "code": "content_copy\n      \n      <h2>First Component</h2>\n\n<nav>\n  <ul>\n    <li><a routerLink=\"../second-component\">Relative Route to second component</a></li>\n  </ul>\n</nav>\n<router-outlet></router-outlet>"
      },
      {
        "language": "text",
        "code": "<h2>First Component</h2>\n\n<nav>\n  <ul>\n    <li><a routerLink=\"../second-component\">Relative Route to second component</a></li>\n  </ul>\n</nav>\n<router-outlet></router-outlet>"
      },
      {
        "language": "text",
        "code": "NavigationExtras"
      },
      {
        "language": "text",
        "code": "NavigationExtras"
      },
      {
        "language": "text",
        "code": "@angular/router"
      },
      {
        "language": "text",
        "code": "ActivatedRoute"
      },
      {
        "language": "text",
        "code": "content_copy\n      \n      goToItems() {\n  this.router.navigate(['items'], { relativeTo: this.route });\n}"
      },
      {
        "language": "text",
        "code": "goToItems() {\n  this.router.navigate(['items'], { relativeTo: this.route });\n}"
      },
      {
        "language": "text",
        "code": "goToItems()"
      },
      {
        "language": "text",
        "code": "content_copy\n      \n      import { ActivatedRoute } from '@angular/router';\nimport { Observable } from 'rxjs';\nimport { switchMap } from 'rxjs/operators';"
      },
      {
        "language": "text",
        "code": "import { ActivatedRoute } from '@angular/router';\nimport { Observable } from 'rxjs';\nimport { switchMap } from 'rxjs/operators';"
      },
      {
        "language": "text",
        "code": "content_copy\n      \n      constructor(private route: ActivatedRoute) {}"
      },
      {
        "language": "text",
        "code": "constructor(private route: ActivatedRoute) {}"
      },
      {
        "language": "text",
        "code": "content_copy\n      \n      heroes$: Observable<Hero[]>;\nselectedId: number;\nheroes = HEROES;\n\nngOnInit() {\n  this.heroes$ = this.route.paramMap.pipe(\n    switchMap(params => {\n      this.selectedId = Number(params.get('id'));\n      return this.service.getHeroes();\n    })\n  );\n}"
      },
      {
        "language": "text",
        "code": "heroes$: Observable<Hero[]>;\nselectedId: number;\nheroes = HEROES;\n\nngOnInit() {\n  this.heroes$ = this.route.paramMap.pipe(\n    switchMap(params => {\n      this.selectedId = Number(params.get('id'));\n      return this.service.getHeroes();\n    })\n  );\n}"
      },
      {
        "language": "text",
        "code": "content_copy\n      \n      import { Router, ActivatedRoute, ParamMap } from '@angular/router';\nimport { Observable } from 'rxjs';"
      },
      {
        "language": "text",
        "code": "import { Router, ActivatedRoute, ParamMap } from '@angular/router';\nimport { Observable } from 'rxjs';"
      },
      {
        "language": "text",
        "code": "ActivatedRoute"
      },
      {
        "language": "text",
        "code": "content_copy\n      \n      hero$: Observable<Hero>;\n\nconstructor(\n  private route: ActivatedRoute,\n  private router: Router  ) {}\n\nngOnInit() {\n  const heroId = this.route.snapshot.paramMap.get('id');\n  this.hero$ = this.service.getHero(heroId);\n}\n\ngotoItems(hero: Hero) {\n  const heroId = hero ? hero.id : null;\n  // Pass along the hero id if available\n  // so that the HeroList component can select that item.\n  this.router.navigate(['/heroes', { id: heroId }]);\n}"
      },
      {
        "language": "text",
        "code": "hero$: Observable<Hero>;\n\nconstructor(\n  private route: ActivatedRoute,\n  private router: Router  ) {}\n\nngOnInit() {\n  const heroId = this.route.snapshot.paramMap.get('id');\n  this.hero$ = this.service.getHero(heroId);\n}\n\ngotoItems(hero: Hero) {\n  const heroId = hero ? hero.id : null;\n  // Pass along the hero id if available\n  // so that the HeroList component can select that item.\n  this.router.navigate(['/heroes', { id: heroId }]);\n}"
      },
      {
        "language": "text",
        "code": "canActivate"
      },
      {
        "language": "text",
        "code": "canActivateChild"
      },
      {
        "language": "text",
        "code": "canDeactivate"
      },
      {
        "language": "text",
        "code": "content_copy\n      \n      ng generate guard your-guard"
      },
      {
        "language": "text",
        "code": "ng generate guard your-guard"
      },
      {
        "language": "text",
        "code": "canActivateFn"
      },
      {
        "language": "text",
        "code": "content_copy\n      \n      export const yourGuardFunction: CanActivateFn = (\n    next: ActivatedRouteSnapshot,\n    state: RouterStateSnapshot) => {\n      // your  logic goes here\n  }"
      },
      {
        "language": "text",
        "code": "export const yourGuardFunction: CanActivateFn = (\n    next: ActivatedRouteSnapshot,\n    state: RouterStateSnapshot) => {\n      // your  logic goes here\n  }"
      },
      {
        "language": "text",
        "code": "canActivate"
      },
      {
        "language": "text",
        "code": "content_copy\n      \n      {\npath: '/your-path',\ncomponent: YourComponent,\ncanActivate: [yourGuardFunction],\n}"
      },
      {
        "language": "text",
        "code": "{\npath: '/your-path',\ncomponent: YourComponent,\ncanActivate: [yourGuardFunction],\n}"
      },
      {
        "language": "text",
        "code": "content_copy\n      \n      <a [routerLink]=\"['/heroes']\">Heroes</a>"
      },
      {
        "language": "text",
        "code": "<a [routerLink]=\"['/heroes']\">Heroes</a>"
      },
      {
        "language": "text",
        "code": "content_copy\n      \n      <a [routerLink]=\"['/hero', hero.id]\">\n  <span class=\"badge\">{{ hero.id }}</span>{{ hero.name }}\n</a>"
      },
      {
        "language": "text",
        "code": "<a [routerLink]=\"['/hero', hero.id]\">\n  <span class=\"badge\">{{ hero.id }}</span>{{ hero.name }}\n</a>"
      },
      {
        "language": "text",
        "code": "{ foo: 'foo' }"
      },
      {
        "language": "text",
        "code": "content_copy\n      \n      <a [routerLink]=\"['/crisis-center', { foo: 'foo' }]\">Crisis Center</a>"
      },
      {
        "language": "text",
        "code": "<a [routerLink]=\"['/crisis-center', { foo: 'foo' }]\">Crisis Center</a>"
      },
      {
        "language": "text",
        "code": "content_copy\n      \n      <a [routerLink]=\"['/crisis-center']\">Crisis Center</a>"
      },
      {
        "language": "text",
        "code": "<a [routerLink]=\"['/crisis-center']\">Crisis Center</a>"
      },
      {
        "language": "text",
        "code": "/crisis-center"
      },
      {
        "language": "text",
        "code": "CrisisListComponent"
      },
      {
        "language": "text",
        "code": "content_copy\n      \n      <a [routerLink]=\"['/crisis-center', 1]\">Dragon Crisis</a>"
      },
      {
        "language": "text",
        "code": "<a [routerLink]=\"['/crisis-center', 1]\">Dragon Crisis</a>"
      },
      {
        "language": "text",
        "code": "/crisis-center"
      },
      {
        "language": "text",
        "code": "/crisis-center/1"
      },
      {
        "language": "text",
        "code": "AppComponent"
      },
      {
        "language": "text",
        "code": "content_copy\n      \n      template: `\n  <h1 class=\"title\">Angular Router</h1>\n  <nav>\n    <a [routerLink]=\"['/crisis-center']\">Crisis Center</a>\n    <a [routerLink]=\"['/crisis-center/1', { foo: 'foo' }]\">Dragon Crisis</a>\n    <a [routerLink]=\"['/crisis-center/2']\">Shark Crisis</a>\n  </nav>\n  <router-outlet></router-outlet>\n`"
      },
      {
        "language": "text",
        "code": "template: `\n  <h1 class=\"title\">Angular Router</h1>\n  <nav>\n    <a [routerLink]=\"['/crisis-center']\">Crisis Center</a>\n    <a [routerLink]=\"['/crisis-center/1', { foo: 'foo' }]\">Dragon Crisis</a>\n    <a [routerLink]=\"['/crisis-center/2']\">Shark Crisis</a>\n  </nav>\n  <router-outlet></router-outlet>\n`"
      },
      {
        "language": "text",
        "code": "LocationStrategy"
      },
      {
        "language": "text",
        "code": "content_copy\n      \n      localhost:3002/crisis-center"
      },
      {
        "language": "text",
        "code": "localhost:3002/crisis-center"
      },
      {
        "language": "text",
        "code": "content_copy\n      \n      localhost:3002/src/#/crisis-center"
      },
      {
        "language": "text",
        "code": "localhost:3002/src/#/crisis-center"
      },
      {
        "language": "text",
        "code": "LocationStrategy"
      },
      {
        "language": "text",
        "code": "PathLocationStrategy"
      },
      {
        "language": "text",
        "code": "HashLocationStrategy"
      },
      {
        "language": "text",
        "code": "provideRouter"
      },
      {
        "language": "text",
        "code": "LocationStrategy"
      },
      {
        "language": "text",
        "code": "PathLocationStrategy"
      },
      {
        "language": "text",
        "code": "HashLocationStrategy"
      },
      {
        "language": "text",
        "code": "<base href>"
      },
      {
        "language": "text",
        "code": "localhost:4200/crisis-center"
      },
      {
        "language": "text",
        "code": "<base href>"
      },
      {
        "language": "text",
        "code": "<base href>"
      },
      {
        "language": "text",
        "code": "content_copy\n      \n      <base href=\"/\">"
      },
      {
        "language": "text",
        "code": "<base href=\"/\">"
      },
      {
        "language": "text",
        "code": "<base href>"
      },
      {
        "language": "text",
        "code": "foo://example.com:8042/over/there?name=ferret#nose\n\\_/   \\______________/\\_________/ \\_________/ \\__/\n |           |            |            |        |\nscheme    authority      path        query   fragment"
      },
      {
        "language": "text",
        "code": "foo://example.com:8042/over/there?name=ferret#nose\n\\_/   \\______________/\\_________/ \\_________/ \\__/\n |           |            |            |        |\nscheme    authority      path        query   fragment"
      },
      {
        "language": "text",
        "code": "<base href>"
      },
      {
        "language": "text",
        "code": "<base href>"
      },
      {
        "language": "text",
        "code": "content_copy\n      \n      <base href=\"/\">"
      },
      {
        "language": "text",
        "code": "<base href=\"/\">"
      },
      {
        "language": "text",
        "code": "APP_BASE_HREF"
      },
      {
        "language": "text",
        "code": "<base href>"
      },
      {
        "language": "text",
        "code": "<base href>"
      },
      {
        "language": "text",
        "code": "<base href>"
      },
      {
        "language": "text",
        "code": "HashLocationStrategy"
      },
      {
        "language": "text",
        "code": "<base href>"
      },
      {
        "language": "text",
        "code": "APP_BASE_HREF"
      },
      {
        "language": "text",
        "code": "<base href>"
      },
      {
        "language": "text",
        "code": "<base href>"
      },
      {
        "language": "text",
        "code": "<base href>"
      },
      {
        "language": "text",
        "code": "HashLocationStrategy"
      },
      {
        "language": "text",
        "code": "HashLocationStrategy"
      },
      {
        "language": "text",
        "code": "withHashLocation"
      },
      {
        "language": "text",
        "code": "provideRouter"
      },
      {
        "language": "text",
        "code": "provideRouter"
      },
      {
        "language": "text",
        "code": "ApplicationConfiguration"
      },
      {
        "language": "text",
        "code": "content_copy\n      \n      providers: [\n  provideRouter(appRoutes, withHashLocation())\n]"
      },
      {
        "language": "text",
        "code": "providers: [\n  provideRouter(appRoutes, withHashLocation())\n]"
      },
      {
        "language": "text",
        "code": "RouterModule.forRoot"
      },
      {
        "language": "text",
        "code": "useHash: true"
      },
      {
        "language": "text",
        "code": "RouterModule.forRoot(routes, {useHash: true})"
      }
    ],
    "links": [
      {
        "text": "link",
        "href": "guide/router#common-routing-tasks"
      },
      {
        "text": "Generate an application",
        "href": "guide/router#generate-an-application"
      },
      {
        "text": "Adding components for routing",
        "href": "guide/router#adding-components-for-routing"
      },
      {
        "text": "Importing your new components",
        "href": "guide/router#importing-your-new-components"
      },
      {
        "text": "Defining a basic route",
        "href": "guide/router#defining-a-basic-route"
      },
      {
        "text": "Route order",
        "href": "guide/router#route-order"
      },
      {
        "text": "Getting route information",
        "href": "guide/router#getting-route-information"
      },
      {
        "text": "Setting up wildcard routes",
        "href": "guide/router#setting-up-wildcard-routes"
      },
      {
        "text": "Displaying a 404 page",
        "href": "guide/router#displaying-a-404-page"
      },
      {
        "text": "Setting up redirects",
        "href": "guide/router#setting-up-redirects"
      },
      {
        "text": "Nesting routes",
        "href": "guide/router#nesting-routes"
      },
      {
        "text": "Setting the page title",
        "href": "guide/router#setting-the-page-title"
      },
      {
        "text": "Using relative paths",
        "href": "guide/router#using-relative-paths"
      },
      {
        "text": "Specifying a relative route",
        "href": "guide/router#specifying-a-relative-route"
      },
      {
        "text": "Accessing query parameters and fragments",
        "href": "guide/router#accessing-query-parameters-and-fragments"
      },
      {
        "text": "Lazy loading",
        "href": "guide/router#lazy-loading"
      },
      {
        "text": "Preventing unauthorized access",
        "href": "guide/router#preventing-unauthorized-access"
      },
      {
        "text": "Link parameters array",
        "href": "guide/router#link-parameters-array"
      },
      {
        "text": "LocationStrategy and browser URL styles",
        "href": "guide/router#locationstrategy-and-browser-url-styles"
      },
      {
        "text": "Choosing a routing strategy",
        "href": "guide/router#choosing-a-routing-strategy"
      },
      {
        "text": "<base href>",
        "href": "guide/router#base-href"
      },
      {
        "text": "HTML5 URLs and the <base href>",
        "href": "guide/router#html5-urls-and-the-base-href"
      },
      {
        "text": "HashLocationStrategy",
        "href": "guide/router#hashlocationstrategy"
      },
      {
        "text": "link",
        "href": "guide/router#generate-an-application"
      },
      {
        "text": "link",
        "href": "guide/router#adding-components-for-routing"
      },
      {
        "text": "Component",
        "href": "api/core/Component"
      },
      {
        "text": "link",
        "href": "guide/router#importing-your-new-components"
      },
      {
        "text": "link",
        "href": "guide/router#defining-a-basic-route"
      },
      {
        "text": "provideRouter",
        "href": "api/router/provideRouter"
      },
      {
        "text": "ApplicationConfig",
        "href": "api/core/ApplicationConfig"
      },
      {
        "text": "ApplicationConfig",
        "href": "api/core/ApplicationConfig"
      },
      {
        "text": "provideRouter",
        "href": "api/router/provideRouter"
      },
      {
        "text": "Routes",
        "href": "api/router/Routes"
      },
      {
        "text": "Routes",
        "href": "api/router/Routes"
      },
      {
        "text": "Routes",
        "href": "api/router/Routes"
      },
      {
        "text": "Routes",
        "href": "api/router/Routes"
      },
      {
        "text": "Routes",
        "href": "api/router/Routes"
      },
      {
        "text": "routerLink",
        "href": "api/router/RouterLink"
      },
      {
        "text": "router-outlet",
        "href": "api/router/RouterOutlet"
      },
      {
        "text": "Router",
        "href": "api/router/Router"
      },
      {
        "text": "routerLink",
        "href": "api/router/RouterLink"
      },
      {
        "text": "routerLinkActive",
        "href": "api/router/RouterLinkActive"
      },
      {
        "text": "Component",
        "href": "api/core/Component"
      },
      {
        "text": "routerLink",
        "href": "api/router/RouterLink"
      },
      {
        "text": "routerLinkActive",
        "href": "api/router/RouterLinkActive"
      },
      {
        "text": "Component",
        "href": "api/core/Component"
      },
      {
        "text": "router-outlet",
        "href": "api/router/RouterOutlet"
      },
      {
        "text": "router-outlet",
        "href": "api/router/RouterOutlet"
      },
      {
        "text": "router-outlet",
        "href": "api/router/RouterOutlet"
      },
      {
        "text": "RouterLink",
        "href": "api/router/RouterLink"
      },
      {
        "text": "RouterLinkActive",
        "href": "api/router/RouterLinkActive"
      },
      {
        "text": "RouterOutlet",
        "href": "api/router/RouterOutlet"
      },
      {
        "text": "Component",
        "href": "api/core/Component"
      },
      {
        "text": "CommonModule",
        "href": "api/common/CommonModule"
      },
      {
        "text": "RouterOutlet",
        "href": "api/router/RouterOutlet"
      },
      {
        "text": "RouterLink",
        "href": "api/router/RouterLink"
      },
      {
        "text": "RouterLinkActive",
        "href": "api/router/RouterLinkActive"
      },
      {
        "text": "link",
        "href": "guide/router#route-order"
      },
      {
        "text": "Router",
        "href": "api/router/Router"
      },
      {
        "text": "wildcard route",
        "href": "guide/router#setting-up-wildcard-routes"
      },
      {
        "text": "Router",
        "href": "api/router/Router"
      },
      {
        "text": "link",
        "href": "guide/router#getting-route-information"
      },
      {
        "text": "withComponentInputBinding",
        "href": "api/router/withComponentInputBinding"
      },
      {
        "text": "provideRouter",
        "href": "api/router/provideRouter"
      },
      {
        "text": "withComponentInputBinding",
        "href": "api/router/withComponentInputBinding"
      },
      {
        "text": "provideRouter",
        "href": "api/router/provideRouter"
      },
      {
        "text": "provideRouter",
        "href": "api/router/provideRouter"
      },
      {
        "text": "withComponentInputBinding",
        "href": "api/router/withComponentInputBinding"
      },
      {
        "text": "Input",
        "href": "api/core/Input"
      },
      {
        "text": "Input",
        "href": "api/core/Input"
      },
      {
        "text": "paramsInheritanceStrategy",
        "href": "api/router/RouterConfigOptions#paramsInheritanceStrategy"
      },
      {
        "text": "withRouterConfig",
        "href": "api/router/withRouterConfig"
      },
      {
        "text": "link",
        "href": "guide/router#setting-up-wildcard-routes"
      },
      {
        "text": "display a 404 page",
        "href": "guide/router#404-page-how-to"
      },
      {
        "text": "Route order",
        "href": "guide/router#route-order"
      },
      {
        "text": "link",
        "href": "guide/router#displaying-a-404-page"
      },
      {
        "text": "wildcard route",
        "href": "guide/router#wildcard-route-how-to"
      },
      {
        "text": "Routes",
        "href": "api/router/Routes"
      },
      {
        "text": "link",
        "href": "guide/router#setting-up-redirects"
      },
      {
        "text": "Routes",
        "href": "api/router/Routes"
      },
      {
        "text": "Spotlight on pathMatch",
        "href": "guide/router-tutorial-toh#pathmatch"
      },
      {
        "text": "link",
        "href": "guide/router#nesting-routes"
      },
      {
        "text": "router-outlet",
        "href": "api/router/RouterOutlet"
      },
      {
        "text": "router-outlet",
        "href": "api/router/RouterOutlet"
      },
      {
        "text": "router-outlet",
        "href": "api/router/RouterOutlet"
      },
      {
        "text": "Component",
        "href": "api/core/Component"
      },
      {
        "text": "routerLink",
        "href": "api/router/RouterLink"
      },
      {
        "text": "routerLink",
        "href": "api/router/RouterLink"
      },
      {
        "text": "router-outlet",
        "href": "api/router/RouterOutlet"
      },
      {
        "text": "router-outlet",
        "href": "api/router/RouterOutlet"
      },
      {
        "text": "Routes",
        "href": "api/router/Routes"
      },
      {
        "text": "router-outlet",
        "href": "api/router/RouterOutlet"
      },
      {
        "text": "link",
        "href": "guide/router#setting-the-page-title"
      },
      {
        "text": "Router",
        "href": "api/router/Router"
      },
      {
        "text": "Route",
        "href": "api/router/Route"
      },
      {
        "text": "Routes",
        "href": "api/router/Routes"
      },
      {
        "text": "router-outlet",
        "href": "api/router/RouterOutlet"
      },
      {
        "text": "ResolveFn",
        "href": "api/router/ResolveFn"
      },
      {
        "text": "ResolveFn",
        "href": "api/router/ResolveFn"
      },
      {
        "text": "TitleStrategy",
        "href": "api/router/TitleStrategy"
      },
      {
        "text": "Injectable",
        "href": "api/core/Injectable"
      },
      {
        "text": "TitleStrategy",
        "href": "api/router/TitleStrategy"
      },
      {
        "text": "Title",
        "href": "api/platform-browser/Title"
      },
      {
        "text": "RouterStateSnapshot",
        "href": "api/router/RouterStateSnapshot"
      },
      {
        "text": "ApplicationConfig",
        "href": "api/core/ApplicationConfig"
      },
      {
        "text": "provideRouter",
        "href": "api/router/provideRouter"
      },
      {
        "text": "TitleStrategy",
        "href": "api/router/TitleStrategy"
      },
      {
        "text": "link",
        "href": "guide/router#using-relative-paths"
      },
      {
        "text": "Component",
        "href": "api/core/Component"
      },
      {
        "text": "routerLink",
        "href": "api/router/RouterLink"
      },
      {
        "text": "Route",
        "href": "api/router/Route"
      },
      {
        "text": "router-outlet",
        "href": "api/router/RouterOutlet"
      },
      {
        "text": "router-outlet",
        "href": "api/router/RouterOutlet"
      },
      {
        "text": "link",
        "href": "guide/router#specifying-a-relative-route"
      },
      {
        "text": "NavigationExtras",
        "href": "api/router/NavigationExtras"
      },
      {
        "text": "NavigationExtras",
        "href": "api/router/NavigationExtras"
      },
      {
        "text": "ActivatedRoute",
        "href": "api/router/ActivatedRoute"
      },
      {
        "text": "link",
        "href": "guide/router#accessing-query-parameters-and-fragments"
      },
      {
        "text": "ActivatedRoute",
        "href": "api/router/ActivatedRoute"
      },
      {
        "text": "ActivatedRoute",
        "href": "api/router/ActivatedRoute"
      },
      {
        "text": "Router",
        "href": "api/router/Router"
      },
      {
        "text": "ActivatedRoute",
        "href": "api/router/ActivatedRoute"
      },
      {
        "text": "ParamMap",
        "href": "api/router/ParamMap"
      },
      {
        "text": "ActivatedRoute",
        "href": "api/router/ActivatedRoute"
      },
      {
        "text": "Router",
        "href": "api/router/Router"
      },
      {
        "text": "ActivatedRoute",
        "href": "api/router/ActivatedRoute"
      },
      {
        "text": "Router",
        "href": "api/router/Router"
      },
      {
        "text": "link",
        "href": "guide/router#lazy-loading"
      },
      {
        "text": "Lazy loading",
        "href": "guide/lazy-loading-ngmodules"
      },
      {
        "text": "link",
        "href": "guide/router#preventing-unauthorized-access"
      },
      {
        "text": "canActivate",
        "href": "api/router/CanActivateFn"
      },
      {
        "text": "canActivateChild",
        "href": "api/router/CanActivateChildFn"
      },
      {
        "text": "canDeactivate",
        "href": "api/router/CanDeactivateFn"
      },
      {
        "text": "canMatch",
        "href": "api/router/CanMatchFn"
      },
      {
        "text": "resolve",
        "href": "api/router/ResolveFn"
      },
      {
        "text": "canLoad",
        "href": "api/router/CanLoadFn"
      },
      {
        "text": "component-less routes",
        "href": "api/router/Route#componentless-routes"
      },
      {
        "text": "CanActivateFn",
        "href": "api/router/CanActivateFn"
      },
      {
        "text": "ActivatedRouteSnapshot",
        "href": "api/router/ActivatedRouteSnapshot"
      },
      {
        "text": "RouterStateSnapshot",
        "href": "api/router/RouterStateSnapshot"
      },
      {
        "text": "routing tutorial section on route guards",
        "href": "guide/router-tutorial-toh#milestone-5-route-guards"
      },
      {
        "text": "link",
        "href": "guide/router#link-parameters-array"
      },
      {
        "text": "RouterLink",
        "href": "api/router/RouterLink"
      },
      {
        "text": "routerLink",
        "href": "api/router/RouterLink"
      },
      {
        "text": "routerLink",
        "href": "api/router/RouterLink"
      },
      {
        "text": "routerLink",
        "href": "api/router/RouterLink"
      },
      {
        "text": "RouterLink",
        "href": "api/router/RouterLink"
      },
      {
        "text": "default child route",
        "href": "guide/router-tutorial-toh#a-crisis-center-with-child-routes"
      },
      {
        "text": "routerLink",
        "href": "api/router/RouterLink"
      },
      {
        "text": "routerLink",
        "href": "api/router/RouterLink"
      },
      {
        "text": "Router",
        "href": "api/router/Router"
      },
      {
        "text": "routerLink",
        "href": "api/router/RouterLink"
      },
      {
        "text": "routerLink",
        "href": "api/router/RouterLink"
      },
      {
        "text": "routerLink",
        "href": "api/router/RouterLink"
      },
      {
        "text": "router-outlet",
        "href": "api/router/RouterOutlet"
      },
      {
        "text": "router-outlet",
        "href": "api/router/RouterOutlet"
      },
      {
        "text": "LocationStrategy",
        "href": "api/common/LocationStrategy"
      },
      {
        "text": "link",
        "href": "guide/router#locationstrategy-and-browser-url-styles"
      },
      {
        "text": "history.pushState",
        "href": "https://developer.mozilla.org/docs/Web/API/History_API/Working_with_the_History_API#adding_and_modifying_history_entries"
      },
      {
        "text": "LocationStrategy",
        "href": "api/common/LocationStrategy"
      },
      {
        "text": "PathLocationStrategy",
        "href": "api/common/PathLocationStrategy"
      },
      {
        "text": "HashLocationStrategy",
        "href": "api/common/HashLocationStrategy"
      },
      {
        "text": "provideRouter",
        "href": "api/router/provideRouter"
      },
      {
        "text": "LocationStrategy",
        "href": "api/common/LocationStrategy"
      },
      {
        "text": "PathLocationStrategy",
        "href": "api/common/PathLocationStrategy"
      },
      {
        "text": "HashLocationStrategy",
        "href": "api/common/HashLocationStrategy"
      },
      {
        "text": "Dependency Injection",
        "href": "guide/dependency-injection-providers"
      },
      {
        "text": "link",
        "href": "guide/router#choosing-a-routing-strategy"
      },
      {
        "text": "link",
        "href": "guide/router#base-href"
      },
      {
        "text": "history.pushState",
        "href": "https://developer.mozilla.org/docs/Web/API/History_API/Working_with_the_History_API#adding_and_modifying_history_entries"
      },
      {
        "text": "LocationStrategy and browser URL styles",
        "href": "guide/router#browser-url-styles"
      },
      {
        "text": "<base href> element",
        "href": "https://developer.mozilla.org/docs/Web/HTML/Element/base"
      },
      {
        "text": "link",
        "href": "guide/router#html5-urls-and-the-base-href"
      },
      {
        "text": "query",
        "href": "api/animations/query"
      },
      {
        "text": "HTML5 pushState",
        "href": "https://developer.mozilla.org/docs/Web/API/History_API#Adding_and_modifying_history_entries"
      },
      {
        "text": "<base href> element",
        "href": "https://developer.mozilla.org/docs/Web/HTML/Element/base"
      },
      {
        "text": "APP_BASE_HREF",
        "href": "api/common/APP_BASE_HREF"
      },
      {
        "text": "query",
        "href": "api/animations/query"
      },
      {
        "text": "query",
        "href": "api/animations/query"
      },
      {
        "text": "query",
        "href": "api/animations/query"
      },
      {
        "text": "query",
        "href": "api/animations/query"
      },
      {
        "text": "HashLocationStrategy",
        "href": "api/common/HashLocationStrategy"
      },
      {
        "text": "APP_BASE_HREF",
        "href": "api/common/APP_BASE_HREF"
      },
      {
        "text": "RFC",
        "href": "https://tools.ietf.org/html/rfc3986#section-5.2.2"
      },
      {
        "text": "HashLocationStrategy",
        "href": "api/common/HashLocationStrategy"
      },
      {
        "text": "link",
        "href": "guide/router#hashlocationstrategy"
      },
      {
        "text": "HashLocationStrategy",
        "href": "api/common/HashLocationStrategy"
      },
      {
        "text": "withHashLocation",
        "href": "api/router/withHashLocation"
      },
      {
        "text": "provideRouter",
        "href": "api/router/provideRouter"
      },
      {
        "text": "provideRouter",
        "href": "api/router/provideRouter"
      },
      {
        "text": "provideRouter",
        "href": "api/router/provideRouter"
      },
      {
        "text": "withHashLocation",
        "href": "api/router/withHashLocation"
      }
    ],
    "meta": {
      "description": "",
      "keywords": ""
    },
    "summary": "Common Routing Taskslink Contents Generate an applicationAdding components for routingImporting your new componentsDefining a basic routeRoute orderGetting route informationSetting up wildcard routesD...",
    "tags": [
      "react",
      "vue",
      "angular",
      "javascript",
      "typescript",
      "css",
      "html",
      "node",
      "vite",
      "setting"
    ],
    "id": "angular-router-part-1",
    "quality": 90
  },
  {
    "title": "async function",
    "url": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Statements/async_function",
    "category": "javascript",
    "content": "async function Baseline Widely available This feature is well established and works across many devices and browser versions. Its been available across browsers since April 2017. Learn more See full compatibility Report feedback The async function declaration creates a binding of a new async function to a given name. The await keyword is permitted within the function body, enabling asynchronous, promise-based behavior to be written in a cleaner style and avoiding the need to explicitly configure promise chains. You can also define async functions using the async function expression. Try it Syntax Note: There cannot be a line terminator between async and function, otherwise a semicolon is automatically inserted, causing async to become an identifier and the rest to become a function declaration. Parameters name The function's name. param Optional The name of a formal parameter for the function. For the parameters' syntax, see the Functions reference. statements Optional The statements comprising the body of the function. The await mechanism may be used. Description An async function declaration creates an AsyncFunction object. Each time when an async function is called, it returns a new Promise which will be resolved with the value returned by the async function, or rejected with an exception uncaught within the async function. Async functions can contain zero or more await expressions. Await expressions make promise-returning functions behave as though they're synchronous by suspending execution until the returned promise is fulfilled or rejected. The resolved value of the promise is treated as the return value of the await expression. Use of async and await enables the use of ordinary try / catch blocks around asynchronous code. Note: The await keyword is only valid inside async functions within regular JavaScript code. If you use it outside of an async function's body, you will get a SyntaxError. await can be used on its own with JavaScript modules. Note: The purpose of async/await is to simplify the syntax necessary to consume promise-based APIs. The behavior of async/await is similar to combining generators and promises. Async functions always return a promise. If the return value of an async function is not explicitly a promise, it will be implicitly wrapped in a promise. For example, consider the following code: It is similar to: Note that even though the return value of an async function behaves as if it's wrapped in a Promise.resolve, they are not equivalent. An async function will return a different reference, whereas Promise.resolve returns the same reference if the given value is a promise. It can be a problem when you want to check the equality of a promise and a return value of an async function. The body of an async function can be thought of as being split by zero or more await expressions. Top-level code, up to and including the first await expression (if there is one), is run synchronously. In this way, an async function without an await expression will run synchronously. If there is an await expression inside the function body, however, the async function will always complete asynchronously. For example: It is also equivalent to: Code after each await expression can be thought of as existing in a .then callback. In this way a promise chain is progressively constructed with each reentrant step through the function. The return value forms the final link in the chain. In the following example, we successively await two promises. Progress moves through function foo in three stages. The first line of the body of function foo is executed synchronously, with the await expression configured with the pending promise. Progress through foo is then suspended and control is yielded back to the function that called foo. Some time later, when the first promise has either been fulfilled or rejected, control moves back into foo. The result of the first promise fulfillment (if it was not rejected) is returned from the await expression. Here 1 is assigned to result1. Progress continues, and the second await expression is evaluated. Again, progress through foo is suspended and control is yielded. Some time later, when the second promise has either been fulfilled or rejected, control re-enters foo. The result of the second promise resolution is returned from the second await expression. Here 2 is assigned to result2. Control moves to the return expression (if any). The default return value of undefined is returned as the resolution value of the current promise. Note how the promise chain is not built-up in one go. Instead, the promise chain is constructed in stages as control is successively yielded from and returned to the async function. As a result, we must be mindful of error handling behavior when dealing with concurrent asynchronous operations. For example, in the following code an unhandled promise rejection error will be thrown, even if a .catch handler has been configured further along the promise chain. This is because p2 will not be \"wired into\" the promise chain until control returns from p1. async function declarations behave similar to function declarations  they are hoisted to the top of their scope and can be called anywhere in their scope, and they can be redeclared only in certain contexts. Examples Async functions and execution order await and concurrency In sequentialStart, execution suspends 2 seconds for the first await, and then another second for the second await. The second timer is not created until the first has already fired, so the code finishes after 3 seconds. In sequentialWait, both timers are created and then awaited. The timers run concurrently, which means the code finishes in 2 rather than 3 seconds, i.e., the slowest timer. However, the await calls still run in series, which means the second await will wait for the first one to finish. In this case, the result of the fastest timer is processed after the slowest. If you wish to safely perform other jobs after two or more jobs run concurrently and are complete, you must await a call to Promise.all() or Promise.allSettled() before that job. Warning: The functions sequentialWait and concurrent1 are not functionally equivalent. In sequentialWait, if promise fast rejects before promise slow is fulfilled, then an unhandled promise rejection error will be raised, regardless of whether the caller has configured a catch clause. In concurrent1, Promise.all wires up the promise chain in one go, meaning that the operation will fail-fast regardless of the order of rejection of the promises, and the error will always occur within the configured promise chain, enabling it to be caught in the normal way. Rewriting a Promise chain with an async function An API that returns a Promise will result in a promise chain, and it splits the function into many parts. Consider the following code: it can be rewritten with a single async function as follows: Alternatively, you can chain the promise with catch(): In the two rewritten versions, notice there is no await statement after the return keyword, although that would be valid too: The return value of an async function is implicitly wrapped in Promise.resolve - if it's not already a promise itself (as in the examples). Specifications Specification ECMAScript 2026 Language Specification# sec-async-function-definitions Browser compatibility See also Functions guide Using promises guide Functions AsyncFunction async function expression function function* async function* await Promise Decorating async JavaScript functions on innolitics.com (2016) Help improve MDN Learn how to contribute This page was last modified on Jul 8, 2025 by MDN contributors. View this page on GitHub  Report a problem with this content",
    "headings": [
      {
        "level": 1,
        "text": "async function",
        "id": ""
      },
      {
        "level": 2,
        "text": "Try it",
        "id": "try_it"
      },
      {
        "level": 2,
        "text": "Syntax",
        "id": "syntax"
      },
      {
        "level": 2,
        "text": "Description",
        "id": "description"
      },
      {
        "level": 2,
        "text": "Examples",
        "id": "examples"
      },
      {
        "level": 2,
        "text": "Specifications",
        "id": "specifications"
      },
      {
        "level": 2,
        "text": "Browser compatibility",
        "id": "browser_compatibility"
      },
      {
        "level": 2,
        "text": "See also",
        "id": "see_also"
      },
      {
        "level": 2,
        "text": "Help improve MDN",
        "id": "feedback"
      },
      {
        "level": 3,
        "text": "Parameters",
        "id": "parameters"
      },
      {
        "level": 3,
        "text": "Async functions and execution order",
        "id": "async_functions_and_execution_order"
      },
      {
        "level": 3,
        "text": "Rewriting a Promise chain with an async function",
        "id": "rewriting_a_promise_chain_with_an_async_function"
      },
      {
        "level": 4,
        "text": "await and concurrency",
        "id": "await_and_concurrency"
      }
    ],
    "codeBlocks": [
      {
        "language": "text",
        "code": "async function"
      },
      {
        "language": "text",
        "code": "async function"
      },
      {
        "language": "text",
        "code": "async function"
      },
      {
        "language": "text",
        "code": "AsyncFunction"
      },
      {
        "language": "text",
        "code": "SyntaxError"
      },
      {
        "language": "text",
        "code": "Promise.resolve"
      },
      {
        "language": "text",
        "code": "Promise.resolve"
      },
      {
        "language": "text",
        "code": "async function"
      },
      {
        "language": "text",
        "code": "sequentialStart"
      },
      {
        "language": "text",
        "code": "sequentialWait"
      },
      {
        "language": "text",
        "code": "Promise.all()"
      },
      {
        "language": "text",
        "code": "Promise.allSettled()"
      },
      {
        "language": "text",
        "code": "sequentialWait"
      },
      {
        "language": "text",
        "code": "concurrent1"
      },
      {
        "language": "text",
        "code": "sequentialWait"
      },
      {
        "language": "text",
        "code": "concurrent1"
      },
      {
        "language": "text",
        "code": "Promise.all"
      },
      {
        "language": "text",
        "code": "Promise.resolve"
      },
      {
        "language": "text",
        "code": "AsyncFunction"
      },
      {
        "language": "text",
        "code": "async function"
      },
      {
        "language": "text",
        "code": "async function*"
      }
    ],
    "links": [
      {
        "text": "Learn more",
        "href": "/en-US/docs/Glossary/Baseline/Compatibility"
      },
      {
        "text": "Report feedback",
        "href": "https://survey.alchemer.com/s3/7634825/MDN-baseline-feedback?page=%2Fen-US%2Fdocs%2FWeb%2FJavaScript%2FReference%2FStatements%2Fasync_function&level=high"
      },
      {
        "text": "binding",
        "href": "/en-US/docs/Glossary/Binding"
      },
      {
        "text": "async function expression",
        "href": "/en-US/docs/Web/JavaScript/Reference/Operators/async_function"
      },
      {
        "text": "automatically inserted",
        "href": "/en-US/docs/Web/JavaScript/Reference/Lexical_grammar#automatic_semicolon_insertion"
      },
      {
        "text": "Functions reference",
        "href": "/en-US/docs/Web/JavaScript/Guide/Functions#function_parameters"
      },
      {
        "text": "AsyncFunction",
        "href": "/en-US/docs/Web/JavaScript/Reference/Global_Objects/AsyncFunction"
      },
      {
        "text": "Promise",
        "href": "/en-US/docs/Web/JavaScript/Reference/Global_Objects/Promise"
      },
      {
        "text": "await",
        "href": "/en-US/docs/Web/JavaScript/Reference/Operators/await"
      },
      {
        "text": "SyntaxError",
        "href": "/en-US/docs/Web/JavaScript/Reference/Global_Objects/SyntaxError"
      },
      {
        "text": "JavaScript modules.",
        "href": "/en-US/docs/Web/JavaScript/Guide/Modules"
      },
      {
        "text": "generators",
        "href": "/en-US/docs/Web/JavaScript/Guide/Iterators_and_generators"
      },
      {
        "text": "function",
        "href": "/en-US/docs/Web/JavaScript/Reference/Statements/function"
      },
      {
        "text": "hoisted",
        "href": "/en-US/docs/Glossary/Hoisting"
      },
      {
        "text": "Promise.all()",
        "href": "/en-US/docs/Web/JavaScript/Reference/Global_Objects/Promise/all"
      },
      {
        "text": "Promise.allSettled()",
        "href": "/en-US/docs/Web/JavaScript/Reference/Global_Objects/Promise/allSettled"
      },
      {
        "text": "Promise",
        "href": "/en-US/docs/Web/JavaScript/Reference/Global_Objects/Promise"
      },
      {
        "text": "Promise.resolve",
        "href": "/en-US/docs/Web/JavaScript/Reference/Global_Objects/Promise/resolve"
      },
      {
        "text": "ECMAScript® 2026 Language Specification# sec-async-function-definitions",
        "href": "https://tc39.es/ecma262/multipage/ecmascript-language-functions-and-classes.html#sec-async-function-definitions"
      },
      {
        "text": "Functions",
        "href": "/en-US/docs/Web/JavaScript/Guide/Functions"
      },
      {
        "text": "Using promises",
        "href": "/en-US/docs/Web/JavaScript/Guide/Using_promises"
      },
      {
        "text": "Functions",
        "href": "/en-US/docs/Web/JavaScript/Reference/Functions"
      },
      {
        "text": "AsyncFunction",
        "href": "/en-US/docs/Web/JavaScript/Reference/Global_Objects/AsyncFunction"
      },
      {
        "text": "async function expression",
        "href": "/en-US/docs/Web/JavaScript/Reference/Operators/async_function"
      },
      {
        "text": "function",
        "href": "/en-US/docs/Web/JavaScript/Reference/Statements/function"
      },
      {
        "text": "function*",
        "href": "/en-US/docs/Web/JavaScript/Reference/Statements/function*"
      },
      {
        "text": "async function*",
        "href": "/en-US/docs/Web/JavaScript/Reference/Statements/async_function*"
      },
      {
        "text": "await",
        "href": "/en-US/docs/Web/JavaScript/Reference/Operators/await"
      },
      {
        "text": "Promise",
        "href": "/en-US/docs/Web/JavaScript/Reference/Global_Objects/Promise"
      },
      {
        "text": "Decorating async JavaScript functions",
        "href": "https://innolitics.com/10x/javascript-decorators-for-promise-returning-functions/"
      },
      {
        "text": "Learn how to contribute",
        "href": "/en-US/docs/MDN/Community/Getting_started"
      },
      {
        "text": "MDN contributors",
        "href": "/en-US/docs/Web/JavaScript/Reference/Statements/async_function/contributors.txt"
      },
      {
        "text": "View this page on GitHub",
        "href": "https://github.com/mdn/content/blob/main/files/en-us/web/javascript/reference/statements/async_function/index.md?plain=1"
      },
      {
        "text": "Report a problem with this content",
        "href": "https://github.com/mdn/content/issues/new?template=page-report.yml&mdn-url=https%3A%2F%2Fdeveloper.mozilla.org%2Fen-US%2Fdocs%2FWeb%2FJavaScript%2FReference%2FStatements%2Fasync_function&metadata=%3C%21--+Do+not+make+changes+below+this+line+--%3E%0A%3Cdetails%3E%0A%3Csummary%3EPage+report+details%3C%2Fsummary%3E%0A%0A*+Folder%3A+%60en-us%2Fweb%2Fjavascript%2Freference%2Fstatements%2Fasync_function%60%0A*+MDN+URL%3A+https%3A%2F%2Fdeveloper.mozilla.org%2Fen-US%2Fdocs%2FWeb%2FJavaScript%2FReference%2FStatements%2Fasync_function%0A*+GitHub+URL%3A+https%3A%2F%2Fgithub.com%2Fmdn%2Fcontent%2Fblob%2Fmain%2Ffiles%2Fen-us%2Fweb%2Fjavascript%2Freference%2Fstatements%2Fasync_function%2Findex.md%0A*+Last+commit%3A+https%3A%2F%2Fgithub.com%2Fmdn%2Fcontent%2Fcommit%2Ffad67be4431d8e6c2a89ac880735233aa76c41d4%0A*+Document+last+modified%3A+2025-07-08T13%3A18%3A45.000Z%0A%0A%3C%2Fdetails%3E"
      }
    ],
    "meta": {
      "description": "The async function declaration creates a binding of a new async function to a given name. The await keyword is permitted within the function body, enabling asynchronous, promise-based behavior to be written in a cleaner style and avoiding the need to explicitly configure promise chains.",
      "keywords": ""
    },
    "summary": "async function Baseline Widely available This feature is well established and works across many devices and browser versions. Its been available across browsers since April 2017",
    "tags": [
      "react",
      "angular",
      "javascript",
      "typescript",
      "css",
      "html",
      "node",
      "vite",
      "async",
      "function"
    ],
    "id": "async-function-async_function-part-1",
    "quality": 100
  },
  {
    "title": "Promise",
    "url": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Promise",
    "category": "javascript",
    "content": "Promise Baseline Widely available * This feature is well established and works across many devices and browser versions. Its been available across browsers since July 2015. * Some parts of this feature may have varying levels of support. Learn more See full compatibility Report feedback The Promise object represents the eventual completion (or failure) of an asynchronous operation and its resulting value. To learn about the way promises work and how you can use them, we advise you to read Using promises first. Description A Promise is a proxy for a value not necessarily known when the promise is created. It allows you to associate handlers with an asynchronous action's eventual success value or failure reason. This lets asynchronous methods return values like synchronous methods: instead of immediately returning the final value, the asynchronous method returns a promise to supply the value at some point in the future. A Promise is in one of these states: pending: initial state, neither fulfilled nor rejected. fulfilled: meaning that the operation was completed successfully. rejected: meaning that the operation failed. The eventual state of a pending promise can either be fulfilled with a value or rejected with a reason (error). When either of these options occur, the associated handlers queued up by a promise's then method are called. If the promise has already been fulfilled or rejected when a corresponding handler is attached, the handler will be called, so there is no race condition between an asynchronous operation completing and its handlers being attached. A promise is said to be settled if it is either fulfilled or rejected, but not pending. You will also hear the term resolved used with promises  this means that the promise is settled or \"locked-in\" to match the eventual state of another promise, and further resolving or rejecting it has no effect. The States and fates document from the original Promise proposal contains more details about promise terminology. Colloquially, \"resolved\" promises are often equivalent to \"fulfilled\" promises, but as illustrated in \"States and fates\", resolved promises can be pending or rejected as well. For example: This promise is already resolved at the time when it's created (because the resolveOuter is called synchronously), but it is resolved with another promise, and therefore won't be fulfilled until 1 second later, when the inner promise fulfills. In practice, the \"resolution\" is often done behind the scenes and not observable, and only its fulfillment or rejection are. Note: Several other languages have mechanisms for lazy evaluation and deferring a computation, which they also call \"promises\", e.g., Scheme. Promises in JavaScript represent processes that are already happening, which can be chained with callback functions. If you are looking to lazily evaluate an expression, consider using a function with no arguments e.g., f = () = expression to create the lazily-evaluated expression, and f() to evaluate the expression immediately. Promise itself has no first-class protocol for cancellation, but you may be able to directly cancel the underlying asynchronous operation, typically using AbortController. Chained Promises The promise methods then(), catch(), and finally() are used to associate further action with a promise that becomes settled. The then() method takes up to two arguments; the first argument is a callback function for the fulfilled case of the promise, and the second argument is a callback function for the rejected case. The catch() and finally() methods call then() internally and make error handling less verbose. For example, a catch() is really just a then() without passing the fulfillment handler. As these methods return promises, they can be chained. For example: We will use the following terminology: initial promise is the promise on which then is called; new promise is the promise returned by then. The two callbacks passed to then are called fulfillment handler and rejection handler, respectively. The settled state of the initial promise determines which handler to execute. If the initial promise is fulfilled, the fulfillment handler is called with the fulfillment value. If the initial promise is rejected, the rejection handler is called with the rejection reason. The completion of the handler determines the settled state of the new promise. If the handler returns a thenable value, the new promise settles in the same state as the returned value. If the handler returns a non-thenable value, the new promise is fulfilled with the returned value. If the handler throws an error, the new promise is rejected with the thrown error. If the initial promise has no corresponding handler attached, the new promise will settle to the same state as the initial promise  that is, without a rejection handler, a rejected promise stays rejected with the same reason. For example, in the code above, if myPromise rejects, handleRejectedA will be called, and if handleRejectedA completes normally (without throwing or returning a rejected promise), the promise returned by the first then will be fulfilled instead of staying rejected. Therefore, if an error must be handled immediately, but we want to maintain the error state down the chain, we must throw an error of some type in the rejection handler. On the other hand, in the absence of an immediate need, we can leave out error handling until the final catch() handler. Using arrow functions for the callback functions, implementation of the promise chain might look something like this: Note: For faster execution, all synchronous actions should preferably be done within one handler, otherwise it would take several ticks to execute all handlers in sequence. JavaScript maintains a job queue. Each time, JavaScript picks a job from the queue and executes it to completion. The jobs are defined by the executor of the Promise() constructor, the handlers passed to then, or any platform API that returns a promise. The promises in a chain represent the dependency relationship between these jobs. When a promise settles, the respective handlers associated with it are added to the back of the job queue. A promise can participate in more than one chain. For the following code, the fulfillment of promiseA will cause both handleFulfilled1 and handleFulfilled2 to be added to the job queue. Because handleFulfilled1 is registered first, it will be invoked first. An action can be assigned to an already settled promise. In this case, the action is added immediately to the back of the job queue and will be performed when all existing jobs are completed. Therefore, an action for an already \"settled\" promise will occur only after the current synchronous code completes and at least one loop-tick has passed. This guarantees that promise actions are asynchronous. Thenables The JavaScript ecosystem had made multiple Promise implementations long before it became part of the language. Despite being represented differently internally, at the minimum, all Promise-like objects implement the Thenable interface. A thenable implements the .then() method, which is called with two callbacks: one for when the promise is fulfilled, one for when it's rejected. Promises are thenables as well. To interoperate with the existing Promise implementations, the language allows using thenables in place of promises. For example, Promise.resolve will not only resolve promises, but also trace thenables. Promise concurrency The Promise class offers four static methods to facilitate async task concurrency: Promise.all() Fulfills when all of the promises fulfill; rejects when any of the promises rejects. Promise.allSettled() Fulfills when all promises settle. Promise.any() Fulfills when any of the promises fulfills; rejects when all of the promises reject. Promise.race() Settles when any of the promises settles. In other words, fulfills when any of the promises fulfills; rejects when any of the promises rejects. All these methods take an iterable of promises (thenables, to be exact) and return a new promise. They all support subclassing, which means they can be called on subclasses of Promise, and the result will be a promise of the subclass type. To do so, the subclass's constructor must implement the same signature as the Promise() constructor  accepting a single executor function that can be called with the resolve and reject callbacks as parameters. The subclass must also have a resolve static method that can be called like Promise.resolve() to resolve values to promises. Note that JavaScript is single-threaded by nature, so at a given instant, only one task will be executing, although control can shift between different promises, making execution of the promises appear concurrent. Parallel execution in JavaScript can only be achieved through worker threads. Constructor Promise() Creates a new Promise object. The constructor is primarily used to wrap functions that do not already support promises. Static properties Promise[Symbol.species] Returns the constructor used to construct return values from promise methods. Static methods Promise.all() Takes an iterable of promises as input and returns a single Promise. This returned promise fulfills when all of the input's promises fulfill (including when an empty iterable is passed), with an array of the fulfillment values. It rejects when any of the input's promises reject, with this first rejection reason. Promise.allSettled() Takes an iterable of promises as input and returns a single Promise. This returned promise fulfills when all of the input's promises settle (including when an empty iterable is passed), with an array of objects that describe the outcome of each promise. Promise.any() Takes an iterable of promises as input and returns a single Promise. This returned promise fulfills when any of the input's promises fulfill, with this first fulfillment value. It rejects when all of the input's promises reject (including when an empty iterable is passed), with an AggregateError containing an array of rejection reasons. Promise.race() Takes an iterable of promises as input and returns a single Promise. This returned promise settles with the eventual state of the first promise that settles. Promise.reject() Returns a new Promise object that is rejected with the given reason. Promise.resolve() Returns a Promise object that is resolved with the given value. If the value is a thenable (i.e., has a then method), the returned promise will \"follow\" that thenable, adopting its eventual state; otherwise, the returned promise will be fulfilled with the value. Promise.try() Takes a callback of any kind (returns or throws, synchronously or asynchronously) and wraps its result in a Promise. Promise.withResolvers() Returns an object containing a new Promise object and two functions to resolve or reject it, corresponding to the two parameters passed to the executor of the Promise() constructor. Instance properties These properties are defined on Promise.prototype and shared by all Promise instances. Promise.prototype.constructor The constructor function that created the instance object. For Promise instances, the initial value is the Promise constructor. Promise.prototype[Symbol.toStringTag] The initial value of the [Symbol.toStringTag] property is the string \"Promise\". This property is used in Object.prototype.toString(). Instance methods Promise.prototype.catch() Appends a rejection handler callback to the promise, and returns a new promise resolving to the return value of the callback if it is called, or to its original fulfillment value if the promise is instead fulfilled. Promise.prototype.finally() Appends a handler to the promise, and returns a new promise that is resolved when the original promise is resolved. The handler is called when the promise is settled, whether fulfilled or rejected. Promise.prototype.then() Appends fulfillment and rejection handlers to the promise, and returns a new promise resolving to the return value of the called handler, or to its original settled value if the promise was not handled (i.e., if the relevant handler onFulfilled or onRejected is not a function). Examples Basic Example In this example, we use setTimeout(...) to simulate async code. In reality, you will probably be using something like XHR or an HTML API. Example with diverse situations This example shows diverse techniques for using Promise capabilities and diverse situations that can occur. To understand this, start by scrolling to the bottom of the code block, and examine the promise chain. Upon provision of an initial promise, a chain of promises can follow. The chain is composed of .then() calls, and typically (but not necessarily) has a single .catch() at the end, optionally followed by .finally(). In this example, the promise chain is initiated by a custom-written new Promise() construct; but in actual practice, promise chains more typically start with an API function (written by someone else) that returns a promise. The example function tetheredGetNumber() shows that a promise generator will utilize reject() while setting up an asynchronous call, or within the call-back, or both. The function promiseGetWord() illustrates how an API function might generate and return a promise in a self-contained manner. Note that the function troubleWithGetNumber() ends with a throw. That is forced because a promise chain goes through all the .then() promises, even after an error, and without the throw, the error would seem \"fixed\". This is a hassle, and for this reason, it is common to omit onRejected throughout the chain of .then() promises, and just have a single onRejected in the final catch(). This code can be run under NodeJS. Comprehension is enhanced by seeing the errors actually occur. To force more errors, change the threshold values. Advanced Example This small example shows the mechanism of a Promise. The testPromise() method is called each time the button is clicked. It creates a promise that will be fulfilled, using setTimeout(), to the promise count (number starting from 1) every 1-3 seconds, at random. The Promise() constructor is used to create the promise. The fulfillment of the promise is logged, via a fulfill callback set using p1.then(). A few logs show how the synchronous part of the method is decoupled from the asynchronous completion of the promise. By clicking the button several times in a short amount of time, you'll even see the different promises being fulfilled one after another. HTML JavaScript Result Loading an image with XHR Another example using Promise and XMLHttpRequest to load an image is shown below. Each step is commented on and allows you to follow the Promise and XHR architecture closely. Incumbent settings object tracking A settings object is an environment that provides additional information when JavaScript code is running. This includes the realm and module map, as well as HTML specific information such as the origin. The incumbent settings object is tracked in order to ensure that the browser knows which one to use for a given piece of user code. To better picture this, we can take a closer look at how the realm might be an issue. A realm can be roughly thought of as the global object. What is unique about realms is that they hold all of the necessary information to run JavaScript code. This includes objects like Array and Error. Each settings object has its own \"copy\" of these and they are not shared. That can cause some unexpected behavior in relation to promises. In order to get around this, we track something called the incumbent settings object. This represents information specific to the context of the user code responsible for a certain function call. To illustrate this a bit further we can take a look at how an iframe embedded in a document communicates with its host. Since all web APIs are aware of the incumbent settings object, the following will work in all browsers: The same concept applies to promises. If we modify the above example a little bit, we get this: If we change this so that the iframe in the document is listening to post messages, we can observe the effect of the incumbent settings object: In the above example, the inner text of the iframe will be updated only if the incumbent settings object is tracked. This is because without tracking the incumbent, we may end up using the wrong environment to send the message. Note: Currently, incumbent realm tracking is fully implemented in Firefox, and has partial implementations in Chrome and Safari. Specifications Specification ECMAScript 2026 Language Specification# sec-promise-objects Browser compatibility See also Polyfill of Promise in core-js Using promises guide Promises/A+ specification JavaScript Promises: an introduction on web.dev (2013) Callbacks, Promises, and Coroutines: Asynchronous Programming Patterns in JavaScript slide show by Domenic Denicola (2011) Help improve MDN Learn how to contribute This page was last modified on Aug 19, 2025 by MDN contributors. View this page on GitHub  Report a problem with this content",
    "headings": [
      {
        "level": 1,
        "text": "Promise",
        "id": ""
      },
      {
        "level": 2,
        "text": "Description",
        "id": "description"
      },
      {
        "level": 2,
        "text": "Constructor",
        "id": "constructor"
      },
      {
        "level": 2,
        "text": "Static properties",
        "id": "static_properties"
      },
      {
        "level": 2,
        "text": "Static methods",
        "id": "static_methods"
      },
      {
        "level": 2,
        "text": "Instance properties",
        "id": "instance_properties"
      },
      {
        "level": 2,
        "text": "Instance methods",
        "id": "instance_methods"
      },
      {
        "level": 2,
        "text": "Examples",
        "id": "examples"
      },
      {
        "level": 2,
        "text": "Specifications",
        "id": "specifications"
      },
      {
        "level": 2,
        "text": "Browser compatibility",
        "id": "browser_compatibility"
      },
      {
        "level": 2,
        "text": "See also",
        "id": "see_also"
      },
      {
        "level": 2,
        "text": "Help improve MDN",
        "id": "feedback"
      },
      {
        "level": 3,
        "text": "Chained Promises",
        "id": "chained_promises"
      },
      {
        "level": 3,
        "text": "Thenables",
        "id": "thenables"
      },
      {
        "level": 3,
        "text": "Promise concurrency",
        "id": "promise_concurrency"
      },
      {
        "level": 3,
        "text": "Basic Example",
        "id": "basic_example"
      },
      {
        "level": 3,
        "text": "Example with diverse situations",
        "id": "example_with_diverse_situations"
      },
      {
        "level": 3,
        "text": "Advanced Example",
        "id": "advanced_example"
      },
      {
        "level": 3,
        "text": "Loading an image with XHR",
        "id": "loading_an_image_with_xhr"
      },
      {
        "level": 3,
        "text": "Incumbent settings object tracking",
        "id": "incumbent_settings_object_tracking"
      },
      {
        "level": 4,
        "text": "HTML",
        "id": "html"
      },
      {
        "level": 4,
        "text": "JavaScript",
        "id": "javascript"
      },
      {
        "level": 4,
        "text": "Result",
        "id": "result"
      }
    ],
    "codeBlocks": [
      {
        "language": "text",
        "code": "resolveOuter"
      },
      {
        "language": "text",
        "code": "f = () => expression"
      },
      {
        "language": "text",
        "code": "AbortController"
      },
      {
        "language": "text",
        "code": "handleRejectedA"
      },
      {
        "language": "text",
        "code": "handleRejectedA"
      },
      {
        "language": "text",
        "code": "handleFulfilled1"
      },
      {
        "language": "text",
        "code": "handleFulfilled2"
      },
      {
        "language": "text",
        "code": "handleFulfilled1"
      },
      {
        "language": "text",
        "code": "Promise.resolve"
      },
      {
        "language": "text",
        "code": "Promise.all()"
      },
      {
        "language": "text",
        "code": "Promise.allSettled()"
      },
      {
        "language": "text",
        "code": "Promise.any()"
      },
      {
        "language": "text",
        "code": "Promise.race()"
      },
      {
        "language": "text",
        "code": "Promise.resolve()"
      },
      {
        "language": "text",
        "code": "Promise[Symbol.species]"
      },
      {
        "language": "text",
        "code": "Promise.all()"
      },
      {
        "language": "text",
        "code": "Promise.allSettled()"
      },
      {
        "language": "text",
        "code": "Promise.any()"
      },
      {
        "language": "text",
        "code": "AggregateError"
      },
      {
        "language": "text",
        "code": "Promise.race()"
      },
      {
        "language": "text",
        "code": "Promise.reject()"
      },
      {
        "language": "text",
        "code": "Promise.resolve()"
      },
      {
        "language": "text",
        "code": "Promise.try()"
      },
      {
        "language": "text",
        "code": "Promise.withResolvers()"
      },
      {
        "language": "text",
        "code": "Promise.prototype"
      },
      {
        "language": "text",
        "code": "Promise.prototype.constructor"
      },
      {
        "language": "text",
        "code": "Promise.prototype[Symbol.toStringTag]"
      },
      {
        "language": "text",
        "code": "[Symbol.toStringTag]"
      },
      {
        "language": "text",
        "code": "Object.prototype.toString()"
      },
      {
        "language": "text",
        "code": "Promise.prototype.catch()"
      },
      {
        "language": "text",
        "code": "Promise.prototype.finally()"
      },
      {
        "language": "text",
        "code": "Promise.prototype.then()"
      },
      {
        "language": "text",
        "code": "onFulfilled"
      },
      {
        "language": "text",
        "code": "setTimeout(...)"
      },
      {
        "language": "text",
        "code": "new Promise()"
      },
      {
        "language": "text",
        "code": "tetheredGetNumber()"
      },
      {
        "language": "text",
        "code": "promiseGetWord()"
      },
      {
        "language": "text",
        "code": "troubleWithGetNumber()"
      },
      {
        "language": "text",
        "code": "testPromise()"
      },
      {
        "language": "text",
        "code": "setTimeout()"
      },
      {
        "language": "text",
        "code": "XMLHttpRequest"
      }
    ],
    "links": [
      {
        "text": "Learn more",
        "href": "/en-US/docs/Glossary/Baseline/Compatibility"
      },
      {
        "text": "Report feedback",
        "href": "https://survey.alchemer.com/s3/7634825/MDN-baseline-feedback?page=%2Fen-US%2Fdocs%2FWeb%2FJavaScript%2FReference%2FGlobal_Objects%2FPromise&level=high"
      },
      {
        "text": "Using promises",
        "href": "/en-US/docs/Web/JavaScript/Guide/Using_promises"
      },
      {
        "text": "States and fates",
        "href": "https://github.com/domenic/promises-unwrapping/blob/master/docs/states-and-fates.md"
      },
      {
        "text": "AbortController",
        "href": "/en-US/docs/Web/API/AbortController"
      },
      {
        "text": "then()",
        "href": "/en-US/docs/Web/JavaScript/Reference/Global_Objects/Promise/then"
      },
      {
        "text": "catch()",
        "href": "/en-US/docs/Web/JavaScript/Reference/Global_Objects/Promise/catch"
      },
      {
        "text": "finally()",
        "href": "/en-US/docs/Web/JavaScript/Reference/Global_Objects/Promise/finally"
      },
      {
        "text": "arrow functions",
        "href": "/en-US/docs/Web/JavaScript/Reference/Functions/Arrow_functions"
      },
      {
        "text": "job queue",
        "href": "/en-US/docs/Web/JavaScript/Reference/Execution_model"
      },
      {
        "text": ".then()",
        "href": "/en-US/docs/Web/JavaScript/Reference/Global_Objects/Promise/then"
      },
      {
        "text": "Promise.resolve",
        "href": "/en-US/docs/Web/JavaScript/Reference/Global_Objects/Promise/resolve"
      },
      {
        "text": "concurrency",
        "href": "https://en.wikipedia.org/wiki/Concurrent_computing"
      },
      {
        "text": "Promise.all()",
        "href": "/en-US/docs/Web/JavaScript/Reference/Global_Objects/Promise/all"
      },
      {
        "text": "Promise.allSettled()",
        "href": "/en-US/docs/Web/JavaScript/Reference/Global_Objects/Promise/allSettled"
      },
      {
        "text": "Promise.any()",
        "href": "/en-US/docs/Web/JavaScript/Reference/Global_Objects/Promise/any"
      },
      {
        "text": "Promise.race()",
        "href": "/en-US/docs/Web/JavaScript/Reference/Global_Objects/Promise/race"
      },
      {
        "text": "iterable",
        "href": "/en-US/docs/Web/JavaScript/Reference/Iteration_protocols#the_iterable_protocol"
      },
      {
        "text": "Promise()",
        "href": "/en-US/docs/Web/JavaScript/Reference/Global_Objects/Promise/Promise"
      },
      {
        "text": "Promise.resolve()",
        "href": "/en-US/docs/Web/JavaScript/Reference/Global_Objects/Promise/resolve"
      },
      {
        "text": "single-threaded",
        "href": "/en-US/docs/Glossary/Thread"
      },
      {
        "text": "Parallel execution",
        "href": "https://en.wikipedia.org/wiki/Parallel_computing"
      },
      {
        "text": "worker threads",
        "href": "/en-US/docs/Web/API/Web_Workers_API"
      },
      {
        "text": "Promise()",
        "href": "/en-US/docs/Web/JavaScript/Reference/Global_Objects/Promise/Promise"
      },
      {
        "text": "Promise[Symbol.species]",
        "href": "/en-US/docs/Web/JavaScript/Reference/Global_Objects/Promise/Symbol.species"
      },
      {
        "text": "Promise.all()",
        "href": "/en-US/docs/Web/JavaScript/Reference/Global_Objects/Promise/all"
      },
      {
        "text": "Promise.allSettled()",
        "href": "/en-US/docs/Web/JavaScript/Reference/Global_Objects/Promise/allSettled"
      },
      {
        "text": "Promise.any()",
        "href": "/en-US/docs/Web/JavaScript/Reference/Global_Objects/Promise/any"
      },
      {
        "text": "AggregateError",
        "href": "/en-US/docs/Web/JavaScript/Reference/Global_Objects/AggregateError"
      },
      {
        "text": "Promise.race()",
        "href": "/en-US/docs/Web/JavaScript/Reference/Global_Objects/Promise/race"
      },
      {
        "text": "Promise.reject()",
        "href": "/en-US/docs/Web/JavaScript/Reference/Global_Objects/Promise/reject"
      },
      {
        "text": "Promise.resolve()",
        "href": "/en-US/docs/Web/JavaScript/Reference/Global_Objects/Promise/resolve"
      },
      {
        "text": "Promise.try()",
        "href": "/en-US/docs/Web/JavaScript/Reference/Global_Objects/Promise/try"
      },
      {
        "text": "Promise.withResolvers()",
        "href": "/en-US/docs/Web/JavaScript/Reference/Global_Objects/Promise/withResolvers"
      },
      {
        "text": "Promise()",
        "href": "/en-US/docs/Web/JavaScript/Reference/Global_Objects/Promise/Promise"
      },
      {
        "text": "Promise.prototype.constructor",
        "href": "/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/constructor"
      },
      {
        "text": "Promise",
        "href": "/en-US/docs/Web/JavaScript/Reference/Global_Objects/Promise/Promise"
      },
      {
        "text": "[Symbol.toStringTag]",
        "href": "/en-US/docs/Web/JavaScript/Reference/Global_Objects/Symbol/toStringTag"
      },
      {
        "text": "Object.prototype.toString()",
        "href": "/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/toString"
      },
      {
        "text": "Promise.prototype.catch()",
        "href": "/en-US/docs/Web/JavaScript/Reference/Global_Objects/Promise/catch"
      },
      {
        "text": "Promise.prototype.finally()",
        "href": "/en-US/docs/Web/JavaScript/Reference/Global_Objects/Promise/finally"
      },
      {
        "text": "Promise.prototype.then()",
        "href": "/en-US/docs/Web/JavaScript/Reference/Global_Objects/Promise/then"
      },
      {
        "text": "<button>",
        "href": "/en-US/docs/Web/HTML/Reference/Elements/button"
      },
      {
        "text": "setTimeout()",
        "href": "/en-US/docs/Web/API/Window/setTimeout"
      },
      {
        "text": "p1.then()",
        "href": "/en-US/docs/Web/JavaScript/Reference/Global_Objects/Promise/then"
      },
      {
        "text": "XMLHttpRequest",
        "href": "/en-US/docs/Web/API/XMLHttpRequest"
      },
      {
        "text": "environment",
        "href": "https://html.spec.whatwg.org/multipage/webappapis.html#environment-settings-object"
      },
      {
        "text": "Array",
        "href": "/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array"
      },
      {
        "text": "Error",
        "href": "/en-US/docs/Web/JavaScript/Reference/Global_Objects/Error"
      },
      {
        "text": "<iframe>",
        "href": "/en-US/docs/Web/HTML/Reference/Elements/iframe"
      },
      {
        "text": "ECMAScript® 2026 Language Specification# sec-promise-objects",
        "href": "https://tc39.es/ecma262/multipage/control-abstraction-objects.html#sec-promise-objects"
      },
      {
        "text": "Polyfill of Promise in core-js",
        "href": "https://github.com/zloirock/core-js#ecmascript-promise"
      },
      {
        "text": "Using promises",
        "href": "/en-US/docs/Web/JavaScript/Guide/Using_promises"
      },
      {
        "text": "Promises/A+ specification",
        "href": "https://promisesaplus.com/"
      },
      {
        "text": "JavaScript Promises: an introduction",
        "href": "https://web.dev/articles/promises"
      },
      {
        "text": "Callbacks, Promises, and Coroutines: Asynchronous Programming Patterns in JavaScript",
        "href": "https://www.slideshare.net/slideshow/callbacks-promises-and-coroutines-oh-my-the-evolution-of-asynchronicity-in-javascript/9953720"
      },
      {
        "text": "Learn how to contribute",
        "href": "/en-US/docs/MDN/Community/Getting_started"
      },
      {
        "text": "MDN contributors",
        "href": "/en-US/docs/Web/JavaScript/Reference/Global_Objects/Promise/contributors.txt"
      },
      {
        "text": "View this page on GitHub",
        "href": "https://github.com/mdn/content/blob/main/files/en-us/web/javascript/reference/global_objects/promise/index.md?plain=1"
      },
      {
        "text": "Report a problem with this content",
        "href": "https://github.com/mdn/content/issues/new?template=page-report.yml&mdn-url=https%3A%2F%2Fdeveloper.mozilla.org%2Fen-US%2Fdocs%2FWeb%2FJavaScript%2FReference%2FGlobal_Objects%2FPromise&metadata=%3C%21--+Do+not+make+changes+below+this+line+--%3E%0A%3Cdetails%3E%0A%3Csummary%3EPage+report+details%3C%2Fsummary%3E%0A%0A*+Folder%3A+%60en-us%2Fweb%2Fjavascript%2Freference%2Fglobal_objects%2Fpromise%60%0A*+MDN+URL%3A+https%3A%2F%2Fdeveloper.mozilla.org%2Fen-US%2Fdocs%2FWeb%2FJavaScript%2FReference%2FGlobal_Objects%2FPromise%0A*+GitHub+URL%3A+https%3A%2F%2Fgithub.com%2Fmdn%2Fcontent%2Fblob%2Fmain%2Ffiles%2Fen-us%2Fweb%2Fjavascript%2Freference%2Fglobal_objects%2Fpromise%2Findex.md%0A*+Last+commit%3A+https%3A%2F%2Fgithub.com%2Fmdn%2Fcontent%2Fcommit%2F79fdc26fea835d65c9361541bb8ab1896f307475%0A*+Document+last+modified%3A+2025-08-19T18%3A15%3A59.000Z%0A%0A%3C%2Fdetails%3E"
      }
    ],
    "meta": {
      "description": "The Promise object represents the eventual completion (or failure) of an asynchronous operation and its resulting value.",
      "keywords": ""
    },
    "summary": "Promise Baseline Widely available * This feature is well established and works across many devices and browser versions. Its been available across browsers since July 2015",
    "tags": [
      "react",
      "angular",
      "javascript",
      "typescript",
      "html",
      "node",
      "vite",
      "promise",
      "description",
      "chained"
    ],
    "id": "promise-Promise-part-1",
    "quality": 90
  },
  {
    "title": "Arrow function expressions",
    "url": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Functions/Arrow_functions",
    "category": "javascript",
    "content": "Arrow function expressions Baseline Widely available This feature is well established and works across many devices and browser versions. Its been available across browsers since September 2016. Learn more See full compatibility Report feedback An arrow function expression is a compact alternative to a traditional function expression, with some semantic differences and deliberate limitations in usage: Arrow functions don't have their own bindings to this, arguments, or super, and should not be used as methods. Arrow functions cannot be used as constructors. Calling them with new throws a TypeError. They also don't have access to the new.target keyword. Arrow functions cannot use yield within their body and cannot be created as generator functions. Try it Syntax Rest parameters, default parameters, and destructuring within params are supported, and always require parentheses: Arrow functions can be async by prefixing the expression with the async keyword. Description Let's decompose a traditional anonymous function down to the simplest arrow function step-by-step. Each step along the way is a valid arrow function. Note: Traditional function expressions and arrow functions have more differences than their syntax. We will introduce their behavior differences in more detail in the next few subsections. In the example above, both the parentheses around the parameter and the braces around the function body may be omitted. However, they can only be omitted in certain cases. The parentheses can only be omitted if the function has a single simple parameter. If it has multiple parameters, no parameters, or default, destructured, or rest parameters, the parentheses around the parameter list are required. The braces can only be omitted if the function directly returns an expression. If the body has statements, the braces are required  and so is the return keyword. Arrow functions cannot guess what or when you want to return. Arrow functions are not inherently associated with a name. If the arrow function needs to call itself, use a named function expression instead. You can also assign the arrow function to a variable, allowing you to refer to it through that variable. Function body Arrow functions can have either an expression body or the usual block body. In an expression body, only a single expression is specified, which becomes the implicit return value. In a block body, you must use an explicit return statement. Returning object literals using the expression body syntax (params) = { object: literal } does not work as expected. This is because JavaScript only sees the arrow function as having an expression body if the token following the arrow is not a left brace, so the code inside braces ({}) is parsed as a sequence of statements, where foo is a label, not a key in an object literal. To fix this, wrap the object literal in parentheses: Cannot be used as methods Arrow function expressions should only be used for non-method functions because they do not have their own this. Let's see what happens when we try to use them as methods: Another example involving Object.defineProperty(): Because a class's body has a this context, arrow functions as class fields close over the class's this context, and the this inside the arrow function's body will correctly point to the instance (or the class itself, for static fields). However, because it is a closure, not the function's own binding, the value of this will not change based on the execution context. Arrow function properties are often said to be \"auto-bound methods\", because the equivalent with normal methods is: Note: Class fields are defined on the instance, not on the prototype, so every instance creation would create a new function reference and allocate a new closure, potentially leading to more memory usage than a normal unbound method. For similar reasons, the call(), apply(), and bind() methods are not useful when called on arrow functions, because arrow functions establish this based on the scope the arrow function is defined within, and the this value does not change based on how the function is invoked. No binding of arguments Arrow functions do not have their own arguments object. Thus, in this example, arguments is a reference to the arguments of the enclosing scope: In most cases, using rest parameters is a good alternative to using an arguments object. Cannot be used as constructors Arrow functions cannot be used as constructors and will throw an error when called with new. They also do not have a prototype property. Cannot be used as generators The yield keyword cannot be used in an arrow function's body (except when used within generator functions further nested within the arrow function). As a consequence, arrow functions cannot be used as generators. Line break before arrow An arrow function cannot contain a line break between its parameters and its arrow. For the purpose of formatting, you may put the line break after the arrow or use parentheses/braces around the function body, as shown below. You can also put line breaks between parameters. Precedence of arrow Although the arrow in an arrow function is not an operator, arrow functions have special parsing rules that interact differently with operator precedence compared to regular functions. Because = has a lower precedence than most operators, parentheses are necessary to avoid callback  () being parsed as the arguments list of the arrow function. Examples Using arrow functions Using call, bind, and apply The call(), apply(), and bind() methods work as expected with traditional functions, because we establish the scope for each of the methods: With arrow functions, since our add function is essentially created on the globalThis (global) scope, it will assume this is the globalThis. Perhaps the greatest benefit of using arrow functions is with methods like setTimeout() and EventTarget.prototype.addEventListener() that usually require some kind of closure, call(), apply(), or bind() to ensure that the function is executed in the proper scope. With traditional function expressions, code like this does not work as expected: With arrow functions, the this scope is more easily preserved: Specifications Specification ECMAScript 2026 Language Specification# sec-arrow-function-definitions Browser compatibility See also Functions guide Functions function function expression ES6 In Depth: Arrow functions on hacks.mozilla.org (2015) Help improve MDN Learn how to contribute This page was last modified on Jul 8, 2025 by MDN contributors. View this page on GitHub  Report a problem with this content",
    "headings": [
      {
        "level": 1,
        "text": "Arrow function expressions",
        "id": ""
      },
      {
        "level": 2,
        "text": "Try it",
        "id": "try_it"
      },
      {
        "level": 2,
        "text": "Syntax",
        "id": "syntax"
      },
      {
        "level": 2,
        "text": "Description",
        "id": "description"
      },
      {
        "level": 2,
        "text": "Examples",
        "id": "examples"
      },
      {
        "level": 2,
        "text": "Specifications",
        "id": "specifications"
      },
      {
        "level": 2,
        "text": "Browser compatibility",
        "id": "browser_compatibility"
      },
      {
        "level": 2,
        "text": "See also",
        "id": "see_also"
      },
      {
        "level": 2,
        "text": "Help improve MDN",
        "id": "feedback"
      },
      {
        "level": 3,
        "text": "Function body",
        "id": "function_body"
      },
      {
        "level": 3,
        "text": "Cannot be used as methods",
        "id": "cannot_be_used_as_methods"
      },
      {
        "level": 3,
        "text": "No binding of arguments",
        "id": "no_binding_of_arguments"
      },
      {
        "level": 3,
        "text": "Cannot be used as constructors",
        "id": "cannot_be_used_as_constructors"
      },
      {
        "level": 3,
        "text": "Cannot be used as generators",
        "id": "cannot_be_used_as_generators"
      },
      {
        "level": 3,
        "text": "Line break before arrow",
        "id": "line_break_before_arrow"
      },
      {
        "level": 3,
        "text": "Precedence of arrow",
        "id": "precedence_of_arrow"
      },
      {
        "level": 3,
        "text": "Using arrow functions",
        "id": "using_arrow_functions"
      },
      {
        "level": 3,
        "text": "Using call, bind, and apply",
        "id": "using_call_bind_and_apply"
      }
    ],
    "codeBlocks": [
      {
        "language": "text",
        "code": "(params) => { object: literal }"
      },
      {
        "language": "text",
        "code": "Object.defineProperty()"
      },
      {
        "language": "text",
        "code": "callback || ()"
      },
      {
        "language": "text",
        "code": "setTimeout()"
      },
      {
        "language": "text",
        "code": "EventTarget.prototype.addEventListener()"
      }
    ],
    "links": [
      {
        "text": "Learn more",
        "href": "/en-US/docs/Glossary/Baseline/Compatibility"
      },
      {
        "text": "Report feedback",
        "href": "https://survey.alchemer.com/s3/7634825/MDN-baseline-feedback?page=%2Fen-US%2Fdocs%2FWeb%2FJavaScript%2FReference%2FFunctions%2FArrow_functions&level=high"
      },
      {
        "text": "function expression",
        "href": "/en-US/docs/Web/JavaScript/Reference/Operators/function"
      },
      {
        "text": "bindings",
        "href": "/en-US/docs/Glossary/Binding"
      },
      {
        "text": "this",
        "href": "/en-US/docs/Web/JavaScript/Reference/Operators/this"
      },
      {
        "text": "arguments",
        "href": "/en-US/docs/Web/JavaScript/Reference/Functions/arguments"
      },
      {
        "text": "super",
        "href": "/en-US/docs/Web/JavaScript/Reference/Operators/super"
      },
      {
        "text": "methods",
        "href": "/en-US/docs/Glossary/Method"
      },
      {
        "text": "constructors",
        "href": "/en-US/docs/Glossary/Constructor"
      },
      {
        "text": "new",
        "href": "/en-US/docs/Web/JavaScript/Reference/Operators/new"
      },
      {
        "text": "TypeError",
        "href": "/en-US/docs/Web/JavaScript/Reference/Global_Objects/TypeError"
      },
      {
        "text": "new.target",
        "href": "/en-US/docs/Web/JavaScript/Reference/Operators/new.target"
      },
      {
        "text": "yield",
        "href": "/en-US/docs/Web/JavaScript/Reference/Operators/yield"
      },
      {
        "text": "Rest parameters",
        "href": "/en-US/docs/Web/JavaScript/Reference/Functions/rest_parameters"
      },
      {
        "text": "default parameters",
        "href": "/en-US/docs/Web/JavaScript/Reference/Functions/Default_parameters"
      },
      {
        "text": "destructuring",
        "href": "/en-US/docs/Web/JavaScript/Reference/Operators/Destructuring"
      },
      {
        "text": "async",
        "href": "/en-US/docs/Web/JavaScript/Reference/Statements/async_function"
      },
      {
        "text": "label",
        "href": "/en-US/docs/Web/JavaScript/Reference/Statements/label"
      },
      {
        "text": "Object.defineProperty()",
        "href": "/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/defineProperty"
      },
      {
        "text": "class",
        "href": "/en-US/docs/Web/JavaScript/Reference/Classes"
      },
      {
        "text": "class fields",
        "href": "/en-US/docs/Web/JavaScript/Reference/Classes/Public_class_fields"
      },
      {
        "text": "static fields",
        "href": "/en-US/docs/Web/JavaScript/Reference/Classes/static"
      },
      {
        "text": "closure",
        "href": "/en-US/docs/Web/JavaScript/Guide/Closures"
      },
      {
        "text": "call()",
        "href": "/en-US/docs/Web/JavaScript/Reference/Global_Objects/Function/call"
      },
      {
        "text": "apply()",
        "href": "/en-US/docs/Web/JavaScript/Reference/Global_Objects/Function/apply"
      },
      {
        "text": "bind()",
        "href": "/en-US/docs/Web/JavaScript/Reference/Global_Objects/Function/bind"
      },
      {
        "text": "arguments",
        "href": "/en-US/docs/Web/JavaScript/Reference/Functions/arguments"
      },
      {
        "text": "rest parameters",
        "href": "/en-US/docs/Web/JavaScript/Reference/Functions/rest_parameters"
      },
      {
        "text": "new",
        "href": "/en-US/docs/Web/JavaScript/Reference/Operators/new"
      },
      {
        "text": "prototype",
        "href": "/en-US/docs/Web/JavaScript/Reference/Global_Objects/Function/prototype"
      },
      {
        "text": "yield",
        "href": "/en-US/docs/Web/JavaScript/Reference/Operators/yield"
      },
      {
        "text": "operator precedence",
        "href": "/en-US/docs/Web/JavaScript/Reference/Operators/Operator_precedence"
      },
      {
        "text": "call()",
        "href": "/en-US/docs/Web/JavaScript/Reference/Global_Objects/Function/call"
      },
      {
        "text": "apply()",
        "href": "/en-US/docs/Web/JavaScript/Reference/Global_Objects/Function/apply"
      },
      {
        "text": "bind()",
        "href": "/en-US/docs/Web/JavaScript/Reference/Global_Objects/Function/bind"
      },
      {
        "text": "setTimeout()",
        "href": "/en-US/docs/Web/API/Window/setTimeout"
      },
      {
        "text": "EventTarget.prototype.addEventListener()",
        "href": "/en-US/docs/Web/API/EventTarget/addEventListener"
      },
      {
        "text": "ECMAScript® 2026 Language Specification# sec-arrow-function-definitions",
        "href": "https://tc39.es/ecma262/multipage/ecmascript-language-functions-and-classes.html#sec-arrow-function-definitions"
      },
      {
        "text": "Functions",
        "href": "/en-US/docs/Web/JavaScript/Guide/Functions"
      },
      {
        "text": "Functions",
        "href": "/en-US/docs/Web/JavaScript/Reference/Functions"
      },
      {
        "text": "function",
        "href": "/en-US/docs/Web/JavaScript/Reference/Statements/function"
      },
      {
        "text": "function expression",
        "href": "/en-US/docs/Web/JavaScript/Reference/Operators/function"
      },
      {
        "text": "ES6 In Depth: Arrow functions",
        "href": "https://hacks.mozilla.org/2015/06/es6-in-depth-arrow-functions/"
      },
      {
        "text": "Learn how to contribute",
        "href": "/en-US/docs/MDN/Community/Getting_started"
      },
      {
        "text": "MDN contributors",
        "href": "/en-US/docs/Web/JavaScript/Reference/Functions/Arrow_functions/contributors.txt"
      },
      {
        "text": "View this page on GitHub",
        "href": "https://github.com/mdn/content/blob/main/files/en-us/web/javascript/reference/functions/arrow_functions/index.md?plain=1"
      },
      {
        "text": "Report a problem with this content",
        "href": "https://github.com/mdn/content/issues/new?template=page-report.yml&mdn-url=https%3A%2F%2Fdeveloper.mozilla.org%2Fen-US%2Fdocs%2FWeb%2FJavaScript%2FReference%2FFunctions%2FArrow_functions&metadata=%3C%21--+Do+not+make+changes+below+this+line+--%3E%0A%3Cdetails%3E%0A%3Csummary%3EPage+report+details%3C%2Fsummary%3E%0A%0A*+Folder%3A+%60en-us%2Fweb%2Fjavascript%2Freference%2Ffunctions%2Farrow_functions%60%0A*+MDN+URL%3A+https%3A%2F%2Fdeveloper.mozilla.org%2Fen-US%2Fdocs%2FWeb%2FJavaScript%2FReference%2FFunctions%2FArrow_functions%0A*+GitHub+URL%3A+https%3A%2F%2Fgithub.com%2Fmdn%2Fcontent%2Fblob%2Fmain%2Ffiles%2Fen-us%2Fweb%2Fjavascript%2Freference%2Ffunctions%2Farrow_functions%2Findex.md%0A*+Last+commit%3A+https%3A%2F%2Fgithub.com%2Fmdn%2Fcontent%2Fcommit%2Ffad67be4431d8e6c2a89ac880735233aa76c41d4%0A*+Document+last+modified%3A+2025-07-08T13%3A18%3A45.000Z%0A%0A%3C%2Fdetails%3E"
      }
    ],
    "meta": {
      "description": "An arrow function expression is a compact alternative to a traditional function expression, with some semantic differences and deliberate limitations in usage:",
      "keywords": ""
    },
    "summary": "Arrow function expressions Baseline Widely available This feature is well established and works across many devices and browser versions. Its been available across browsers since September 2016",
    "tags": [
      "react",
      "javascript",
      "typescript",
      "html",
      "vite",
      "arrow",
      "function",
      "cannot",
      "used",
      "expressions"
    ],
    "id": "arrow-function-expressions-Arrow_functions-part-1",
    "quality": 100
  },
  {
    "title": "Classes",
    "url": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Classes",
    "category": "javascript",
    "content": "Classes Baseline Widely available * This feature is well established and works across many devices and browser versions. Its been available across browsers since March 2016. * Some parts of this feature may have varying levels of support. Learn more See full compatibility Report feedback Classes are a template for creating objects. They encapsulate data with code to work on that data. Classes in JS are built on prototypes but also have some syntax and semantics that are unique to classes. For more examples and explanations, see the Using classes guide. Description Defining classes Classes are in fact \"special functions\", and just as you can define function expressions and function declarations, a class can be defined in two ways: a class expression or a class declaration. Like function expressions, class expressions may be anonymous, or have a name that's different from the variable that it's assigned to. However, unlike function declarations, class declarations have the same temporal dead zone restrictions as let or const and behave as if they are not hoisted. Class body The body of a class is the part that is in curly braces {}. This is where you define class members, such as methods or constructor. The body of a class is executed in strict mode even without the \"use strict\" directive. A class element can be characterized by three aspects: Kind: Getter, setter, method, or field Location: Static or instance Visibility: Public or private Together, they add up to 16 possible combinations. To divide the reference more logically and avoid overlapping content, the different elements are introduced in detail in different pages: Method definitions Public instance method getter Public instance getter setter Public instance setter Public class fields Public instance field static Public static method, getter, setter, and field Private elements Everything that's private Note: Private elements have the restriction that all private names declared in the same class must be unique. All other public properties do not have this restriction  you can have multiple public properties with the same name, and the last one overwrites the others. This is the same behavior as in object initializers. In addition, there are two special class element syntaxes: constructor and static initialization blocks, with their own references. Constructor The constructor method is a special method for creating and initializing an object created with a class. There can only be one special method with the name \"constructor\" in a class  a SyntaxError is thrown if the class contains more than one occurrence of a constructor method. A constructor can use the super keyword to call the constructor of the super class. You can create instance properties inside the constructor: Alternatively, if your instance properties' values do not depend on the constructor's arguments, you can define them as class fields. Static initialization blocks Static initialization blocks allow flexible initialization of static properties, including the evaluation of statements during initialization, while granting access to the private scope. Multiple static blocks can be declared, and these can be interleaved with the declaration of static fields and methods (all static items are evaluated in declaration order). Methods Methods are defined on the prototype of each class instance and are shared by all instances. Methods can be plain functions, async functions, generator functions, or async generator functions. For more information, see method definitions. Static methods and fields The static keyword defines a static method or field for a class. Static properties (fields and methods) are defined on the class itself instead of each instance. Static methods are often used to create utility functions for an application, whereas static fields are useful for caches, fixed-configuration, or any other data that doesn't need to be replicated across instances. Field declarations With the class field declaration syntax, the constructor example can be written as: Class fields are similar to object properties, not variables, so we don't use keywords such as const to declare them. In JavaScript, private elements use a special identifier syntax, so modifier keywords like public and private should not be used either. As seen above, the fields can be declared with or without a default value. Fields without default values default to undefined. By declaring fields up-front, class definitions become more self-documenting, and the fields are always present, which help with optimizations. See public class fields for more information. Private elements Using private fields, the definition can be refined as below. It's an error to reference private fields from outside of the class; they can only be read or written within the class body. By defining things that are not visible outside of the class, you ensure that your classes' users can't depend on internals, which may change from version to version. Private fields can only be declared up-front in a field declaration. They cannot be created later through assigning to them, the way that normal properties can. Private methods and accessors can also be defined using the same syntax as their public counterparts, but with the identifier starting with #. For more information, see private elements. Inheritance The extends keyword is used in class declarations or class expressions to create a class as a child of another constructor (either a class or a function). If there is a constructor present in the subclass, it needs to first call super() before using this. The super keyword can also be used to call corresponding methods of super class. Evaluation order When a class declaration or class expression is evaluated, its various components are evaluated in the following order: The extends clause, if present, is first evaluated. It must evaluate to a valid constructor function or null, or a TypeError is thrown. The constructor method is extracted, substituted with a default implementation if constructor is not present. However, because the constructor definition is only a method definition, this step is not observable. The class elements' property keys are evaluated in the order of declaration. If the property key is computed, the computed expression is evaluated, with the this value set to the this value surrounding the class (not the class itself). None of the property values are evaluated yet. Methods and accessors are installed in the order of declaration. Instance methods and accessors are installed on the prototype property of the current class, and static methods and accessors are installed on the class itself. Private instance methods and accessors are saved to be installed on the instance directly later. This step is not observable. The class is now initialized with the prototype specified by extends and implementation specified by constructor. For all steps above, if an evaluated expression tries to access the name of the class, a ReferenceError is thrown because the class is not initialized yet. The class elements' values are evaluated in the order of declaration: For each instance field (public or private), its initializer expression is saved. The initializer is evaluated during instance creation, at the start of the constructor (for base classes) or immediately before the super() call returns (for derived classes). For each static field (public or private), its initializer is evaluated with this set to the class itself, and the property is created on the class. Static initialization blocks are evaluated with this set to the class itself. The class is now fully initialized and can be used as a constructor function. For how instances are created, see the constructor reference. Examples Binding this with instance and static methods When a static or instance method is called without a value for this, such as by assigning the method to a variable and then calling it, the this value will be undefined inside the method. This behavior is the same even if the \"use strict\" directive isn't present, because code within the class body is always executed in strict mode. If we rewrite the above using traditional function-based syntax in nonstrict mode, then this method calls are automatically bound to globalThis. In strict mode, the value of this remains as undefined. Specifications Specification ECMAScript 2026 Language Specification# sec-class-definitions Browser compatibility See also Using classes guide class class expression Functions ES6 In Depth: Classes on hacks.mozilla.org (2015) Help improve MDN Learn how to contribute This page was last modified on Jul 8, 2025 by MDN contributors. View this page on GitHub  Report a problem with this content",
    "headings": [
      {
        "level": 1,
        "text": "Classes",
        "id": ""
      },
      {
        "level": 2,
        "text": "Description",
        "id": "description"
      },
      {
        "level": 2,
        "text": "Examples",
        "id": "examples"
      },
      {
        "level": 2,
        "text": "Specifications",
        "id": "specifications"
      },
      {
        "level": 2,
        "text": "Browser compatibility",
        "id": "browser_compatibility"
      },
      {
        "level": 2,
        "text": "See also",
        "id": "see_also"
      },
      {
        "level": 2,
        "text": "Help improve MDN",
        "id": "feedback"
      },
      {
        "level": 3,
        "text": "Defining classes",
        "id": "defining_classes"
      },
      {
        "level": 3,
        "text": "Class body",
        "id": "class_body"
      },
      {
        "level": 3,
        "text": "Inheritance",
        "id": "inheritance"
      },
      {
        "level": 3,
        "text": "Evaluation order",
        "id": "evaluation_order"
      },
      {
        "level": 3,
        "text": "Binding this with instance and static methods",
        "id": "binding_this_with_instance_and_static_methods"
      },
      {
        "level": 4,
        "text": "Constructor",
        "id": "constructor"
      },
      {
        "level": 4,
        "text": "Static initialization blocks",
        "id": "static_initialization_blocks"
      },
      {
        "level": 4,
        "text": "Methods",
        "id": "methods"
      },
      {
        "level": 4,
        "text": "Static methods and fields",
        "id": "static_methods_and_fields"
      },
      {
        "level": 4,
        "text": "Field declarations",
        "id": "field_declarations"
      },
      {
        "level": 4,
        "text": "Private elements",
        "id": "private_elements"
      }
    ],
    "codeBlocks": [
      {
        "language": "text",
        "code": "\"use strict\""
      },
      {
        "language": "text",
        "code": "constructor"
      },
      {
        "language": "text",
        "code": "constructor"
      },
      {
        "language": "text",
        "code": "SyntaxError"
      },
      {
        "language": "text",
        "code": "constructor"
      },
      {
        "language": "text",
        "code": "constructor"
      },
      {
        "language": "text",
        "code": "constructor"
      },
      {
        "language": "text",
        "code": "constructor"
      },
      {
        "language": "text",
        "code": "constructor"
      },
      {
        "language": "text",
        "code": "ReferenceError"
      },
      {
        "language": "text",
        "code": "constructor"
      },
      {
        "language": "text",
        "code": "\"use strict\""
      }
    ],
    "links": [
      {
        "text": "Learn more",
        "href": "/en-US/docs/Glossary/Baseline/Compatibility"
      },
      {
        "text": "Report feedback",
        "href": "https://survey.alchemer.com/s3/7634825/MDN-baseline-feedback?page=%2Fen-US%2Fdocs%2FWeb%2FJavaScript%2FReference%2FClasses&level=high"
      },
      {
        "text": "prototypes",
        "href": "/en-US/docs/Web/JavaScript/Guide/Inheritance_and_the_prototype_chain"
      },
      {
        "text": "Using classes",
        "href": "/en-US/docs/Web/JavaScript/Guide/Using_classes"
      },
      {
        "text": "functions",
        "href": "/en-US/docs/Web/JavaScript/Reference/Functions"
      },
      {
        "text": "function expressions",
        "href": "/en-US/docs/Web/JavaScript/Reference/Operators/function"
      },
      {
        "text": "function declarations",
        "href": "/en-US/docs/Web/JavaScript/Reference/Statements/function"
      },
      {
        "text": "class expression",
        "href": "/en-US/docs/Web/JavaScript/Reference/Operators/class"
      },
      {
        "text": "class declaration",
        "href": "/en-US/docs/Web/JavaScript/Reference/Statements/class"
      },
      {
        "text": "temporal dead zone",
        "href": "/en-US/docs/Web/JavaScript/Reference/Statements/let#temporal_dead_zone_tdz"
      },
      {
        "text": "not hoisted",
        "href": "/en-US/docs/Web/JavaScript/Guide/Using_classes#class_declaration_hoisting"
      },
      {
        "text": "strict mode",
        "href": "/en-US/docs/Web/JavaScript/Reference/Strict_mode"
      },
      {
        "text": "Method definitions",
        "href": "/en-US/docs/Web/JavaScript/Reference/Functions/Method_definitions"
      },
      {
        "text": "getter",
        "href": "/en-US/docs/Web/JavaScript/Reference/Functions/get"
      },
      {
        "text": "setter",
        "href": "/en-US/docs/Web/JavaScript/Reference/Functions/set"
      },
      {
        "text": "Public class fields",
        "href": "/en-US/docs/Web/JavaScript/Reference/Classes/Public_class_fields"
      },
      {
        "text": "static",
        "href": "/en-US/docs/Web/JavaScript/Reference/Classes/static"
      },
      {
        "text": "Private elements",
        "href": "/en-US/docs/Web/JavaScript/Reference/Classes/Private_elements"
      },
      {
        "text": "object initializers",
        "href": "/en-US/docs/Web/JavaScript/Reference/Operators/Object_initializer#duplicate_property_names"
      },
      {
        "text": "constructor",
        "href": "/en-US/docs/Web/JavaScript/Reference/Classes/constructor"
      },
      {
        "text": "SyntaxError",
        "href": "/en-US/docs/Web/JavaScript/Reference/Global_Objects/SyntaxError"
      },
      {
        "text": "super",
        "href": "/en-US/docs/Web/JavaScript/Reference/Operators/super"
      },
      {
        "text": "Static initialization blocks",
        "href": "/en-US/docs/Web/JavaScript/Reference/Classes/Static_initialization_blocks"
      },
      {
        "text": "method definitions",
        "href": "/en-US/docs/Web/JavaScript/Reference/Functions/Method_definitions"
      },
      {
        "text": "static",
        "href": "/en-US/docs/Web/JavaScript/Reference/Classes/static"
      },
      {
        "text": "public class fields",
        "href": "/en-US/docs/Web/JavaScript/Reference/Classes/Public_class_fields"
      },
      {
        "text": "private elements",
        "href": "/en-US/docs/Web/JavaScript/Reference/Classes/Private_elements"
      },
      {
        "text": "extends",
        "href": "/en-US/docs/Web/JavaScript/Reference/Classes/extends"
      },
      {
        "text": "super",
        "href": "/en-US/docs/Web/JavaScript/Reference/Operators/super"
      },
      {
        "text": "class declaration",
        "href": "/en-US/docs/Web/JavaScript/Reference/Statements/class"
      },
      {
        "text": "class expression",
        "href": "/en-US/docs/Web/JavaScript/Reference/Operators/class"
      },
      {
        "text": "extends",
        "href": "/en-US/docs/Web/JavaScript/Reference/Classes/extends"
      },
      {
        "text": "TypeError",
        "href": "/en-US/docs/Web/JavaScript/Reference/Global_Objects/TypeError"
      },
      {
        "text": "constructor",
        "href": "/en-US/docs/Web/JavaScript/Reference/Classes/constructor"
      },
      {
        "text": "ReferenceError",
        "href": "/en-US/docs/Web/JavaScript/Reference/Global_Objects/ReferenceError"
      },
      {
        "text": "instance field",
        "href": "/en-US/docs/Web/JavaScript/Reference/Classes/Public_class_fields"
      },
      {
        "text": "static field",
        "href": "/en-US/docs/Web/JavaScript/Reference/Classes/static"
      },
      {
        "text": "Static initialization blocks",
        "href": "/en-US/docs/Web/JavaScript/Reference/Classes/Static_initialization_blocks"
      },
      {
        "text": "constructor",
        "href": "/en-US/docs/Web/JavaScript/Reference/Classes/constructor"
      },
      {
        "text": "this",
        "href": "/en-US/docs/Web/JavaScript/Reference/Operators/this"
      },
      {
        "text": "\"use strict\"",
        "href": "/en-US/docs/Web/JavaScript/Reference/Strict_mode"
      },
      {
        "text": "globalThis",
        "href": "/en-US/docs/Web/JavaScript/Reference/Global_Objects/globalThis"
      },
      {
        "text": "ECMAScript® 2026 Language Specification# sec-class-definitions",
        "href": "https://tc39.es/ecma262/multipage/ecmascript-language-functions-and-classes.html#sec-class-definitions"
      },
      {
        "text": "Using classes",
        "href": "/en-US/docs/Web/JavaScript/Guide/Using_classes"
      },
      {
        "text": "class",
        "href": "/en-US/docs/Web/JavaScript/Reference/Statements/class"
      },
      {
        "text": "class expression",
        "href": "/en-US/docs/Web/JavaScript/Reference/Operators/class"
      },
      {
        "text": "Functions",
        "href": "/en-US/docs/Web/JavaScript/Reference/Functions"
      },
      {
        "text": "ES6 In Depth: Classes",
        "href": "https://hacks.mozilla.org/2015/07/es6-in-depth-classes/"
      },
      {
        "text": "Learn how to contribute",
        "href": "/en-US/docs/MDN/Community/Getting_started"
      },
      {
        "text": "MDN contributors",
        "href": "/en-US/docs/Web/JavaScript/Reference/Classes/contributors.txt"
      },
      {
        "text": "View this page on GitHub",
        "href": "https://github.com/mdn/content/blob/main/files/en-us/web/javascript/reference/classes/index.md?plain=1"
      },
      {
        "text": "Report a problem with this content",
        "href": "https://github.com/mdn/content/issues/new?template=page-report.yml&mdn-url=https%3A%2F%2Fdeveloper.mozilla.org%2Fen-US%2Fdocs%2FWeb%2FJavaScript%2FReference%2FClasses&metadata=%3C%21--+Do+not+make+changes+below+this+line+--%3E%0A%3Cdetails%3E%0A%3Csummary%3EPage+report+details%3C%2Fsummary%3E%0A%0A*+Folder%3A+%60en-us%2Fweb%2Fjavascript%2Freference%2Fclasses%60%0A*+MDN+URL%3A+https%3A%2F%2Fdeveloper.mozilla.org%2Fen-US%2Fdocs%2FWeb%2FJavaScript%2FReference%2FClasses%0A*+GitHub+URL%3A+https%3A%2F%2Fgithub.com%2Fmdn%2Fcontent%2Fblob%2Fmain%2Ffiles%2Fen-us%2Fweb%2Fjavascript%2Freference%2Fclasses%2Findex.md%0A*+Last+commit%3A+https%3A%2F%2Fgithub.com%2Fmdn%2Fcontent%2Fcommit%2Ffad67be4431d8e6c2a89ac880735233aa76c41d4%0A*+Document+last+modified%3A+2025-07-08T13%3A18%3A45.000Z%0A%0A%3C%2Fdetails%3E"
      }
    ],
    "meta": {
      "description": "Classes are a template for creating objects. They encapsulate data with code to work on that data. Classes in JS are built on prototypes but also have some syntax and semantics that are unique to classes.",
      "keywords": ""
    },
    "summary": "Classes Baseline Widely available * This feature is well established and works across many devices and browser versions. Its been available across browsers since March 2016",
    "tags": [
      "react",
      "vue",
      "angular",
      "javascript",
      "typescript",
      "html",
      "vite",
      "classes",
      "methods",
      "description"
    ],
    "id": "classes-Classes-part-1",
    "quality": 90
  },
  {
    "title": "Destructuring",
    "url": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/Destructuring",
    "category": "javascript",
    "content": "Destructuring Baseline Widely available This feature is well established and works across many devices and browser versions. Its been available across browsers since August 2016. Learn more See full compatibility Report feedback The destructuring syntax is a JavaScript syntax that makes it possible to unpack values from arrays, or properties from objects, into distinct variables. It can be used in locations that receive data (such as the left-hand side of an assignment or anywhere that creates new identifier bindings). Try it Syntax Description The object and array literal expressions provide an easy way to create ad hoc packages of data. The destructuring uses similar syntax but uses it on the left-hand side of the assignment instead. It performs the reverse operation of an array declaration, by declaring each element in the collection as a separate variable. As for objects, compare the two pairs of lines below, and see how there's a direct correspondence within each pair. This capability is similar to features present in languages such as Perl and Python. For features specific to array or object destructuring, refer to the individual examples below. Binding and assignment For both object and array destructuring, there are two kinds of destructuring patterns: binding pattern and assignment pattern, with slightly different syntaxes. In binding patterns, the pattern starts with a declaration keyword (var, let, or const). Then, each individual property must either be bound to a variable or further destructured. All variables share the same declaration, so if you want some variables to be re-assignable but others to be read-only, you may have to destructure twice  once with let, once with const. In many other syntaxes where the language binds a variable for you, you can use a binding destructuring pattern. These include: The looping variable of for...in for...of, and for await...of loops; Function parameters; The catch binding variable. In assignment patterns, the pattern does not start with a keyword. Each destructured property is assigned to a target of assignment  which may either be declared beforehand with var or let, or is a property of another object  in general, anything that can appear on the left-hand side of an assignment expression. Note: The parentheses ( ... ) around the assignment statement are required when using object literal destructuring without a declaration. { a, b } = { a: 1, b: 2 } is not valid stand-alone syntax, as the { a, b } on the left-hand side is considered a block and not an object literal according to the rules of expression statements. However, ({ a, b } = { a: 1, b: 2 }) is valid, as is const { a, b } = { a: 1, b: 2 }. If your coding style does not include trailing semicolons, the ( ... ) expression needs to be preceded by a semicolon, or it may be used to execute a function on the previous line. Note that the equivalent binding pattern of the code above is not valid syntax: You can only use assignment patterns as the left-hand side of the assignment operator. You cannot use them with compound assignment operators such as += or *=. Default value Each destructured property can have a default value. The default value is used when the property is not present, or has value undefined. It is not used if the property has value null. The default value can be any expression. It will only be evaluated when necessary. Rest properties and rest elements You can end a destructuring pattern with a rest property ...rest. For array destructuring, it collects remaining elements of the iterable into a new array called rest (or any name you give it). For object destructuring, it copies all enumerable own properties of the object that are not already picked off by the destructuring pattern into a new object called rest. More formally, the ...rest syntax is called \"rest elements\" in array destructuring and \"rest properties\" in object destructuring, but we often just collectively call them \"rest property\". The rest property must be the last in the pattern, and must not have a trailing comma. Examples Array destructuring Basic variable assignment Destructuring with more elements than the source In an array destructuring from an array of length N specified on the right-hand side of the assignment, if the number of variables specified on the left-hand side of the assignment is greater than N, only the first N variables are assigned values. The values of the remaining variables will be undefined. Swapping variables Two variables values can be swapped in one destructuring expression. Without destructuring, swapping two values requires a temporary variable (or, in some low-level languages, the XOR-swap trick). Parsing an array returned from a function It's always been possible to return an array from a function. Destructuring can make working with an array return value more concise. In this example, f() returns the values [1, 2] as its output, which can be parsed in a single line with destructuring. Ignoring some returned values You can ignore return values that you're not interested in: You can also ignore all returned values: Though in this case, it's probably clearer to just call the function and not use destructuring at all. You don't have to use the return value. Using a binding pattern as the rest property The rest property of array destructuring can be another array or object binding pattern. The inner destructuring destructures from the array created after collecting the rest elements, so you cannot access any properties present on the original iterable in this way. These binding patterns can even be nested, as long as each rest property is the last in the list. On the other hand, object destructuring can only have an identifier as the rest property. Unpacking values from a regular expression match When the regular expression exec() method finds a match, it returns an array containing first the entire matched portion of the string and then the portions of the string that matched each parenthesized group in the regular expression. Destructuring allows you to unpack the parts out of this array easily, ignoring the full match if it is not needed. Using array destructuring on any iterable Array destructuring calls the iterable protocol of the right-hand side. Therefore, any iterable, not necessarily arrays, can be destructured. Non-iterables cannot be destructured as arrays. Iterables are only iterated until all bindings are assigned. The rest binding is eagerly evaluated and creates a new array, instead of using the old iterable. Object destructuring Basic assignment Assigning to new variable names A property can be unpacked from an object and assigned to a variable with a different name than the object property. Here, for example, const { p: foo } = o takes from the object o the property named p and assigns it to a local variable named foo. Assigning to new variable names and providing default values A property can be both Unpacked from an object and assigned to a variable with a different name. Assigned a default value in case the unpacked value is undefined. Unpacking properties from objects passed as a function parameter Objects passed into function parameters can also be unpacked into variables, which may then be accessed within the function body. As for object assignment, the destructuring syntax allows for the new variable to have the same name or a different name than the original property, and to assign default values for the case when the original object does not define the property. Consider this object, which contains information about a user. Here we show how to unpack a property of the passed object into a variable with the same name. The parameter value { id } indicates that the id property of the object passed to the function should be unpacked into a variable with the same name, which can then be used within the function. You can define the name of the unpacked variable. Here we unpack the property named displayName, and rename it to dname for use within the function body. Nested objects can also be unpacked. The example below shows the property fullname.firstName being unpacked into a variable called name. Setting a function parameter's default value Default values can be specified using =, and will be used as variable values if a specified property does not exist in the passed object. Below we show a function where the default size is 'big', default co-ordinates are x: 0, y: 0 and default radius is 25. In the function signature for drawChart above, the destructured left-hand side has a default value of an empty object = {}. You could have also written the function without that default. However, if you leave out that default value, the function will look for at least one argument to be supplied when invoked, whereas in its current form, you can call drawChart() without supplying any parameters. Otherwise, you need to at least supply an empty object literal. For more information, see Default parameters  Destructured parameter with default value assignment. Nested object and array destructuring For of iteration and destructuring Computed object property names and destructuring Computed property names, like on object literals, can be used with destructuring. Invalid JavaScript identifier as a property name Destructuring can be used with property names that are not valid JavaScript identifiers by providing an alternative identifier that is valid. Destructuring primitive values Object destructuring is almost equivalent to property accessing. This means if you try to destruct a primitive value, the value will get wrapped into the corresponding wrapper object and the property is accessed on the wrapper object. Same as accessing properties, destructuring null or undefined throws a TypeError. This happens even when the pattern is empty. Combined array and object destructuring Array and object destructuring can be combined. Say you want the third element in the array props below, and then you want the name property in the object, you can do the following: The prototype chain is looked up when the object is deconstructed When deconstructing an object, if a property is not accessed in itself, it will continue to look up along the prototype chain. Specifications Specification ECMAScript 2026 Language Specification# sec-destructuring-assignment ECMAScript 2026 Language Specification# sec-destructuring-binding-patterns Browser compatibility See also Assignment operators ES6 in Depth: Destructuring on hacks.mozilla.org (2015) Help improve MDN Learn how to contribute This page was last modified on Jul 8, 2025 by MDN contributors. View this page on GitHub  Report a problem with this content",
    "headings": [
      {
        "level": 1,
        "text": "Destructuring",
        "id": ""
      },
      {
        "level": 2,
        "text": "Try it",
        "id": "try_it"
      },
      {
        "level": 2,
        "text": "Syntax",
        "id": "syntax"
      },
      {
        "level": 2,
        "text": "Description",
        "id": "description"
      },
      {
        "level": 2,
        "text": "Examples",
        "id": "examples"
      },
      {
        "level": 2,
        "text": "Specifications",
        "id": "specifications"
      },
      {
        "level": 2,
        "text": "Browser compatibility",
        "id": "browser_compatibility"
      },
      {
        "level": 2,
        "text": "See also",
        "id": "see_also"
      },
      {
        "level": 2,
        "text": "Help improve MDN",
        "id": "feedback"
      },
      {
        "level": 3,
        "text": "Binding and assignment",
        "id": "binding_and_assignment"
      },
      {
        "level": 3,
        "text": "Default value",
        "id": "default_value"
      },
      {
        "level": 3,
        "text": "Rest properties and rest elements",
        "id": "rest_properties_and_rest_elements"
      },
      {
        "level": 3,
        "text": "Array destructuring",
        "id": "array_destructuring"
      },
      {
        "level": 3,
        "text": "Object destructuring",
        "id": "object_destructuring"
      },
      {
        "level": 3,
        "text": "Destructuring primitive values",
        "id": "destructuring_primitive_values"
      },
      {
        "level": 4,
        "text": "Basic variable assignment",
        "id": "basic_variable_assignment"
      },
      {
        "level": 4,
        "text": "Destructuring with more elements than the source",
        "id": "destructuring_with_more_elements_than_the_source"
      },
      {
        "level": 4,
        "text": "Swapping variables",
        "id": "swapping_variables"
      },
      {
        "level": 4,
        "text": "Parsing an array returned from a function",
        "id": "parsing_an_array_returned_from_a_function"
      },
      {
        "level": 4,
        "text": "Ignoring some returned values",
        "id": "ignoring_some_returned_values"
      },
      {
        "level": 4,
        "text": "Using a binding pattern as the rest property",
        "id": "using_a_binding_pattern_as_the_rest_property"
      },
      {
        "level": 4,
        "text": "Unpacking values from a regular expression match",
        "id": "unpacking_values_from_a_regular_expression_match"
      },
      {
        "level": 4,
        "text": "Using array destructuring on any iterable",
        "id": "using_array_destructuring_on_any_iterable"
      },
      {
        "level": 4,
        "text": "Basic assignment",
        "id": "basic_assignment"
      },
      {
        "level": 4,
        "text": "Assigning to new variable names",
        "id": "assigning_to_new_variable_names"
      },
      {
        "level": 4,
        "text": "Assigning to new variable names and providing default values",
        "id": "assigning_to_new_variable_names_and_providing_default_values"
      },
      {
        "level": 4,
        "text": "Unpacking properties from objects passed as a function parameter",
        "id": "unpacking_properties_from_objects_passed_as_a_function_parameter"
      },
      {
        "level": 4,
        "text": "Setting a function parameter's default value",
        "id": "setting_a_function_parameters_default_value"
      },
      {
        "level": 4,
        "text": "Nested object and array destructuring",
        "id": "nested_object_and_array_destructuring"
      },
      {
        "level": 4,
        "text": "For of iteration and destructuring",
        "id": "for_of_iteration_and_destructuring"
      },
      {
        "level": 4,
        "text": "Computed object property names and destructuring",
        "id": "computed_object_property_names_and_destructuring"
      },
      {
        "level": 4,
        "text": "Invalid JavaScript identifier as a property name",
        "id": "invalid_javascript_identifier_as_a_property_name"
      },
      {
        "level": 4,
        "text": "Combined array and object destructuring",
        "id": "combined_array_and_object_destructuring"
      },
      {
        "level": 4,
        "text": "The prototype chain is looked up when the object is deconstructed",
        "id": "the_prototype_chain_is_looked_up_when_the_object_is_deconstructed"
      }
    ],
    "codeBlocks": [
      {
        "language": "text",
        "code": "for await...of"
      },
      {
        "language": "text",
        "code": "{ a, b } = { a: 1, b: 2 }"
      },
      {
        "language": "text",
        "code": "({ a, b } = { a: 1, b: 2 })"
      },
      {
        "language": "text",
        "code": "const { a, b } = { a: 1, b: 2 }"
      },
      {
        "language": "text",
        "code": "const { p: foo } = o"
      },
      {
        "language": "text",
        "code": "displayName"
      },
      {
        "language": "text",
        "code": "fullname.firstName"
      },
      {
        "language": "text",
        "code": "drawChart()"
      }
    ],
    "links": [
      {
        "text": "Learn more",
        "href": "/en-US/docs/Glossary/Baseline/Compatibility"
      },
      {
        "text": "Report feedback",
        "href": "https://survey.alchemer.com/s3/7634825/MDN-baseline-feedback?page=%2Fen-US%2Fdocs%2FWeb%2FJavaScript%2FReference%2FOperators%2FDestructuring&level=high"
      },
      {
        "text": "binding",
        "href": "/en-US/docs/Glossary/Binding"
      },
      {
        "text": "for...in",
        "href": "/en-US/docs/Web/JavaScript/Reference/Statements/for...in"
      },
      {
        "text": "for...of",
        "href": "/en-US/docs/Web/JavaScript/Reference/Statements/for...of"
      },
      {
        "text": "for await...of",
        "href": "/en-US/docs/Web/JavaScript/Reference/Statements/for-await...of"
      },
      {
        "text": "Function",
        "href": "/en-US/docs/Web/JavaScript/Reference/Functions"
      },
      {
        "text": "catch",
        "href": "/en-US/docs/Web/JavaScript/Reference/Statements/try...catch"
      },
      {
        "text": "expression statements",
        "href": "/en-US/docs/Web/JavaScript/Reference/Statements/Expression_statement"
      },
      {
        "text": "assignment",
        "href": "/en-US/docs/Web/JavaScript/Reference/Operators/Assignment"
      },
      {
        "text": "XOR-swap trick",
        "href": "https://en.wikipedia.org/wiki/XOR_swap_algorithm"
      },
      {
        "text": "exec()",
        "href": "/en-US/docs/Web/JavaScript/Reference/Global_Objects/RegExp/exec"
      },
      {
        "text": "iterable protocol",
        "href": "/en-US/docs/Web/JavaScript/Reference/Iteration_protocols"
      },
      {
        "text": "Default parameters > Destructured parameter with default value assignment",
        "href": "/en-US/docs/Web/JavaScript/Reference/Functions/Default_parameters#destructured_parameter_with_default_value_assignment"
      },
      {
        "text": "object literals",
        "href": "/en-US/docs/Web/JavaScript/Reference/Operators/Object_initializer#computed_property_names"
      },
      {
        "text": "identifiers",
        "href": "/en-US/docs/Glossary/Identifier"
      },
      {
        "text": "property accessing",
        "href": "/en-US/docs/Web/JavaScript/Reference/Operators/Property_accessors"
      },
      {
        "text": "TypeError",
        "href": "/en-US/docs/Web/JavaScript/Reference/Global_Objects/TypeError"
      },
      {
        "text": "ECMAScript® 2026 Language Specification# sec-destructuring-assignment",
        "href": "https://tc39.es/ecma262/multipage/ecmascript-language-expressions.html#sec-destructuring-assignment"
      },
      {
        "text": "ECMAScript® 2026 Language Specification# sec-destructuring-binding-patterns",
        "href": "https://tc39.es/ecma262/multipage/ecmascript-language-statements-and-declarations.html#sec-destructuring-binding-patterns"
      },
      {
        "text": "Assignment operators",
        "href": "/en-US/docs/Web/JavaScript/Reference/Operators#assignment_operators"
      },
      {
        "text": "ES6 in Depth: Destructuring",
        "href": "https://hacks.mozilla.org/2015/05/es6-in-depth-destructuring/"
      },
      {
        "text": "Learn how to contribute",
        "href": "/en-US/docs/MDN/Community/Getting_started"
      },
      {
        "text": "MDN contributors",
        "href": "/en-US/docs/Web/JavaScript/Reference/Operators/Destructuring/contributors.txt"
      },
      {
        "text": "View this page on GitHub",
        "href": "https://github.com/mdn/content/blob/main/files/en-us/web/javascript/reference/operators/destructuring/index.md?plain=1"
      },
      {
        "text": "Report a problem with this content",
        "href": "https://github.com/mdn/content/issues/new?template=page-report.yml&mdn-url=https%3A%2F%2Fdeveloper.mozilla.org%2Fen-US%2Fdocs%2FWeb%2FJavaScript%2FReference%2FOperators%2FDestructuring&metadata=%3C%21--+Do+not+make+changes+below+this+line+--%3E%0A%3Cdetails%3E%0A%3Csummary%3EPage+report+details%3C%2Fsummary%3E%0A%0A*+Folder%3A+%60en-us%2Fweb%2Fjavascript%2Freference%2Foperators%2Fdestructuring%60%0A*+MDN+URL%3A+https%3A%2F%2Fdeveloper.mozilla.org%2Fen-US%2Fdocs%2FWeb%2FJavaScript%2FReference%2FOperators%2FDestructuring%0A*+GitHub+URL%3A+https%3A%2F%2Fgithub.com%2Fmdn%2Fcontent%2Fblob%2Fmain%2Ffiles%2Fen-us%2Fweb%2Fjavascript%2Freference%2Foperators%2Fdestructuring%2Findex.md%0A*+Last+commit%3A+https%3A%2F%2Fgithub.com%2Fmdn%2Fcontent%2Fcommit%2Ffad67be4431d8e6c2a89ac880735233aa76c41d4%0A*+Document+last+modified%3A+2025-07-08T13%3A18%3A45.000Z%0A%0A%3C%2Fdetails%3E"
      }
    ],
    "meta": {
      "description": "The destructuring syntax is a JavaScript syntax that makes it possible to unpack values from arrays, or properties from objects, into distinct variables. It can be used in locations that receive data (such as the left-hand side of an assignment or anywhere that creates new identifier bindings).",
      "keywords": ""
    },
    "summary": "Destructuring Baseline Widely available This feature is well established and works across many devices and browser versions. Its been available across browsers since August 2016",
    "tags": [
      "react",
      "javascript",
      "typescript",
      "css",
      "html",
      "vite",
      "destructuring",
      "array",
      "object",
      "values"
    ],
    "id": "destructuring-Destructuring-part-1",
    "quality": 100
  },
  {
    "title": "JavaScript modules",
    "url": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Guide/Modules",
    "category": "javascript",
    "content": "JavaScript modules Previous This guide gives you all you need to get started with JavaScript module syntax. A background on modules JavaScript programs started off pretty small  most of its usage in the early days was to do isolated scripting tasks, providing a bit of interactivity to your web pages where needed, so large scripts were generally not needed. Fast forward a few years and we now have complete applications being run in browsers with a lot of JavaScript, as well as JavaScript being used in other contexts (Node.js, for example). Complex projects necessitate a mechanism for splitting JavaScript programs into separate modules that can be imported when needed. Node.js has had this ability for a long time, and there are a number of JavaScript libraries and frameworks that enable module usage (for example, other CommonJS and AMD-based module systems like RequireJS, webpack, and Babel). All modern browsers support module features natively without needing transpilation. It can only be a good thing  browsers can optimize loading of modules, making it more efficient than having to use a library and do all of that extra client-side processing and extra round trips. It does not obsolete bundlers like webpack, though  bundlers still do a good job at partitioning code into reasonably sized chunks, and are able to do other optimizations like minification, dead code elimination, and tree-shaking. Introducing an example To demonstrate usage of modules, we've created a set of examples that you can find on GitHub. These examples demonstrate a set of modules that create a canvas element on a webpage, and then draw (and report information about) different shapes on the canvas. These are fairly trivial, but have been kept deliberately simple to demonstrate modules clearly. Note: If you want to download the examples and run them locally, you'll need to run them through a local web server. Basic example structure In our first example (see basic-modules) we have a file structure as follows: index.html main.js modules/ canvas.js square.js Note: All of the examples in this guide have basically the same structure; the above should start getting pretty familiar. The modules directory's two modules are described below: canvas.js  contains functions related to setting up the canvas: create()  creates a canvas with a specified width and height inside a wrapper div with a specified ID, which is itself appended inside a specified parent element. Returns an object containing the canvas's 2D context and the wrapper's ID. createReportList()  creates an unordered list appended inside a specified wrapper element, which can be used to output report data into. Returns the list's ID. square.js  contains: name  a constant containing the string 'square'. draw()  draws a square on a specified canvas, with a specified size, position, and color. Returns an object containing the square's size, position, and color. reportArea()  writes a square's area to a specific report list, given its length. reportPerimeter()  writes a square's perimeter to a specific report list, given its length. Aside  .mjs versus .js Throughout this article, we've used .js extensions for our module files, but in other resources you may see the .mjs extension used instead. V8's documentation recommends this, for example. The reasons given are: It is good for clarity, i.e., it makes it clear which files are modules, and which are regular JavaScript. It ensures that your module files are parsed as a module by runtimes such as Node.js, and build tools such as Babel. However, we decided to keep using .js, at least for the moment. To get modules to work correctly in a browser, you need to make sure that your server is serving them with a Content-Type header that contains a JavaScript MIME type such as text/javascript. If you don't, you'll get a strict MIME type checking error along the lines of \"The server responded with a non-JavaScript MIME type\" and the browser won't run your JavaScript. Most servers already set the correct type for .js files, but not yet for .mjs files. Servers that already serve .mjs files correctly include GitHub Pages and http-server for Node.js. This is OK if you are using such an environment already, or if you aren't but you know what you are doing and have access (i.e., you can configure your server to set the correct Content-Type for .mjs files). It could however cause confusion if you don't control the server you are serving files from, or are publishing files for public use, as we are here. For learning and portability purposes, we decided to keep to .js. If you really value the clarity of using .mjs for modules versus using .js for \"normal\" JavaScript files, but don't want to run into the problem described above, you could always use .mjs during development and convert them to .js during your build step. It is also worth noting that: Some tools may never support .mjs. The script type=\"module\" attribute is used to denote when a module is being pointed to, as you'll see below. Exporting module features The first thing you do to get access to module features is export them. This is done using the export statement. The easiest way to use it is to place it in front of any items you want exported out of the module, for example: You can export functions, var, let, const, and  as we'll see later  classes. They need to be top-level items: for example, you can't use export inside a function. A more convenient way of exporting all the items you want to export is to use a single export statement at the end of your module file, followed by a comma-separated list of the features you want to export wrapped in curly braces. For example: Importing features into your script Once you've exported some features out of your module, you need to import them into your script to be able to use them. The simplest way to do this is as follows: You use the import statement, followed by a comma-separated list of the features you want to import wrapped in curly braces, followed by the keyword from, followed by the module specifier. The module specifier provides a string that the JavaScript environment can resolve to a path to the module file. In a browser, this could be a path relative to the site root, which for our basic-modules example would be /js-examples/module-examples/basic-modules. However, here we are instead using the dot (.) syntax to mean \"the current location\", followed by the relative path to the file we are trying to find. This is much better than writing out the entire absolute path each time, as relative paths are shorter and make the URL portable  the example will still work if you move it to a different location in the site hierarchy. So for example: becomes You can see such lines in action in main.js. Note: In some module systems, you can use a module specifier like modules/square that isn't a relative or absolute path, and that doesn't have a file extension. This kind of specifier can be used in a browser environment if you first define an import map. Once you've imported the features into your script, you can use them just like they were defined inside the same file. The following is found in main.js, below the import lines: Note: The imported values are read-only views of the features that were exported. Similar to const variables, you cannot re-assign the variable that was imported, but you can still modify properties of object values. The value can only be re-assigned by the module exporting it. See the import reference for an example. Importing modules using import maps Above we saw how a browser can import a module using a module specifier that is either an absolute URL, or a relative URL that is resolved using the base URL of the document: Import maps allow developers to instead specify almost any text they want in the module specifier when importing a module; the map provides a corresponding value that will replace the text when the module URL is resolved. For example, the imports key in the import map below defines a \"module specifier map\" JSON object where the property names can be used as module specifiers, and the corresponding values will be substituted when the browser resolves the module URL. The values must be absolute or relative URLs. Relative URLs are resolved to absolute URL addresses using the base URL of the document containing the import map. The import map is defined using a JSON object inside a script element with the type attribute set to importmap. Note that an import map only applies to the document  the specification does not cover how to apply an import map in a worker or worklet context. With this map you can now use the property names above as module specifiers. If there is no trailing forward slash on the module specifier key then the whole module specifier key is matched and substituted. For example, below we match bare module names, and remap a URL to another path. If the module specifier has a trailing forward slash then the value must have one as well, and the key is matched as a \"path prefix\". This allows remapping of whole classes of URLs. It is possible for multiple keys in an import map to be valid matches for a module specifier. For example, a module specifier of shapes/circle/ could match the module specifier keys shapes/ and shapes/circle/. In this case the browser will select the most specific (longest) matching module specifier key. Import maps allow modules to be imported using bare module names (as in Node.js), and can also simulate importing modules from packages, both with and without file extensions. While not shown above, they also allow particular versions of a library to be imported, based on the path of the script that is importing the module. Generally they let developers write more ergonomic import code, and make it easier to manage the different versions and dependencies of modules used by a site. This can reduce the effort required to use the same JavaScript libraries in both browser and server. The following sections expand on the various features outlined above. Feature detection You can check support for import maps using the HTMLScriptElement.supports() static method (which is itself broadly supported): Importing modules as bare names In some JavaScript environments, such as Node.js, you can use bare names for the module specifier. This works because the environment can resolve module names to a standard location in the file system. For example, you might use the following syntax to import the \"square\" module. To use bare names on a browser you need an import map, which provides the information needed by the browser to resolve module specifiers to URLs (JavaScript will throw a TypeError if it attempts to import a module specifier that can't be resolved to a module location). Below you can see a map that defines a square module specifier key, which in this case maps to a relative address value. With this map we can now use a bare name when we import the module: Remapping module paths Module specifier map entries, where both the specifier key and its associated value have a trailing forward slash (/), can be used as a path-prefix. This allows the remapping of a whole set of import URLs from one location to another. It can also be used to emulate working with \"packages and modules\", such as you might see in the Node ecosystem. Note: The trailing / indicates that the module specifier key can be substituted as part of a module specifier. If this is not present, the browser will only match (and substitute) the whole module specifier key. Packages of modules The following JSON import map definition maps lodash as a bare name, and the module specifier prefix lodash/ to the path /node_modules/lodash-es/ (resolved to the document base URL): With this mapping you can import both the whole \"package\", using the bare name, and modules within it (using the path mapping): It is possible to import fp above without the .js file extension, but you would need to create a bare module specifier key for that file, such as lodash/fp, rather than using the path. This may be reasonable for just one module, but scales poorly if you wish to import many modules. General URL remapping A module specifier key doesn't have to be path  it can also be an absolute URL (or a URL-like relative path like ./, ../, /). This may be useful if you want to remap a module that has absolute paths to a resource with your own local resources. Scoped modules for version management Ecosystems like Node use package managers such as npm to manage modules and their dependencies. The package manager ensures that each module is separated from other modules and their dependencies. As a result, while a complex application might include the same module multiple times with several different versions in different parts of the module graph, users do not need to think about this complexity. Note: You can also achieve version management using relative paths, but this is subpar because, among other things, this forces a particular structure on your project, and prevents you from using bare module names. Import maps similarly allow you to have multiple versions of dependencies in your application and refer to them using the same module specifier. You implement this with the scopes key, which allows you to provide module specifier maps that will be used depending on the path of the script performing the import. The example below demonstrates this. With this mapping, if a script with an URL that contains /node_modules/dependency/ imports cool-module, the version in /node_modules/some/other/location/cool-module/index.js will be used. The map in imports is used as a fallback if there is no matching scope in the scoped map, or the matching scopes don't contain a matching specifier. For example, if cool-module is imported from a script with a non-matching scope path, then the module specifier map in imports will be used instead, mapping to the version in /node_modules/cool-module/index.js. Note that the path used to select a scope does not affect how the address is resolved. The value in the mapped path does not have to match the scopes path, and relative paths are still resolved to the base URL of the script that contains the import map. Just as for module specifier maps, you can have many scope keys, and these may contain overlapping paths. If multiple scopes match the referrer URL, then the most specific scope path is checked first (the longest scope key) for a matching specifier. The browsers will fall back to the next most specific matching scoped path if there is no matching specifier, and so on. If there is no matching specifier in any of the matching scopes, the browser checks for a match in the module specifier map in the imports key. Improve caching by mapping away hashed filenames Script files used by websites often have hashed filenames to simplify caching. The downside of this approach is that if a module changes, any modules that import it using its hashed filename will also need to be updated/regenerated. This potentially results in a cascade of updates, which is wasteful of network resources. Import maps provide a convenient solution to this problem. Rather than depending on specific hashed filenames, applications and scripts instead depend on an un-hashed version of the module name (address). An import map like the one below then provides a mapping to the actual script file. If dependency_script changes, then its hash contained in the file name changes as well. In this case, we only need to update the import map to reflect the changed name of the module. We don't have to update the source of any JavaScript code that depends on it, because the specifier in the import statement does not change. Loading non-JavaScript resources One exciting feature that a unified module architecture brings is the ability to load non-JavaScript resources as modules. For example, you can import JSON as a JavaScript object, or import CSS as a CSSStyleSheet object. You must explicitly declare what kind of resource you are importing. By default, the browser assumes that the resource is JavaScript, and will throw an error if the resolved resource is something else. To import JSON, CSS, or other types of resource, use the import attributes syntax: Browsers will also perform validation on the module type, and fail if, for example, ./data.json does not resolve to a JSON file. This ensures that you don't accidentally execute code when you just intend to import data. Once imported successfully, you can now use the imported value as a normal JavaScript object or CSSStyleSheet object. Applying the module to your HTML Now we just need to apply the main.js module to our HTML page. This is very similar to how we apply a regular script to a page, with a few notable differences. First of all, you need to include type=\"module\" in the script element, to declare this script as a module. To import the main.js script, we use this: You can also embed the module's script directly into the HTML file by placing the JavaScript code within the body of the script element: You can only use import and export statements inside modules, not regular scripts. An error will be thrown if your script element doesn't have the type=\"module\" attribute and attempts to import other modules. For example: You should generally define all your modules in separate files. Modules declared inline in HTML can only import other modules, but anything they export will not be accessible by other modules (because they don't have a URL). Note: Modules and their dependencies can be preloaded by specifying them in link elements with rel=\"modulepreload\". This can significantly reduce load time when the modules are used. Other differences between modules and classic scripts You need to pay attention to local testing  if you try to load the HTML file locally (i.e., with a file:// URL), you'll run into CORS errors due to JavaScript module security requirements. You need to do your testing through a server. Also, note that you might get different behavior from sections of script defined inside modules as opposed to in classic scripts. This is because modules use strict mode automatically. There is no need to use the defer attribute (see script attributes) when loading a module script; modules are deferred automatically. Modules are only executed once, even if they have been referenced in multiple script tags. Last but not least, let's make this clear  module features are imported into the scope of a single script  they aren't available in the global scope. Therefore, you will only be able to access imported features in the script they are imported into, and you won't be able to access them from the JavaScript console, for example. You'll still get syntax errors shown in the DevTools, but you'll not be able to use some of the debugging techniques you might have expected to use. Module-defined variables are scoped to the module unless explicitly attached to the global object. On the other hand, globally-defined variables are available within the module. For example, given the following code: The page would still render Hello, because the global variables text and document are available in the module. (Also note from this example that a module doesn't necessarily need an import/export statement  the only thing needed is for the entry point to have type=\"module\".) Default exports versus named exports The functionality we've exported so far has been comprised of named exports  each item (be it a function, const, etc.) has been referred to by its name upon export, and that name has been used to refer to it on import as well. There is also a type of export called the default export  this is designed to make it easy to have a default function provided by a module, and also helps JavaScript modules to interoperate with existing CommonJS and AMD module systems (as explained nicely in ES6 In Depth: Modules by Jason Orendorff; search for \"Default exports\"). Let's look at an example as we explain how it works. In our basic-modules square.js you can find a function called randomSquare() that creates a square with a random color, size, and position. We want to export this as our default, so at the bottom of the file we write this: Note the lack of curly braces. We could instead prepend export default onto the function and define it as an anonymous function, like this: Over in our main.js file, we import the default function using this line: Again, note the lack of curly braces. This is because there is only one default export allowed per module, and we know that randomSquare is it. The above line is basically shorthand for: Note: The as syntax for renaming exported items is explained below in the Renaming imports and exports section. Avoiding naming conflicts So far, our canvas shape drawing modules seem to be working OK. But what happens if we try to add a module that deals with drawing another shape, like a circle or triangle? These shapes would probably have associated functions like draw(), reportArea(), etc. too; if we tried to import different functions of the same name into the same top-level module file, we'd end up with conflicts and errors. Fortunately there are a number of ways to get around this. We'll look at these in the following sections. Renaming imports and exports Inside your import and export statement's curly braces, you can use the keyword as along with a new feature name, to change the identifying name you will use for a feature inside the top-level module. So for example, both of the following would do the same job, albeit in a slightly different way: Let's look at a real example. In our renaming directory you'll see the same module system as in the previous example, except that we've added circle.js and triangle.js modules to draw and report on circles and triangles. Inside each of these modules, we've got features with the same names being exported, and therefore each has the same export statement at the bottom: When importing these into main.js, if we tried to use The browser would throw an error such as \"SyntaxError: redeclaration of import name\" (Firefox). Instead we need to rename the imports so that they are unique: Note that you could solve the problem in the module files instead, e.g. And it would work just the same. What style you use is up to you, however it arguably makes more sense to leave your module code alone, and make the changes in the imports. This especially makes sense when you are importing from third party modules that you don't have any control over. Creating a module object The above method works OK, but it's a little messy and long-winded. An even better solution is to import each module's features inside a module object. The following syntax form does that: This grabs all the exports available inside module.js, and makes them available as members of an object Module, effectively giving it its own namespace. So for example: Again, let's look at a real example. If you go to our module-objects directory, you'll see the same example again, but rewritten to take advantage of this new syntax. In the modules, the exports are all in the following simple form: The imports on the other hand look like this: In each case, you can now access the module's imports underneath the specified object name, for example: So you can now write the code just the same as before (as long as you include the object names where needed), and the imports are much neater. Modules and classes As we hinted at earlier, you can also export and import classes; this is another option for avoiding conflicts in your code, and is especially useful if you've already got your module code written in an object-oriented style. You can see an example of our shape drawing module rewritten with ES classes in our classes directory. As an example, the square.js file now contains all its functionality in a single class: which we then export: Over in main.js, we import it like this: And then use the class to draw our square: Aggregating modules There will be times where you'll want to aggregate modules together. You might have multiple levels of dependencies, where you want to simplify things, combining several submodules into one parent module. This is possible using export syntax of the following forms in the parent module: For an example, see our module-aggregation directory. In this example (based on our earlier classes example) we've got an extra module called shapes.js, which aggregates all the functionality from circle.js, square.js, and triangle.js together. We've also moved our submodules inside a subdirectory inside the modules directory called shapes. So the module structure in this example is: modules/ canvas.js shapes.js shapes/ circle.js square.js triangle.js In each of the submodules, the export is of the same form, e.g. Next up comes the aggregation part. Inside shapes.js, we include the following lines: These grab the exports from the individual submodules and effectively make them available from the shapes.js module. Note: The exports referenced in shapes.js basically get redirected through the file and don't really exist there, so you won't be able to write any useful related code inside the same file. So now in the main.js file, we can get access to all three module classes by replacing with the following single line: Dynamic module loading A recent addition to JavaScript modules functionality is dynamic module loading. This allows you to dynamically load modules only when they are needed, rather than having to load everything up front. This has some obvious performance advantages; let's read on and see how it works. This new functionality allows you to call import() as a function, passing it the path to the module as a parameter. It returns a Promise, which fulfills with a module object (see Creating a module object) giving you access to that object's exports. For example: Note: Dynamic import is permitted in the browser main thread, and in shared and dedicated workers. However import() will throw if called in a service worker or worklet. Let's look at an example. In the dynamic-module-imports directory we've got another example based on our classes example. This time however we are not drawing anything on the canvas when the example loads. Instead, we include three buttons  \"Circle\", \"Square\", and \"Triangle\"  that, when pressed, dynamically load the required module and then use it to draw the associated shape. In this example we've only made changes to our index.html and main.js files  the module exports remain the same as before. Over in main.js we've grabbed a reference to each button using a document.querySelector() call, for example: We then attach an event listener to each button so that when pressed, the relevant module is dynamically loaded and used to draw the shape: Note that, because the promise fulfillment returns a module object, the class is then made a subfeature of the object, hence we now need to access the constructor with Module. prepended to it, e.g., Module.Square( /*  */ ). Another advantage of dynamic imports is that they are always available, even in script environments. Therefore, if you have an existing script tag in your HTML that doesn't have type=\"module\", you can still reuse code distributed as modules by dynamically importing it. Top level await Top level await is a feature available within modules. This means the await keyword can be used. It allows modules to act as big asynchronous functions meaning code can be evaluated before use in parent modules, but without blocking sibling modules from loading. Let's take a look at an example. You can find all the files and code described in this section within the top-level-await directory, which extends from the previous examples. Firstly we'll declare our color palette in a separate colors.json file: Then we'll create a module called getColors.js which uses a fetch request to load the colors.json file and return the data as an object. Notice the last export line here. We're using the keyword await before specifying the constant colors to export. This means any other modules which include this one will wait until colors has been downloaded and parsed before using it. Let's include this module in our main.js file: We'll use colors instead of the previously used strings when calling our shape functions: This is useful because the code within main.js won't execute until the code in getColors.js has run. However it won't block other modules being loaded. For instance our canvas.js module will continue to load while colors is being fetched. Import declarations are hoisted Import declarations are hoisted. In this case, it means that the imported values are available in the module's code even before the place that declares them, and that the imported module's side effects are produced before the rest of the module's code starts running. So for example, in main.js, importing Canvas in the middle of the code would still work: Still, it is considered good practice to put all your imports at the top of the code, which makes it easier to analyze dependencies. Cyclic imports Modules can import other modules, and those modules can import other modules, and so on. This forms a directed graph called the \"dependency graph\". In an ideal world, this graph is acyclic. In this case, the graph can be evaluated using a depth-first traversal. However, cycles are often inevitable. Cyclic import arises if module a imports module b, but b directly or indirectly depends on a. For example: Cyclic imports don't always fail. The imported variable's value is only retrieved when the variable is actually used (hence allowing live bindings), and only if the variable remains uninitialized at that time will a ReferenceError be thrown. In this example, both a and b are used asynchronously. Therefore, at the time the module is evaluated, neither b nor a is actually read, so the rest of the code is executed as normal, and the two export declarations produce the values of a and b. Then, after the timeout, both a and b are available, so the two console.log statements also execute as normal. If you change the code to use a synchronously, the module evaluation fails: This is because when JavaScript evaluates a.js, it needs to first evaluate b.js, the dependency of a.js. However, b.js uses a, which is not yet available. On the other hand, if you change the code to use b synchronously but a asynchronously, the module evaluation succeeds: This is because the evaluation of b.js completes normally, so the value of b is available when a.js is evaluated. You should usually avoid cyclic imports in your project, because they make your code more error-prone. Some common cycle-elimination techniques are: Merge the two modules into one. Move the shared code into a third module. Move some code from one module to the other. However, cyclic imports can also occur if the libraries depend on each other, which is harder to fix. Authoring \"isomorphic\" modules The introduction of modules encourages the JavaScript ecosystem to distribute and reuse code in a modular fashion. However, that doesn't necessarily mean a piece of JavaScript code can run in every environment. Suppose you discovered a module that generates SHA hashes of your user's password. Can you use it in the browser front end? Can you use it on your Node.js server? The answer is: it depends. Modules still have access to global variables, as demonstrated previously. If the module references globals like window, it can run in the browser, but will throw an error in your Node.js server, because window is not available there. Similarly, if the code requires access to process to be functional, it can only be used in Node.js. In order to maximize the reusability of a module, it is often advised to make the code \"isomorphic\"  that is, exhibits the same behavior in every runtime. This is commonly achieved in three ways: Separate your modules into \"core\" and \"binding\". For the \"core\", focus on pure JavaScript logic like computing the hash, without any DOM, network, filesystem access, and expose utility functions. For the \"binding\" part, you can read from and write to the global context. For example, the \"browser binding\" may choose to read the value from an input box, while the \"Node binding\" may read it from process.env, but values read from either place will be piped to the same core function and handled in the same way. The core can be imported in every environment and used in the same way, while only the binding, which is usually lightweight, needs to be platform-specific. Detect whether a particular global exists before using it. For example, if you test that typeof window === \"undefined\", you know that you are probably in a Node.js environment, and should not read DOM. This is preferable if the two branches actually end up with the same behavior (\"isomorphic\"). If it's impossible to provide the same functionality, or if doing so involves loading significant amounts of code while a large part remains unused, better use different \"bindings\" instead. Use a polyfill to provide a fallback for missing features. For example, if you want to use the fetch function, which is only supported in Node.js since v18, you can use a similar API, like the one provided by node-fetch. You can do so conditionally through dynamic imports: The globalThis variable is a global object that is available in every environment and is useful if you want to read or create global variables within modules. These practices are not unique to modules. Still, with the trend of code reusability and modularization, you are encouraged to make your code cross-platform so that it can be enjoyed by as many people as possible. Runtimes like Node.js are also actively implementing web APIs where possible to improve interoperability with the web. Troubleshooting Here are a few tips that may help you if you are having trouble getting your modules to work. Feel free to add to the list if you discover more! We mentioned this before, but to reiterate: .mjs files need to be loaded with a MIME-type of text/javascript (or another JavaScript-compatible MIME-type, but text/javascript is recommended), otherwise you'll get a strict MIME type checking error like \"The server responded with a non-JavaScript MIME type\". If you try to load the HTML file locally (i.e., with a file:// URL), you'll run into CORS errors due to JavaScript module security requirements. You need to do your testing through a server. GitHub pages is ideal as it also serves .mjs files with the correct MIME type. Because .mjs is a non-standard file extension, some operating systems might not recognize it, or try to replace it with something else. For example, we found that macOS was silently adding on .js to the end of .mjs files and then automatically hiding the file extension. So all of our files were actually coming out as x.mjs.js. Once we turned off automatically hiding file extensions, and trained it to accept .mjs, it was OK. See also JavaScript modules on v8.dev (2018) ES modules: A cartoon deep-dive on hacks.mozilla.org (2018) ES6 in Depth: Modules on hacks.mozilla.org (2015) Exploring JS, Ch.16: Modules by Dr. Axel Rauschmayer Previous Help improve MDN Learn how to contribute This page was last modified on Jul 20, 2025 by MDN contributors. View this page on GitHub  Report a problem with this content",
    "headings": [
      {
        "level": 1,
        "text": "JavaScript modules",
        "id": ""
      },
      {
        "level": 2,
        "text": "A background on modules",
        "id": "a_background_on_modules"
      },
      {
        "level": 2,
        "text": "Introducing an example",
        "id": "introducing_an_example"
      },
      {
        "level": 2,
        "text": "Basic example structure",
        "id": "basic_example_structure"
      },
      {
        "level": 2,
        "text": "Exporting module features",
        "id": "exporting_module_features"
      },
      {
        "level": 2,
        "text": "Importing features into your script",
        "id": "importing_features_into_your_script"
      },
      {
        "level": 2,
        "text": "Importing modules using import maps",
        "id": "importing_modules_using_import_maps"
      },
      {
        "level": 2,
        "text": "Loading non-JavaScript resources",
        "id": "loading_non-javascript_resources"
      },
      {
        "level": 2,
        "text": "Applying the module to your HTML",
        "id": "applying_the_module_to_your_html"
      },
      {
        "level": 2,
        "text": "Other differences between modules and classic scripts",
        "id": "other_differences_between_modules_and_classic_scripts"
      },
      {
        "level": 2,
        "text": "Default exports versus named exports",
        "id": "default_exports_versus_named_exports"
      },
      {
        "level": 2,
        "text": "Avoiding naming conflicts",
        "id": "avoiding_naming_conflicts"
      },
      {
        "level": 2,
        "text": "Renaming imports and exports",
        "id": "renaming_imports_and_exports"
      },
      {
        "level": 2,
        "text": "Creating a module object",
        "id": "creating_a_module_object"
      },
      {
        "level": 2,
        "text": "Modules and classes",
        "id": "modules_and_classes"
      },
      {
        "level": 2,
        "text": "Aggregating modules",
        "id": "aggregating_modules"
      },
      {
        "level": 2,
        "text": "Dynamic module loading",
        "id": "dynamic_module_loading"
      },
      {
        "level": 2,
        "text": "Top level await",
        "id": "top_level_await"
      },
      {
        "level": 2,
        "text": "Import declarations are hoisted",
        "id": "import_declarations_are_hoisted"
      },
      {
        "level": 2,
        "text": "Cyclic imports",
        "id": "cyclic_imports"
      },
      {
        "level": 2,
        "text": "Authoring \"isomorphic\" modules",
        "id": "authoring_isomorphic_modules"
      },
      {
        "level": 2,
        "text": "Troubleshooting",
        "id": "troubleshooting"
      },
      {
        "level": 2,
        "text": "See also",
        "id": "see_also"
      },
      {
        "level": 2,
        "text": "Help improve MDN",
        "id": "feedback"
      },
      {
        "level": 3,
        "text": "Aside — .mjs versus .js",
        "id": "aside_—_.mjs_versus_.js"
      },
      {
        "level": 3,
        "text": "Feature detection",
        "id": "feature_detection"
      },
      {
        "level": 3,
        "text": "Importing modules as bare names",
        "id": "importing_modules_as_bare_names"
      },
      {
        "level": 3,
        "text": "Remapping module paths",
        "id": "remapping_module_paths"
      },
      {
        "level": 3,
        "text": "Scoped modules for version management",
        "id": "scoped_modules_for_version_management"
      },
      {
        "level": 3,
        "text": "Improve caching by mapping away hashed filenames",
        "id": "improve_caching_by_mapping_away_hashed_filenames"
      },
      {
        "level": 4,
        "text": "Packages of modules",
        "id": "packages_of_modules"
      },
      {
        "level": 4,
        "text": "General URL remapping",
        "id": "general_url_remapping"
      }
    ],
    "codeBlocks": [
      {
        "language": "text",
        "code": "index.html\nmain.js\nmodules/\n    canvas.js\n    square.js"
      },
      {
        "language": "text",
        "code": "createReportList()"
      },
      {
        "language": "text",
        "code": "reportArea()"
      },
      {
        "language": "text",
        "code": "reportPerimeter()"
      },
      {
        "language": "text",
        "code": "Content-Type"
      },
      {
        "language": "text",
        "code": "text/javascript"
      },
      {
        "language": "text",
        "code": "http-server"
      },
      {
        "language": "text",
        "code": "Content-Type"
      },
      {
        "language": "text",
        "code": "<script type=\"module\">"
      },
      {
        "language": "text",
        "code": "basic-modules"
      },
      {
        "language": "text",
        "code": "/js-examples/module-examples/basic-modules"
      },
      {
        "language": "text",
        "code": "modules/square"
      },
      {
        "language": "text",
        "code": "shapes/circle/"
      },
      {
        "language": "text",
        "code": "shapes/circle/"
      },
      {
        "language": "text",
        "code": "HTMLScriptElement.supports()"
      },
      {
        "language": "text",
        "code": "/node_modules/lodash-es/"
      },
      {
        "language": "text",
        "code": "/node_modules/dependency/"
      },
      {
        "language": "text",
        "code": "cool-module"
      },
      {
        "language": "text",
        "code": "/node_modules/some/other/location/cool-module/index.js"
      },
      {
        "language": "text",
        "code": "cool-module"
      },
      {
        "language": "text",
        "code": "/node_modules/cool-module/index.js"
      },
      {
        "language": "text",
        "code": "dependency_script"
      },
      {
        "language": "text",
        "code": "CSSStyleSheet"
      },
      {
        "language": "text",
        "code": "./data.json"
      },
      {
        "language": "text",
        "code": "CSSStyleSheet"
      },
      {
        "language": "text",
        "code": "type=\"module\""
      },
      {
        "language": "text",
        "code": "type=\"module\""
      },
      {
        "language": "text",
        "code": "rel=\"modulepreload\""
      },
      {
        "language": "text",
        "code": "type=\"module\""
      },
      {
        "language": "text",
        "code": "randomSquare()"
      },
      {
        "language": "text",
        "code": "export default"
      },
      {
        "language": "text",
        "code": "randomSquare"
      },
      {
        "language": "text",
        "code": "reportArea()"
      },
      {
        "language": "text",
        "code": "triangle.js"
      },
      {
        "language": "text",
        "code": "triangle.js"
      },
      {
        "language": "text",
        "code": "modules/\n  canvas.js\n  shapes.js\n  shapes/\n    circle.js\n    square.js\n    triangle.js"
      },
      {
        "language": "text",
        "code": "document.querySelector()"
      },
      {
        "language": "text",
        "code": "Module.Square( /* … */ )"
      },
      {
        "language": "text",
        "code": "type=\"module\""
      },
      {
        "language": "text",
        "code": "top-level-await"
      },
      {
        "language": "text",
        "code": "colors.json"
      },
      {
        "language": "text",
        "code": "getColors.js"
      },
      {
        "language": "text",
        "code": "colors.json"
      },
      {
        "language": "text",
        "code": "getColors.js"
      },
      {
        "language": "text",
        "code": "ReferenceError"
      },
      {
        "language": "text",
        "code": "console.log"
      },
      {
        "language": "text",
        "code": "process.env"
      },
      {
        "language": "text",
        "code": "typeof window === \"undefined\""
      },
      {
        "language": "text",
        "code": "text/javascript"
      },
      {
        "language": "text",
        "code": "text/javascript"
      }
    ],
    "links": [
      {
        "text": "Previous",
        "href": "/en-US/docs/Web/JavaScript/Guide/Internationalization"
      },
      {
        "text": "Node.js",
        "href": "/en-US/docs/Glossary/Node.js"
      },
      {
        "text": "CommonJS",
        "href": "https://en.wikipedia.org/wiki/CommonJS"
      },
      {
        "text": "AMD",
        "href": "https://github.com/amdjs/amdjs-api/blob/master/AMD.md"
      },
      {
        "text": "RequireJS",
        "href": "https://requirejs.org/"
      },
      {
        "text": "webpack",
        "href": "https://webpack.js.org/"
      },
      {
        "text": "Babel",
        "href": "https://babeljs.io/"
      },
      {
        "text": "set of examples",
        "href": "https://github.com/mdn/js-examples/tree/main/module-examples"
      },
      {
        "text": "<canvas>",
        "href": "/en-US/docs/Web/HTML/Reference/Elements/canvas"
      },
      {
        "text": "basic-modules",
        "href": "https://github.com/mdn/js-examples/tree/main/module-examples/basic-modules"
      },
      {
        "text": "<div>",
        "href": "/en-US/docs/Web/HTML/Reference/Elements/div"
      },
      {
        "text": "V8's documentation recommends this",
        "href": "https://v8.dev/features/modules#mjs"
      },
      {
        "text": "Node.js",
        "href": "https://nodejs.org/api/esm.html#esm_enabling"
      },
      {
        "text": "Babel",
        "href": "https://babeljs.io/docs/options#sourcetype"
      },
      {
        "text": "GitHub Pages",
        "href": "https://pages.github.com/"
      },
      {
        "text": "http-server",
        "href": "https://github.com/http-party/http-server#readme"
      },
      {
        "text": "Content-Type",
        "href": "/en-US/docs/Web/HTTP/Reference/Headers/Content-Type"
      },
      {
        "text": "export",
        "href": "/en-US/docs/Web/JavaScript/Reference/Statements/export"
      },
      {
        "text": "import",
        "href": "/en-US/docs/Web/JavaScript/Reference/Statements/import"
      },
      {
        "text": "main.js",
        "href": "https://github.com/mdn/js-examples/blob/main/module-examples/basic-modules/main.js"
      },
      {
        "text": "import reference",
        "href": "/en-US/docs/Web/JavaScript/Reference/Statements/import#imported_values_can_only_be_modified_by_the_exporter"
      },
      {
        "text": "Import maps",
        "href": "/en-US/docs/Web/HTML/Reference/Elements/script/type/importmap"
      },
      {
        "text": "base URL",
        "href": "/en-US/docs/Web/HTML/Reference/Elements/base"
      },
      {
        "text": "JSON object",
        "href": "/en-US/docs/Web/HTML/Reference/Elements/script/type/importmap#import_map_json_representation"
      },
      {
        "text": "importmap",
        "href": "/en-US/docs/Web/HTML/Reference/Elements/script/type/importmap"
      },
      {
        "text": "HTMLScriptElement.supports()",
        "href": "/en-US/docs/Web/API/HTMLScriptElement/supports_static"
      },
      {
        "text": "CSSStyleSheet",
        "href": "/en-US/docs/Web/API/CSSStyleSheet"
      },
      {
        "text": "import attributes",
        "href": "/en-US/docs/Web/JavaScript/Reference/Statements/import/with"
      },
      {
        "text": "<script>",
        "href": "/en-US/docs/Web/HTML/Reference/Elements/script"
      },
      {
        "text": "<link>",
        "href": "/en-US/docs/Web/HTML/Reference/Elements/link"
      },
      {
        "text": "rel=\"modulepreload\"",
        "href": "/en-US/docs/Web/HTML/Reference/Attributes/rel/modulepreload"
      },
      {
        "text": "strict mode",
        "href": "/en-US/docs/Web/JavaScript/Reference/Strict_mode"
      },
      {
        "text": "<script> attributes",
        "href": "/en-US/docs/Web/HTML/Reference/Elements/script#attributes"
      },
      {
        "text": "ES6 In Depth: Modules",
        "href": "https://hacks.mozilla.org/2015/08/es6-in-depth-modules/"
      },
      {
        "text": "renaming",
        "href": "https://github.com/mdn/js-examples/tree/main/module-examples/renaming"
      },
      {
        "text": "module-objects",
        "href": "https://github.com/mdn/js-examples/tree/main/module-examples/module-objects"
      },
      {
        "text": "classes",
        "href": "https://github.com/mdn/js-examples/tree/main/module-examples/classes"
      },
      {
        "text": "square.js",
        "href": "https://github.com/mdn/js-examples/blob/main/module-examples/classes/modules/square.js"
      },
      {
        "text": "main.js",
        "href": "https://github.com/mdn/js-examples/blob/main/module-examples/classes/main.js"
      },
      {
        "text": "module-aggregation",
        "href": "https://github.com/mdn/js-examples/tree/main/module-examples/module-aggregation"
      },
      {
        "text": "shapes.js",
        "href": "https://github.com/mdn/js-examples/blob/main/module-examples/module-aggregation/modules/shapes.js"
      },
      {
        "text": "import()",
        "href": "/en-US/docs/Web/JavaScript/Reference/Operators/import"
      },
      {
        "text": "Promise",
        "href": "/en-US/docs/Web/JavaScript/Reference/Global_Objects/Promise"
      },
      {
        "text": "dynamic-module-imports",
        "href": "https://github.com/mdn/js-examples/tree/main/module-examples/dynamic-module-imports"
      },
      {
        "text": "index.html",
        "href": "https://github.com/mdn/js-examples/blob/main/module-examples/dynamic-module-imports/index.html"
      },
      {
        "text": "main.js",
        "href": "https://github.com/mdn/js-examples/blob/main/module-examples/dynamic-module-imports/main.js"
      },
      {
        "text": "document.querySelector()",
        "href": "/en-US/docs/Web/API/Document/querySelector"
      },
      {
        "text": "asynchronous functions",
        "href": "/en-US/docs/Learn_web_development/Extensions/Async_JS/Introducing"
      },
      {
        "text": "top-level-await",
        "href": "https://github.com/mdn/js-examples/tree/main/module-examples/top-level-await"
      },
      {
        "text": "colors.json",
        "href": "https://github.com/mdn/js-examples/blob/main/module-examples/top-level-await/data/colors.json"
      },
      {
        "text": "getColors.js",
        "href": "https://github.com/mdn/js-examples/blob/main/module-examples/top-level-await/modules/getColors.js"
      },
      {
        "text": "colors.json",
        "href": "https://github.com/mdn/js-examples/blob/main/module-examples/top-level-await/data/colors.json"
      },
      {
        "text": "main.js",
        "href": "https://github.com/mdn/js-examples/blob/main/module-examples/top-level-await/main.js"
      },
      {
        "text": "main.js",
        "href": "https://github.com/mdn/js-examples/blob/main/module-examples/top-level-await/main.js"
      },
      {
        "text": "getColors.js",
        "href": "https://github.com/mdn/js-examples/blob/main/module-examples/top-level-await/modules/getColors.js"
      },
      {
        "text": "canvas.js",
        "href": "https://github.com/mdn/js-examples/blob/main/module-examples/top-level-await/modules/canvas.js"
      },
      {
        "text": "hoisted",
        "href": "/en-US/docs/Glossary/Hoisting"
      },
      {
        "text": "directed graph",
        "href": "https://en.wikipedia.org/wiki/Directed_graph"
      },
      {
        "text": "acyclic",
        "href": "https://en.wikipedia.org/wiki/Directed_acyclic_graph"
      },
      {
        "text": "live bindings",
        "href": "/en-US/docs/Web/JavaScript/Reference/Statements/import#imported_values_can_only_be_modified_by_the_exporter"
      },
      {
        "text": "ReferenceError",
        "href": "/en-US/docs/Web/JavaScript/Reference/Errors/Cant_access_lexical_declaration_before_init"
      },
      {
        "text": "fetch",
        "href": "/en-US/docs/Web/API/Fetch_API"
      },
      {
        "text": "node-fetch",
        "href": "https://www.npmjs.com/package/node-fetch"
      },
      {
        "text": "globalThis",
        "href": "/en-US/docs/Web/JavaScript/Reference/Global_Objects/globalThis"
      },
      {
        "text": "JavaScript modules",
        "href": "https://v8.dev/features/modules"
      },
      {
        "text": "ES modules: A cartoon deep-dive",
        "href": "https://hacks.mozilla.org/2018/03/es-modules-a-cartoon-deep-dive/"
      },
      {
        "text": "ES6 in Depth: Modules",
        "href": "https://hacks.mozilla.org/2015/08/es6-in-depth-modules/"
      },
      {
        "text": "Exploring JS, Ch.16: Modules",
        "href": "https://exploringjs.com/es6/ch_modules.html"
      },
      {
        "text": "Previous",
        "href": "/en-US/docs/Web/JavaScript/Guide/Internationalization"
      },
      {
        "text": "Learn how to contribute",
        "href": "/en-US/docs/MDN/Community/Getting_started"
      },
      {
        "text": "MDN contributors",
        "href": "/en-US/docs/Web/JavaScript/Guide/Modules/contributors.txt"
      },
      {
        "text": "View this page on GitHub",
        "href": "https://github.com/mdn/content/blob/main/files/en-us/web/javascript/guide/modules/index.md?plain=1"
      },
      {
        "text": "Report a problem with this content",
        "href": "https://github.com/mdn/content/issues/new?template=page-report.yml&mdn-url=https%3A%2F%2Fdeveloper.mozilla.org%2Fen-US%2Fdocs%2FWeb%2FJavaScript%2FGuide%2FModules&metadata=%3C%21--+Do+not+make+changes+below+this+line+--%3E%0A%3Cdetails%3E%0A%3Csummary%3EPage+report+details%3C%2Fsummary%3E%0A%0A*+Folder%3A+%60en-us%2Fweb%2Fjavascript%2Fguide%2Fmodules%60%0A*+MDN+URL%3A+https%3A%2F%2Fdeveloper.mozilla.org%2Fen-US%2Fdocs%2FWeb%2FJavaScript%2FGuide%2FModules%0A*+GitHub+URL%3A+https%3A%2F%2Fgithub.com%2Fmdn%2Fcontent%2Fblob%2Fmain%2Ffiles%2Fen-us%2Fweb%2Fjavascript%2Fguide%2Fmodules%2Findex.md%0A*+Last+commit%3A+https%3A%2F%2Fgithub.com%2Fmdn%2Fcontent%2Fcommit%2Fcd22b9f18cf2450c0cc488379b8b780f0f343397%0A*+Document+last+modified%3A+2025-07-20T13%3A51%3A13.000Z%0A%0A%3C%2Fdetails%3E"
      }
    ],
    "meta": {
      "description": "This guide gives you all you need to get started with JavaScript module syntax.",
      "keywords": ""
    },
    "summary": "JavaScript modules Previous This guide gives you all you need to get started with JavaScript module syntax",
    "tags": [
      "react",
      "angular",
      "javascript",
      "typescript",
      "css",
      "html",
      "node",
      "webpack",
      "vite",
      "modules"
    ],
    "id": "javascript-modules-Modules-part-1",
    "quality": 100
  },
  {
    "title": "Closures",
    "url": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Guide/Closures",
    "category": "javascript",
    "content": "Closures A closure is the combination of a function bundled together (enclosed) with references to its surrounding state (the lexical environment). In other words, a closure gives a function access to its outer scope. In JavaScript, closures are created every time a function is created, at function creation time. Lexical scoping Consider the following example code: init() creates a local variable called name and a function called displayName(). The displayName() function is an inner function that is defined inside init() and is available only within the body of the init() function. Note that the displayName() function has no local variables of its own. However, since inner functions have access to the variables of outer scopes, displayName() can access the variable name declared in the parent function, init(). If you run this code in your console, you can see that the console.log() statement within the displayName() function successfully displays the value of the name variable, which is declared in its parent function. This is an example of lexical scoping, which describes how a parser resolves variable names when functions are nested. The word lexical refers to the fact that lexical scoping uses the location where a variable is declared within the source code to determine where that variable is available. Nested functions have access to variables declared in their outer scope. Scoping with let and const Traditionally (before ES6), JavaScript variables only had two kinds of scopes: function scope and global scope. Variables declared with var are either function-scoped or global-scoped, depending on whether they are declared within a function or outside a function. This can be tricky, because blocks with curly braces do not create scopes: For people from other languages (e.g., C, Java) where blocks create scopes, the above code should throw an error on the console.log line, because we are outside the scope of x in either block. However, because blocks don't create scopes for var, the var statements here actually create a global variable. There is also a practical example introduced below that illustrates how this can cause actual bugs when combined with closures. In ES6, JavaScript introduced the let and const declarations, which, among other things like temporal dead zones, allow you to create block-scoped variables. In essence, blocks are finally treated as scopes in ES6, but only if you declare variables with let or const. In addition, ES6 introduced modules, which introduced another kind of scope. Closures are able to capture variables in all these scopes, which we will introduce later. Closure Consider the following code example: Running this code has exactly the same effect as the previous example of the init() function above. What's different (and interesting) is that the displayName() inner function is returned from the outer function before being executed. At first glance, it might seem unintuitive that this code still works. In some programming languages, the local variables within a function exist for just the duration of that function's execution. Once makeFunc() finishes executing, you might expect that the name variable would no longer be accessible. However, because the code still works as expected, this is obviously not the case in JavaScript. The reason is that functions in JavaScript form closures. A closure is the combination of a function and the lexical environment within which that function was declared. This environment consists of any variables that were in-scope at the time the closure was created. In this case, myFunc is a reference to the instance of the function displayName that is created when makeFunc is run. The instance of displayName maintains a reference to its lexical environment, within which the variable name exists. For this reason, when myFunc is invoked, the variable name remains available for use, and \"Mozilla\" is passed to console.log. Here's a slightly more interesting examplea makeAdder function: In this example, we have defined a function makeAdder(x), that takes a single argument x, and returns a new function. The function it returns takes a single argument y, and returns the sum of x and y. In essence, makeAdder is a function factory. It creates functions that can add a specific value to their argument. In the above example, the function factory creates two new functionsone that adds five to its argument, and one that adds 10. add5 and add10 both form closures. They share the same function body definition, but store different lexical environments. In add5's lexical environment, x is 5, while in the lexical environment for add10, x is 10. Practical closures Closures are useful because they let you associate data (the lexical environment) with a function that operates on that data. This has obvious parallels to object-oriented programming, where objects allow you to associate data (the object's properties) with one or more methods. Consequently, you can use a closure anywhere that you might normally use an object with only a single method. Situations where you might want to do this are particularly common on the web. Much of the code written in front-end JavaScript is event-based. You define some behavior, and then attach it to an event that is triggered by the user (such as a click or a keypress). The code is attached as a callback (a single function that is executed in response to the event). For instance, suppose we want to add buttons to a page to adjust the text size. One way of doing this is to specify the font-size of the body element (in pixels), and then set the size of the other elements on the page (such as headers) using the relative em unit: Such interactive text size buttons can change the font-size property of the body element, and the adjustments are picked up by other elements on the page thanks to the relative units. Here's the JavaScript: size12, size14, and size16 are now functions that resize the body text to 12, 14, and 16 pixels, respectively. You can attach them to buttons as demonstrated in the following code example. Emulating private methods with closures Languages such as Java allow you to declare methods as private, meaning that they can be called only by other methods in the same class. JavaScript, prior to classes, didn't have a native way of declaring private methods, but it was possible to emulate private methods using closures. Private methods aren't just useful for restricting access to code. They also provide a powerful way of managing your global namespace. The following code illustrates how to use closures to define public functions that can access private functions and variables. Note that these closures follow the Module Design Pattern. In previous examples, each closure had its own lexical environment. Here though, there is a single lexical environment that is shared by the three functions: counter.increment, counter.decrement, and counter.value. The shared lexical environment is created in the body of an anonymous function, which is executed as soon as it has been defined (also known as an IIFE). The lexical environment contains two private items: a variable called privateCounter, and a function called changeBy. You can't access either of these private members from outside the anonymous function. Instead, you indirectly access them using the three public functions that are returned from the anonymous wrapper. Those three public functions form closures that share the same lexical environment. Thanks to JavaScript's lexical scoping, they each have access to the privateCounter variable and the changeBy function. Notice how the two counters maintain their independence from one another. Each closure references a different version of the privateCounter variable through its own closure. Each time one of the counters is called, its lexical environment changes by changing the value of this variable. Changes to the variable value in one closure don't affect the value in the other closure. Note: Using closures in this way provides benefits that are normally associated with object-oriented programming. In particular, data hiding and encapsulation. Closure scope chain A nested function's access to the outer function's scope includes the enclosing scope of the outer functioneffectively creating a chain of function scopes. To demonstrate, consider the following example code. You can also write without anonymous functions: In the example above, there's a series of nested functions, all of which have access to the outer functions' scope. In this context, we can say that closures have access to all outer scopes. Closures can capture variables in block scopes and module scopes as well. For example, the following creates a closure over the block-scoped variable y: Closures over modules can be more interesting. Here, the module exports a pair of getter-setter functions, which close over the module-scoped variable x. Even when x is not directly accessible from other modules, it can be read and written with the functions. Closures can close over imported values as well, which are regarded as live bindings, because when the original value changes, the imported one changes accordingly. Creating closures in loops: A common mistake Prior to the introduction of the let keyword, a common problem with closures occurred when you created them inside a loop. To demonstrate, consider the following example code. The helpText array defines three helpful hints, each associated with the ID of an input field in the document. The loop cycles through these definitions, hooking up an onfocus event to each one that shows the associated help method. If you try this code out, you'll see that it doesn't work as expected. No matter what field you focus on, the message about your age will be displayed. The reason for this is that the functions assigned to onfocus form closures; they consist of the function definition and the captured environment from the setupHelp function's scope. Three closures have been created by the loop, but each one shares the same single lexical environment, which has a variable with changing values (item). This is because the variable item is declared with var and thus has function scope due to hoisting. The value of item.help is determined when the onfocus callbacks are executed. Because the loop has already run its course by that time, the item variable object (shared by all three closures) has been left pointing to the last entry in the helpText list. One solution in this case is to use more closures: in particular, to use a function factory as described earlier: This works as expected. Rather than the callbacks all sharing a single lexical environment, the makeHelpCallback function creates a new lexical environment for each callback, in which help refers to the corresponding string from the helpText array. One other way to write the above using anonymous closures is: If you don't want to use more closures, you can use the let or const keyword: This example uses const instead of var, so every closure binds the block-scoped variable, meaning that no additional closures are required. If you are writing modern JavaScript anyway, you can consider more alternatives to the plain for loop, such as using for...of loop and declaring item as let or const, or using the forEach() method, which both avoid the closure problem. Performance considerations As mentioned previously, each function instance manages its own scope and closure. Therefore, it is unwise to unnecessarily create functions within other functions if closures are not needed for a particular task, as it will negatively affect script performance both in terms of processing speed and memory consumption. For instance, when creating a new object/class, methods should normally be associated to the object's prototype rather than defined into the object constructor. The reason is that whenever the constructor is called, the methods would get reassigned (that is, for every object creation). Consider the following case: Because the previous code does not take advantage of the benefits of using closures in this particular instance, we could instead rewrite it to avoid using closures as follows: However, redefining the prototype is not recommended. The following example instead appends to the existing prototype: In the two previous examples, the inherited prototype can be shared by all objects and the method definitions need not occur at every object creation. See Inheritance and the prototype chain for more. Help improve MDN Learn how to contribute This page was last modified on Aug 6, 2025 by MDN contributors. View this page on GitHub  Report a problem with this content",
    "headings": [
      {
        "level": 1,
        "text": "Closures",
        "id": ""
      },
      {
        "level": 2,
        "text": "Lexical scoping",
        "id": "lexical_scoping"
      },
      {
        "level": 2,
        "text": "Closure",
        "id": "closure"
      },
      {
        "level": 2,
        "text": "Practical closures",
        "id": "practical_closures"
      },
      {
        "level": 2,
        "text": "Emulating private methods with closures",
        "id": "emulating_private_methods_with_closures"
      },
      {
        "level": 2,
        "text": "Closure scope chain",
        "id": "closure_scope_chain"
      },
      {
        "level": 2,
        "text": "Creating closures in loops: A common mistake",
        "id": "creating_closures_in_loops_a_common_mistake"
      },
      {
        "level": 2,
        "text": "Performance considerations",
        "id": "performance_considerations"
      },
      {
        "level": 2,
        "text": "Help improve MDN",
        "id": "feedback"
      },
      {
        "level": 3,
        "text": "Scoping with let and const",
        "id": "scoping_with_let_and_const"
      }
    ],
    "codeBlocks": [
      {
        "language": "text",
        "code": "displayName()"
      },
      {
        "language": "text",
        "code": "displayName()"
      },
      {
        "language": "text",
        "code": "displayName()"
      },
      {
        "language": "text",
        "code": "displayName()"
      },
      {
        "language": "text",
        "code": "console.log()"
      },
      {
        "language": "text",
        "code": "displayName()"
      },
      {
        "language": "text",
        "code": "console.log"
      },
      {
        "language": "text",
        "code": "displayName()"
      },
      {
        "language": "text",
        "code": "displayName"
      },
      {
        "language": "text",
        "code": "displayName"
      },
      {
        "language": "text",
        "code": "console.log"
      },
      {
        "language": "text",
        "code": "makeAdder(x)"
      },
      {
        "language": "text",
        "code": "counter.increment"
      },
      {
        "language": "text",
        "code": "counter.decrement"
      },
      {
        "language": "text",
        "code": "counter.value"
      },
      {
        "language": "text",
        "code": "privateCounter"
      },
      {
        "language": "text",
        "code": "privateCounter"
      },
      {
        "language": "text",
        "code": "privateCounter"
      },
      {
        "language": "text",
        "code": "makeHelpCallback"
      }
    ],
    "links": [
      {
        "text": "temporal dead zones",
        "href": "/en-US/docs/Web/JavaScript/Reference/Statements/let#temporal_dead_zone_tdz"
      },
      {
        "text": "modules",
        "href": "/en-US/docs/Web/JavaScript/Guide/Modules"
      },
      {
        "text": "classes",
        "href": "/en-US/docs/Web/JavaScript/Reference/Classes"
      },
      {
        "text": "private methods",
        "href": "/en-US/docs/Web/JavaScript/Reference/Classes/Private_elements#private_methods"
      },
      {
        "text": "Module Design Pattern",
        "href": "https://www.google.com/search?q=javascript+module+pattern"
      },
      {
        "text": "IIFE",
        "href": "/en-US/docs/Glossary/IIFE"
      },
      {
        "text": "bindings",
        "href": "/en-US/docs/Glossary/Binding"
      },
      {
        "text": "let",
        "href": "/en-US/docs/Web/JavaScript/Reference/Statements/let"
      },
      {
        "text": "let",
        "href": "/en-US/docs/Web/JavaScript/Reference/Statements/let"
      },
      {
        "text": "const",
        "href": "/en-US/docs/Web/JavaScript/Reference/Statements/const"
      },
      {
        "text": "for...of",
        "href": "/en-US/docs/Web/JavaScript/Reference/Statements/for...of"
      },
      {
        "text": "forEach()",
        "href": "/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/forEach"
      },
      {
        "text": "Inheritance and the prototype chain",
        "href": "/en-US/docs/Web/JavaScript/Guide/Inheritance_and_the_prototype_chain"
      },
      {
        "text": "Learn how to contribute",
        "href": "/en-US/docs/MDN/Community/Getting_started"
      },
      {
        "text": "MDN contributors",
        "href": "/en-US/docs/Web/JavaScript/Guide/Closures/contributors.txt"
      },
      {
        "text": "View this page on GitHub",
        "href": "https://github.com/mdn/content/blob/main/files/en-us/web/javascript/guide/closures/index.md?plain=1"
      },
      {
        "text": "Report a problem with this content",
        "href": "https://github.com/mdn/content/issues/new?template=page-report.yml&mdn-url=https%3A%2F%2Fdeveloper.mozilla.org%2Fen-US%2Fdocs%2FWeb%2FJavaScript%2FGuide%2FClosures&metadata=%3C%21--+Do+not+make+changes+below+this+line+--%3E%0A%3Cdetails%3E%0A%3Csummary%3EPage+report+details%3C%2Fsummary%3E%0A%0A*+Folder%3A+%60en-us%2Fweb%2Fjavascript%2Fguide%2Fclosures%60%0A*+MDN+URL%3A+https%3A%2F%2Fdeveloper.mozilla.org%2Fen-US%2Fdocs%2FWeb%2FJavaScript%2FGuide%2FClosures%0A*+GitHub+URL%3A+https%3A%2F%2Fgithub.com%2Fmdn%2Fcontent%2Fblob%2Fmain%2Ffiles%2Fen-us%2Fweb%2Fjavascript%2Fguide%2Fclosures%2Findex.md%0A*+Last+commit%3A+https%3A%2F%2Fgithub.com%2Fmdn%2Fcontent%2Fcommit%2Ff97e095b8c0b44bbc6fdd04d380345d4b1743410%0A*+Document+last+modified%3A+2025-08-06T16%3A34%3A28.000Z%0A%0A%3C%2Fdetails%3E"
      }
    ],
    "meta": {
      "description": "A closure is the combination of a function bundled together (enclosed) with references to its surrounding state (the lexical environment). In other words, a closure gives a function access to its outer scope. In JavaScript, closures are created every time a function is created, at function creation time.",
      "keywords": ""
    },
    "summary": "Closures A closure is the combination of a function bundled together (enclosed) with references to its surrounding state (the lexical environment)",
    "tags": [
      "react",
      "angular",
      "javascript",
      "typescript",
      "html",
      "node",
      "webpack",
      "closures",
      "scoping",
      "closure"
    ],
    "id": "closures-Closures-part-1",
    "quality": 90
  },
  {
    "title": "Inheritance and the prototype chain",
    "url": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Guide/Inheritance_and_the_prototype_chain",
    "category": "javascript",
    "content": "Inheritance and the prototype chain In programming, inheritance refers to passing down characteristics from a parent to a child so that a new piece of code can reuse and build upon the features of an existing one. JavaScript implements inheritance by using objects. Each object has an internal link to another object called its prototype. That prototype object has a prototype of its own, and so on until an object is reached with null as its prototype. By definition, null has no prototype and acts as the final link in this prototype chain. It is possible to mutate any member of the prototype chain or even swap out the prototype at runtime, so concepts like static dispatching do not exist in JavaScript. JavaScript is a bit confusing for developers experienced in class-based languages (like Java or C++), as it is dynamic and does not have static types. While this confusion is often considered to be one of JavaScript's weaknesses, the prototypal inheritance model itself is, in fact, more powerful than the classic model. It is, for example, fairly trivial to build a classic model on top of a prototypal model  which is how classes are implemented. Although classes are now widely adopted and have become a new paradigm in JavaScript, classes do not bring a new inheritance pattern. While classes abstract most of the prototypal mechanism away, understanding how prototypes work under the hood is still useful. Inheritance with the prototype chain Inheriting properties JavaScript objects are dynamic \"bags\" of properties (referred to as own properties). JavaScript objects have a link to a prototype object. When trying to access a property of an object, the property will not only be sought on the object but on the prototype of the object, the prototype of the prototype, and so on until either a property with a matching name is found or the end of the prototype chain is reached. Note: Following the ECMAScript standard, the notation someObject.[[Prototype]] is used to designate the prototype of someObject. The [[Prototype]] internal slot can be accessed and modified with the Object.getPrototypeOf() and Object.setPrototypeOf() functions respectively. This is equivalent to the JavaScript accessor __proto__ which is non-standard but de-facto implemented by many JavaScript engines. To prevent confusion while keeping it succinct, in our notation we will avoid using obj.__proto__ but use obj.[[Prototype]] instead. This corresponds to Object.getPrototypeOf(obj). It should not be confused with the func.prototype property of functions, which instead specifies the [[Prototype]] to be assigned to all instances of objects created by the given function when used as a constructor. We will discuss the prototype property of constructor functions in a later section. There are several ways to specify the [[Prototype]] of an object, which are listed in a later section. For now, we will use the __proto__ syntax for illustration. It's worth noting that the { __proto__: ... } syntax is different from the obj.__proto__ accessor: the former is standard and not deprecated. In an object literal like { a: 1, b: 2, __proto__: c }, the value c (which has to be either null or another object) will become the [[Prototype]] of the object represented by the literal, while the other keys like a and b will become the own properties of the object. This syntax reads very naturally, since [[Prototype]] is just an \"internal property\" of the object. Here is what happens when trying to access a property: Setting a property to an object creates an own property. The only exception to the getting and setting behavior rules is when it's intercepted by a getter or setter. Similarly, you can create longer prototype chains, and a property will be sought on all of them. Inheriting \"methods\" JavaScript does not have \"methods\" in the form that class-based languages define them. In JavaScript, any function can be added to an object in the form of a property. An inherited function acts just as any other property, including property shadowing as shown above (in this case, a form of method overriding). When an inherited function is executed, the value of this points to the inheriting object, not to the prototype object where the function is an own property. Constructors The power of prototypes is that we can reuse a set of properties if they should be present on every instance  especially for methods. Suppose we are to create a series of boxes, where each box is an object that contains a value which can be accessed through a getValue function. A naive implementation would be: This is subpar, because each instance has its own function property that does the same thing, which is redundant and unnecessary. Instead, we can move getValue to the [[Prototype]] of all boxes: This way, all boxes' getValue method will refer to the same function, lowering memory usage. However, manually binding the __proto__ for every object creation is still very inconvenient. This is when we would use a constructor function, which automatically sets the [[Prototype]] for every object manufactured. Constructors are functions called with new. We say that new Box(1) is an instance created from the Box constructor function. Box.prototype is not much different from the boxPrototype object we created previously  it's just a plain object. Every instance created from a constructor function will automatically have the constructor's prototype property as its [[Prototype]]  that is, Object.getPrototypeOf(new Box()) === Box.prototype. Constructor.prototype by default has one own property: constructor, which references the constructor function itself  that is, Box.prototype.constructor === Box. This allows one to access the original constructor from any instance. Note: If a non-primitive is returned from the constructor function, that value will become the result of the new expression. In this case the [[Prototype]] may not be correctly bound  but this should not happen much in practice. The above constructor function can be rewritten in classes as: Classes are syntax sugar over constructor functions, which means you can still manipulate Box.prototype to change the behavior of all instances. However, because classes are designed to be an abstraction over the underlying prototype mechanism, we will use the more-lightweight constructor function syntax for this tutorial to fully demonstrate how prototypes work. Because Box.prototype references the same object as the [[Prototype]] of all instances, we can change the behavior of all instances by mutating Box.prototype. A corollary is, re-assigning Constructor.prototype (Constructor.prototype = ...) is a bad idea for two reasons: The [[Prototype]] of instances created before the reassignment is now referencing a different object from the [[Prototype]] of instances created after the reassignment  mutating one's [[Prototype]] no longer mutates the other. Unless you manually re-set the constructor property, the constructor function can no longer be traced from instance.constructor, which may break user expectation. Some built-in operations will read the constructor property as well, and if it is not set, they may not work as expected. Constructor.prototype is only useful when constructing instances. It has nothing to do with Constructor.[[Prototype]], which is the constructor function's own prototype, which is Function.prototype  that is, Object.getPrototypeOf(Constructor) === Function.prototype. Implicit constructors of literals Some literal syntaxes in JavaScript create instances that implicitly set the [[Prototype]]. For example: We can \"de-sugar\" them into their constructor form. For example, \"array methods\" like map() are simply methods defined on Array.prototype, which is why they are automatically available on all array instances. Warning: There is one misfeature that used to be prevalent  extending Object.prototype or one of the other built-in prototypes. An example of this misfeature is, defining Array.prototype.myMethod = function () {...} and then using myMethod on all array instances. This misfeature is called monkey patching. Doing monkey patching risks forward compatibility, because if the language adds this method in the future but with a different signature, your code will break. It has led to incidents like the SmooshGate, and can be a great nuisance for the language to advance since JavaScript tries to \"not break the web\". The only good reason for extending a built-in prototype is to backport the features of newer JavaScript engines, like Array.prototype.forEach. It may be interesting to note that due to historical reasons, some built-in constructors' prototype property are instances themselves. For example, Number.prototype is a number 0, Array.prototype is an empty array, and RegExp.prototype is /(?:)/. However, this is not the case for user-defined constructors, nor for modern constructors like Map. Building longer inheritance chains The Constructor.prototype property will become the [[Prototype]] of the constructor's instances, as-is  including Constructor.prototype's own [[Prototype]]. By default, Constructor.prototype is a plain object  that is, Object.getPrototypeOf(Constructor.prototype) === Object.prototype. The only exception is Object.prototype itself, whose [[Prototype]] is null  that is, Object.getPrototypeOf(Object.prototype) === null. Therefore, a typical constructor will build the following prototype chain: To build longer prototype chains, we can set the [[Prototype]] of Constructor.prototype via the Object.setPrototypeOf() function. In class terms, this is equivalent to using the extends syntax. You may also see some legacy code using Object.create() to build the inheritance chain. However, because this reassigns the prototype property and removes the constructor property, it can be more error-prone, while performance gains may not be apparent if the constructors haven't created any instances yet. Inspecting prototypes: a deeper dive Let's look at what happens behind the scenes in a bit more detail. In JavaScript, as mentioned above, functions are able to have properties. All functions have a special property named prototype. Please note that the code below is free-standing (it is safe to assume there is no other JavaScript on the webpage other than the below code). For the best learning experience, it is highly recommended that you open a console, navigate to the \"console\" tab, copy-and-paste in the below JavaScript code, and run it by pressing the Enter/Return key. (The console is included in most web browser's Developer Tools. More information is available for Firefox Developer Tools, Chrome DevTools, and Edge DevTools.) As seen above, doSomething() has a default prototype property, as demonstrated by the console. After running this code, the console should have displayed an object that looks similar to this. { constructor:  doSomething(), [[Prototype]]: { constructor:  Object(), hasOwnProperty:  hasOwnProperty(), isPrototypeOf:  isPrototypeOf(), propertyIsEnumerable:  propertyIsEnumerable(), toLocaleString:  toLocaleString(), toString:  toString(), valueOf:  valueOf() } } Note: The Chrome console uses [[Prototype]] to denote the object's prototype, following the spec's terms; Firefox uses prototype. For consistency we will use [[Prototype]]. We can add properties to the prototype of doSomething(), as shown below. This results in: { foo: \"bar\", constructor:  doSomething(), [[Prototype]]: { constructor:  Object(), hasOwnProperty:  hasOwnProperty(), isPrototypeOf:  isPrototypeOf(), propertyIsEnumerable:  propertyIsEnumerable(), toLocaleString:  toLocaleString(), toString:  toString(), valueOf:  valueOf() } } We can now use the new operator to create an instance of doSomething() based on this prototype. To use the new operator, call the function normally except prefix it with new. Calling a function with the new operator returns an object that is an instance of the function. Properties can then be added onto this object. Try the following code: This results in an output similar to the following: { prop: \"some value\", [[Prototype]]: { foo: \"bar\", constructor:  doSomething(), [[Prototype]]: { constructor:  Object(), hasOwnProperty:  hasOwnProperty(), isPrototypeOf:  isPrototypeOf(), propertyIsEnumerable:  propertyIsEnumerable(), toLocaleString:  toLocaleString(), toString:  toString(), valueOf:  valueOf() } } } As seen above, the [[Prototype]] of doSomeInstancing is doSomething.prototype. But, what does this do? When you access a property of doSomeInstancing, the runtime first looks to see if doSomeInstancing has that property. If doSomeInstancing does not have the property, then the runtime looks for the property in doSomeInstancing.[[Prototype]] (a.k.a. doSomething.prototype). If doSomeInstancing.[[Prototype]] has the property being looked for, then that property on doSomeInstancing.[[Prototype]] is used. Otherwise, if doSomeInstancing.[[Prototype]] does not have the property, then doSomeInstancing.[[Prototype]].[[Prototype]] is checked for the property. By default, the [[Prototype]] of any function's prototype property is Object.prototype. So, doSomeInstancing.[[Prototype]].[[Prototype]] (a.k.a. doSomething.prototype.[[Prototype]] (a.k.a. Object.prototype)) is then looked through for the property being searched for. If the property is not found in doSomeInstancing.[[Prototype]].[[Prototype]], then doSomeInstancing.[[Prototype]].[[Prototype]].[[Prototype]] is looked through. However, there is a problem: doSomeInstancing.[[Prototype]].[[Prototype]].[[Prototype]] does not exist, because Object.prototype.[[Prototype]] is null. Then, and only then, after the entire prototype chain of [[Prototype]]'s is looked through, the runtime asserts that the property does not exist and conclude that the value at the property is undefined. Let's try entering some more code into the console: This results in the following: doSomeInstancing.prop: some value doSomeInstancing.foo: bar doSomething.prop: undefined doSomething.foo: undefined doSomething.prototype.prop: undefined doSomething.prototype.foo: bar Different ways of creating and mutating prototype chains We have encountered many ways to create objects and change their prototype chains. We will systematically summarize the different ways, comparing each approach's pros and cons. Objects created with syntax constructs When using the __proto__ key in object initializers, pointing the __proto__ key to something that is not an object only fails silently without throwing an exception. Contrary to the Object.prototype.__proto__ setter, __proto__ in object literal initializers is standardized and optimized, and can even be more performant than Object.create. Declaring extra own properties on the object at creation is more ergonomic than Object.create. With constructor functions Constructor functions have been available since very early JavaScript. Therefore, it is very fast, very standard, and very JIT-optimizable. However, it's also hard to \"do properly\" because methods added this way are enumerable by default, which is inconsistent with the class syntax or how built-in methods behave. Doing longer inheritance chains is also error-prone, as previously demonstrated. With Object.create() Calling Object.create() creates a new object. The [[Prototype]] of this object is the first argument of the function: Similar to the __proto__ key in object initializers, Object.create() allows directly setting the prototype of an object at creation time, which permits the runtime to further optimize the object. It also allows the creation of objects with null prototype, using Object.create(null). The second parameter of Object.create() allows you to precisely specify the attributes of each property in the new object, which can be a double-edged sword: It allows you to create non-enumerable properties, etc., during object creation, which is not possible with object literals. It is much more verbose and error-prone than object literals. It may be slower than object literals, especially when creating many properties. With classes Classes offer the highest readability and maintainability when defining complex inheritance structures. Private elements are a feature with no trivial replacement in prototypal inheritance. However, classes are less optimized than traditional constructor functions and are not supported in older environments. With Object.setPrototypeOf() While all methods above will set the prototype chain at object creation time, Object.setPrototypeOf() allows mutating the [[Prototype]] internal property of an existing object. It can even force a prototype on a prototype-less object created with Object.create(null) or remove the prototype of an object by setting it to null. However, you should set the prototype during creation if possible, because setting the prototype dynamically disrupts all optimizations that engines have made to the prototype chain. It might cause some engines to recompile your code for de-optimization, to make it work according to the specs. With the __proto__ accessor All objects inherit the Object.prototype.__proto__ setter, which can be used to set the [[Prototype]] of an existing object (if the __proto__ key is not overridden on the object). Warning: Object.prototype.__proto__ accessors are non-standard and deprecated. You should almost always use Object.setPrototypeOf instead. Compared to Object.setPrototypeOf, setting __proto__ to something that is not an object fails silently without throwing an exception. It also has slightly better browser support. However, it is non-standard and deprecated. You should almost always use Object.setPrototypeOf instead. Performance The lookup time for properties that are high up on the prototype chain can have a negative impact on the performance, and this may be significant in the code where performance is critical. Additionally, trying to access nonexistent properties will always traverse the full prototype chain. Also, when iterating over the properties of an object, every enumerable property that is on the prototype chain will be enumerated. To check whether an object has a property defined on itself and not somewhere on its prototype chain, it is necessary to use the hasOwnProperty or Object.hasOwn methods. All objects, except those with null as [[Prototype]], inherit hasOwnProperty from Object.prototype  unless it has been overridden further down the prototype chain. To give you a concrete example, let's take the above graph example code to illustrate it: Note: It is not enough to check whether a property is undefined. The property might very well exist, but its value just happens to be set to undefined. Conclusion JavaScript may be a bit confusing for developers coming from Java or C++, as it's all dynamic, all runtime, and it has no static types at all. Everything is either an object (instance) or a function (constructor), and even functions themselves are instances of the Function constructor. Even the \"classes\" as syntax constructs are just constructor functions at runtime. All constructor functions in JavaScript have a special property called prototype, which works with the new operator. The reference to the prototype object is copied to the internal [[Prototype]] property of the new instance. For example, when you do const a1 = new A(), JavaScript (after creating the object in memory and before running function A() with this defined to it) sets a1.[[Prototype]] = A.prototype. When you then access properties of the instance, JavaScript first checks whether they exist on that object directly, and if not, it looks in [[Prototype]]. [[Prototype]] is looked at recursively, i.e., a1.doSomething, Object.getPrototypeOf(a1).doSomething, Object.getPrototypeOf(Object.getPrototypeOf(a1)).doSomething etc., until it's found or Object.getPrototypeOf returns null. This means that all properties defined on prototype are effectively shared by all instances, and you can even later change parts of prototype and have the changes appear in all existing instances. If, in the example above, you do const a1 = new A(); const a2 = new A();, then a1.doSomething would actually refer to Object.getPrototypeOf(a1).doSomething  which is the same as the A.prototype.doSomething you defined, i.e., Object.getPrototypeOf(a1).doSomething === Object.getPrototypeOf(a2).doSomething === A.prototype.doSomething. It is essential to understand the prototypal inheritance model before writing complex code that makes use of it. Also, be aware of the length of the prototype chains in your code and break them up if necessary to avoid possible performance problems. Further, the native prototypes should never be extended unless it is for the sake of compatibility with newer JavaScript features. Help improve MDN Learn how to contribute This page was last modified on Jul 8, 2025 by MDN contributors. View this page on GitHub  Report a problem with this content",
    "headings": [
      {
        "level": 1,
        "text": "Inheritance and the prototype chain",
        "id": ""
      },
      {
        "level": 2,
        "text": "Inheritance with the prototype chain",
        "id": "inheritance_with_the_prototype_chain"
      },
      {
        "level": 2,
        "text": "Constructors",
        "id": "constructors"
      },
      {
        "level": 2,
        "text": "Inspecting prototypes: a deeper dive",
        "id": "inspecting_prototypes_a_deeper_dive"
      },
      {
        "level": 2,
        "text": "Different ways of creating and mutating prototype chains",
        "id": "different_ways_of_creating_and_mutating_prototype_chains"
      },
      {
        "level": 2,
        "text": "Performance",
        "id": "performance"
      },
      {
        "level": 2,
        "text": "Conclusion",
        "id": "conclusion"
      },
      {
        "level": 2,
        "text": "Help improve MDN",
        "id": "feedback"
      },
      {
        "level": 3,
        "text": "Inheriting properties",
        "id": "inheriting_properties"
      },
      {
        "level": 3,
        "text": "Inheriting \"methods\"",
        "id": "inheriting_methods"
      },
      {
        "level": 3,
        "text": "Implicit constructors of literals",
        "id": "implicit_constructors_of_literals"
      },
      {
        "level": 3,
        "text": "Building longer inheritance chains",
        "id": "building_longer_inheritance_chains"
      },
      {
        "level": 3,
        "text": "Objects created with syntax constructs",
        "id": "objects_created_with_syntax_constructs"
      },
      {
        "level": 3,
        "text": "With constructor functions",
        "id": "with_constructor_functions"
      },
      {
        "level": 3,
        "text": "With Object.create()",
        "id": "with_object.create"
      },
      {
        "level": 3,
        "text": "With classes",
        "id": "with_classes"
      },
      {
        "level": 3,
        "text": "With Object.setPrototypeOf()",
        "id": "with_object.setprototypeof"
      },
      {
        "level": 3,
        "text": "With the __proto__ accessor",
        "id": "with_the___proto___accessor"
      }
    ],
    "codeBlocks": [
      {
        "language": "text",
        "code": "someObject.[[Prototype]]"
      },
      {
        "language": "text",
        "code": "[[Prototype]]"
      },
      {
        "language": "text",
        "code": "Object.getPrototypeOf()"
      },
      {
        "language": "text",
        "code": "Object.setPrototypeOf()"
      },
      {
        "language": "text",
        "code": "obj.__proto__"
      },
      {
        "language": "text",
        "code": "obj.[[Prototype]]"
      },
      {
        "language": "text",
        "code": "Object.getPrototypeOf(obj)"
      },
      {
        "language": "text",
        "code": "func.prototype"
      },
      {
        "language": "text",
        "code": "[[Prototype]]"
      },
      {
        "language": "text",
        "code": "[[Prototype]]"
      },
      {
        "language": "text",
        "code": "{ __proto__: ... }"
      },
      {
        "language": "text",
        "code": "obj.__proto__"
      },
      {
        "language": "text",
        "code": "{ a: 1, b: 2, __proto__: c }"
      },
      {
        "language": "text",
        "code": "[[Prototype]]"
      },
      {
        "language": "text",
        "code": "[[Prototype]]"
      },
      {
        "language": "text",
        "code": "[[Prototype]]"
      },
      {
        "language": "text",
        "code": "[[Prototype]]"
      },
      {
        "language": "text",
        "code": "Box.prototype"
      },
      {
        "language": "text",
        "code": "boxPrototype"
      },
      {
        "language": "text",
        "code": "[[Prototype]]"
      },
      {
        "language": "text",
        "code": "Object.getPrototypeOf(new Box()) === Box.prototype"
      },
      {
        "language": "text",
        "code": "Constructor.prototype"
      },
      {
        "language": "text",
        "code": "constructor"
      },
      {
        "language": "text",
        "code": "Box.prototype.constructor === Box"
      },
      {
        "language": "text",
        "code": "[[Prototype]]"
      },
      {
        "language": "text",
        "code": "Box.prototype"
      },
      {
        "language": "text",
        "code": "Box.prototype"
      },
      {
        "language": "text",
        "code": "[[Prototype]]"
      },
      {
        "language": "text",
        "code": "Box.prototype"
      },
      {
        "language": "text",
        "code": "Constructor.prototype"
      },
      {
        "language": "text",
        "code": "Constructor.prototype = ..."
      },
      {
        "language": "text",
        "code": "[[Prototype]]"
      },
      {
        "language": "text",
        "code": "[[Prototype]]"
      },
      {
        "language": "text",
        "code": "[[Prototype]]"
      },
      {
        "language": "text",
        "code": "constructor"
      },
      {
        "language": "text",
        "code": "instance.constructor"
      },
      {
        "language": "text",
        "code": "constructor"
      },
      {
        "language": "text",
        "code": "Constructor.prototype"
      },
      {
        "language": "text",
        "code": "Constructor.[[Prototype]]"
      },
      {
        "language": "text",
        "code": "Function.prototype"
      },
      {
        "language": "text",
        "code": "Object.getPrototypeOf(Constructor) === Function.prototype"
      },
      {
        "language": "text",
        "code": "[[Prototype]]"
      },
      {
        "language": "text",
        "code": "Array.prototype"
      },
      {
        "language": "text",
        "code": "Object.prototype"
      },
      {
        "language": "text",
        "code": "Array.prototype.myMethod = function () {...}"
      },
      {
        "language": "text",
        "code": "Array.prototype.forEach"
      },
      {
        "language": "text",
        "code": "Number.prototype"
      },
      {
        "language": "text",
        "code": "Array.prototype"
      },
      {
        "language": "text",
        "code": "RegExp.prototype"
      },
      {
        "language": "text",
        "code": "Constructor.prototype"
      },
      {
        "language": "text",
        "code": "[[Prototype]]"
      },
      {
        "language": "text",
        "code": "Constructor.prototype"
      },
      {
        "language": "text",
        "code": "[[Prototype]]"
      },
      {
        "language": "text",
        "code": "Constructor.prototype"
      },
      {
        "language": "text",
        "code": "Object.getPrototypeOf(Constructor.prototype) === Object.prototype"
      },
      {
        "language": "text",
        "code": "Object.prototype"
      },
      {
        "language": "text",
        "code": "[[Prototype]]"
      },
      {
        "language": "text",
        "code": "Object.getPrototypeOf(Object.prototype) === null"
      },
      {
        "language": "text",
        "code": "[[Prototype]]"
      },
      {
        "language": "text",
        "code": "Constructor.prototype"
      },
      {
        "language": "text",
        "code": "Object.setPrototypeOf()"
      },
      {
        "language": "text",
        "code": "Object.create()"
      },
      {
        "language": "text",
        "code": "constructor"
      },
      {
        "language": "text",
        "code": "doSomething()"
      },
      {
        "language": "text",
        "code": "{\n  constructor: ƒ doSomething(),\n  [[Prototype]]: {\n    constructor: ƒ Object(),\n    hasOwnProperty: ƒ hasOwnProperty(),\n    isPrototypeOf: ƒ isPrototypeOf(),\n    propertyIsEnumerable: ƒ propertyIsEnumerable(),\n    toLocaleString: ƒ toLocaleString(),\n    toString: ƒ toString(),\n    valueOf: ƒ valueOf()\n  }\n}"
      },
      {
        "language": "text",
        "code": "[[Prototype]]"
      },
      {
        "language": "text",
        "code": "<prototype>"
      },
      {
        "language": "text",
        "code": "[[Prototype]]"
      },
      {
        "language": "text",
        "code": "doSomething()"
      },
      {
        "language": "text",
        "code": "{\n  foo: \"bar\",\n  constructor: ƒ doSomething(),\n  [[Prototype]]: {\n    constructor: ƒ Object(),\n    hasOwnProperty: ƒ hasOwnProperty(),\n    isPrototypeOf: ƒ isPrototypeOf(),\n    propertyIsEnumerable: ƒ propertyIsEnumerable(),\n    toLocaleString: ƒ toLocaleString(),\n    toString: ƒ toString(),\n    valueOf: ƒ valueOf()\n  }\n}"
      },
      {
        "language": "text",
        "code": "doSomething()"
      },
      {
        "language": "text",
        "code": "{\n  prop: \"some value\",\n  [[Prototype]]: {\n    foo: \"bar\",\n    constructor: ƒ doSomething(),\n    [[Prototype]]: {\n      constructor: ƒ Object(),\n      hasOwnProperty: ƒ hasOwnProperty(),\n      isPrototypeOf: ƒ isPrototypeOf(),\n      propertyIsEnumerable: ƒ propertyIsEnumerable(),\n      toLocaleString: ƒ toLocaleString(),\n      toString: ƒ toString(),\n      valueOf: ƒ valueOf()\n    }\n  }\n}"
      },
      {
        "language": "text",
        "code": "[[Prototype]]"
      },
      {
        "language": "text",
        "code": "doSomeInstancing"
      },
      {
        "language": "text",
        "code": "doSomething.prototype"
      },
      {
        "language": "text",
        "code": "doSomeInstancing"
      },
      {
        "language": "text",
        "code": "doSomeInstancing"
      },
      {
        "language": "text",
        "code": "doSomeInstancing"
      },
      {
        "language": "text",
        "code": "doSomeInstancing.[[Prototype]]"
      },
      {
        "language": "text",
        "code": "doSomething.prototype"
      },
      {
        "language": "text",
        "code": "doSomeInstancing.[[Prototype]]"
      },
      {
        "language": "text",
        "code": "doSomeInstancing.[[Prototype]]"
      },
      {
        "language": "text",
        "code": "doSomeInstancing.[[Prototype]]"
      },
      {
        "language": "text",
        "code": "doSomeInstancing.[[Prototype]].[[Prototype]]"
      },
      {
        "language": "text",
        "code": "[[Prototype]]"
      },
      {
        "language": "text",
        "code": "Object.prototype"
      },
      {
        "language": "text",
        "code": "doSomeInstancing.[[Prototype]].[[Prototype]]"
      },
      {
        "language": "text",
        "code": "doSomething.prototype.[[Prototype]]"
      },
      {
        "language": "text",
        "code": "Object.prototype"
      },
      {
        "language": "text",
        "code": "doSomeInstancing.[[Prototype]].[[Prototype]]"
      },
      {
        "language": "text",
        "code": "doSomeInstancing.[[Prototype]].[[Prototype]].[[Prototype]]"
      },
      {
        "language": "text",
        "code": "doSomeInstancing.[[Prototype]].[[Prototype]].[[Prototype]]"
      },
      {
        "language": "text",
        "code": "Object.prototype.[[Prototype]]"
      },
      {
        "language": "text",
        "code": "[[Prototype]]"
      },
      {
        "language": "text",
        "code": "doSomeInstancing.prop:      some value\ndoSomeInstancing.foo:       bar\ndoSomething.prop:           undefined\ndoSomething.foo:            undefined\ndoSomething.prototype.prop: undefined\ndoSomething.prototype.foo:  bar"
      },
      {
        "language": "text",
        "code": "Object.prototype.__proto__"
      },
      {
        "language": "text",
        "code": "Object.create"
      },
      {
        "language": "text",
        "code": "Object.create"
      },
      {
        "language": "text",
        "code": "Object.create()"
      },
      {
        "language": "text",
        "code": "[[Prototype]]"
      },
      {
        "language": "text",
        "code": "Object.create()"
      },
      {
        "language": "text",
        "code": "Object.create(null)"
      },
      {
        "language": "text",
        "code": "Object.create()"
      },
      {
        "language": "text",
        "code": "Object.setPrototypeOf()"
      },
      {
        "language": "text",
        "code": "[[Prototype]]"
      },
      {
        "language": "text",
        "code": "Object.create(null)"
      },
      {
        "language": "text",
        "code": "Object.prototype.__proto__"
      },
      {
        "language": "text",
        "code": "[[Prototype]]"
      },
      {
        "language": "text",
        "code": "Object.prototype.__proto__"
      },
      {
        "language": "text",
        "code": "Object.setPrototypeOf"
      },
      {
        "language": "text",
        "code": "Object.setPrototypeOf"
      },
      {
        "language": "text",
        "code": "Object.setPrototypeOf"
      },
      {
        "language": "text",
        "code": "hasOwnProperty"
      },
      {
        "language": "text",
        "code": "Object.hasOwn"
      },
      {
        "language": "text",
        "code": "[[Prototype]]"
      },
      {
        "language": "text",
        "code": "hasOwnProperty"
      },
      {
        "language": "text",
        "code": "Object.prototype"
      },
      {
        "language": "text",
        "code": "[[Prototype]]"
      },
      {
        "language": "text",
        "code": "const a1 = new A()"
      },
      {
        "language": "text",
        "code": "a1.[[Prototype]] = A.prototype"
      },
      {
        "language": "text",
        "code": "[[Prototype]]"
      },
      {
        "language": "text",
        "code": "[[Prototype]]"
      },
      {
        "language": "text",
        "code": "a1.doSomething"
      },
      {
        "language": "text",
        "code": "Object.getPrototypeOf(a1).doSomething"
      },
      {
        "language": "text",
        "code": "Object.getPrototypeOf(Object.getPrototypeOf(a1)).doSomething"
      },
      {
        "language": "text",
        "code": "Object.getPrototypeOf"
      },
      {
        "language": "text",
        "code": "const a1 = new A(); const a2 = new A();"
      },
      {
        "language": "text",
        "code": "a1.doSomething"
      },
      {
        "language": "text",
        "code": "Object.getPrototypeOf(a1).doSomething"
      },
      {
        "language": "text",
        "code": "A.prototype.doSomething"
      },
      {
        "language": "text",
        "code": "Object.getPrototypeOf(a1).doSomething === Object.getPrototypeOf(a2).doSomething === A.prototype.doSomething"
      }
    ],
    "links": [
      {
        "text": "objects",
        "href": "/en-US/docs/Web/JavaScript/Guide/Data_structures#objects"
      },
      {
        "text": "static dispatching",
        "href": "https://en.wikipedia.org/wiki/Static_dispatch"
      },
      {
        "text": "dynamic",
        "href": "/en-US/docs/Web/JavaScript/Guide/Data_structures#dynamic_and_weak_typing"
      },
      {
        "text": "classes",
        "href": "/en-US/docs/Web/JavaScript/Reference/Classes"
      },
      {
        "text": "Object.getPrototypeOf()",
        "href": "/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/getPrototypeOf"
      },
      {
        "text": "Object.setPrototypeOf()",
        "href": "/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/setPrototypeOf"
      },
      {
        "text": "__proto__",
        "href": "/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/proto"
      },
      {
        "text": "__proto__ syntax",
        "href": "/en-US/docs/Web/JavaScript/Reference/Operators/Object_initializer#prototype_setter"
      },
      {
        "text": "getter or setter",
        "href": "/en-US/docs/Web/JavaScript/Guide/Working_with_objects#defining_getters_and_setters"
      },
      {
        "text": "methods",
        "href": "/en-US/docs/Glossary/Method"
      },
      {
        "text": "this",
        "href": "/en-US/docs/Web/JavaScript/Reference/Operators/this"
      },
      {
        "text": "new",
        "href": "/en-US/docs/Web/JavaScript/Reference/Operators/new"
      },
      {
        "text": "prototype",
        "href": "/en-US/docs/Web/JavaScript/Reference/Global_Objects/Function/prototype"
      },
      {
        "text": "constructor",
        "href": "/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/constructor"
      },
      {
        "text": "classes",
        "href": "/en-US/docs/Web/JavaScript/Reference/Classes"
      },
      {
        "text": "map()",
        "href": "/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/map"
      },
      {
        "text": "SmooshGate",
        "href": "https://developer.chrome.com/blog/smooshgate/"
      },
      {
        "text": "Object.setPrototypeOf()",
        "href": "/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/setPrototypeOf"
      },
      {
        "text": "extends",
        "href": "/en-US/docs/Web/JavaScript/Reference/Classes/extends"
      },
      {
        "text": "Object.create()",
        "href": "/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/create"
      },
      {
        "text": "constructor",
        "href": "/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/constructor"
      },
      {
        "text": "Firefox Developer Tools",
        "href": "https://firefox-source-docs.mozilla.org/devtools-user/index.html"
      },
      {
        "text": "Chrome DevTools",
        "href": "https://developer.chrome.com/docs/devtools/"
      },
      {
        "text": "Edge DevTools",
        "href": "https://learn.microsoft.com/en-us/archive/microsoft-edge/legacy/developer/"
      },
      {
        "text": "object initializers",
        "href": "/en-US/docs/Web/JavaScript/Reference/Operators/Object_initializer"
      },
      {
        "text": "Object.prototype.__proto__",
        "href": "/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/proto"
      },
      {
        "text": "Object.create",
        "href": "/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/create"
      },
      {
        "text": "Object.create",
        "href": "/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/create"
      },
      {
        "text": "Object.create()",
        "href": "/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/create"
      },
      {
        "text": "Private elements",
        "href": "/en-US/docs/Web/JavaScript/Reference/Classes/Private_elements"
      },
      {
        "text": "Object.setPrototypeOf()",
        "href": "/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/setPrototypeOf"
      },
      {
        "text": "Object.prototype.__proto__",
        "href": "/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/proto"
      },
      {
        "text": "hasOwnProperty",
        "href": "/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/hasOwnProperty"
      },
      {
        "text": "Object.hasOwn",
        "href": "/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/hasOwn"
      },
      {
        "text": "hasOwnProperty",
        "href": "/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/hasOwnProperty"
      },
      {
        "text": "undefined",
        "href": "/en-US/docs/Web/JavaScript/Reference/Global_Objects/undefined"
      },
      {
        "text": "Learn how to contribute",
        "href": "/en-US/docs/MDN/Community/Getting_started"
      },
      {
        "text": "MDN contributors",
        "href": "/en-US/docs/Web/JavaScript/Guide/Inheritance_and_the_prototype_chain/contributors.txt"
      },
      {
        "text": "View this page on GitHub",
        "href": "https://github.com/mdn/content/blob/main/files/en-us/web/javascript/guide/inheritance_and_the_prototype_chain/index.md?plain=1"
      },
      {
        "text": "Report a problem with this content",
        "href": "https://github.com/mdn/content/issues/new?template=page-report.yml&mdn-url=https%3A%2F%2Fdeveloper.mozilla.org%2Fen-US%2Fdocs%2FWeb%2FJavaScript%2FGuide%2FInheritance_and_the_prototype_chain&metadata=%3C%21--+Do+not+make+changes+below+this+line+--%3E%0A%3Cdetails%3E%0A%3Csummary%3EPage+report+details%3C%2Fsummary%3E%0A%0A*+Folder%3A+%60en-us%2Fweb%2Fjavascript%2Fguide%2Finheritance_and_the_prototype_chain%60%0A*+MDN+URL%3A+https%3A%2F%2Fdeveloper.mozilla.org%2Fen-US%2Fdocs%2FWeb%2FJavaScript%2FGuide%2FInheritance_and_the_prototype_chain%0A*+GitHub+URL%3A+https%3A%2F%2Fgithub.com%2Fmdn%2Fcontent%2Fblob%2Fmain%2Ffiles%2Fen-us%2Fweb%2Fjavascript%2Fguide%2Finheritance_and_the_prototype_chain%2Findex.md%0A*+Last+commit%3A+https%3A%2F%2Fgithub.com%2Fmdn%2Fcontent%2Fcommit%2Ffad67be4431d8e6c2a89ac880735233aa76c41d4%0A*+Document+last+modified%3A+2025-07-08T13%3A18%3A45.000Z%0A%0A%3C%2Fdetails%3E"
      }
    ],
    "meta": {
      "description": "In programming, inheritance refers to passing down characteristics from a parent to a child so that a new piece of code can reuse and build upon the features of an existing one. JavaScript implements inheritance by using objects. Each object has an internal link to another object called its prototype. That prototype object has a prototype of its own, and so on until an object is reached with null as its prototype. By definition, null has no prototype and acts as the final link in this prototype chain. It is possible to mutate any member of the prototype chain or even swap out the prototype at runtime, so concepts like static dispatching do not exist in JavaScript.",
      "keywords": ""
    },
    "summary": "Inheritance and the prototype chain In programming, inheritance refers to passing down characteristics from a parent to a child so that a new piece of code can reuse and build upon the features of an ...",
    "tags": [
      "javascript",
      "typescript",
      "html",
      "vite",
      "inheritance",
      "prototype",
      "chain",
      "inheriting",
      "constructors"
    ],
    "id": "inheritance-and-the-prototype-chain-Inheritance_an-part-1",
    "quality": 100
  },
  {
    "title": "JavaScript execution model",
    "url": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Execution_model",
    "category": "javascript",
    "content": "JavaScript execution model This page introduces the basic infrastructure of the JavaScript runtime environment. The model is largely theoretical and abstract, without any platform-specific or implementation-specific details. Modern JavaScript engines heavily optimize the described semantics. This page is a reference. It assumes you are already familiar with the execution model of other programming languages, such as C and Java. It makes heavy references to existing concepts in operating systems and programming languages. The engine and the host JavaScript execution requires the cooperation of two pieces of software: the JavaScript engine and the host environment. The JavaScript engine implements the ECMAScript (JavaScript) language, providing the core functionality. It takes source code, parses it, and executes it. However, in order to interact with the outside world, such as to produce any meaningful output, to interface with external resources, or to implement security- or performance-related mechanisms, we need additional environment-specific mechanisms provided by the host environment. For example, the HTML DOM is the host environment when JavaScript is executed in a web browser. Node.js is another host environment that allows JavaScript to be run on the server side. While we focus primarily on the mechanisms defined in ECMAScript in this reference, we will occasionally talk about mechanisms defined in the HTML spec, which is often mimicked by other host environments like Node.js or Deno. This way, we can give a coherent picture of the JavaScript execution model as used on the web and beyond. Agent execution model In the JavaScript specification, each autonomous executor of JavaScript is called an agent, which maintains its facilities for code execution: Heap (of objects): this is just a name to denote a large (mostly unstructured) region of memory. It gets populated as objects get created in the program. Note that in the case of shared memory, each agent has its own heap with its own version of a SharedArrayBuffer object, but the underlying memory represented by the buffer is shared. Queue (of jobs): this is known in HTML (and also commonly) as the event loop which enables asynchronous programming in JavaScript while being single-threaded. It's called a queue because it's generally first-in-first-out: earlier jobs are executed before later ones. Stack (of execution contexts): this is what's known as a call stack and allows transferring control flow by entering and exiting execution contexts like functions. It's called a stack because it's last-in-first-out. Every job enters by pushing a new frame onto the (empty) stack, and exits by emptying the stack. These are three distinct data structures that keep track of different data. We will introduce the queue and the stack in more detail in the following sections. To read more about how heap memory is allocated and freed, see memory management. Each agent is analogous to a thread (note that the underlying implementation may or may not be an actual operating system thread). Each agent can own multiple realms (which 1-to-1 correlate with global objects) that can synchronously access each other, and thus needs to run in a single execution thread. An agent also has a single memory model, indicating whether it's little-endian, whether it can be synchronously blocked, whether atomic operations are lock-free, etc. An agent on the web can be one of the following: A Similar-origin window agent, which contains various Window objects which can potentially reach each other, either directly or by using document.domain. If the window is origin-keyed, then only same-origin windows can reach each other. A Dedicated worker agent containing a single DedicatedWorkerGlobalScope. A Shared worker agent containing a single SharedWorkerGlobalScope. A Service worker agent containing a single ServiceWorkerGlobalScope. A Worklet agent containing a single WorkletGlobalScope. In other words, each worker creates its own agent, while one or more windows may be within the same agentusually a main document and its similar-origin iframes. In Node.js, a similar concept called worker threads is available. The diagram below illustrates the execution model of agents: Realms Each agent owns one or more realms. Each piece of JavaScript code is associated with a realm when it's loaded, which remains the same even when called from another realm. A realm consists of the follow information: A list of intrinsic objects like Array, Array.prototype, etc. Globally declared variables, the value of globalThis, and the global object A cache of template literal arrays, because evaluation of the same tagged template literal expression always causes the tag to receive the same array object On the web, the realm and the global object are 1-to-1 corresponded. The global object is either a Window, a WorkerGlobalScope, or a WorkletGlobalScope. So for example, every iframe executes in a different realm, though it may be in the same agent as the parent window. Realms are usually mentioned when talking about the identities of global objects. For example, we need methods such as Array.isArray() or Error.isError(), because an array constructed in another realm will have a different prototype object than the Array.prototype object in the current realm, so instanceof Array will wrongly return false. Stack and execution contexts We first consider synchronous code execution. Each job enters by calling its associated callback. Code inside this callback may create variables, call functions, or exit. Each function needs to keep track of its own variable environments and where to return to. To handle this, the agent needs a stack to keep track of the execution contexts. A execution context, also known generally as a stack frame, is the smallest unit of execution. It tracks the following information: Code evaluation state The module or script, the function (if applicable), and the currently executing generator that contains this code The current realm Bindings, including: Variables defined with var, let, const, function, class, etc. Private identifiers like #foo which are only valid in the current context this reference Imagine a program consisting of a single job defined by the following code: When the job starts, the first frame is created, where the variables foo, bar, and baz are defined. It calls bar with the argument 7. A second frame is created for the bar call, containing bindings for the parameter x and the local variable y. It first performs the multiplication x * y, then calls foo with the result. A third frame is created for the foo call, containing bindings for the parameter b and the local variable a. It first performs the addition a + b + 11, then returns the result. When foo returns, the top frame element is popped out of the stack, and the call expression foo(x * y) resolves to the return value. It then continues execution, which is just to return this result. When bar returns, the top frame element is popped out of the stack, and the call expression bar(7) resolves to the return value. This initializes baz with the return value. We reach the end of the job's source code, so the stack frame for the entrypoint is popped out of the stack. The stack is empty, so the job is considered completed. Generators and reentry When a frame is popped, it's not necessarily gone forever, because sometimes we need to come back to it. For example, consider a generator function: In this case, calling gen() first creates an execution context which is suspendedno code inside gen gets executed yet. The generator g saves this execution context internally. The current running execution context remains to be the entrypoint. When g.next() is called, the execution context for gen is pushed onto the stack, and the code inside gen is executed until the yield expression. Then, the generator execution context gets suspended and removed from the stack, which returns control back to the entrypoint. When g.next() is called again, the generator execution context is pushed back onto the stack, and the code inside gen resumes from where it left off. Tail calls One mechanism defined in the specification is proper tail call (PTC). A function call is a tail call if the caller does nothing after the call except return the value: In this case, the call to g is a tail call. If a function call is in tail position, the engine is required to discard the current execution context and replace it with the context of the tail call, instead of pushing a new frame for the g() call. This means that tail recursion is not subject to the stack size limits: In reality, discarding the current frame causes debugging problems, because if g() throws an error, f is no longer on the stack and won't appear in the stack trace. Currently, only Safari (JavaScriptCore) implements PTC, and they have invented some specific infrastructure to address the debuggability issue. Closures Another interesting phenomenon related to variable scoping and function calls is closures. Whenever a function is created, it also memorizes internally the variable bindings of the current running execution context. Then, these variable bindings can outlive the execution context. Job queue and event loop An agent is a thread, which means the interpreter can only process one statement at a time. When the code is all synchronous, this is fine because we can always make progress. But if the code needs to perform asynchronous action, then we cannot progress unless that action is completed. However, it would be detrimental to user experience if that halts the whole programthe nature of JavaScript as a web scripting language requires it to be never blocking. Therefore, the code that handles the completion of that asynchronous action is defined as a callback. This callback defines a job, which gets placed into a job queueor, in HTML terminology, an event looponce the action is completed. Every time, the agent pulls a job from the queue and executes it. When the job is executed, it may create more jobs, which are added to the end of the queue. Jobs can also be added via the completion of asynchronous platform mechanisms, such as timers, I/O, and events. A job is considered completed when the stack is empty; then, the next job is pulled from the queue. Jobs might not be pulled with uniform priorityfor example, HTML event loops split jobs into two categories: tasks and microtasks. Microtasks have higher priority and the microtask queue is drained first before the task queue is pulled. For more information, check the HTML microtask guide. If the job queue is empty, the agent waits for more jobs to be added. \"Run-to-completion\" Each job is processed completely before any other job is processed. This offers some nice properties when reasoning about your program, including the fact that whenever a function runs, it cannot be preempted and will run entirely before any other code runs (and can modify data the function manipulates). This differs from C, for instance, where if a function runs in a thread, it may be stopped at any point by the runtime system to run some other code in another thread. For example, consider this example: In this example, we create an already-resolved promise, which means any callback attached to it will be immediately scheduled as jobs. The two callbacks seem to cause a race condition, but actually, the output is fully predictable: 1 and 2 will be logged in order. This is because each job runs to completion before the next one is executed, so the overall order is always i += 1; console.log(i); i += 1; console.log(i); and never i += 1; i += 1; console.log(i); console.log(i);. A downside of this model is that if a job takes too long to complete, the web application is unable to process user interactions like click or scroll. The browser mitigates this with the \"a script is taking too long to run\" dialog. A good practice to follow is to make job processing short and if possible cut down one job into several jobs. Never blocking Another important guarantee offered by the event loop model is that JavaScript execution is never blocking. Handling I/O is typically performed via events and callbacks, so when the application is waiting for an IndexedDB query to return or a fetch() request to return, it can still process other things like user input. The code that executes after the completion of an asynchronous action is always provided as a callback function (for example, the promise then() handler, the callback function in setTimeout(), or the event handler), which defines a job to be added to the job queue once the action completes. Of course, the guarantee of \"never-blocking\" requires the platform API to be inherently asynchronous, but some legacy exceptions exist like alert() or synchronous XHR. It is considered good practice to avoid them to ensure the responsiveness of the application. Agent clusters and memory sharing Multiple agents can communicate via memory sharing, forming an agent cluster. Agents are within the same cluster if and only if they can share memory. There is no built-in mechanism for two agent clusters to exchange any information, so they can be regarded as completely isolated execution models. When creating an agent (such as by spawning a worker), there are some criteria for whether it's in the same cluster as the current agent, or a new cluster is created. For example, the following pairs of global objects are each within the same agent cluster, and thus can share memory with each other: A Window object and a dedicated worker that it created. A worker (of any type) and a dedicated worker it created. A Window object A and the Window object of a same-origin iframe element that A created. A Window object and a same-origin Window object that opened it. A Window object and a worklet that it created. The following pairs of global objects are not within the same agent cluster, and thus cannot share memory: A Window object and a shared worker it created. A worker (of any type) and a shared worker it created. A Window object and a service worker it created. A Window object A and the Window object of an iframe element that A created that cannot be same origin-domain with A. Any two Window objects with no opener or ancestor relationship. This holds even if the two Window objects are same origin. For the exact algorithm, check the HTML specification. Cross-agent communication and memory model As aforementioned, agents communicate via memory sharing. On the web, memory is shared via the postMessage() method. The using web workers guide provides an overview of this. Typically, data is passed by value only (via structured cloning), and therefore does not involve any concurrency complications. To share memory, one must post a SharedArrayBuffer object, which can be simultaneously accessed by multiple agents. Once two agents share access to the same memory via a SharedArrayBuffer, they can synchronize executions via the Atomics object. There are two ways to access shared memory: via normal memory access (which is not atomic) and via atomic memory access. The latter is sequentially consistent (which means there is a strict total ordering of events agreed upon by all agents in the cluster), while the former is unordered (which means no ordering exists); JavaScript does not provide operations with other ordering guarantees. The spec provides the following guidelines for programmers working with shared memory: We recommend programs be kept data race free, i.e., make it so that it is impossible for there to be concurrent non-atomic operations on the same memory location. Data race free programs have interleaving semantics where each step in the evaluation semantics of each agent are interleaved with each other. For data race free programs, it is not necessary to understand the details of the memory model. The details are unlikely to build intuition that will help one to better write ECMAScript. More generally, even if a program is not data race free it may have predictable behavior, so long as atomic operations are not involved in any data races and the operations that race all have the same access size. The simplest way to arrange for atomics not to be involved in races is to ensure that different memory cells are used by atomic and non-atomic operations and that atomic accesses of different sizes are not used to access the same cells at the same time. Effectively, the program should treat shared memory as strongly typed as much as possible. One still cannot depend on the ordering and timing of non-atomic accesses that race, but if memory is treated as strongly typed the racing accesses will not \"tear\" (bits of their values will not be mixed). Concurrency and ensuring forward progress When multiple agents cooperate, the never-blocking guarantee does not always hold. An agent can become blocked, or paused, while waiting for another agent to perform some action. This is different from waiting on a promise in the same agent, because it halts the entire agent and does not allow any other code to run in the meantimein other words, it cannot make forward progress. To prevent deadlocks, there are some strong restrictions on when and which agents can become blocked. Every unblocked agent with a dedicated executing thread eventually makes forward progress. In a set of agents that share an executing thread, one agent eventually makes forward progress. An agent does not cause another agent to become blocked except via explicit APIs that provide blocking. Only certain agents can be blocked. On the web, this includes dedicated workers and shared workers, but not similar-origin windows or service workers. The agent cluster ensures some level of integrity over the activeness of its agents, in the case of external pauses or terminations: An agent may be paused or resumed without its knowledge or cooperation. For example, navigating away from a window may suspend code execution but preserve its state. However, an agent cluster is not allowed to be partially deactivated, to avoid an agent starving because another agent has been deactivated. For example, shared workers are never in the same agent cluster as the creator window or other dedicated workers. This is because a shared worker's lifetime is independent of documents: if a document is deactivated while its dedicated worker holds a lock, the shared worker is blocked from acquiring the lock until the dedicated worker is reactivated, if ever. Meanwhile other workers trying to access the shared worker from other windows will starve. Similarly, an agent may be terminated by factors external to the cluster. For example, operating systems or users killing a browser process, or the browser force-terminating one agent because it's using too many resources. In this case, all the agents in the cluster get terminated. (The spec also allows a second strategy, which is an API that allows at least one remaining member of the cluster to identify the termination and the agent that was terminated, but this is not implemented on the web.) Specifications Specification ECMAScript 2026 Language Specification ECMAScript 2026 Language Specification HTML See also Event loops in the HTML standard What is the Event Loop? in the Node.js docs Help improve MDN Learn how to contribute This page was last modified on Jul 8, 2025 by MDN contributors. View this page on GitHub  Report a problem with this content",
    "headings": [
      {
        "level": 1,
        "text": "JavaScript execution model",
        "id": ""
      },
      {
        "level": 2,
        "text": "The engine and the host",
        "id": "the_engine_and_the_host"
      },
      {
        "level": 2,
        "text": "Agent execution model",
        "id": "agent_execution_model"
      },
      {
        "level": 2,
        "text": "Realms",
        "id": "realms"
      },
      {
        "level": 2,
        "text": "Stack and execution contexts",
        "id": "stack_and_execution_contexts"
      },
      {
        "level": 2,
        "text": "Job queue and event loop",
        "id": "job_queue_and_event_loop"
      },
      {
        "level": 2,
        "text": "Agent clusters and memory sharing",
        "id": "agent_clusters_and_memory_sharing"
      },
      {
        "level": 2,
        "text": "Specifications",
        "id": "specifications"
      },
      {
        "level": 2,
        "text": "See also",
        "id": "see_also"
      },
      {
        "level": 2,
        "text": "Help improve MDN",
        "id": "feedback"
      },
      {
        "level": 3,
        "text": "Generators and reentry",
        "id": "generators_and_reentry"
      },
      {
        "level": 3,
        "text": "Tail calls",
        "id": "tail_calls"
      },
      {
        "level": 3,
        "text": "Closures",
        "id": "closures"
      },
      {
        "level": 3,
        "text": "\"Run-to-completion\"",
        "id": "run-to-completion"
      },
      {
        "level": 3,
        "text": "Never blocking",
        "id": "never_blocking"
      },
      {
        "level": 3,
        "text": "Cross-agent communication and memory model",
        "id": "cross-agent_communication_and_memory_model"
      },
      {
        "level": 3,
        "text": "Concurrency and ensuring forward progress",
        "id": "concurrency_and_ensuring_forward_progress"
      }
    ],
    "codeBlocks": [
      {
        "language": "text",
        "code": "SharedArrayBuffer"
      },
      {
        "language": "text",
        "code": "document.domain"
      },
      {
        "language": "text",
        "code": "DedicatedWorkerGlobalScope"
      },
      {
        "language": "text",
        "code": "SharedWorkerGlobalScope"
      },
      {
        "language": "text",
        "code": "ServiceWorkerGlobalScope"
      },
      {
        "language": "text",
        "code": "WorkletGlobalScope"
      },
      {
        "language": "text",
        "code": "Array.prototype"
      },
      {
        "language": "text",
        "code": "WorkerGlobalScope"
      },
      {
        "language": "text",
        "code": "WorkletGlobalScope"
      },
      {
        "language": "text",
        "code": "Array.isArray()"
      },
      {
        "language": "text",
        "code": "Error.isError()"
      },
      {
        "language": "text",
        "code": "Array.prototype"
      },
      {
        "language": "text",
        "code": "instanceof Array"
      },
      {
        "language": "text",
        "code": "i += 1; console.log(i); i += 1; console.log(i);"
      },
      {
        "language": "text",
        "code": "i += 1; i += 1; console.log(i); console.log(i);"
      },
      {
        "language": "text",
        "code": "setTimeout()"
      },
      {
        "language": "text",
        "code": "postMessage()"
      },
      {
        "language": "text",
        "code": "SharedArrayBuffer"
      },
      {
        "language": "text",
        "code": "SharedArrayBuffer"
      }
    ],
    "links": [
      {
        "text": "ECMAScript (JavaScript) language",
        "href": "/en-US/docs/Web/JavaScript/Reference/JavaScript_technologies_overview#javascript_the_core_language_ecmascript"
      },
      {
        "text": "SharedArrayBuffer",
        "href": "/en-US/docs/Web/JavaScript/Reference/Global_Objects/SharedArrayBuffer"
      },
      {
        "text": "memory management",
        "href": "/en-US/docs/Web/JavaScript/Guide/Memory_management"
      },
      {
        "text": "lock-free",
        "href": "/en-US/docs/Web/JavaScript/Reference/Global_Objects/Atomics/isLockFree"
      },
      {
        "text": "Window",
        "href": "/en-US/docs/Web/API/Window"
      },
      {
        "text": "document.domain",
        "href": "/en-US/docs/Web/API/Document/domain"
      },
      {
        "text": "origin-keyed",
        "href": "/en-US/docs/Web/API/Window/originAgentCluster"
      },
      {
        "text": "DedicatedWorkerGlobalScope",
        "href": "/en-US/docs/Web/API/DedicatedWorkerGlobalScope"
      },
      {
        "text": "SharedWorkerGlobalScope",
        "href": "/en-US/docs/Web/API/SharedWorkerGlobalScope"
      },
      {
        "text": "ServiceWorkerGlobalScope",
        "href": "/en-US/docs/Web/API/ServiceWorkerGlobalScope"
      },
      {
        "text": "WorkletGlobalScope",
        "href": "/en-US/docs/Web/API/WorkletGlobalScope"
      },
      {
        "text": "worker threads",
        "href": "https://nodejs.org/api/worker_threads.html"
      },
      {
        "text": "globalThis",
        "href": "/en-US/docs/Web/JavaScript/Reference/Global_Objects/globalThis"
      },
      {
        "text": "template literal arrays",
        "href": "/en-US/docs/Web/JavaScript/Reference/Template_literals#tagged_templates"
      },
      {
        "text": "Window",
        "href": "/en-US/docs/Web/API/Window"
      },
      {
        "text": "WorkerGlobalScope",
        "href": "/en-US/docs/Web/API/WorkerGlobalScope"
      },
      {
        "text": "WorkletGlobalScope",
        "href": "/en-US/docs/Web/API/WorkletGlobalScope"
      },
      {
        "text": "Array.isArray()",
        "href": "/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/isArray"
      },
      {
        "text": "Error.isError()",
        "href": "/en-US/docs/Web/JavaScript/Reference/Global_Objects/Error/isError"
      },
      {
        "text": "generator",
        "href": "/en-US/docs/Web/JavaScript/Reference/Global_Objects/Generator"
      },
      {
        "text": "Bindings",
        "href": "/en-US/docs/Glossary/Binding"
      },
      {
        "text": "specific infrastructure",
        "href": "https://webkit.org/blog/6240/ecmascript-6-proper-tail-calls-in-webkit/"
      },
      {
        "text": "closures",
        "href": "/en-US/docs/Web/JavaScript/Guide/Closures"
      },
      {
        "text": "HTML microtask guide",
        "href": "/en-US/docs/Web/API/HTML_DOM_API/Microtask_guide"
      },
      {
        "text": "IndexedDB",
        "href": "/en-US/docs/Web/API/IndexedDB_API"
      },
      {
        "text": "fetch()",
        "href": "/en-US/docs/Web/API/Window/fetch"
      },
      {
        "text": "then()",
        "href": "/en-US/docs/Web/JavaScript/Reference/Global_Objects/Promise/then"
      },
      {
        "text": "HTML specification",
        "href": "https://html.spec.whatwg.org/multipage/webappapis.html#integration-with-the-javascript-agent-cluster-formalism"
      },
      {
        "text": "postMessage()",
        "href": "/en-US/docs/Web/API/Window/postMessage"
      },
      {
        "text": "using web workers",
        "href": "/en-US/docs/Web/API/Web_Workers_API/Using_web_workers"
      },
      {
        "text": "structured cloning",
        "href": "/en-US/docs/Web/API/Web_Workers_API/Structured_clone_algorithm"
      },
      {
        "text": "SharedArrayBuffer",
        "href": "/en-US/docs/Web/JavaScript/Reference/Global_Objects/SharedArrayBuffer"
      },
      {
        "text": "Atomics",
        "href": "/en-US/docs/Web/JavaScript/Reference/Global_Objects/Atomics"
      },
      {
        "text": "sequentially consistent",
        "href": "https://en.wikipedia.org/wiki/Sequential_consistency"
      },
      {
        "text": "ECMAScript® 2026 Language Specification",
        "href": "https://tc39.es/ecma262/multipage/executable-code-and-execution-contexts.html"
      },
      {
        "text": "ECMAScript® 2026 Language Specification",
        "href": "https://tc39.es/ecma262/multipage/memory-model.html"
      },
      {
        "text": "HTML",
        "href": "https://html.spec.whatwg.org/multipage/webappapis.html"
      },
      {
        "text": "Event loops",
        "href": "https://html.spec.whatwg.org/multipage/webappapis.html#event-loops"
      },
      {
        "text": "What is the Event Loop?",
        "href": "https://nodejs.org/en/learn/asynchronous-work/event-loop-timers-and-nexttick#what-is-the-event-loop"
      },
      {
        "text": "Learn how to contribute",
        "href": "/en-US/docs/MDN/Community/Getting_started"
      },
      {
        "text": "MDN contributors",
        "href": "/en-US/docs/Web/JavaScript/Reference/Execution_model/contributors.txt"
      },
      {
        "text": "View this page on GitHub",
        "href": "https://github.com/mdn/content/blob/main/files/en-us/web/javascript/reference/execution_model/index.md?plain=1"
      },
      {
        "text": "Report a problem with this content",
        "href": "https://github.com/mdn/content/issues/new?template=page-report.yml&mdn-url=https%3A%2F%2Fdeveloper.mozilla.org%2Fen-US%2Fdocs%2FWeb%2FJavaScript%2FReference%2FExecution_model&metadata=%3C%21--+Do+not+make+changes+below+this+line+--%3E%0A%3Cdetails%3E%0A%3Csummary%3EPage+report+details%3C%2Fsummary%3E%0A%0A*+Folder%3A+%60en-us%2Fweb%2Fjavascript%2Freference%2Fexecution_model%60%0A*+MDN+URL%3A+https%3A%2F%2Fdeveloper.mozilla.org%2Fen-US%2Fdocs%2FWeb%2FJavaScript%2FReference%2FExecution_model%0A*+GitHub+URL%3A+https%3A%2F%2Fgithub.com%2Fmdn%2Fcontent%2Fblob%2Fmain%2Ffiles%2Fen-us%2Fweb%2Fjavascript%2Freference%2Fexecution_model%2Findex.md%0A*+Last+commit%3A+https%3A%2F%2Fgithub.com%2Fmdn%2Fcontent%2Fcommit%2Ffad67be4431d8e6c2a89ac880735233aa76c41d4%0A*+Document+last+modified%3A+2025-07-08T13%3A18%3A45.000Z%0A%0A%3C%2Fdetails%3E"
      }
    ],
    "meta": {
      "description": "This page introduces the basic infrastructure of the JavaScript runtime environment. The model is largely theoretical and abstract, without any platform-specific or implementation-specific details. Modern JavaScript engines heavily optimize the described semantics.",
      "keywords": ""
    },
    "summary": "JavaScript execution model This page introduces the basic infrastructure of the JavaScript runtime environment",
    "tags": [
      "react",
      "angular",
      "javascript",
      "typescript",
      "css",
      "html",
      "node",
      "vite",
      "execution",
      "model"
    ],
    "id": "javascript-execution-model-Execution_model-part-1",
    "quality": 100
  },
  {
    "title": "Fetch API",
    "url": "https://developer.mozilla.org/en-US/docs/Web/API/Fetch_API",
    "category": "javascript",
    "content": "Fetch API Baseline Widely available * This feature is well established and works across many devices and browser versions. Its been available across browsers since March 2017. * Some parts of this feature may have varying levels of support. Learn more See full compatibility Report feedback Note: This feature is available in Web Workers. The Fetch API provides an interface for fetching resources (including across the network). It is a more powerful and flexible replacement for XMLHttpRequest. Concepts and usage The Fetch API uses Request and Response objects (and other things involved with network requests), as well as related concepts such as CORS and the HTTP Origin header semantics. For making a request and fetching a resource, use the fetch() method. It is a global method in both Window and Worker contexts. This makes it available in pretty much any context you might want to fetch resources in. The fetch() method takes one mandatory argument, the path to the resource you want to fetch. It returns a Promise that resolves to the Response to that request  as soon as the server responds with headers  even if the server response is an HTTP error status. You can also optionally pass in an init options object as the second argument (see Request). Once a Response is retrieved, there are a number of methods available to define what the body content is and how it should be handled. You can create a request and response directly using the Request() and Response() constructors, but it's uncommon to do this directly. Instead, these are more likely to be created as results of other API actions (for example, FetchEvent.respondWith() from service workers). Find out more about using the Fetch API features in Using Fetch. Interfaces Window.fetch() and WorkerGlobalScope.fetch() The fetch() method used to fetch a resource. Headers Represents response/request headers, allowing you to query them and take different actions depending on the results. Request Represents a resource request. Response Represents the response to a request. Specifications Specification Fetch# fetch-method Browser compatibility See also Using Fetch Service Worker API HTTP access control (CORS) HTTP Help improve MDN Learn how to contribute This page was last modified on Apr 9, 2025 by MDN contributors. View this page on GitHub  Report a problem with this content",
    "headings": [
      {
        "level": 1,
        "text": "Fetch API",
        "id": ""
      },
      {
        "level": 2,
        "text": "Concepts and usage",
        "id": "concepts_and_usage"
      },
      {
        "level": 2,
        "text": "Interfaces",
        "id": "interfaces"
      },
      {
        "level": 2,
        "text": "Specifications",
        "id": "specifications"
      },
      {
        "level": 2,
        "text": "Browser compatibility",
        "id": "browser_compatibility"
      },
      {
        "level": 2,
        "text": "See also",
        "id": "see_also"
      },
      {
        "level": 2,
        "text": "Help improve MDN",
        "id": "feedback"
      }
    ],
    "codeBlocks": [
      {
        "language": "text",
        "code": "XMLHttpRequest"
      },
      {
        "language": "text",
        "code": "FetchEvent.respondWith()"
      },
      {
        "language": "text",
        "code": "Window.fetch()"
      },
      {
        "language": "text",
        "code": "WorkerGlobalScope.fetch()"
      }
    ],
    "links": [
      {
        "text": "Learn more",
        "href": "/en-US/docs/Glossary/Baseline/Compatibility"
      },
      {
        "text": "Report feedback",
        "href": "https://survey.alchemer.com/s3/7634825/MDN-baseline-feedback?page=%2Fen-US%2Fdocs%2FWeb%2FAPI%2FFetch_API&level=high"
      },
      {
        "text": "Web Workers",
        "href": "/en-US/docs/Web/API/Web_Workers_API"
      },
      {
        "text": "XMLHttpRequest",
        "href": "/en-US/docs/Web/API/XMLHttpRequest"
      },
      {
        "text": "Request",
        "href": "/en-US/docs/Web/API/Request"
      },
      {
        "text": "Response",
        "href": "/en-US/docs/Web/API/Response"
      },
      {
        "text": "fetch()",
        "href": "/en-US/docs/Web/API/Window/fetch"
      },
      {
        "text": "Window",
        "href": "/en-US/docs/Web/API/Window"
      },
      {
        "text": "Worker",
        "href": "/en-US/docs/Web/API/WorkerGlobalScope"
      },
      {
        "text": "Promise",
        "href": "/en-US/docs/Web/JavaScript/Reference/Global_Objects/Promise"
      },
      {
        "text": "Response",
        "href": "/en-US/docs/Web/API/Response"
      },
      {
        "text": "Request",
        "href": "/en-US/docs/Web/API/Request"
      },
      {
        "text": "Response",
        "href": "/en-US/docs/Web/API/Response"
      },
      {
        "text": "Request()",
        "href": "/en-US/docs/Web/API/Request/Request"
      },
      {
        "text": "Response()",
        "href": "/en-US/docs/Web/API/Response/Response"
      },
      {
        "text": "FetchEvent.respondWith()",
        "href": "/en-US/docs/Web/API/FetchEvent/respondWith"
      },
      {
        "text": "Using Fetch",
        "href": "/en-US/docs/Web/API/Fetch_API/Using_Fetch"
      },
      {
        "text": "Window.fetch()",
        "href": "/en-US/docs/Web/API/Window/fetch"
      },
      {
        "text": "WorkerGlobalScope.fetch()",
        "href": "/en-US/docs/Web/API/WorkerGlobalScope/fetch"
      },
      {
        "text": "Headers",
        "href": "/en-US/docs/Web/API/Headers"
      },
      {
        "text": "Request",
        "href": "/en-US/docs/Web/API/Request"
      },
      {
        "text": "Response",
        "href": "/en-US/docs/Web/API/Response"
      },
      {
        "text": "Fetch# fetch-method",
        "href": "https://fetch.spec.whatwg.org/#fetch-method"
      },
      {
        "text": "Using Fetch",
        "href": "/en-US/docs/Web/API/Fetch_API/Using_Fetch"
      },
      {
        "text": "Service Worker API",
        "href": "/en-US/docs/Web/API/Service_Worker_API"
      },
      {
        "text": "HTTP access control (CORS)",
        "href": "/en-US/docs/Web/HTTP/Guides/CORS"
      },
      {
        "text": "HTTP",
        "href": "/en-US/docs/Web/HTTP"
      },
      {
        "text": "Learn how to contribute",
        "href": "/en-US/docs/MDN/Community/Getting_started"
      },
      {
        "text": "MDN contributors",
        "href": "/en-US/docs/Web/API/Fetch_API/contributors.txt"
      },
      {
        "text": "View this page on GitHub",
        "href": "https://github.com/mdn/content/blob/main/files/en-us/web/api/fetch_api/index.md?plain=1"
      },
      {
        "text": "Report a problem with this content",
        "href": "https://github.com/mdn/content/issues/new?template=page-report.yml&mdn-url=https%3A%2F%2Fdeveloper.mozilla.org%2Fen-US%2Fdocs%2FWeb%2FAPI%2FFetch_API&metadata=%3C%21--+Do+not+make+changes+below+this+line+--%3E%0A%3Cdetails%3E%0A%3Csummary%3EPage+report+details%3C%2Fsummary%3E%0A%0A*+Folder%3A+%60en-us%2Fweb%2Fapi%2Ffetch_api%60%0A*+MDN+URL%3A+https%3A%2F%2Fdeveloper.mozilla.org%2Fen-US%2Fdocs%2FWeb%2FAPI%2FFetch_API%0A*+GitHub+URL%3A+https%3A%2F%2Fgithub.com%2Fmdn%2Fcontent%2Fblob%2Fmain%2Ffiles%2Fen-us%2Fweb%2Fapi%2Ffetch_api%2Findex.md%0A*+Last+commit%3A+https%3A%2F%2Fgithub.com%2Fmdn%2Fcontent%2Fcommit%2F31ba9f6da2dd1175250ece8d8d467d523e79b447%0A*+Document+last+modified%3A+2025-04-09T12%3A12%3A12.000Z%0A%0A%3C%2Fdetails%3E"
      }
    ],
    "meta": {
      "description": "The Fetch API provides an interface for fetching resources (including across the network). It is a more powerful and flexible replacement for XMLHttpRequest.",
      "keywords": ""
    },
    "summary": "Fetch API Baseline Widely available * This feature is well established and works across many devices and browser versions. Its been available across browsers since March 2017",
    "tags": [
      "angular",
      "javascript",
      "typescript",
      "html",
      "node",
      "vite",
      "fetch",
      "api",
      "concepts",
      "usage"
    ],
    "id": "fetch-api-Fetch_API-part-1",
    "quality": 90
  },
  {
    "title": "TypeScript: Documentation",
    "url": "https://www.typescriptlang.org/docs/handbook/2/basic-types.html",
    "category": "typescript",
    "content": "Each and every value in JavaScript has a set of behaviors you can observe from running different operations. That sounds abstract, but as a quick example, consider some operations we might run on a variable named message. js// Accessing the property 'toLowerCase'// on 'message' and then calling itmessage.toLowerCase();// Calling 'message'message(); If we break this down, the first runnable line of code accesses a property called toLowerCase and then calls it. The second one tries to call message directly. But assuming we dont know the value of message - and thats pretty common - we cant reliably say what results well get from trying to run any of this code. The behavior of each operation depends entirely on what value we had in the first place. Is message callable? Does it have a property called toLowerCase on it? If it does, is toLowerCase even callable? If both of these values are callable, what do they return? The answers to these questions are usually things we keep in our heads when we write JavaScript, and we have to hope we got all the details right. Lets say message was defined in the following way. jsconst message = \"Hello World!\"; As you can probably guess, if we try to run message.toLowerCase(), well get the same string only in lower-case. What about that second line of code? If youre familiar with JavaScript, youll know this fails with an exception: txtTypeError: message is not a function Itd be great if we could avoid mistakes like this. When we run our code, the way that our JavaScript runtime chooses what to do is by figuring out the type of the value - what sorts of behaviors and capabilities it has. Thats part of what that TypeError is alluding to - its saying that the string \"Hello World!\" cannot be called as a function. For some values, such as the primitives string and number, we can identify their type at runtime using the typeof operator. But for other things like functions, theres no corresponding runtime mechanism to identify their types. For example, consider this function: jsfunction fn(x) { return x.flip();} We can observe by reading the code that this function will only work if given an object with a callable flip property, but JavaScript doesnt surface this information in a way that we can check while the code is running. The only way in pure JavaScript to tell what fn does with a particular value is to call it and see what happens. This kind of behavior makes it hard to predict what the code will do before it runs, which means its harder to know what your code is going to do while youre writing it. Seen in this way, a type is the concept of describing which values can be passed to fn and which will crash. JavaScript only truly provides dynamic typing - running the code to see what happens. The alternative is to use a static type system to make predictions about what the code is expected to do before it runs. Static type-checking Think back to that TypeError we got earlier from trying to call a string as a function. Most people dont like to get any sorts of errors when running their code - those are considered bugs! And when we write new code, we try our best to avoid introducing new bugs. If we add just a bit of code, save our file, re-run the code, and immediately see the error, we might be able to isolate the problem quickly; but thats not always the case. We might not have tested the feature thoroughly enough, so we might never actually run into a potential error that would be thrown! Or if we were lucky enough to witness the error, we might have ended up doing large refactorings and adding a lot of different code that were forced to dig through. Ideally, we could have a tool that helps us find these bugs before our code runs. Thats what a static type-checker like TypeScript does. Static type systems describe the shapes and behaviors of what our values will be when we run our programs. A type-checker like TypeScript uses that information and tells us when things might be going off the rails. tsconst message = \"hello!\"; message();This expression is not callable. Type 'String' has no call signatures.2349This expression is not callable. Type 'String' has no call signatures.Try Running that last sample with TypeScript will give us an error message before we run the code in the first place. Non-exception Failures So far weve been discussing certain things like runtime errors - cases where the JavaScript runtime tells us that it thinks something is nonsensical. Those cases come up because the ECMAScript specification has explicit instructions on how the language should behave when it runs into something unexpected. For example, the specification says that trying to call something that isnt callable should throw an error. Maybe that sounds like obvious behavior, but you could imagine that accessing a property that doesnt exist on an object should throw an error too. Instead, JavaScript gives us different behavior and returns the value undefined: jsconst user = { name: \"Daniel\", age: 26,};user.location; // returns undefined Ultimately, a static type system has to make the call over what code should be flagged as an error in its system, even if its valid JavaScript that wont immediately throw an error. In TypeScript, the following code produces an error about location not being defined: tsconst user = { name: \"Daniel\", age: 26,}; user.location;Property 'location' does not exist on type '{ name: string; age: number; }'.2339Property 'location' does not exist on type '{ name: string; age: number; }'.Try While sometimes that implies a trade-off in what you can express, the intent is to catch legitimate bugs in our programs. And TypeScript catches a lot of legitimate bugs. For example: typos, tsconst announcement = \"Hello World!\"; // How quickly can you spot the typos?announcement.toLocaleLowercase();announcement.toLocalLowerCase(); // We probably meant to write this...announcement.toLocaleLowerCase();Try uncalled functions, tsfunction flipCoin() { // Meant to be Math.random() return Math.random  0.5;Operator '' cannot be applied to types '() = number' and 'number'.2365Operator '' cannot be applied to types '() = number' and 'number'.}Try or basic logic errors. tsconst value = Math.random()  0.5 ? \"a\" : \"b\";if (value !== \"a\") { // ...} else if (value === \"b\") {This comparison appears to be unintentional because the types '\"a\"' and '\"b\"' have no overlap.2367This comparison appears to be unintentional because the types '\"a\"' and '\"b\"' have no overlap. // Oops, unreachable}Try Types for Tooling TypeScript can catch bugs when we make mistakes in our code. Thats great, but TypeScript can also prevent us from making those mistakes in the first place. The type-checker has information to check things like whether were accessing the right properties on variables and other properties. Once it has that information, it can also start suggesting which properties you might want to use. That means TypeScript can be leveraged for editing code too, and the core type-checker can provide error messages and code completion as you type in the editor. Thats part of what people often refer to when they talk about tooling in TypeScript. tsimport express from \"express\";const app = express(); app.get(\"/\", function (req, res) { res.sen sendsendDatesendfilesendFilesendStatus}); app.listen(3000);Try TypeScript takes tooling seriously, and that goes beyond completions and errors as you type. An editor that supports TypeScript can deliver quick fixes to automatically fix errors, refactorings to easily re-organize code, and useful navigation features for jumping to definitions of a variable, or finding all references to a given variable. All of this is built on top of the type-checker and is fully cross-platform, so its likely that your favorite editor has TypeScript support available. tsc, the TypeScript compiler Weve been talking about type-checking, but we havent yet used our type-checker. Lets get acquainted with our new friend tsc, the TypeScript compiler. First well need to grab it via npm. shnpm install -g typescript This installs the TypeScript Compiler tsc globally. You can use npx or similar tools if youd prefer to run tsc from a local node_modules package instead. Now lets move to an empty folder and try writing our first TypeScript program: hello.ts: ts// Greets the world.console.log(\"Hello world!\");Try Notice there are no frills here; this hello world program looks identical to what youd write for a hello world program in JavaScript. And now lets type-check it by running the command tsc which was installed for us by the typescript package. shtsc hello.ts Tada! Wait, tada what exactly? We ran tsc and nothing happened! Well, there were no type errors, so we didnt get any output in our console since there was nothing to report. But check again - we got some file output instead. If we look in our current directory, well see a hello.js file next to hello.ts. Thats the output from our hello.ts file after tsc compiles or transforms it into a plain JavaScript file. And if we check the contents, well see what TypeScript spits out after it processes a .ts file: js// Greets the world.console.log(\"Hello world!\"); In this case, there was very little for TypeScript to transform, so it looks identical to what we wrote. The compiler tries to emit clean readable code that looks like something a person would write. While thats not always so easy, TypeScript indents consistently, is mindful of when our code spans across different lines of code, and tries to keep comments around. What about if we did introduce a type-checking error? Lets rewrite hello.ts: ts// This is an industrial-grade general-purpose greeter function:function greet(person, date) { console.log(Hello ${person}, today is ${date}!);} greet(\"Brendan\");Try If we run tsc hello.ts again, notice that we get an error on the command line! txtExpected 2 arguments, but got 1. TypeScript is telling us we forgot to pass an argument to the greet function, and rightfully so. So far weve only written standard JavaScript, and yet type-checking was still able to find problems with our code. Thanks TypeScript! Emitting with Errors One thing you might not have noticed from the last example was that our hello.js file changed again. If we open that file up then well see that the contents still basically look the same as our input file. That might be a bit surprising given the fact that tsc reported an error about our code, but this is based on one of TypeScripts core values: much of the time, you will know better than TypeScript. To reiterate from earlier, type-checking code limits the sorts of programs you can run, and so theres a tradeoff on what sorts of things a type-checker finds acceptable. Most of the time thats okay, but there are scenarios where those checks get in the way. For example, imagine yourself migrating JavaScript code over to TypeScript and introducing type-checking errors. Eventually youll get around to cleaning things up for the type-checker, but that original JavaScript code was already working! Why should converting it over to TypeScript stop you from running it? So TypeScript doesnt get in your way. Of course, over time, you may want to be a bit more defensive against mistakes, and make TypeScript act a bit more strictly. In that case, you can use the noEmitOnError compiler option. Try changing your hello.ts file and running tsc with that flag: shtsc --noEmitOnError hello.ts Youll notice that hello.js never gets updated. Explicit Types Up until now, we havent told TypeScript what person or date are. Lets edit the code to tell TypeScript that person is a string, and that date should be a Date object. Well also use the toDateString() method on date. tsfunction greet(person: string, date: Date) { console.log(Hello ${person}, today is ${date.toDateString()}!);}Try What we did was add type annotations on person and date to describe what types of values greet can be called with. You can read that signature as greet takes a person of type string, and a date of type Date. With this, TypeScript can tell us about other cases where greet might have been called incorrectly. For example tsfunction greet(person: string, date: Date) { console.log(Hello ${person}, today is ${date.toDateString()}!);} greet(\"Maddison\", Date());Argument of type 'string' is not assignable to parameter of type 'Date'.2345Argument of type 'string' is not assignable to parameter of type 'Date'.Try Huh? TypeScript reported an error on our second argument, but why? Perhaps surprisingly, calling Date() in JavaScript returns a string. On the other hand, constructing a Date with new Date() actually gives us what we were expecting. Anyway, we can quickly fix up the error: tsfunction greet(person: string, date: Date) { console.log(Hello ${person}, today is ${date.toDateString()}!);} greet(\"Maddison\", new Date());Try Keep in mind, we dont always have to write explicit type annotations. In many cases, TypeScript can even just infer (or figure out) the types for us even if we omit them. tslet msg = \"hello there!\"; let msg: stringTry Even though we didnt tell TypeScript that msg had the type string it was able to figure that out. Thats a feature, and its best not to add annotations when the type system would end up inferring the same type anyway. Note: The message bubble inside the previous code sample is what your editor would show if you had hovered over the word. Erased Types Lets take a look at what happens when we compile the above function greet with tsc to output JavaScript: ts\"use strict\";function greet(person, date) { console.log(\"Hello \".concat(person, \", today is \").concat(date.toDateString(), \"!\"));}greet(\"Maddison\", new Date()); Try Notice two things here: Our person and date parameters no longer have type annotations. Our template string - that string that used backticks (the  character) - was converted to plain strings with concatenations. More on that second point later, but lets now focus on that first point. Type annotations arent part of JavaScript (or ECMAScript to be pedantic), so there really arent any browsers or other runtimes that can just run TypeScript unmodified. Thats why TypeScript needs a compiler in the first place - it needs some way to strip out or transform any TypeScript-specific code so that you can run it. Most TypeScript-specific code gets erased away, and likewise, here our type annotations were completely erased. Remember: Type annotations never change the runtime behavior of your program. Downleveling One other difference from the above was that our template string was rewritten from jsHello ${person}, today is ${date.toDateString()}!; to js\"Hello \".concat(person, \", today is \").concat(date.toDateString(), \"!\"); Why did this happen? Template strings are a feature from a version of ECMAScript called ECMAScript 2015 (a.k.a. ECMAScript 6, ES2015, ES6, etc. - dont ask). TypeScript has the ability to rewrite code from newer versions of ECMAScript to older ones such as ECMAScript 3 or ECMAScript 5 (a.k.a. ES5). This process of moving from a newer or higher version of ECMAScript down to an older or lower one is sometimes called downleveling. By default TypeScript targets ES5, an extremely old version of ECMAScript. We could have chosen something a little bit more recent by using the target option. Running with --target es2015 changes TypeScript to target ECMAScript 2015, meaning code should be able to run wherever ECMAScript 2015 is supported. So running tsc --target es2015 hello.ts gives us the following output: jsfunction greet(person, date) { console.log(Hello ${person}, today is ${date.toDateString()}!);}greet(\"Maddison\", new Date()); While the default target is ES5, the great majority of current browsers support ES2015. Most developers can therefore safely specify ES2015 or above as a target, unless compatibility with certain ancient browsers is important. Strictness Different users come to TypeScript looking for different things in a type-checker. Some people are looking for a more loose opt-in experience which can help validate only some parts of their program, and still have decent tooling. This is the default experience with TypeScript, where types are optional, inference takes the most lenient types, and theres no checking for potentially null/undefined values. Much like how tsc emits in the face of errors, these defaults are put in place to stay out of your way. If youre migrating existing JavaScript, that might be a desirable first step. In contrast, a lot of users prefer to have TypeScript validate as much as it can straight away, and thats why the language provides strictness settings as well. These strictness settings turn static type-checking from a switch (either your code is checked or not) into something closer to a dial. The further you turn this dial up, the more TypeScript will check for you. This can require a little extra work, but generally speaking it pays for itself in the long run, and enables more thorough checks and more accurate tooling. When possible, a new codebase should always turn these strictness checks on. TypeScript has several type-checking strictness flags that can be turned on or off, and all of our examples will be written with all of them enabled unless otherwise stated. The strict flag in the CLI, or \"strict\": true in a tsconfig.json toggles them all on simultaneously, but we can opt out of them individually. The two biggest ones you should know about are noImplicitAny and strictNullChecks. noImplicitAny Recall that in some places, TypeScript doesnt try to infer types for us and instead falls back to the most lenient type: any. This isnt the worst thing that can happen - after all, falling back to any is just the plain JavaScript experience anyway. However, using any often defeats the purpose of using TypeScript in the first place. The more typed your program is, the more validation and tooling youll get, meaning youll run into fewer bugs as you code. Turning on the noImplicitAny flag will issue an error on any variables whose type is implicitly inferred as any. strictNullChecks By default, values like null and undefined are assignable to any other type. This can make writing some code easier, but forgetting to handle null and undefined is the cause of countless bugs in the world - some consider it a billion dollar mistake! The strictNullChecks flag makes handling null and undefined more explicit, and spares us from worrying about whether we forgot to handle null and undefined.",
    "headings": [
      {
        "level": 2,
        "text": "Static type-checking",
        "id": "static-type-checking"
      },
      {
        "level": 2,
        "text": "Non-exception Failures",
        "id": "non-exception-failures"
      },
      {
        "level": 2,
        "text": "Types for Tooling",
        "id": "types-for-tooling"
      },
      {
        "level": 2,
        "text": "tsc, the TypeScript compiler",
        "id": "tsc-the-typescript-compiler"
      },
      {
        "level": 2,
        "text": "Emitting with Errors",
        "id": "emitting-with-errors"
      },
      {
        "level": 2,
        "text": "Explicit Types",
        "id": "explicit-types"
      },
      {
        "level": 2,
        "text": "Erased Types",
        "id": "erased-types"
      },
      {
        "level": 2,
        "text": "Downleveling",
        "id": "downleveling"
      },
      {
        "level": 2,
        "text": "Strictness",
        "id": "strictness"
      },
      {
        "level": 2,
        "text": "noImplicitAny",
        "id": "noimplicitany"
      },
      {
        "level": 2,
        "text": "strictNullChecks",
        "id": "strictnullchecks"
      }
    ],
    "codeBlocks": [
      {
        "language": "text",
        "code": "js// Accessing the property 'toLowerCase'// on 'message' and then calling itmessage.toLowerCase();// Calling 'message'message();"
      },
      {
        "language": "text",
        "code": "// Accessing the property 'toLowerCase'// on 'message' and then calling itmessage.toLowerCase();// Calling 'message'message();"
      },
      {
        "language": "text",
        "code": "toLowerCase"
      },
      {
        "language": "text",
        "code": "toLowerCase"
      },
      {
        "language": "text",
        "code": "toLowerCase"
      },
      {
        "language": "text",
        "code": "jsconst message = \"Hello World!\";"
      },
      {
        "language": "text",
        "code": "const message = \"Hello World!\";"
      },
      {
        "language": "text",
        "code": "message.toLowerCase()"
      },
      {
        "language": "text",
        "code": "txtTypeError: message is not a function"
      },
      {
        "language": "text",
        "code": "TypeError: message is not a function"
      },
      {
        "language": "text",
        "code": "\"Hello World!\""
      },
      {
        "language": "text",
        "code": "jsfunction fn(x) {  return x.flip();}"
      },
      {
        "language": "text",
        "code": "function fn(x) {  return x.flip();}"
      },
      {
        "language": "text",
        "code": "tsconst message = \"hello!\"; message();This expression is not callable.\n  Type 'String' has no call signatures.2349This expression is not callable.\n  Type 'String' has no call signatures.Try"
      },
      {
        "language": "text",
        "code": "const message = \"hello!\"; message();This expression is not callable.\n  Type 'String' has no call signatures.2349This expression is not callable.\n  Type 'String' has no call signatures."
      },
      {
        "language": "text",
        "code": "jsconst user = {  name: \"Daniel\",  age: 26,};user.location; // returns undefined"
      },
      {
        "language": "text",
        "code": "const user = {  name: \"Daniel\",  age: 26,};user.location; // returns undefined"
      },
      {
        "language": "text",
        "code": "tsconst user = {  name: \"Daniel\",  age: 26,}; user.location;Property 'location' does not exist on type '{ name: string; age: number; }'.2339Property 'location' does not exist on type '{ name: string; age: number; }'.Try"
      },
      {
        "language": "text",
        "code": "const user = {  name: \"Daniel\",  age: 26,}; user.location;Property 'location' does not exist on type '{ name: string; age: number; }'.2339Property 'location' does not exist on type '{ name: string; age: number; }'."
      },
      {
        "language": "text",
        "code": "tsconst announcement = \"Hello World!\"; // How quickly can you spot the typos?announcement.toLocaleLowercase();announcement.toLocalLowerCase(); // We probably meant to write this...announcement.toLocaleLowerCase();Try"
      },
      {
        "language": "text",
        "code": "const announcement = \"Hello World!\"; // How quickly can you spot the typos?announcement.toLocaleLowercase();announcement.toLocalLowerCase(); // We probably meant to write this...announcement.toLocaleLowerCase();"
      },
      {
        "language": "text",
        "code": "tsfunction flipCoin() {  // Meant to be Math.random()  return Math.random < 0.5;Operator '<' cannot be applied to types '() => number' and 'number'.2365Operator '<' cannot be applied to types '() => number' and 'number'.}Try"
      },
      {
        "language": "text",
        "code": "function flipCoin() {  // Meant to be Math.random()  return Math.random < 0.5;Operator '<' cannot be applied to types '() => number' and 'number'.2365Operator '<' cannot be applied to types '() => number' and 'number'.}"
      },
      {
        "language": "text",
        "code": "tsconst value = Math.random() < 0.5 ? \"a\" : \"b\";if (value !== \"a\") {  // ...} else if (value === \"b\") {This comparison appears to be unintentional because the types '\"a\"' and '\"b\"' have no overlap.2367This comparison appears to be unintentional because the types '\"a\"' and '\"b\"' have no overlap.  // Oops, unreachable}Try"
      },
      {
        "language": "text",
        "code": "const value = Math.random() < 0.5 ? \"a\" : \"b\";if (value !== \"a\") {  // ...} else if (value === \"b\") {This comparison appears to be unintentional because the types '\"a\"' and '\"b\"' have no overlap.2367This comparison appears to be unintentional because the types '\"a\"' and '\"b\"' have no overlap.  // Oops, unreachable}"
      },
      {
        "language": "text",
        "code": "tsimport express from \"express\";const app = express(); app.get(\"/\", function (req, res) {  res.sen         sendsendDatesendfilesendFilesendStatus}); app.listen(3000);Try"
      },
      {
        "language": "text",
        "code": "import express from \"express\";const app = express(); app.get(\"/\", function (req, res) {  res.sen         sendsendDatesendfilesendFilesendStatus}); app.listen(3000);"
      },
      {
        "language": "text",
        "code": "shnpm install -g typescript"
      },
      {
        "language": "text",
        "code": "npm install -g typescript"
      },
      {
        "language": "text",
        "code": "node_modules"
      },
      {
        "language": "text",
        "code": "ts// Greets the world.console.log(\"Hello world!\");Try"
      },
      {
        "language": "text",
        "code": "// Greets the world.console.log(\"Hello world!\");"
      },
      {
        "language": "text",
        "code": "shtsc hello.ts"
      },
      {
        "language": "text",
        "code": "tsc hello.ts"
      },
      {
        "language": "text",
        "code": "js// Greets the world.console.log(\"Hello world!\");"
      },
      {
        "language": "text",
        "code": "// Greets the world.console.log(\"Hello world!\");"
      },
      {
        "language": "text",
        "code": "ts// This is an industrial-grade general-purpose greeter function:function greet(person, date) {  console.log(`Hello ${person}, today is ${date}!`);} greet(\"Brendan\");Try"
      },
      {
        "language": "text",
        "code": "// This is an industrial-grade general-purpose greeter function:function greet(person, date) {  console.log(`Hello ${person}, today is ${date}!`);} greet(\"Brendan\");"
      },
      {
        "language": "text",
        "code": "tsc hello.ts"
      },
      {
        "language": "text",
        "code": "txtExpected 2 arguments, but got 1."
      },
      {
        "language": "text",
        "code": "Expected 2 arguments, but got 1."
      },
      {
        "language": "text",
        "code": "noEmitOnError"
      },
      {
        "language": "text",
        "code": "shtsc --noEmitOnError hello.ts"
      },
      {
        "language": "text",
        "code": "tsc --noEmitOnError hello.ts"
      },
      {
        "language": "text",
        "code": "toDateString()"
      },
      {
        "language": "text",
        "code": "tsfunction greet(person: string, date: Date) {  console.log(`Hello ${person}, today is ${date.toDateString()}!`);}Try"
      },
      {
        "language": "text",
        "code": "function greet(person: string, date: Date) {  console.log(`Hello ${person}, today is ${date.toDateString()}!`);}"
      },
      {
        "language": "text",
        "code": "tsfunction greet(person: string, date: Date) {  console.log(`Hello ${person}, today is ${date.toDateString()}!`);} greet(\"Maddison\", Date());Argument of type 'string' is not assignable to parameter of type 'Date'.2345Argument of type 'string' is not assignable to parameter of type 'Date'.Try"
      },
      {
        "language": "text",
        "code": "function greet(person: string, date: Date) {  console.log(`Hello ${person}, today is ${date.toDateString()}!`);} greet(\"Maddison\", Date());Argument of type 'string' is not assignable to parameter of type 'Date'.2345Argument of type 'string' is not assignable to parameter of type 'Date'."
      },
      {
        "language": "text",
        "code": "tsfunction greet(person: string, date: Date) {  console.log(`Hello ${person}, today is ${date.toDateString()}!`);} greet(\"Maddison\", new Date());Try"
      },
      {
        "language": "text",
        "code": "function greet(person: string, date: Date) {  console.log(`Hello ${person}, today is ${date.toDateString()}!`);} greet(\"Maddison\", new Date());"
      },
      {
        "language": "text",
        "code": "tslet msg = \"hello there!\";    let msg: stringTry"
      },
      {
        "language": "text",
        "code": "let msg = \"hello there!\";    let msg: string"
      },
      {
        "language": "text",
        "code": "ts\"use strict\";function greet(person, date) {    console.log(\"Hello \".concat(person, \", today is \").concat(date.toDateString(), \"!\"));}greet(\"Maddison\", new Date()); Try"
      },
      {
        "language": "text",
        "code": "\"use strict\";function greet(person, date) {    console.log(\"Hello \".concat(person, \", today is \").concat(date.toDateString(), \"!\"));}greet(\"Maddison\", new Date());"
      },
      {
        "language": "text",
        "code": "js`Hello ${person}, today is ${date.toDateString()}!`;"
      },
      {
        "language": "text",
        "code": "`Hello ${person}, today is ${date.toDateString()}!`;"
      },
      {
        "language": "text",
        "code": "js\"Hello \".concat(person, \", today is \").concat(date.toDateString(), \"!\");"
      },
      {
        "language": "text",
        "code": "\"Hello \".concat(person, \", today is \").concat(date.toDateString(), \"!\");"
      },
      {
        "language": "text",
        "code": "--target es2015"
      },
      {
        "language": "text",
        "code": "tsc --target es2015 hello.ts"
      },
      {
        "language": "text",
        "code": "jsfunction greet(person, date) {  console.log(`Hello ${person}, today is ${date.toDateString()}!`);}greet(\"Maddison\", new Date());"
      },
      {
        "language": "text",
        "code": "function greet(person, date) {  console.log(`Hello ${person}, today is ${date.toDateString()}!`);}greet(\"Maddison\", new Date());"
      },
      {
        "language": "text",
        "code": "\"strict\": true"
      },
      {
        "language": "text",
        "code": "tsconfig.json"
      },
      {
        "language": "text",
        "code": "noImplicitAny"
      },
      {
        "language": "text",
        "code": "strictNullChecks"
      },
      {
        "language": "text",
        "code": "noImplicitAny"
      },
      {
        "language": "text",
        "code": "noImplicitAny"
      },
      {
        "language": "text",
        "code": "strictNullChecks"
      },
      {
        "language": "text",
        "code": "strictNullChecks"
      }
    ],
    "links": [
      {
        "text": "Try",
        "href": "https://www.typescriptlang.org/play/#code/PTAEAEFMCdoe2gZwFygEwGYAsBOAUAMZwB2iALqALaSKICGA5pKALygBEAFpADY9wBCdgG48earUaQAFAEphQA"
      },
      {
        "text": "the ECMAScript specification",
        "href": "https://tc39.github.io/ecma262/"
      },
      {
        "text": "Try",
        "href": "https://www.typescriptlang.org/play/#code/PTAEAEFMCdoe2gZwFygEwGYME4BQBjOAO0QBdQBXRGUAXlAG9dRQiBDAW0lQCIARNkQCWkADY8ANM1BsA5t3QA2KQF8A3LlxUYAOlFx8bUkOJqgA"
      },
      {
        "text": "Try",
        "href": "https://www.typescriptlang.org/play/#code/PTAEAEDsHsFECd7XgZwFAGNqRQF1AIaQwCukGApgLYWT4C8oARABIUA270oA6suwBMAhEwDcaNCFAtoAd1ABHEgEsMAa3YBPUBiKhN0EqBQAHaPlwALCqFyazKAPxoipctVq4AdLmgAZaF12CgDZCnhdFAoACgBKcVdDdxo6H39AgnZQ8IBhAii48UkwHhsTJAAjAgqtUBoiC25ZeGVcGytlFC9ul2IkyhTvXwCgkLlc-Jj4oA"
      },
      {
        "text": "Try",
        "href": "https://www.typescriptlang.org/play/#code/PTAEAEDsHsFVIK4GcCmATAMtAxgQwDZIBQIEKATudOUgFygBMAzAGwCsRAZgpNgC4BLaJFCd8AgA4BhaAMgAKAJSgA3kVChSAWRS5IfUH2igARilBbcfABYA6cnrTQAtkvWhyKPgnIjLN+0cXUAAeUAAGWzYAbiIAXyA"
      },
      {
        "text": "Try",
        "href": "https://www.typescriptlang.org/play/#code/PTAEAEFMCdoe2gZwFygEwGYBsB2AUAMZwB2iALqAG4CGANgK6SgC8oAstWQBYB001xACZwAtgAoAlKAA8oAAw8ArKAD8oAETV1oVOoBG6gNx4AlgDNQYmgyYBCZq03qpAbzyhQIUDx94AvqCQtIhM5pbWjCwOGgau7p5gAPJwAA6IADSg9MTQkNQEXNR6tJD+QA"
      },
      {
        "text": "Try",
        "href": "https://www.typescriptlang.org/play/#code/PTAEAEDsHsFECd7XgZwFAggUxQWWgCYCuANlgJKQAuWSADmgJYC2dyVoWAHnfDiqABmSZqABE3XvzEBuNAGNokFBwCGdOqAC8nHnxQoAFAEo5adXQB0AcyxVDY4GIA0QopHlVGS0Ib4BHV31jUABvNFBQfUsULEgMMEik0AA9AB80AF9TNHMNSxJGFTjDAGYABkrTIA"
      },
      {
        "text": "your favorite editor has TypeScript support available",
        "href": "https://github.com/Microsoft/TypeScript/wiki/TypeScript-Editor-Support"
      },
      {
        "text": "Try",
        "href": "https://www.typescriptlang.org/play/#code/PTAEHECcFNoFwM6jgC2qA7ge0gGwCYB0AUAMZYB2CWu0huWA5gBQBEAEtLg5jgQISsAlAG4gA"
      },
      {
        "text": "Try",
        "href": "https://www.typescriptlang.org/play/#code/PTAEAEDsHsFECd7XgZwFAlAFQBYEsVQDQBDSIyAEwFcUAXePEgGwFoBzeEygU1HZ6QeXNgAdq8UdBR9OPHnWGgAZtUgBjOnmiQAXGlUatO-vHl0AFKOEodAGlCUSigJSgA3mlCh1O28x4AOmZodgsAAwAJHmYQ0AASd2tUHQBfBzpoJwBPIkJEp0VUgEJwlwBuNFS0NDkFCwAiACEzKjIGiqA"
      },
      {
        "text": "noEmitOnError",
        "href": "/tsconfig#noEmitOnError"
      },
      {
        "text": "Try",
        "href": "https://www.typescriptlang.org/play/#code/GYVwdgxgLglg9mABAcwE4FN1QBQAd2oDOCAXIoVKjGMgDSIAmAhlOmQCIvoCUiA3gChEiCAmIAbdADpxcZNgAGACXTjZiACR98RBAF96UOMwCeiGIU19mrKUc6sAypWrzuegIQLuAbgF6gA"
      },
      {
        "text": "Try",
        "href": "https://www.typescriptlang.org/play/#code/PTAEAEFMCdoe2gZwFygEwGYAsBWAUAGYCuAdgMYAuAlnCaAObSSQUAUADjIraohdFRL0ANKAAmAQwqRUAESmQAlKADeeUKDK1uAG0gA6HXHqsABgAlIOo6AAkKzkloBfURTiSAnqCqI7KyWl9d3lpAGV+QRNFZwBCU0UAbjxnPDxGZjYAIgBZCTExX1os0VDIVkUkoA"
      },
      {
        "text": "Try",
        "href": "https://www.typescriptlang.org/play/#code/GYVwdgxgLglg9mABAcwE4FN1QBQAd2oDOCAXIoVKjGMgDSIAmAhlOmQCIvoCUiA3gChEiCAmIAbdADpxcZNgAGACXTjZiACR98RBAF96UOMwCeiGIU19mrKUc6sAypWrzuegIQLuAbgF6BATRMHAAiAFkmBgYLBFD6MHQAd0QHdGxuXyA"
      },
      {
        "text": "Try",
        "href": "https://www.typescriptlang.org/play/#code/DYUwLgBAtgzg5hAvBARACxMYB7CYMBOIAhCgNwBQA9FRBAHoD8QA"
      },
      {
        "text": "Try",
        "href": "https://www.typescriptlang.org/play/#code/PTAEAEGcAsHsHcCiBbAlgFwFAgughgE4DmApugFygmQCsmAZgK4B2AxuqrM6EQSWQAoADiQKQulSOgKpmRADSgAJnnQlKAEVUkAlKADemUKFZdxAGxIA6c7CICABgAkS526AAk+kWK4BfRXRYFQBPUFRIT30VNSsgrTUAZWlZex0-AEIHHQBuTD9MTF5+dAEAIgBZPCUlCK4yxWYSeFAEkgEdXKA"
      },
      {
        "text": "target",
        "href": "/tsconfig#target"
      },
      {
        "text": "strict",
        "href": "/tsconfig#strict"
      },
      {
        "text": "tsconfig.json",
        "href": "https://www.typescriptlang.org/docs/handbook/tsconfig-json.html"
      },
      {
        "text": "noImplicitAny",
        "href": "/tsconfig#noImplicitAny"
      },
      {
        "text": "strictNullChecks",
        "href": "/tsconfig#strictNullChecks"
      },
      {
        "text": "noImplicitAny",
        "href": "/tsconfig#noImplicitAny"
      },
      {
        "text": "billion dollar mistake",
        "href": "https://www.youtube.com/watch?v=ybrQvs4x0Ps"
      },
      {
        "text": "strictNullChecks",
        "href": "/tsconfig#strictNullChecks"
      }
    ],
    "meta": {
      "description": "Step one in learning TypeScript: The basic types.",
      "keywords": ""
    },
    "summary": "Each and every value in JavaScript has a set of behaviors you can observe from running different operations",
    "tags": [
      "react",
      "angular",
      "javascript",
      "typescript",
      "html",
      "node",
      "vite",
      "types",
      "documentation",
      "static"
    ],
    "id": "typescript-documentation-basictypeshtml-part-1",
    "quality": 100
  },
  {
    "title": "TypeScript: Documentation",
    "url": "https://www.typescriptlang.org/docs/handbook/2/objects.html",
    "category": "typescript",
    "content": "In JavaScript, the fundamental way that we group and pass around data is through objects. In TypeScript, we represent those through object types. As weve seen, they can be anonymous: tsfunction greet(person: { name: string; age: number }) { return \"Hello \" + person.name;}Try or they can be named by using either an interface: tsinterface Person { name: string; age: number;} function greet(person: Person) { return \"Hello \" + person.name;}Try or a type alias: tstype Person = { name: string; age: number;}; function greet(person: Person) { return \"Hello \" + person.name;}Try In all three examples above, weve written functions that take objects that contain the property name (which must be a string) and age (which must be a number). Quick Reference We have cheat-sheets available for both type and interface, if you want a quick look at the important every-day syntax at a glance. Property Modifiers Each property in an object type can specify a couple of things: the type, whether the property is optional, and whether the property can be written to. Optional Properties Much of the time, well find ourselves dealing with objects that might have a property set. In those cases, we can mark those properties as optional by adding a question mark (?) to the end of their names. tsinterface PaintOptions { shape: Shape; xPos?: number; yPos?: number;} function paintShape(opts: PaintOptions) { // ...} const shape = getShape();paintShape({ shape });paintShape({ shape, xPos: 100 });paintShape({ shape, yPos: 100 });paintShape({ shape, xPos: 100, yPos: 100 });Try In this example, both xPos and yPos are considered optional. We can choose to provide either of them, so every call above to paintShape is valid. All optionality really says is that if the property is set, it better have a specific type. We can also read from those properties - but when we do under strictNullChecks, TypeScript will tell us theyre potentially undefined. tsfunction paintShape(opts: PaintOptions) { let xPos = opts.xPos; (property) PaintOptions.xPos?: number  undefined let yPos = opts.yPos; (property) PaintOptions.yPos?: number  undefined // ...}Try In JavaScript, even if the property has never been set, we can still access it - its just going to give us the value undefined. We can just handle undefined specially by checking for it. tsfunction paintShape(opts: PaintOptions) { let xPos = opts.xPos === undefined ? 0 : opts.xPos; let xPos: number let yPos = opts.yPos === undefined ? 0 : opts.yPos; let yPos: number // ...}Try Note that this pattern of setting defaults for unspecified values is so common that JavaScript has syntax to support it. tsfunction paintShape({ shape, xPos = 0, yPos = 0 }: PaintOptions) { console.log(\"x coordinate at\", xPos); (parameter) xPos: number console.log(\"y coordinate at\", yPos); (parameter) yPos: number // ...}Try Here we used a destructuring pattern for paintShapes parameter, and provided default values for xPos and yPos. Now xPos and yPos are both definitely present within the body of paintShape, but optional for any callers to paintShape. Note that there is currently no way to place type annotations within destructuring patterns. This is because the following syntax already means something different in JavaScript. tsfunction draw({ shape: Shape, xPos: number = 100 /*...*/ }) { render(shape);Cannot find name 'shape'. Did you mean 'Shape'?2552Cannot find name 'shape'. Did you mean 'Shape'? render(xPos);Cannot find name 'xPos'.2304Cannot find name 'xPos'.}Try In an object destructuring pattern, shape: Shape means grab the property shape and redefine it locally as a variable named Shape. Likewise xPos: number creates a variable named number whose value is based on the parameters xPos. readonly Properties Properties can also be marked as readonly for TypeScript. While it wont change any behavior at runtime, a property marked as readonly cant be written to during type-checking. tsinterface SomeType { readonly prop: string;} function doSomething(obj: SomeType) { // We can read from 'obj.prop'. console.log(prop has the value '${obj.prop}'.); // But we can't re-assign it. obj.prop = \"hello\";Cannot assign to 'prop' because it is a read-only property.2540Cannot assign to 'prop' because it is a read-only property.}Try Using the readonly modifier doesnt necessarily imply that a value is totally immutable - or in other words, that its internal contents cant be changed. It just means the property itself cant be re-written to. tsinterface Home { readonly resident: { name: string; age: number };} function visitForBirthday(home: Home) { // We can read and update properties from 'home.resident'. console.log(Happy birthday ${home.resident.name}!); home.resident.age++;} function evict(home: Home) { // But we can't write to the 'resident' property itself on a 'Home'. home.resident = {Cannot assign to 'resident' because it is a read-only property.2540Cannot assign to 'resident' because it is a read-only property. name: \"Victor the Evictor\", age: 42, };}Try Its important to manage expectations of what readonly implies. Its useful to signal intent during development time for TypeScript on how an object should be used. TypeScript doesnt factor in whether properties on two types are readonly when checking whether those types are compatible, so readonly properties can also change via aliasing. tsinterface Person { name: string; age: number;} interface ReadonlyPerson { readonly name: string; readonly age: number;} let writablePerson: Person = { name: \"Person McPersonface\", age: 42,}; // workslet readonlyPerson: ReadonlyPerson = writablePerson; console.log(readonlyPerson.age); // prints '42'writablePerson.age++;console.log(readonlyPerson.age); // prints '43'Try Using mapping modifiers, you can remove readonly attributes. Index Signatures Sometimes you dont know all the names of a types properties ahead of time, but you do know the shape of the values. In those cases you can use an index signature to describe the types of possible values, for example: tsinterface StringArray { [index: number]: string;} const myArray: StringArray = getStringArray();const secondItem = myArray[1]; const secondItem: stringTry Above, we have a StringArray interface which has an index signature. This index signature states that when a StringArray is indexed with a number, it will return a string. Only some types are allowed for index signature properties: string, number, symbol, template string patterns, and union types consisting only of these. It is possible to support multiple types of indexers... It is possible to support multiple types of indexers. Note that when using both number and string indexers, the type returned from a numeric indexer must be a subtype of the type returned from the string indexer. This is because when indexing with a number, JavaScript will actually convert that to a string before indexing into an object. That means that indexing with 100 (a number) is the same thing as indexing with \"100\" (a string), so the two need to be consistent. tsinterface Animal { name: string;} interface Dog extends Animal { breed: string;} // Error: indexing with a numeric string might get you a completely separate type of Animal!interface NotOkay { [x: number]: Animal;'number' index type 'Animal' is not assignable to 'string' index type 'Dog'.2413'number' index type 'Animal' is not assignable to 'string' index type 'Dog'. [x: string]: Dog;}Try While string index signatures are a powerful way to describe the dictionary pattern, they also enforce that all properties match their return type. This is because a string index declares that obj.property is also available as obj[\"property\"]. In the following example, names type does not match the string indexs type, and the type checker gives an error: tsinterface NumberDictionary { [index: string]: number; length: number; // ok name: string;Property 'name' of type 'string' is not assignable to 'string' index type 'number'.2411Property 'name' of type 'string' is not assignable to 'string' index type 'number'.}Try However, properties of different types are acceptable if the index signature is a union of the property types: tsinterface NumberOrStringDictionary { [index: string]: number  string; length: number; // ok, length is a number name: string; // ok, name is a string}Try Finally, you can make index signatures readonly in order to prevent assignment to their indices: tsinterface ReadonlyStringArray { readonly [index: number]: string;} let myArray: ReadonlyStringArray = getReadOnlyStringArray();myArray[2] = \"Mallory\";Index signature in type 'ReadonlyStringArray' only permits reading.2542Index signature in type 'ReadonlyStringArray' only permits reading.Try You cant set myArray[2] because the index signature is readonly. Excess Property Checks Where and how an object is assigned a type can make a difference in the type system. One of the key examples of this is in excess property checking, which validates the object more thoroughly when it is created and assigned to an object type during creation. tsinterface SquareConfig { color?: string; width?: number;} function createSquare(config: SquareConfig): { color: string; area: number } { return { color: config.color  \"red\", area: config.width ? config.width * config.width : 20, };} let mySquare = createSquare({ colour: \"red\", width: 100 });Object literal may only specify known properties, but 'colour' does not exist in type 'SquareConfig'. Did you mean to write 'color'?2561Object literal may only specify known properties, but 'colour' does not exist in type 'SquareConfig'. Did you mean to write 'color'?Try Notice the given argument to createSquare is spelled colour instead of color. In plain JavaScript, this sort of thing fails silently. You could argue that this program is correctly typed, since the width properties are compatible, theres no color property present, and the extra colour property is insignificant. However, TypeScript takes the stance that theres probably a bug in this code. Object literals get special treatment and undergo excess property checking when assigning them to other variables, or passing them as arguments. If an object literal has any properties that the target type doesnt have, youll get an error: tslet mySquare = createSquare({ colour: \"red\", width: 100 });Object literal may only specify known properties, but 'colour' does not exist in type 'SquareConfig'. Did you mean to write 'color'?2561Object literal may only specify known properties, but 'colour' does not exist in type 'SquareConfig'. Did you mean to write 'color'?Try Getting around these checks is actually really simple. The easiest method is to just use a type assertion: tslet mySquare = createSquare({ width: 100, opacity: 0.5 } as SquareConfig);Try However, a better approach might be to add a string index signature if youre sure that the object can have some extra properties that are used in some special way. If SquareConfig can have color and width properties with the above types, but could also have any number of other properties, then we could define it like so: tsinterface SquareConfig { color?: string; width?: number; [propName: string]: unknown;}Try Here were saying that SquareConfig can have any number of properties, and as long as they arent color or width, their types dont matter. One final way to get around these checks, which might be a bit surprising, is to assign the object to another variable: Since assigning squareOptions wont undergo excess property checks, the compiler wont give you an error: tslet squareOptions = { colour: \"red\", width: 100 };let mySquare = createSquare(squareOptions);Try The above workaround will work as long as you have a common property between squareOptions and SquareConfig. In this example, it was the property width. It will however, fail if the variable does not have any common object property. For example: tslet squareOptions = { colour: \"red\" };let mySquare = createSquare(squareOptions);Type '{ colour: string; }' has no properties in common with type 'SquareConfig'.2559Type '{ colour: string; }' has no properties in common with type 'SquareConfig'.Try Keep in mind that for simple code like above, you probably shouldnt be trying to get around these checks. For more complex object literals that have methods and hold state, you might need to keep these techniques in mind, but a majority of excess property errors are actually bugs. That means if youre running into excess property checking problems for something like option bags, you might need to revise some of your type declarations. In this instance, if its okay to pass an object with both a color or colour property to createSquare, you should fix up the definition of SquareConfig to reflect that. Extending Types Its pretty common to have types that might be more specific versions of other types. For example, we might have a BasicAddress type that describes the fields necessary for sending letters and packages in the U.S. tsinterface BasicAddress { name?: string; street: string; city: string; country: string; postalCode: string;}Try In some situations thats enough, but addresses often have a unit number associated with them if the building at an address has multiple units. We can then describe an AddressWithUnit. tsinterface AddressWithUnit { name?: string; unit: string; street: string; city: string; country: string; postalCode: string;}Try This does the job, but the downside here is that we had to repeat all the other fields from BasicAddress when our changes were purely additive. Instead, we can extend the original BasicAddress type and just add the new fields that are unique to AddressWithUnit. tsinterface BasicAddress { name?: string; street: string; city: string; country: string; postalCode: string;} interface AddressWithUnit extends BasicAddress { unit: string;}Try The extends keyword on an interface allows us to effectively copy members from other named types, and add whatever new members we want. This can be useful for cutting down the amount of type declaration boilerplate we have to write, and for signaling intent that several different declarations of the same property might be related. For example, AddressWithUnit didnt need to repeat the street property, and because street originates from BasicAddress, a reader will know that those two types are related in some way. interfaces can also extend from multiple types. tsinterface Colorful { color: string;} interface Circle { radius: number;} interface ColorfulCircle extends Colorful, Circle {} const cc: ColorfulCircle = { color: \"red\", radius: 42,};Try Intersection Types interfaces allowed us to build up new types from other types by extending them. TypeScript provides another construct called intersection types that is mainly used to combine existing object types. An intersection type is defined using the & operator. tsinterface Colorful { color: string;}interface Circle { radius: number;} type ColorfulCircle = Colorful & Circle;Try Here, weve intersected Colorful and Circle to produce a new type that has all the members of Colorful and Circle. tsfunction draw(circle: Colorful & Circle) { console.log(Color was ${circle.color}); console.log(Radius was ${circle.radius});} // okaydraw({ color: \"blue\", radius: 42 }); // oopsdraw({ color: \"red\", raidus: 42 });Object literal may only specify known properties, but 'raidus' does not exist in type 'Colorful & Circle'. Did you mean to write 'radius'?2561Object literal may only specify known properties, but 'raidus' does not exist in type 'Colorful & Circle'. Did you mean to write 'radius'?Try Interface Extension vs. Intersection We just looked at two ways to combine types which are similar, but are actually subtly different. With interfaces, we could use an extends clause to extend from other types, and we were able to do something similar with intersections and name the result with a type alias. The principal difference between the two is how conflicts are handled, and that difference is typically one of the main reasons why youd pick one over the other between an interface and a type alias of an intersection type. If interfaces are defined with the same name, TypeScript will attempt to merge them if the properties are compatible. If the properties are not compatible (i.e., they have the same property name but different types), TypeScript will raise an error. In the case of intersection types, properties with different types will be merged automatically. When the type is used later, TypeScript will expect the property to satisfy both types simultaneously, which may produce unexpected results. For example, the following code will throw an error because the properties are incompatible: tsinterface Person { name: string;}interface Person { name: number;} In contrast, the following code will compile, but it results in a never type: tsinterface Person1 { name: string;} interface Person2 { name: number;} type Staff = Person1 & Person2 declare const staffer: Staff;staffer.name; (property) name: neverTry In this case, Staff would require the name property to be both a string and a number, which results in property being of type never. Generic Object Types Lets imagine a Box type that can contain any value - strings, numbers, Giraffes, whatever. tsinterface Box { contents: any;}Try Right now, the contents property is typed as any, which works, but can lead to accidents down the line. We could instead use unknown, but that would mean that in cases where we already know the type of contents, wed need to do precautionary checks, or use error-prone type assertions. tsinterface Box { contents: unknown;} let x: Box = { contents: \"hello world\",}; // we could check 'x.contents'if (typeof x.contents === \"string\") { console.log(x.contents.toLowerCase());} // or we could use a type assertionconsole.log((x.contents as string).toLowerCase());Try One type safe approach would be to instead scaffold out different Box types for every type of contents. tsinterface NumberBox { contents: number;} interface StringBox { contents: string;} interface BooleanBox { contents: boolean;}Try But that means well have to create different functions, or overloads of functions, to operate on these types. tsfunction setContents(box: StringBox, newContents: string): void;function setContents(box: NumberBox, newContents: number): void;function setContents(box: BooleanBox, newContents: boolean): void;function setContents(box: { contents: any }, newContents: any) { box.contents = newContents;}Try Thats a lot of boilerplate. Moreover, we might later need to introduce new types and overloads. This is frustrating, since our box types and overloads are all effectively the same. Instead, we can make a generic Box type which declares a type parameter. tsinterface BoxType { contents: Type;}Try You might read this as A Box of Type is something whose contents have type Type. Later on, when we refer to Box, we have to give a type argument in place of Type. tslet box: Boxstring;Try Think of Box as a template for a real type, where Type is a placeholder that will get replaced with some other type. When TypeScript sees Boxstring, it will replace every instance of Type in BoxType with string, and end up working with something like { contents: string }. In other words, Boxstring and our earlier StringBox work identically. tsinterface BoxType { contents: Type;}interface StringBox { contents: string;} let boxA: Boxstring = { contents: \"hello\" };boxA.contents; (property) Boxstring.contents: string let boxB: StringBox = { contents: \"world\" };boxB.contents; (property) StringBox.contents: stringTry Box is reusable in that Type can be substituted with anything. That means that when we need a box for a new type, we dont need to declare a new Box type at all (though we certainly could if we wanted to). tsinterface BoxType { contents: Type;} interface Apple { // ....} // Same as '{ contents: Apple }'.type AppleBox = BoxApple;Try This also means that we can avoid overloads entirely by instead using generic functions. tsfunction setContentsType(box: BoxType, newContents: Type) { box.contents = newContents;}Try It is worth noting that type aliases can also be generic. We could have defined our new BoxType interface, which was: tsinterface BoxType { contents: Type;}Try by using a type alias instead: tstype BoxType = { contents: Type;};Try Since type aliases, unlike interfaces, can describe more than just object types, we can also use them to write other kinds of generic helper types. tstype OrNullType = Type  null; type OneOrManyType = Type  Type[]; type OneOrManyOrNullType = OrNullOneOrManyType; type OneOrManyOrNullType = OneOrManyType  null type OneOrManyOrNullStrings = OneOrManyOrNullstring; type OneOrManyOrNullStrings = OneOrManystring  nullTry Well circle back to type aliases in just a little bit. The Array Type Generic object types are often some sort of container type that work independently of the type of elements they contain. Its ideal for data structures to work this way so that theyre re-usable across different data types. It turns out weve been working with a type just like that throughout this handbook: the Array type. Whenever we write out types like number[] or string[], thats really just a shorthand for Arraynumber and Arraystring. tsfunction doSomething(value: Arraystring) { // ...} let myArray: string[] = [\"hello\", \"world\"]; // either of these work!doSomething(myArray);doSomething(new Array(\"hello\", \"world\"));Try Much like the Box type above, Array itself is a generic type. tsinterface ArrayType { /** * Gets or sets the length of the array. */ length: number; /** * Removes the last element from an array and returns it. */ pop(): Type  undefined; /** * Appends new elements to an array, and returns the new length of the array. */ push(...items: Type[]): number; // ...}Try Modern JavaScript also provides other data structures which are generic, like MapK, V, SetT, and PromiseT. All this really means is that because of how Map, Set, and Promise behave, they can work with any sets of types. The ReadonlyArray Type The ReadonlyArray is a special type that describes arrays that shouldnt be changed. tsfunction doStuff(values: ReadonlyArraystring) { // We can read from 'values'... const copy = values.slice(); console.log(The first value is ${values[0]}); // ...but we can't mutate 'values'. values.push(\"hello!\");Property 'push' does not exist on type 'readonly string[]'.2339Property 'push' does not exist on type 'readonly string[]'.}Try Much like the readonly modifier for properties, its mainly a tool we can use for intent. When we see a function that returns ReadonlyArrays, it tells us were not meant to change the contents at all, and when we see a function that consumes ReadonlyArrays, it tells us that we can pass any array into that function without worrying that it will change its contents. Unlike Array, there isnt a ReadonlyArray constructor that we can use. tsnew ReadonlyArray(\"red\", \"green\", \"blue\");'ReadonlyArray' only refers to a type, but is being used as a value here.2693'ReadonlyArray' only refers to a type, but is being used as a value here.Try Instead, we can assign regular Arrays to ReadonlyArrays. tsconst roArray: ReadonlyArraystring = [\"red\", \"green\", \"blue\"];Try Just as TypeScript provides a shorthand syntax for ArrayType with Type[], it also provides a shorthand syntax for ReadonlyArrayType with readonly Type[]. tsfunction doStuff(values: readonly string[]) { // We can read from 'values'... const copy = values.slice(); console.log(The first value is ${values[0]}); // ...but we can't mutate 'values'. values.push(\"hello!\");Property 'push' does not exist on type 'readonly string[]'.2339Property 'push' does not exist on type 'readonly string[]'.}Try One last thing to note is that unlike the readonly property modifier, assignability isnt bidirectional between regular Arrays and ReadonlyArrays. tslet x: readonly string[] = [];let y: string[] = []; x = y;y = x;The type 'readonly string[]' is 'readonly' and cannot be assigned to the mutable type 'string[]'.4104The type 'readonly string[]' is 'readonly' and cannot be assigned to the mutable type 'string[]'.Try Tuple Types A tuple type is another sort of Array type that knows exactly how many elements it contains, and exactly which types it contains at specific positions. tstype StringNumberPair = [string, number];Try Here, StringNumberPair is a tuple type of string and number. Like ReadonlyArray, it has no representation at runtime, but is significant to TypeScript. To the type system, StringNumberPair describes arrays whose 0 index contains a string and whose 1 index contains a number. tsfunction doSomething(pair: [string, number]) { const a = pair[0]; const a: string const b = pair[1]; const b: number // ...} doSomething([\"hello\", 42]);Try If we try to index past the number of elements, well get an error. tsfunction doSomething(pair: [string, number]) { // ... const c = pair[2];Tuple type '[string, number]' of length '2' has no element at index '2'.2493Tuple type '[string, number]' of length '2' has no element at index '2'.}Try We can also destructure tuples using JavaScripts array destructuring. tsfunction doSomething(stringHash: [string, number]) { const [inputString, hash] = stringHash; console.log(inputString); const inputString: string console.log(hash); const hash: number}Try Tuple types are useful in heavily convention-based APIs, where each elements meaning is obvious. This gives us flexibility in whatever we want to name our variables when we destructure them. In the above example, we were able to name elements 0 and 1 to whatever we wanted. However, since not every user holds the same view of whats obvious, it may be worth reconsidering whether using objects with descriptive property names may be better for your API. Other than those length checks, simple tuple types like these are equivalent to types which are versions of Arrays that declare properties for specific indexes, and that declare length with a numeric literal type. tsinterface StringNumberPair { // specialized properties length: 2; 0: string; 1: number; // Other 'Arraystring  number' members... slice(start?: number, end?: number): Arraystring  number;}Try Another thing you may be interested in is that tuples can have optional properties by writing out a question mark (? after an elements type). Optional tuple elements can only come at the end, and also affect the type of length. tstype Either2dOr3d = [number, number, number?]; function setCoordinate(coord: Either2dOr3d) { const [x, y, z] = coord; const z: number  undefined console.log(Provided coordinates had ${coord.length} dimensions); (property) length: 2  3}Try Tuples can also have rest elements, which have to be an array/tuple type. tstype StringNumberBooleans = [string, number, ...boolean[]];type StringBooleansNumber = [string, ...boolean[], number];type BooleansStringNumber = [...boolean[], string, number];Try StringNumberBooleans describes a tuple whose first two elements are string and number respectively, but which may have any number of booleans following. StringBooleansNumber describes a tuple whose first element is string and then any number of booleans and ending with a number. BooleansStringNumber describes a tuple whose starting elements are any number of booleans and ending with a string then a number. A tuple with a rest element has no set length - it only has a set of well-known elements in different positions. tsconst a: StringNumberBooleans = [\"hello\", 1];const b: StringNumberBooleans = [\"beautiful\", 2, true];const c: StringNumberBooleans = [\"world\", 3, true, false, true, false, true];Try Why might optional and rest elements be useful? Well, it allows TypeScript to correspond tuples with parameter lists. Tuples types can be used in rest parameters and arguments, so that the following: tsfunction readButtonInput(...args: [string, number, ...boolean[]]) { const [name, version, ...input] = args; // ...}Try is basically equivalent to: tsfunction readButtonInput(name: string, version: number, ...input: boolean[]) { // ...}Try This is handy when you want to take a variable number of arguments with a rest parameter, and you need a minimum number of elements, but you dont want to introduce intermediate variables. readonly Tuple Types One final note about tuple types - tuple types have readonly variants, and can be specified by sticking a readonly modifier in front of them - just like with array shorthand syntax. tsfunction doSomething(pair: readonly [string, number]) { // ...}Try As you might expect, writing to any property of a readonly tuple isnt allowed in TypeScript. tsfunction doSomething(pair: readonly [string, number]) { pair[0] = \"hello!\";Cannot assign to '0' because it is a read-only property.2540Cannot assign to '0' because it is a read-only property.}Try Tuples tend to be created and left un-modified in most code, so annotating types as readonly tuples when possible is a good default. This is also important given that array literals with const assertions will be inferred with readonly tuple types. tslet point = [3, 4] as const; function distanceFromOrigin([x, y]: [number, number]) { return Math.sqrt(x ** 2 + y ** 2);} distanceFromOrigin(point);Argument of type 'readonly [3, 4]' is not assignable to parameter of type '[number, number]'. The type 'readonly [3, 4]' is 'readonly' and cannot be assigned to the mutable type '[number, number]'.2345Argument of type 'readonly [3, 4]' is not assignable to parameter of type '[number, number]'. The type 'readonly [3, 4]' is 'readonly' and cannot be assigned to the mutable type '[number, number]'.Try Here, distanceFromOrigin never modifies its elements, but expects a mutable tuple. Since points type was inferred as readonly [3, 4], it wont be compatible with [number, number] since that type cant guarantee points elements wont be mutated.",
    "headings": [
      {
        "level": 2,
        "text": "Quick Reference",
        "id": "quick-reference"
      },
      {
        "level": 2,
        "text": "Property Modifiers",
        "id": "property-modifiers"
      },
      {
        "level": 2,
        "text": "Excess Property Checks",
        "id": "excess-property-checks"
      },
      {
        "level": 2,
        "text": "Extending Types",
        "id": "extending-types"
      },
      {
        "level": 2,
        "text": "Intersection Types",
        "id": "intersection-types"
      },
      {
        "level": 2,
        "text": "Interface Extension vs. Intersection",
        "id": "interface-extension-vs-intersection"
      },
      {
        "level": 2,
        "text": "Generic Object Types",
        "id": "generic-object-types"
      },
      {
        "level": 3,
        "text": "Optional Properties",
        "id": "optional-properties"
      },
      {
        "level": 3,
        "text": "readonly Properties",
        "id": "readonly-properties"
      },
      {
        "level": 3,
        "text": "Index Signatures",
        "id": "index-signatures"
      },
      {
        "level": 3,
        "text": "The Array Type",
        "id": "the-array-type"
      },
      {
        "level": 3,
        "text": "The ReadonlyArray Type",
        "id": "the-readonlyarray-type"
      },
      {
        "level": 3,
        "text": "Tuple Types",
        "id": "tuple-types"
      },
      {
        "level": 3,
        "text": "readonly Tuple Types",
        "id": "readonly-tuple-types"
      }
    ],
    "codeBlocks": [
      {
        "language": "text",
        "code": "tsfunction greet(person: { name: string; age: number }) {  return \"Hello \" + person.name;}Try"
      },
      {
        "language": "text",
        "code": "function greet(person: { name: string; age: number }) {  return \"Hello \" + person.name;}"
      },
      {
        "language": "text",
        "code": "tsinterface Person {  name: string;  age: number;} function greet(person: Person) {  return \"Hello \" + person.name;}Try"
      },
      {
        "language": "text",
        "code": "interface Person {  name: string;  age: number;} function greet(person: Person) {  return \"Hello \" + person.name;}"
      },
      {
        "language": "text",
        "code": "tstype Person = {  name: string;  age: number;}; function greet(person: Person) {  return \"Hello \" + person.name;}Try"
      },
      {
        "language": "text",
        "code": "type Person = {  name: string;  age: number;}; function greet(person: Person) {  return \"Hello \" + person.name;}"
      },
      {
        "language": "text",
        "code": "tsinterface PaintOptions {  shape: Shape;  xPos?: number;  yPos?: number;} function paintShape(opts: PaintOptions) {  // ...} const shape = getShape();paintShape({ shape });paintShape({ shape, xPos: 100 });paintShape({ shape, yPos: 100 });paintShape({ shape, xPos: 100, yPos: 100 });Try"
      },
      {
        "language": "text",
        "code": "interface PaintOptions {  shape: Shape;  xPos?: number;  yPos?: number;} function paintShape(opts: PaintOptions) {  // ...} const shape = getShape();paintShape({ shape });paintShape({ shape, xPos: 100 });paintShape({ shape, yPos: 100 });paintShape({ shape, xPos: 100, yPos: 100 });"
      },
      {
        "language": "text",
        "code": "strictNullChecks"
      },
      {
        "language": "text",
        "code": "tsfunction paintShape(opts: PaintOptions) {  let xPos = opts.xPos;                   (property) PaintOptions.xPos?: number | undefined  let yPos = opts.yPos;                   (property) PaintOptions.yPos?: number | undefined  // ...}Try"
      },
      {
        "language": "text",
        "code": "function paintShape(opts: PaintOptions) {  let xPos = opts.xPos;                   (property) PaintOptions.xPos?: number | undefined  let yPos = opts.yPos;                   (property) PaintOptions.yPos?: number | undefined  // ...}"
      },
      {
        "language": "text",
        "code": "tsfunction paintShape(opts: PaintOptions) {  let xPos = opts.xPos === undefined ? 0 : opts.xPos;       let xPos: number  let yPos = opts.yPos === undefined ? 0 : opts.yPos;       let yPos: number  // ...}Try"
      },
      {
        "language": "text",
        "code": "function paintShape(opts: PaintOptions) {  let xPos = opts.xPos === undefined ? 0 : opts.xPos;       let xPos: number  let yPos = opts.yPos === undefined ? 0 : opts.yPos;       let yPos: number  // ...}"
      },
      {
        "language": "text",
        "code": "tsfunction paintShape({ shape, xPos = 0, yPos = 0 }: PaintOptions) {  console.log(\"x coordinate at\", xPos);                                  (parameter) xPos: number  console.log(\"y coordinate at\", yPos);                                  (parameter) yPos: number  // ...}Try"
      },
      {
        "language": "text",
        "code": "function paintShape({ shape, xPos = 0, yPos = 0 }: PaintOptions) {  console.log(\"x coordinate at\", xPos);                                  (parameter) xPos: number  console.log(\"y coordinate at\", yPos);                                  (parameter) yPos: number  // ...}"
      },
      {
        "language": "text",
        "code": "tsfunction draw({ shape: Shape, xPos: number = 100 /*...*/ }) {  render(shape);Cannot find name 'shape'. Did you mean 'Shape'?2552Cannot find name 'shape'. Did you mean 'Shape'?  render(xPos);Cannot find name 'xPos'.2304Cannot find name 'xPos'.}Try"
      },
      {
        "language": "text",
        "code": "function draw({ shape: Shape, xPos: number = 100 /*...*/ }) {  render(shape);Cannot find name 'shape'. Did you mean 'Shape'?2552Cannot find name 'shape'. Did you mean 'Shape'?  render(xPos);Cannot find name 'xPos'.2304Cannot find name 'xPos'.}"
      },
      {
        "language": "text",
        "code": "shape: Shape"
      },
      {
        "language": "text",
        "code": "xPos: number"
      },
      {
        "language": "text",
        "code": "tsinterface SomeType {  readonly prop: string;} function doSomething(obj: SomeType) {  // We can read from 'obj.prop'.  console.log(`prop has the value '${obj.prop}'.`);   // But we can't re-assign it.  obj.prop = \"hello\";Cannot assign to 'prop' because it is a read-only property.2540Cannot assign to 'prop' because it is a read-only property.}Try"
      },
      {
        "language": "text",
        "code": "interface SomeType {  readonly prop: string;} function doSomething(obj: SomeType) {  // We can read from 'obj.prop'.  console.log(`prop has the value '${obj.prop}'.`);   // But we can't re-assign it.  obj.prop = \"hello\";Cannot assign to 'prop' because it is a read-only property.2540Cannot assign to 'prop' because it is a read-only property.}"
      },
      {
        "language": "text",
        "code": "tsinterface Home {  readonly resident: { name: string; age: number };} function visitForBirthday(home: Home) {  // We can read and update properties from 'home.resident'.  console.log(`Happy birthday ${home.resident.name}!`);  home.resident.age++;} function evict(home: Home) {  // But we can't write to the 'resident' property itself on a 'Home'.  home.resident = {Cannot assign to 'resident' because it is a read-only property.2540Cannot assign to 'resident' because it is a read-only property.    name: \"Victor the Evictor\",    age: 42,  };}Try"
      },
      {
        "language": "text",
        "code": "interface Home {  readonly resident: { name: string; age: number };} function visitForBirthday(home: Home) {  // We can read and update properties from 'home.resident'.  console.log(`Happy birthday ${home.resident.name}!`);  home.resident.age++;} function evict(home: Home) {  // But we can't write to the 'resident' property itself on a 'Home'.  home.resident = {Cannot assign to 'resident' because it is a read-only property.2540Cannot assign to 'resident' because it is a read-only property.    name: \"Victor the Evictor\",    age: 42,  };}"
      },
      {
        "language": "text",
        "code": "tsinterface Person {  name: string;  age: number;} interface ReadonlyPerson {  readonly name: string;  readonly age: number;} let writablePerson: Person = {  name: \"Person McPersonface\",  age: 42,}; // workslet readonlyPerson: ReadonlyPerson = writablePerson; console.log(readonlyPerson.age); // prints '42'writablePerson.age++;console.log(readonlyPerson.age); // prints '43'Try"
      },
      {
        "language": "text",
        "code": "interface Person {  name: string;  age: number;} interface ReadonlyPerson {  readonly name: string;  readonly age: number;} let writablePerson: Person = {  name: \"Person McPersonface\",  age: 42,}; // workslet readonlyPerson: ReadonlyPerson = writablePerson; console.log(readonlyPerson.age); // prints '42'writablePerson.age++;console.log(readonlyPerson.age); // prints '43'"
      },
      {
        "language": "text",
        "code": "tsinterface StringArray {  [index: number]: string;} const myArray: StringArray = getStringArray();const secondItem = myArray[1];          const secondItem: stringTry"
      },
      {
        "language": "text",
        "code": "interface StringArray {  [index: number]: string;} const myArray: StringArray = getStringArray();const secondItem = myArray[1];          const secondItem: string"
      },
      {
        "language": "text",
        "code": "StringArray"
      },
      {
        "language": "text",
        "code": "StringArray"
      },
      {
        "language": "text",
        "code": "tsinterface Animal {  name: string;} interface Dog extends Animal {  breed: string;} // Error: indexing with a numeric string might get you a completely separate type of Animal!interface NotOkay {  [x: number]: Animal;'number' index type 'Animal' is not assignable to 'string' index type 'Dog'.2413'number' index type 'Animal' is not assignable to 'string' index type 'Dog'.  [x: string]: Dog;}Try"
      },
      {
        "language": "text",
        "code": "interface Animal {  name: string;} interface Dog extends Animal {  breed: string;} // Error: indexing with a numeric string might get you a completely separate type of Animal!interface NotOkay {  [x: number]: Animal;'number' index type 'Animal' is not assignable to 'string' index type 'Dog'.2413'number' index type 'Animal' is not assignable to 'string' index type 'Dog'.  [x: string]: Dog;}"
      },
      {
        "language": "text",
        "code": "obj.property"
      },
      {
        "language": "text",
        "code": "obj[\"property\"]"
      },
      {
        "language": "text",
        "code": "tsinterface NumberDictionary {  [index: string]: number;   length: number; // ok  name: string;Property 'name' of type 'string' is not assignable to 'string' index type 'number'.2411Property 'name' of type 'string' is not assignable to 'string' index type 'number'.}Try"
      },
      {
        "language": "text",
        "code": "interface NumberDictionary {  [index: string]: number;   length: number; // ok  name: string;Property 'name' of type 'string' is not assignable to 'string' index type 'number'.2411Property 'name' of type 'string' is not assignable to 'string' index type 'number'.}"
      },
      {
        "language": "text",
        "code": "tsinterface NumberOrStringDictionary {  [index: string]: number | string;  length: number; // ok, length is a number  name: string; // ok, name is a string}Try"
      },
      {
        "language": "text",
        "code": "interface NumberOrStringDictionary {  [index: string]: number | string;  length: number; // ok, length is a number  name: string; // ok, name is a string}"
      },
      {
        "language": "text",
        "code": "tsinterface ReadonlyStringArray {  readonly [index: number]: string;} let myArray: ReadonlyStringArray = getReadOnlyStringArray();myArray[2] = \"Mallory\";Index signature in type 'ReadonlyStringArray' only permits reading.2542Index signature in type 'ReadonlyStringArray' only permits reading.Try"
      },
      {
        "language": "text",
        "code": "interface ReadonlyStringArray {  readonly [index: number]: string;} let myArray: ReadonlyStringArray = getReadOnlyStringArray();myArray[2] = \"Mallory\";Index signature in type 'ReadonlyStringArray' only permits reading.2542Index signature in type 'ReadonlyStringArray' only permits reading."
      },
      {
        "language": "text",
        "code": "tsinterface SquareConfig {  color?: string;  width?: number;} function createSquare(config: SquareConfig): { color: string; area: number } {  return {    color: config.color || \"red\",    area: config.width ? config.width * config.width : 20,  };} let mySquare = createSquare({ colour: \"red\", width: 100 });Object literal may only specify known properties, but 'colour' does not exist in type 'SquareConfig'. Did you mean to write 'color'?2561Object literal may only specify known properties, but 'colour' does not exist in type 'SquareConfig'. Did you mean to write 'color'?Try"
      },
      {
        "language": "text",
        "code": "interface SquareConfig {  color?: string;  width?: number;} function createSquare(config: SquareConfig): { color: string; area: number } {  return {    color: config.color || \"red\",    area: config.width ? config.width * config.width : 20,  };} let mySquare = createSquare({ colour: \"red\", width: 100 });Object literal may only specify known properties, but 'colour' does not exist in type 'SquareConfig'. Did you mean to write 'color'?2561Object literal may only specify known properties, but 'colour' does not exist in type 'SquareConfig'. Did you mean to write 'color'?"
      },
      {
        "language": "text",
        "code": "createSquare"
      },
      {
        "language": "text",
        "code": "tslet mySquare = createSquare({ colour: \"red\", width: 100 });Object literal may only specify known properties, but 'colour' does not exist in type 'SquareConfig'. Did you mean to write 'color'?2561Object literal may only specify known properties, but 'colour' does not exist in type 'SquareConfig'. Did you mean to write 'color'?Try"
      },
      {
        "language": "text",
        "code": "let mySquare = createSquare({ colour: \"red\", width: 100 });Object literal may only specify known properties, but 'colour' does not exist in type 'SquareConfig'. Did you mean to write 'color'?2561Object literal may only specify known properties, but 'colour' does not exist in type 'SquareConfig'. Did you mean to write 'color'?"
      },
      {
        "language": "text",
        "code": "tslet mySquare = createSquare({ width: 100, opacity: 0.5 } as SquareConfig);Try"
      },
      {
        "language": "text",
        "code": "let mySquare = createSquare({ width: 100, opacity: 0.5 } as SquareConfig);"
      },
      {
        "language": "text",
        "code": "SquareConfig"
      },
      {
        "language": "text",
        "code": "tsinterface SquareConfig {  color?: string;  width?: number;  [propName: string]: unknown;}Try"
      },
      {
        "language": "text",
        "code": "interface SquareConfig {  color?: string;  width?: number;  [propName: string]: unknown;}"
      },
      {
        "language": "text",
        "code": "SquareConfig"
      },
      {
        "language": "text",
        "code": "squareOptions"
      },
      {
        "language": "text",
        "code": "tslet squareOptions = { colour: \"red\", width: 100 };let mySquare = createSquare(squareOptions);Try"
      },
      {
        "language": "text",
        "code": "let squareOptions = { colour: \"red\", width: 100 };let mySquare = createSquare(squareOptions);"
      },
      {
        "language": "text",
        "code": "squareOptions"
      },
      {
        "language": "text",
        "code": "SquareConfig"
      },
      {
        "language": "text",
        "code": "tslet squareOptions = { colour: \"red\" };let mySquare = createSquare(squareOptions);Type '{ colour: string; }' has no properties in common with type 'SquareConfig'.2559Type '{ colour: string; }' has no properties in common with type 'SquareConfig'.Try"
      },
      {
        "language": "text",
        "code": "let squareOptions = { colour: \"red\" };let mySquare = createSquare(squareOptions);Type '{ colour: string; }' has no properties in common with type 'SquareConfig'.2559Type '{ colour: string; }' has no properties in common with type 'SquareConfig'."
      },
      {
        "language": "text",
        "code": "createSquare"
      },
      {
        "language": "text",
        "code": "SquareConfig"
      },
      {
        "language": "text",
        "code": "BasicAddress"
      },
      {
        "language": "text",
        "code": "tsinterface BasicAddress {  name?: string;  street: string;  city: string;  country: string;  postalCode: string;}Try"
      },
      {
        "language": "text",
        "code": "interface BasicAddress {  name?: string;  street: string;  city: string;  country: string;  postalCode: string;}"
      },
      {
        "language": "text",
        "code": "AddressWithUnit"
      },
      {
        "language": "text",
        "code": "tsinterface AddressWithUnit {  name?: string;  unit: string;  street: string;  city: string;  country: string;  postalCode: string;}Try"
      },
      {
        "language": "text",
        "code": "interface AddressWithUnit {  name?: string;  unit: string;  street: string;  city: string;  country: string;  postalCode: string;}"
      },
      {
        "language": "text",
        "code": "BasicAddress"
      },
      {
        "language": "text",
        "code": "BasicAddress"
      },
      {
        "language": "text",
        "code": "AddressWithUnit"
      },
      {
        "language": "text",
        "code": "tsinterface BasicAddress {  name?: string;  street: string;  city: string;  country: string;  postalCode: string;} interface AddressWithUnit extends BasicAddress {  unit: string;}Try"
      },
      {
        "language": "text",
        "code": "interface BasicAddress {  name?: string;  street: string;  city: string;  country: string;  postalCode: string;} interface AddressWithUnit extends BasicAddress {  unit: string;}"
      },
      {
        "language": "text",
        "code": "AddressWithUnit"
      },
      {
        "language": "text",
        "code": "BasicAddress"
      },
      {
        "language": "text",
        "code": "tsinterface Colorful {  color: string;} interface Circle {  radius: number;} interface ColorfulCircle extends Colorful, Circle {} const cc: ColorfulCircle = {  color: \"red\",  radius: 42,};Try"
      },
      {
        "language": "text",
        "code": "interface Colorful {  color: string;} interface Circle {  radius: number;} interface ColorfulCircle extends Colorful, Circle {} const cc: ColorfulCircle = {  color: \"red\",  radius: 42,};"
      },
      {
        "language": "text",
        "code": "tsinterface Colorful {  color: string;}interface Circle {  radius: number;} type ColorfulCircle = Colorful & Circle;Try"
      },
      {
        "language": "text",
        "code": "interface Colorful {  color: string;}interface Circle {  radius: number;} type ColorfulCircle = Colorful & Circle;"
      },
      {
        "language": "text",
        "code": "tsfunction draw(circle: Colorful & Circle) {  console.log(`Color was ${circle.color}`);  console.log(`Radius was ${circle.radius}`);} // okaydraw({ color: \"blue\", radius: 42 }); // oopsdraw({ color: \"red\", raidus: 42 });Object literal may only specify known properties, but 'raidus' does not exist in type 'Colorful & Circle'. Did you mean to write 'radius'?2561Object literal may only specify known properties, but 'raidus' does not exist in type 'Colorful & Circle'. Did you mean to write 'radius'?Try"
      },
      {
        "language": "text",
        "code": "function draw(circle: Colorful & Circle) {  console.log(`Color was ${circle.color}`);  console.log(`Radius was ${circle.radius}`);} // okaydraw({ color: \"blue\", radius: 42 }); // oopsdraw({ color: \"red\", raidus: 42 });Object literal may only specify known properties, but 'raidus' does not exist in type 'Colorful & Circle'. Did you mean to write 'radius'?2561Object literal may only specify known properties, but 'raidus' does not exist in type 'Colorful & Circle'. Did you mean to write 'radius'?"
      },
      {
        "language": "text",
        "code": "tsinterface Person {  name: string;}interface Person {  name: number;}"
      },
      {
        "language": "text",
        "code": "interface Person {  name: string;}interface Person {  name: number;}"
      },
      {
        "language": "text",
        "code": "tsinterface Person1 {  name: string;} interface Person2 {  name: number;} type Staff = Person1 & Person2 declare const staffer: Staff;staffer.name;         (property) name: neverTry"
      },
      {
        "language": "text",
        "code": "interface Person1 {  name: string;} interface Person2 {  name: number;} type Staff = Person1 & Person2 declare const staffer: Staff;staffer.name;         (property) name: never"
      },
      {
        "language": "text",
        "code": "tsinterface Box {  contents: any;}Try"
      },
      {
        "language": "text",
        "code": "interface Box {  contents: any;}"
      },
      {
        "language": "text",
        "code": "tsinterface Box {  contents: unknown;} let x: Box = {  contents: \"hello world\",}; // we could check 'x.contents'if (typeof x.contents === \"string\") {  console.log(x.contents.toLowerCase());} // or we could use a type assertionconsole.log((x.contents as string).toLowerCase());Try"
      },
      {
        "language": "text",
        "code": "interface Box {  contents: unknown;} let x: Box = {  contents: \"hello world\",}; // we could check 'x.contents'if (typeof x.contents === \"string\") {  console.log(x.contents.toLowerCase());} // or we could use a type assertionconsole.log((x.contents as string).toLowerCase());"
      },
      {
        "language": "text",
        "code": "tsinterface NumberBox {  contents: number;} interface StringBox {  contents: string;} interface BooleanBox {  contents: boolean;}Try"
      },
      {
        "language": "text",
        "code": "interface NumberBox {  contents: number;} interface StringBox {  contents: string;} interface BooleanBox {  contents: boolean;}"
      },
      {
        "language": "text",
        "code": "tsfunction setContents(box: StringBox, newContents: string): void;function setContents(box: NumberBox, newContents: number): void;function setContents(box: BooleanBox, newContents: boolean): void;function setContents(box: { contents: any }, newContents: any) {  box.contents = newContents;}Try"
      },
      {
        "language": "text",
        "code": "function setContents(box: StringBox, newContents: string): void;function setContents(box: NumberBox, newContents: number): void;function setContents(box: BooleanBox, newContents: boolean): void;function setContents(box: { contents: any }, newContents: any) {  box.contents = newContents;}"
      },
      {
        "language": "text",
        "code": "tsinterface Box<Type> {  contents: Type;}Try"
      },
      {
        "language": "text",
        "code": "interface Box<Type> {  contents: Type;}"
      },
      {
        "language": "text",
        "code": "tslet box: Box<string>;Try"
      },
      {
        "language": "text",
        "code": "let box: Box<string>;"
      },
      {
        "language": "text",
        "code": "Box<string>"
      },
      {
        "language": "text",
        "code": "{ contents: string }"
      },
      {
        "language": "text",
        "code": "Box<string>"
      },
      {
        "language": "text",
        "code": "tsinterface Box<Type> {  contents: Type;}interface StringBox {  contents: string;} let boxA: Box<string> = { contents: \"hello\" };boxA.contents;        (property) Box<string>.contents: string let boxB: StringBox = { contents: \"world\" };boxB.contents;        (property) StringBox.contents: stringTry"
      },
      {
        "language": "text",
        "code": "interface Box<Type> {  contents: Type;}interface StringBox {  contents: string;} let boxA: Box<string> = { contents: \"hello\" };boxA.contents;        (property) Box<string>.contents: string let boxB: StringBox = { contents: \"world\" };boxB.contents;        (property) StringBox.contents: string"
      },
      {
        "language": "text",
        "code": "tsinterface Box<Type> {  contents: Type;} interface Apple {  // ....} // Same as '{ contents: Apple }'.type AppleBox = Box<Apple>;Try"
      },
      {
        "language": "text",
        "code": "interface Box<Type> {  contents: Type;} interface Apple {  // ....} // Same as '{ contents: Apple }'.type AppleBox = Box<Apple>;"
      },
      {
        "language": "text",
        "code": "tsfunction setContents<Type>(box: Box<Type>, newContents: Type) {  box.contents = newContents;}Try"
      },
      {
        "language": "text",
        "code": "function setContents<Type>(box: Box<Type>, newContents: Type) {  box.contents = newContents;}"
      },
      {
        "language": "text",
        "code": "tsinterface Box<Type> {  contents: Type;}Try"
      },
      {
        "language": "text",
        "code": "interface Box<Type> {  contents: Type;}"
      },
      {
        "language": "text",
        "code": "tstype Box<Type> = {  contents: Type;};Try"
      },
      {
        "language": "text",
        "code": "type Box<Type> = {  contents: Type;};"
      },
      {
        "language": "text",
        "code": "tstype OrNull<Type> = Type | null; type OneOrMany<Type> = Type | Type[]; type OneOrManyOrNull<Type> = OrNull<OneOrMany<Type>>;           type OneOrManyOrNull<Type> = OneOrMany<Type> | null type OneOrManyOrNullStrings = OneOrManyOrNull<string>;               type OneOrManyOrNullStrings = OneOrMany<string> | nullTry"
      },
      {
        "language": "text",
        "code": "type OrNull<Type> = Type | null; type OneOrMany<Type> = Type | Type[]; type OneOrManyOrNull<Type> = OrNull<OneOrMany<Type>>;           type OneOrManyOrNull<Type> = OneOrMany<Type> | null type OneOrManyOrNullStrings = OneOrManyOrNull<string>;               type OneOrManyOrNullStrings = OneOrMany<string> | null"
      },
      {
        "language": "text",
        "code": "Array<number>"
      },
      {
        "language": "text",
        "code": "Array<string>"
      },
      {
        "language": "text",
        "code": "tsfunction doSomething(value: Array<string>) {  // ...} let myArray: string[] = [\"hello\", \"world\"]; // either of these work!doSomething(myArray);doSomething(new Array(\"hello\", \"world\"));Try"
      },
      {
        "language": "text",
        "code": "function doSomething(value: Array<string>) {  // ...} let myArray: string[] = [\"hello\", \"world\"]; // either of these work!doSomething(myArray);doSomething(new Array(\"hello\", \"world\"));"
      },
      {
        "language": "text",
        "code": "tsinterface Array<Type> {  /**   * Gets or sets the length of the array.   */  length: number;   /**   * Removes the last element from an array and returns it.   */  pop(): Type | undefined;   /**   * Appends new elements to an array, and returns the new length of the array.   */  push(...items: Type[]): number;   // ...}Try"
      },
      {
        "language": "text",
        "code": "interface Array<Type> {  /**   * Gets or sets the length of the array.   */  length: number;   /**   * Removes the last element from an array and returns it.   */  pop(): Type | undefined;   /**   * Appends new elements to an array, and returns the new length of the array.   */  push(...items: Type[]): number;   // ...}"
      },
      {
        "language": "text",
        "code": "ReadonlyArray"
      },
      {
        "language": "text",
        "code": "ReadonlyArray"
      },
      {
        "language": "text",
        "code": "tsfunction doStuff(values: ReadonlyArray<string>) {  // We can read from 'values'...  const copy = values.slice();  console.log(`The first value is ${values[0]}`);   // ...but we can't mutate 'values'.  values.push(\"hello!\");Property 'push' does not exist on type 'readonly string[]'.2339Property 'push' does not exist on type 'readonly string[]'.}Try"
      },
      {
        "language": "text",
        "code": "function doStuff(values: ReadonlyArray<string>) {  // We can read from 'values'...  const copy = values.slice();  console.log(`The first value is ${values[0]}`);   // ...but we can't mutate 'values'.  values.push(\"hello!\");Property 'push' does not exist on type 'readonly string[]'.2339Property 'push' does not exist on type 'readonly string[]'.}"
      },
      {
        "language": "text",
        "code": "ReadonlyArray"
      },
      {
        "language": "text",
        "code": "ReadonlyArray"
      },
      {
        "language": "text",
        "code": "ReadonlyArray"
      },
      {
        "language": "text",
        "code": "tsnew ReadonlyArray(\"red\", \"green\", \"blue\");'ReadonlyArray' only refers to a type, but is being used as a value here.2693'ReadonlyArray' only refers to a type, but is being used as a value here.Try"
      },
      {
        "language": "text",
        "code": "new ReadonlyArray(\"red\", \"green\", \"blue\");'ReadonlyArray' only refers to a type, but is being used as a value here.2693'ReadonlyArray' only refers to a type, but is being used as a value here."
      },
      {
        "language": "text",
        "code": "ReadonlyArray"
      },
      {
        "language": "text",
        "code": "tsconst roArray: ReadonlyArray<string> = [\"red\", \"green\", \"blue\"];Try"
      },
      {
        "language": "text",
        "code": "const roArray: ReadonlyArray<string> = [\"red\", \"green\", \"blue\"];"
      },
      {
        "language": "text",
        "code": "Array<Type>"
      },
      {
        "language": "text",
        "code": "ReadonlyArray<Type>"
      },
      {
        "language": "text",
        "code": "readonly Type[]"
      },
      {
        "language": "text",
        "code": "tsfunction doStuff(values: readonly string[]) {  // We can read from 'values'...  const copy = values.slice();  console.log(`The first value is ${values[0]}`);   // ...but we can't mutate 'values'.  values.push(\"hello!\");Property 'push' does not exist on type 'readonly string[]'.2339Property 'push' does not exist on type 'readonly string[]'.}Try"
      },
      {
        "language": "text",
        "code": "function doStuff(values: readonly string[]) {  // We can read from 'values'...  const copy = values.slice();  console.log(`The first value is ${values[0]}`);   // ...but we can't mutate 'values'.  values.push(\"hello!\");Property 'push' does not exist on type 'readonly string[]'.2339Property 'push' does not exist on type 'readonly string[]'.}"
      },
      {
        "language": "text",
        "code": "ReadonlyArray"
      },
      {
        "language": "text",
        "code": "tslet x: readonly string[] = [];let y: string[] = []; x = y;y = x;The type 'readonly string[]' is 'readonly' and cannot be assigned to the mutable type 'string[]'.4104The type 'readonly string[]' is 'readonly' and cannot be assigned to the mutable type 'string[]'.Try"
      },
      {
        "language": "text",
        "code": "let x: readonly string[] = [];let y: string[] = []; x = y;y = x;The type 'readonly string[]' is 'readonly' and cannot be assigned to the mutable type 'string[]'.4104The type 'readonly string[]' is 'readonly' and cannot be assigned to the mutable type 'string[]'."
      },
      {
        "language": "text",
        "code": "tstype StringNumberPair = [string, number];Try"
      },
      {
        "language": "text",
        "code": "type StringNumberPair = [string, number];"
      },
      {
        "language": "text",
        "code": "StringNumberPair"
      },
      {
        "language": "text",
        "code": "ReadonlyArray"
      },
      {
        "language": "text",
        "code": "StringNumberPair"
      },
      {
        "language": "text",
        "code": "tsfunction doSomething(pair: [string, number]) {  const a = pair[0];       const a: string  const b = pair[1];       const b: number  // ...} doSomething([\"hello\", 42]);Try"
      },
      {
        "language": "text",
        "code": "function doSomething(pair: [string, number]) {  const a = pair[0];       const a: string  const b = pair[1];       const b: number  // ...} doSomething([\"hello\", 42]);"
      },
      {
        "language": "text",
        "code": "tsfunction doSomething(pair: [string, number]) {  // ...   const c = pair[2];Tuple type '[string, number]' of length '2' has no element at index '2'.2493Tuple type '[string, number]' of length '2' has no element at index '2'.}Try"
      },
      {
        "language": "text",
        "code": "function doSomething(pair: [string, number]) {  // ...   const c = pair[2];Tuple type '[string, number]' of length '2' has no element at index '2'.2493Tuple type '[string, number]' of length '2' has no element at index '2'.}"
      },
      {
        "language": "text",
        "code": "tsfunction doSomething(stringHash: [string, number]) {  const [inputString, hash] = stringHash;   console.log(inputString);                  const inputString: string   console.log(hash);               const hash: number}Try"
      },
      {
        "language": "text",
        "code": "function doSomething(stringHash: [string, number]) {  const [inputString, hash] = stringHash;   console.log(inputString);                  const inputString: string   console.log(hash);               const hash: number}"
      },
      {
        "language": "text",
        "code": "tsinterface StringNumberPair {  // specialized properties  length: 2;  0: string;  1: number;   // Other 'Array<string | number>' members...  slice(start?: number, end?: number): Array<string | number>;}Try"
      },
      {
        "language": "text",
        "code": "interface StringNumberPair {  // specialized properties  length: 2;  0: string;  1: number;   // Other 'Array<string | number>' members...  slice(start?: number, end?: number): Array<string | number>;}"
      },
      {
        "language": "text",
        "code": "tstype Either2dOr3d = [number, number, number?]; function setCoordinate(coord: Either2dOr3d) {  const [x, y, z] = coord;              const z: number | undefined   console.log(`Provided coordinates had ${coord.length} dimensions`);                                                  (property) length: 2 | 3}Try"
      },
      {
        "language": "text",
        "code": "type Either2dOr3d = [number, number, number?]; function setCoordinate(coord: Either2dOr3d) {  const [x, y, z] = coord;              const z: number | undefined   console.log(`Provided coordinates had ${coord.length} dimensions`);                                                  (property) length: 2 | 3}"
      },
      {
        "language": "text",
        "code": "tstype StringNumberBooleans = [string, number, ...boolean[]];type StringBooleansNumber = [string, ...boolean[], number];type BooleansStringNumber = [...boolean[], string, number];Try"
      },
      {
        "language": "text",
        "code": "type StringNumberBooleans = [string, number, ...boolean[]];type StringBooleansNumber = [string, ...boolean[], number];type BooleansStringNumber = [...boolean[], string, number];"
      },
      {
        "language": "text",
        "code": "StringNumberBooleans"
      },
      {
        "language": "text",
        "code": "StringBooleansNumber"
      },
      {
        "language": "text",
        "code": "BooleansStringNumber"
      },
      {
        "language": "text",
        "code": "tsconst a: StringNumberBooleans = [\"hello\", 1];const b: StringNumberBooleans = [\"beautiful\", 2, true];const c: StringNumberBooleans = [\"world\", 3, true, false, true, false, true];Try"
      },
      {
        "language": "text",
        "code": "const a: StringNumberBooleans = [\"hello\", 1];const b: StringNumberBooleans = [\"beautiful\", 2, true];const c: StringNumberBooleans = [\"world\", 3, true, false, true, false, true];"
      },
      {
        "language": "text",
        "code": "tsfunction readButtonInput(...args: [string, number, ...boolean[]]) {  const [name, version, ...input] = args;  // ...}Try"
      },
      {
        "language": "text",
        "code": "function readButtonInput(...args: [string, number, ...boolean[]]) {  const [name, version, ...input] = args;  // ...}"
      },
      {
        "language": "text",
        "code": "tsfunction readButtonInput(name: string, version: number, ...input: boolean[]) {  // ...}Try"
      },
      {
        "language": "text",
        "code": "function readButtonInput(name: string, version: number, ...input: boolean[]) {  // ...}"
      },
      {
        "language": "text",
        "code": "tsfunction doSomething(pair: readonly [string, number]) {  // ...}Try"
      },
      {
        "language": "text",
        "code": "function doSomething(pair: readonly [string, number]) {  // ...}"
      },
      {
        "language": "text",
        "code": "tsfunction doSomething(pair: readonly [string, number]) {  pair[0] = \"hello!\";Cannot assign to '0' because it is a read-only property.2540Cannot assign to '0' because it is a read-only property.}Try"
      },
      {
        "language": "text",
        "code": "function doSomething(pair: readonly [string, number]) {  pair[0] = \"hello!\";Cannot assign to '0' because it is a read-only property.2540Cannot assign to '0' because it is a read-only property.}"
      },
      {
        "language": "text",
        "code": "tslet point = [3, 4] as const; function distanceFromOrigin([x, y]: [number, number]) {  return Math.sqrt(x ** 2 + y ** 2);} distanceFromOrigin(point);Argument of type 'readonly [3, 4]' is not assignable to parameter of type '[number, number]'.\n  The type 'readonly [3, 4]' is 'readonly' and cannot be assigned to the mutable type '[number, number]'.2345Argument of type 'readonly [3, 4]' is not assignable to parameter of type '[number, number]'.\n  The type 'readonly [3, 4]' is 'readonly' and cannot be assigned to the mutable type '[number, number]'.Try"
      },
      {
        "language": "text",
        "code": "let point = [3, 4] as const; function distanceFromOrigin([x, y]: [number, number]) {  return Math.sqrt(x ** 2 + y ** 2);} distanceFromOrigin(point);Argument of type 'readonly [3, 4]' is not assignable to parameter of type '[number, number]'.\n  The type 'readonly [3, 4]' is 'readonly' and cannot be assigned to the mutable type '[number, number]'.2345Argument of type 'readonly [3, 4]' is not assignable to parameter of type '[number, number]'.\n  The type 'readonly [3, 4]' is 'readonly' and cannot be assigned to the mutable type '[number, number]'."
      },
      {
        "language": "text",
        "code": "distanceFromOrigin"
      },
      {
        "language": "text",
        "code": "readonly [3, 4]"
      },
      {
        "language": "text",
        "code": "[number, number]"
      }
    ],
    "links": [
      {
        "text": "Try",
        "href": "https://www.typescriptlang.org/play/#code/GYVwdgxgLglg9mABAcwE4FN1QBQAd2oDOCAXIgN6JgCGAtumYVKjGMgNyLXINUi0AjAogC+ASgoAoRIgD0smYqXLlAPXUbNW7TtXTEGKCFRIARAAl0AGytxEpxAGpE+IggB0Neu0kigA"
      },
      {
        "text": "Try",
        "href": "https://www.typescriptlang.org/play/#code/JYOwLgpgTgZghgYwgAgArQM4HsTIN4BQyyA9CcRcgHo21HIhwC2EAXMhmFKAOYDc9ODzYMArkwBG0AQF8CBGKJAIwwHMh5QIEMAAoADphzt0UbCACU+elrCiouAEQAJCABs3WZI+QBqZIZmOAB0jCyyQA"
      },
      {
        "text": "Try",
        "href": "https://www.typescriptlang.org/play/#code/C4TwDgpgBAChBOBnA9gOygXigbwFBSgHpCoA9ci-KVAQwFsIAuKRYeAS1QHMBuKmrk2oBXOgCMEfAL59cAM2GoAxsHZooXeBAjAAFJCRpmcQ6gCUOKluDD46AEQAJCABsXyKPagBqKAZSoAHS0DNJAA"
      },
      {
        "text": "type and interface",
        "href": "https://www.typescriptlang.org/cheatsheets"
      },
      {
        "text": "Try",
        "href": "https://www.typescriptlang.org/play/#code/JYOwLgpgTgZghgYwgAgMoAs4AcUG8C+AUACYQIA2cUKMAriAmMAPYjIDmEYG2EAFAEoAXGkw4A3IUIB6acgC0ihLTCL5hUJFiIUABTiaA8liasAzslyFkyM2IgieE68gAeu5mYD8IkLQC2AEbQkjayNgB6LgCeHt6+AcFQocjhyFFEhHQMpmxYBuBO-MwmZiL6RiYsIGYCli7hAHTNhJkI5mC29sgAvBxcRYKS+ZqDuF28yPgCwwXc9nzjdrwANG5xIgCMAAzbUzOEI4ULS-ZrsZ5bu-uzoycTOGvul8g72+cbr9fT4kA"
      },
      {
        "text": "strictNullChecks",
        "href": "/tsconfig#strictNullChecks"
      },
      {
        "text": "Try",
        "href": "https://www.typescriptlang.org/play/#code/JYOwLgpgTgZghgYwgAgMoAs4AcUG8C+AUACYQIA2cUKMAriAmMAPYjIDmEYG2EAFAEoAXGkw4A3IUKhIsRCgAKcGQHksTVgGdkuQsmSaxEETwl7kADwXNNAfhEhaAWwBG0SfoCe1uw+duoSSJCAHoQ5ABaKIRaMCiIwjoGDTYsZXBTfmZ1TRElVXUWEE0BHXNyLksfZABeZGywTQA6KxsPZDD9Lu6egD1bcsrvG1r6nKbhzXbOntn9fvNOpuXCfCA"
      },
      {
        "text": "Try",
        "href": "https://www.typescriptlang.org/play/#code/JYOwLgpgTgZghgYwgAgMoAs4AcUG8C+AUACYQIA2cUKMAriAmMAPYjIDmEYG2EAFAEoAXGkw4A3IUKhIsRCgAKcGQHksTVgGdkuQsmSaxEETwl7kADwXNNAfhEhaAWwBG0SfoCe1uw+duoSSJCAHoQ5ABaKIRaMCiIwjoGDTYsZXBTfmZ1TRElVXUWEE0BHXNyLksfZABeZGywTQA6Kxtamrr6UhhQCGJkW2QABmQRBubWzQ9kMP0APVtyyu82uvGmle0OzpBu3v7BkbGcjZ9p2eQF81mm28J8IA"
      },
      {
        "text": "Try",
        "href": "https://www.typescriptlang.org/play/#code/JYOwLgpgTgZghgYwgAgMoAs4AcUG8C+AUACYQIA2cUKMAriAmMAPYjIDmEYG2EAFAEoAXGkw4A3IUKhIsRCgAKcGQHksTVgGdkuQsmSaxEETwl7kADwXNNAfhEhaAWwBG0SfoCe1uw+duoSSJCAHoQ5ABaKIRaMCiIwjoGDTYsZXBTflwDIwAaSx9kAF5kAAZ87xtisuR8ESVVdRYQTQEdcwQtZnIIADpyZnY+ACILZE7mKGJQOEhkWeH8qxsBD2Qw-U2t7Z3d-QA9Ww6unv7Bkc9x5knpkFmUBYqfVfMNvfeP5EPX8N6-wnwQA"
      },
      {
        "text": "a destructuring pattern",
        "href": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/Destructuring_assignment"
      },
      {
        "text": "default values",
        "href": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/Destructuring_assignment#Default_values"
      },
      {
        "text": "Try",
        "href": "https://www.typescriptlang.org/play/#code/PTAEAEDsHsEkFsAOAbAlgY1QFwIKQJ4BcoAZgIbIDOApgFAgTUBOT0TlxATAKzeeicAzAAYALLVSQszcumqgAygAsyieQG8AvrQAm1dMjJN5JAK6R0WVNEihjkPUwAUAD2LmA1jADukAJQA3PRgALRh6KZYYSG0ZhZWNqA6TGTeTuqglCpqxMqq1AA0oC4ACtAcoJCm8ABGzKAAvKAAjMLCoMAAVAB0vZ1gmn6g6rSgdtQOzE5Z+YGj45POpeVzmkA"
      },
      {
        "text": "Try",
        "href": "https://www.typescriptlang.org/play/#code/PTAEAEFMCdoe2gZwFygEwFYAsAGAUAJYB2ALjAGYCGAxpKAMpwC2kAKgJ4AOdA3nqKGiRKAEzhEANu1Cd4nVIhLRiAcwDceAL5485AK5FqJAuNBjGLEgAtVACjgAjAFaoLbLpACUoPgJCgAdTpqSiJBYRFQcngmUAByRycAOlk4Tjik-lBqcUQ4CUgkiTgVWwADVM5QK0pEUGs6ADdKCT06OIASHkSUuU0Mss8NLP8AIT0SUAB3YNC4yaEAWlrEAhUwghJMgR7K0ABeUAAiK0gJYqONTSA"
      },
      {
        "text": "Try",
        "href": "https://www.typescriptlang.org/play/#code/PTAEAEFMCdoe2gZwFygEwFYAsAGAUAJYB2ALjAGYCGAxpKABJwC2dA3nqKNJJQCZxEANgE8ukRAV6RSqVqCKUWqRCWjEA5gG5QldZFREArkwBGMUAF9NeC3jzlDRaiQIDQANwISSAMQQAhAmgSAAteSmEAChDmfQZYgEpQdk4QUAB1OmpKIjE+HSJeUEMAB3CyUBL4EpgXcVByeCZQAHIYlgA6bgkpUhaOjlBqAUQ4QUgOwTh1SIADekoSktETINDw0QASVnaJ7slpEg6FFgsAQlmE605drvED0g7dSABqF+tbe0dnV1zIT2c0ViqEYLCSKVAaX8hhIoAA7lkci1YXC1BUSHBQKE6C19r0SC1KtVaqICCREJBBORQG5KK1QZB+oNbnjDqAALzJQacE5xABEADUCM4EFiQnQAKIAjHQPkAGm5Oj0qCwaAVnCsNiAA"
      },
      {
        "text": "Try",
        "href": "https://www.typescriptlang.org/play/#code/JYOwLgpgTgZghgYwgAgArQM4HsTIN4BQyyIcAthAFzIZhSgDmA3EcnA1SQK5kBG0LAL4ECoSLEQoAShDgATHABsAnuijZchYlFkKQKkuU616IZqx3ylyth2oge-KEJGKIYZAHd6YOLzdqGtSBOMgAvPispBTUAEQhuACyCAnwSLEANKzsnAAsAExZgiwEAPSlXlhQANYYBG4elnoqCdQyVvqqmKER3sC+-hAJJQg42G4AdIpYDAAUTdYJEzkAlEzI5cgADqZgGMgA5AUHBH0DAd0gyxwA1DcsoyDjEFMz87qLl9cQaxsVO2J9kcAMwHIA"
      },
      {
        "text": "mapping modifiers",
        "href": "/docs/handbook/2/mapped-types.html#mapping-modifiers"
      },
      {
        "text": "Try",
        "href": "https://www.typescriptlang.org/play/#code/CYUwxgNghgTiAEAzArgOzAFwJYHtXwHMQMBlDGLVAgQRhigE8AKASgC54yKrb6GBuAFAB6YfAC0ksMgyTxgyhhAxEUMAi6UadRvADeg+PADalUAA8OqZAFsARsoC6HAM7ktQgL6DBYPG-gbBl5GDk0eHQZ4AF5CYnDtPlYhP1QAl3A8YABJJRsYwODI4wBGRyFRIyqAPQB+IA"
      },
      {
        "text": "Try",
        "href": "https://www.typescriptlang.org/play/#code/PTAEAEFMCdoe2gZwFygEwBYCMBmAUCBIgC7QCWAxsQArwAOMxAngJIB2ZxZAhgDZkAvblzhtUAMz6JIeMm2IxJFSKACCHALZ9QAbzyhQbbhsioS5NgHMA3HgC+eWfMXdloACJxLoSAA8FbAAmiGqa2noGAEbQkJCBZqRyNvaOhACisAiocoF+SaAA7pwAFqDchgCuJuQUoOb5GmSWxcSglpCtTHAVZaAUcBp0vB2QvEx1kHTc0MIqzAygcOKhZFq8AIROCtBKKgBycMQA8gDW3OMRoADavqhsVZEwALqo6qt8tgY3CRaWLx5eWx2IA"
      },
      {
        "text": "Try",
        "href": "https://www.typescriptlang.org/play/#code/PTAEAEFMCdoe2gZwFygEwBYCMWBQIIZ4lVMdcBLAOwBcYAzAQwGNJQA5AVwFsAjGACIVmNCnCqNoAT1ABvXKFABtagBNIAD1SIa0agHMAuqio9+0ANy4FoADaQq+mgAsTZmBdAE4AaxsTuSG1dAysAXyA"
      },
      {
        "text": "Try",
        "href": "https://www.typescriptlang.org/play/#code/JYOwLgpgTgZghgYwgAgHIFcC2AjaB5KAZTClAHMARYBMYAexDigE9kBvAKGWQG1QATCAA8AXMgDOJcgF0xILLijIAPhKkgyAbi7IANhA1gAFnIXRNyAPSXkdANYAaPQbLHkwccjjJ5OaDsZMCDFJUg0La1tHHzgg909vUPIOAF8gA"
      },
      {
        "text": "Try",
        "href": "https://www.typescriptlang.org/play/#code/CYUwxgNghgTiAEAzArgOzAFwJYHtXwHMQMAlEKYAeVQgE8BlDGLVAgQRhiloAoBKAFzwyFPHUbNWHLrQDcAKAD0i+AFp1YZBnWqlKgAIhOOGAGchAJgCsAFgvyWGI4ihgEI4GIZMW7Tt3gAb3l4eDhRGlp4AG0WUAAPIVRkAFsAIyMAXSFTH1YFAF95eQhieBTaaW4hDy8JXyqogF5CYg9qcTy-GX4FCsboi0z4FoAiAFkoCAgTWlHZIA"
      },
      {
        "text": "Try",
        "href": "https://www.typescriptlang.org/play/#code/PTAEAEFMCdoe2gZwFygEwGYAsBWdB2DATgCgBLAOwBcYAzAQwGNJQBlARwFd7pIBhOBVpkA5qADeJUKEZwANggD8qRFWiURAbimgA7mQAmVABbLQFTgFsARjG0BfEiVqcKjKmUEze9Gh268ABSyQqKo-jz8gsIiAJSo4jLyCCpqGpqgkfSoFjYwoPYSOrxUnNAURdLSsgrQqCExAHQ1CKAAPm2gAES8Bl0ANDrSWfXRoo36RsagikmhIhOGJqAAVHNNk8uoaAAMg9L2Dk5ykFSglgCeEbygALzekL6Q15CBiS1lqD2Qff16S8ZUABGHY7AqxTRAA"
      },
      {
        "text": "Try",
        "href": "https://www.typescriptlang.org/play/#code/PTAEAEFMCdoe2gZwFygEwGYAsBWdB2DATgCgBLAOwBcYAzAQwGNJQBlARwFd7pIBhOBVpkA5qADeJUKEZwANggD8qRFWiURAbimgA7mQAmVABbLQFTgFsARjG0BfEiVqcKjKmUEze9Gh268ABSyQqKo-jz8gsIiAJSo4jLyCCpqGpqgkfSoFjYwoPYSOrxUnNAURdLSsgrQqCExAHQ1CKAAPm2gAES8Bl0ANDrSWfXRoo36RsagikmhIhOGJqAAVHNNk8uoaAAMg9L2DiQgoAC054ycVOenJHKQVKCWAJ4RvKAAvN6QvpBvkIFEi0yqgepA+v09EtjKgAIw7HYFWKaIA"
      },
      {
        "text": "Try",
        "href": "https://www.typescriptlang.org/play/#code/PTAEAEFMCdoe2gZwFygEwGYAsBWdB2DATgCgBLAOwBcYAzAQwGNJQBlARwFd7pIBhOBVpkA5qADeJUKEZwANggD8qRFWiURAbimgA7mQAmVABbLQFTgFsARjG0BfEiVqcKjKmUEze9Gh268ABSyQqKo-jz8gsIiAJSo4jLyCCpqGpqgkfSoFjYwoPYSOrxUnNAURdLSsgrQqCExAHQ1CKAAPm2gAES8Bl0ANDrSWfXRoo36RsagikmhIhOGJqAAVHNNk8uoaAAMg9L2DiQgoAC054ycVOenJHKQVKCWAJ4RvKAAvN6QvpBvkIFEptjKgAIw7PagOAAByYZCoz1QO0aeEK9EQbC4kQE81imiAA"
      },
      {
        "text": "Try",
        "href": "https://www.typescriptlang.org/play/#code/JYOwLgpgTgZghgYwgAgMoEcCucoQMID2IMwA5sgN4BQyyCBANgVAPwBcyAzmFKKQNw1kAd2AATMAAt2yEJgC2AI2iDaAbQAOUAhoByceRA7deIUgF0OmEAGsQBYSEEBfIA"
      },
      {
        "text": "Try",
        "href": "https://www.typescriptlang.org/play/#code/JYOwLgpgTgZghgYwgAgMoEcCucoQMID2IMwA5sgN4BQyyCBANgVAPwBcyAzmFKKQNw1kAd2AATMAAt2yEJgC2AI2iCAvlSoxMIBGGBE6uOJAzZcACnrEyHUznxESpAJQcKdRsw7deIAcns4DjklaGRVSiFcMEwoEEjaWnomKA4rJwA6ZOZkAB9c5AAiXDFCgBohWkC0xzIM0QlJZBYPa1J68SlkACpWzIaujgAmAAYK2lU1KgB6aeQAWkWETDBF+aoGCDAuLHsAeQAHPSJOZABeSg8mWI5iiFKykU7JDgBGEZHwwU3t+QBPOy4c6GCDGCCAiDmTi7XCHY4gTjOfhAA"
      },
      {
        "text": "Try",
        "href": "https://www.typescriptlang.org/play/#code/PTAEAEFMCdoe2gZwFygEwFYME4BQBLAOwBcYAzAQwGNJQBlARwFcLpIBhOQs-Ac1ADeuUKCpwANggD8qRMWhFeAbmGgA7vgAmxABYzQhJgFsARjBUBfXLjJNCVYvi6i2FUoxZsAFGO59UHqwcXDy8AJSoAqISCLLyikqgQRSohqYwoBaCqmzETNCE2SIiYpLQqL6hAHSlCKAAPvWgAERsms0ANKoiyRUhfFUa2jqgUtF+vINauqAAVOPVQzOoaAAMXSIWlrggoAC0B1RMxAd7uOKQxKCIzEEA8gAOjlyIoAC8gtGS+aitkO2ZFQXK5GACegTY7xckDckAhkC8N08kEez0IiDCSiAA"
      },
      {
        "text": "Try",
        "href": "https://www.typescriptlang.org/play/#code/JYOwLgpgTgZghgYwgAgEJwM7AQQQCZ5QQYbIDeAUMsiHALYQD8AXMhmFKAOYDcVbHCBDCt2nEL34JgYAJ6iO3PtQQB7AK7go8geMnUADqvZwANgGFVeCAr18AvkA"
      },
      {
        "text": "Try",
        "href": "https://www.typescriptlang.org/play/#code/JYOwLgpgTgZghgYwgAgIIBN1QgZxwdWDAAsBVEI5AbwChlkQ4BbCAfgC5kcwpQBzANx1kAVwphO3XiEE0A9HIB6ylapXCpECBK49+Q+giIBPSXpkHkCAPZiep3dNn0ADte5wANgGFr6CGZOQgC+QA"
      },
      {
        "text": "Try",
        "href": "https://www.typescriptlang.org/play/#code/JYOwLgpgTgZghgYwgAgEJwM7AQQQCZ5QQYbIDeAUMsiHALYQD8AXMhmFKAOYDcVbHCBDCt2nEL34JgYAJ6iO3PtQQB7AK7go8geMnUADqvZwANgGFVeCAr18AvhQqhIsRCnyFiGAOoyAFgCqIDLIEAAekCB4pOhYuAREJOT8mjK2ShT2QA"
      },
      {
        "text": "Try",
        "href": "https://www.typescriptlang.org/play/#code/JYOwLgpgTgZghgYwgAgMIHsA27YFdPIDeAUMsgljgFzIDOYUoA5gNzEC+xxoksiKqYFASYUJMlDgATYLlo0QuALYAjaG07dw0eEjSU8mQcNHIIAD0ggptfdkMAaNEJFjNFEPXIIaGezHxjV2QAXiJScgMaACIoCClohwjJGTkaABYAJiT2FiA"
      },
      {
        "text": "Try",
        "href": "https://www.typescriptlang.org/play/#code/JYOwLgpgTgZghgYwgAgMIHsA27YFdPIDeAUMsgljgFzIDOYUoA5gNzEC+xoksiKqwKAkwoSZKHAAmwXLRohcAWwBG0Np2JgAngAd+lPJgFCRyALxoDMfMgBkaQcIgsgA"
      },
      {
        "text": "Try",
        "href": "https://www.typescriptlang.org/play/#code/PTAEAEFMCdoe2gZwFygEwGYAsBWAUAJYB2ALjAGYCGAxpKAMJwA2C5Ark6AN56ijXMEqRCWjEA5gG48AX0KkKNOvQLRqTOjz7RKAEwJsUoImwC2AIxjS5IUAFoH1NiQd287ItRIE4RULp0AdwAKalV1SFRGFmh2TgAyBnCNAEpuXn5fRGZIADoWcWCAA2iEUEDKRFAAEi4wtQ1cgRiZIpTpPgEibMaC4oAlPQMqiqra+ojcnX1DVvbZPDxbOABrSgBPPADKEK5MmNQAInMmNkhDgBpQaeHULDRQGXmlsDg4AAdELaDgveahUCHaCQXSXa6UAi6Qx3B5PSRAA"
      },
      {
        "text": "Try",
        "href": "https://www.typescriptlang.org/play/#code/JYOwLgpgTgZghgYwgAgArQM4HsQEZkDeAUMsiHALYQBcyGYUoA5gNxEC+RRoksiK6KNhAAmQiTKUaZAK4UARtDaciYAJ4AHFAGUwcGDGQBeNJhz4AZKaE4RXACYQEAGzhQUCHPTp6D0Wrr6MGz0QdAAdORUbAD0MaQJpAB6APxAA"
      },
      {
        "text": "Try",
        "href": "https://www.typescriptlang.org/play/#code/JYOwLgpgTgZghgYwgAgEIHsAeyDeAoZZBdcCcAZwC5k4QBPAbjwF8g"
      },
      {
        "text": "Try",
        "href": "https://www.typescriptlang.org/play/#code/JYOwLgpgTgZghgYwgAgEIHsAeyDeAoZZBdcCcAZwC5kBXEAaxHQHcQBuPAXzzwBsIwyTNQzYAvLgJESkCtQBEACwi9e6ZM3RReAE3kAaLhzwB6ExpTEauosoT1kAckwA6YqQqO8wGMgAUYACeAA4Q6L6u7rJg5Mhi8cjy5GBQoADm8gCUkoTu5Oj8LmppfpEyZDEuYOgAMizQAMJw5BB+mZkc3KbmWhbS1jq0LchwyEGhI+QtUGDAJHh5BRBF6CWlbuUUk8jJqSBpmVW19VBNLW0dQA"
      },
      {
        "text": "Try",
        "href": "https://www.typescriptlang.org/play/#code/PTAEAEFMCdoe2gZwFygEwGY1oFAEsA7AFxgDMBDAY0lADkBXAWwCMYAhOAD1AG8dRQlOMUjEUoAk1bQA3DgC+OfCOgVqoAMpFohAOYdufAUJFjUibXrmLlJVVRoc4AG0jkCB3v0HCSZ0MxwLm4E1kA"
      },
      {
        "text": "Try",
        "href": "https://www.typescriptlang.org/play/#code/JYOwLgpgTgZghgYwgAgHIFcC2AjaAhAewA9kBvAKGWQQPAnAGcAuZELXKAbnIF9zzQkWIhQBlMFFABzQiQpUadRiwYTp3PgLrCkyQgQA2EOCFllK1WpGXJsBQ8ZAbyAehfIAtF4TowXj+Qw6CAIYMC0yAwQYADCVvRgDAAUdkQs4pIgMsQANKwQAO5xSokqalkAlCwAbgTAACbcQSFhEVGx8YwpxCwYOPi5+UWdpazs0FXItQ1NwaHhIJHRxdaJ3Wl69kYmsnkghSsJzLZbjpPTjYFzrYvth12pLKSWJccmAJ7IPHsHI28g7wq5ioqQAdIpVgxkABeIb3RIaIA"
      },
      {
        "text": "Try",
        "href": "https://www.typescriptlang.org/play/#code/JYOwLgpgTgZghgYwgAgEIHsAeAeAKgTwAcIA+ZAbwChlkF1wJwBnALmQOIG5KBfIA"
      },
      {
        "text": "Try",
        "href": "https://www.typescriptlang.org/play/#code/JYOwLgpgTgZghgYwgAgEIHsAeAeAKgTwAcIA+ZAbwChlkF1wJwBnALmQOIG5KBfSgen7IAtKIQBXMKOGUANhDDIARljYYcTMFFABzEpyA"
      },
      {
        "text": "Try",
        "href": "https://www.typescriptlang.org/play/#code/JYOwLgpgTgZghgYwgAgEIHsAeAeAKgTwAcIA+ZAbwChlkF1wJwBnALmQOIG5KBfS0SLEQoAymCigA5hkwVqtepGZsm4qdz6UANhDDIARlgCCbGdlUSQksgF4KChsuQAiABYQtW9M+Q9uhzCMAOjpHMCZuAHpImmQAPQB+Sm1dAyxUNjFLaSxkO3IHJXC2ZwB3dCgtABMfP0oA1BDFRnComJpEoA"
      },
      {
        "text": "Try",
        "href": "https://www.typescriptlang.org/play/#code/JYOwLgpgTgZghgYwgAgEIHsAeAeAKgTwAcIA+ZAbwChlkF1wJwBnALmQOIG5KBfSy0JFiIUAQUKEANiio0A9HOQA6FUt78FyAMpwAtijhNkAcnK16kZm3FSUPY2rBExE6RkzIAvGizYb0kk4gA"
      },
      {
        "text": "generic functions",
        "href": "/docs/handbook/2/functions.html#generic-functions"
      },
      {
        "text": "Try",
        "href": "https://www.typescriptlang.org/play/#code/JYOwLgpgTgZghgYwgAgEIHsAeAeAKgTwAcIA+ZAbwChlkF1wJwBnALmQOIG5KBfSygPQDkAWjEIArmDEjKMCSARhg9ZEwhgAwvUjM8RUgAoARljYYcHUgBpkICAHdtDZmysBKCtWSnMAOjoXMCZkAF47R2ddYO4eIA"
      },
      {
        "text": "Try",
        "href": "https://www.typescriptlang.org/play/#code/JYOwLgpgTgZghgYwgAgEIHsAeAeAKgTwAcIA+ZAbwChlkF1wJwBnALmQOIG5KBfIA"
      },
      {
        "text": "Try",
        "href": "https://www.typescriptlang.org/play/#code/C4TwDgpgBAQg9gDwDwBVwQHxQLxQN4BQUUAxnAHbASUDOAXFGpANwEC+zQA"
      },
      {
        "text": "Try",
        "href": "https://www.typescriptlang.org/play/#code/PTAEAEFMCdoe2gZwFygEwFYDsGBQAXATwAdJQB5aAOQFcAbOgHgBUTIA+UAXlFdNAA+oAHb06AblwE2FYZEoBZAIbDCLNpx58yQ7QG0AupOn9ycxSsKVaDdaU0VqYxmfnRlqux3aSQofwB6APxSRKbm7pbWYgDK+NAAlsIA5ojcsm4eVk62iPFJyT64foFBQA"
      },
      {
        "text": "Try",
        "href": "https://www.typescriptlang.org/play/#code/GYVwdgxgLglg9mABAEzgZTgWwKZQBYxgDmAFAG4CGANiNgFyICCATsxQJ4A8AzlM4UQB8ASkQBvAFCJEAehmIAdEokBfCRKq5EmdizbsGvfsQDaAXUQBeRCYBEebFSpxbAGkS2A7nGZVktswBudTlEbBh8bGZEOGBESO5sRG9mAGsAQglUDBx8ARIdPQ5hYOysXAJiEjBsTyZWDhJ7R2c3DxS-W2ESoA"
      },
      {
        "text": "Try",
        "href": "https://www.typescriptlang.org/play/#code/PTAEAEDsHsBkEsBGAuUAXATgVwKYCh5I0cMAzAQwGMdQA5LAW0RNAG8BfAoki60AZUyEA5m06FiZKjQBC0aABsc5SGK6TeNfgE8mitSFABaE5SxoTR9T2mgAghgzltAHgAq2gA44AfGzygoMAAVMEBgcGgAOI4aADOoNAYoHGxCWgAFjRKkMKZiaToWaDkjs4AdOGgwcDhOXkZqJCMzBgA3HjhIWGB1aAASjgM0ABuOOnFCuRxaKA4Sgw4RKCkGNAMJaqlTtqbACagGLFYGJAJ8GiVvTXhntCeABQAlKge3qAAPqBYkHs4pIQcHsOl1QlVInZPN5fglIDgAO5zBZLeLoaCbEplbQAGn2h2OpwmNDhiPq+WghUyNG2FXBtUCniwcQyD3KbIuQziry8OAA2gBdF6gZpMEggwKGNmVdhAA"
      },
      {
        "text": "Try",
        "href": "https://www.typescriptlang.org/play/#code/PTAEAEFMCdoe2gZwFygEwGYME4BQAzAVwDsBjAFwEs5jQATOAZXMP3wAoA3AQwBtDIKUACVI3BsV4BPAIKxuUgDyJy0SsQDmAPgCUoAN65QoEKADqkUKW61oYuqHzwAtqADkPfoLcA6P0asaFUCABylQAF5QTwFEH0ReSlJIdh0AbgDSILheSB9eOA12AAMAFQALS3xKJHJovgFQSkRQABJ9GMEAbQAGAF0AX2L03ADTPx8AI0I6gHdLa2I3OucZ7nJLDwbvHwDOuJDCRHL2ACJK3gKAQlORgaA"
      },
      {
        "text": "Try",
        "href": "https://www.typescriptlang.org/play/#code/PTAEAEFMCdoe2gZwFygEwDYCcBmAUAHaQDuoASpAIYAmcBANgJ4CCsljAFAETSTVcAaUFwDmvSAUHCARvQCukLgEoA3EA"
      },
      {
        "text": "Try",
        "href": "https://www.typescriptlang.org/play/#code/MYewdgzgLgBATiAgnOBDAngLhgJQKaoAm4ANusmugDzRwCWYA5gHwwC8MA2gERx6HcANDG6M+eMEJEAjEgFc83ALoBuIA"
      },
      {
        "text": "Try",
        "href": "https://www.typescriptlang.org/play/#code/PTAEAEFMCdoe2gZwFygEwGYME4BQAzAVwDsBjAFwEs5jQATOAZXMP3wAoA3AQwBtDIKUNEjcGxXgE9QictErEA5gG0AugEpQAb1yhQIPYaPGToAHoXLV6xd36wAdUihS3WiLGh88ALagA5Dz8gv4AdOF2pDSyLnAADtIAvKBBAoihiLyUpJDs6gDckdFwvJChvHCK7AAGACoAFs74lEjkKXwCoJSIoAAkWqmCygAMqgC+1QW4dgbhoQBGhG0A7s6uxP5tPkvc5M6BHSGhdoPpcYSI9ewARI28FQCE11NjQA"
      },
      {
        "text": "Try",
        "href": "https://www.typescriptlang.org/play/#code/PTAEAEFMCdoe2gZwFygCwEYAMaBQAbSAF1AA9VpIBDAEzgDt8BPURI6AS3oHMBtAXVABeUAIDcBYqCao2nHgOGj+E3KSVMJLEaTFA"
      },
      {
        "text": "Try",
        "href": "https://www.typescriptlang.org/play/#code/C4TwDgpgBAysBOBLAdgcwHIFcC2AjC8ACgIaLxQC8UA2gM4IqoA0UyO+8AugNwBQA9PyjCRoseKgA9aTNlzJQA"
      },
      {
        "text": "Try",
        "href": "https://www.typescriptlang.org/play/#code/GYVwdgxgLglg9mABAEzgZTgWwKZQBYxgDmAFAA4CGMATgFyIDaAzlNYUQDSJgiYBG2agF0AlIgDeAKESIICFogqIAvIko0GABiEBuaYgD0BmTIB6Afn1ywCvirVVqDAIy79Rk4gvvjAOn+SAL6SkqgYOPjsJAwARHjYADYJcDFcACwATKI6QA"
      },
      {
        "text": "Try",
        "href": "https://www.typescriptlang.org/play/#code/PTAEAEFMCdoe2gZwFygEwBYCcBmAUAGYCuAdgMYAuAlnCaACZwDKcAtpBQBZUkDmAFAAcAhlWioA2ogrQevADSgSRVgCMYAXQCUoAN55QoEKAB0ZvAdBla0q6AC8oEWIloNAbjwBfIA"
      },
      {
        "text": "destructure tuples",
        "href": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/Destructuring_assignment#Array_destructuring"
      },
      {
        "text": "Try",
        "href": "https://www.typescriptlang.org/play/#code/GYVwdgxgLglg9mABAEzgZTgWwKZQBYxgDmAFAM5QBOhRAEgIZl4BciA2hdcQDSJgiYARtkoBdAJSIA3gChEiCAgrtCABxBQ0VGrzyM8oxAF5EnGgyYBuGXIVK4AG2wA6B3FJqNWrkXHX5APQB8iGhiAB6APw28opgZI4ubqR6TH62QWFhUTIAvkA"
      },
      {
        "text": "Try",
        "href": "https://www.typescriptlang.org/play/#code/JYOwLgpgTgZghgYwgAgMpiqA5gOQK4C2ARtAApzBTIDeAUMsgPSPIDOADhAsHADbAAvCABNk7KAHtOUMMAit6yXhBBYwACwBcyAEwBuRQAZtrDNgMMAjNpCESUA4ubIA8hujIA5AEEoUOACeADymmKrIAD7ItsTQAHyeyAQQsVCsAHSZiqz8SAAUpnAyAPw2dtAANMgqwqXR5VAAlNq+-sGh2JH1qXEGAL5AA"
      },
      {
        "text": "Try",
        "href": "https://www.typescriptlang.org/play/#code/C4TwDgpgBAoglsAFhATgJgCYHkUGYNQC8UA2gHYCuAtgEaoA0UltDT1dKA-ALoDcAUPwBmFMgGNgcAPZkoAZwjAAwlKkoMcMgENgEABRjV6gFywEydNjwYAlFADe-KFENk5wUgA9GIRgC9uIhcjDAFnAHpw52iY5wA9TkFnVzkpABsIADo0qQBzPQADAAUUKQA3OAwIAkM1DW1dOShELQIAEnta9WyIMlykAF8oDSpeuWk3ApswqEjY+YXFpaWE-gGgA"
      },
      {
        "text": "Try",
        "href": "https://www.typescriptlang.org/play/#code/C4TwDgpgBAysBOBLAdgcwHIFcC2AjC8AQgPbEA2EAhsgM5QC8UA2jQiqgDRTI77xcA6IblIVqTALoSA3AChQkWGzQlyVWljwEGzVkjSDho9ZK48t8GfPDRVY2nH0Ze2xkyECRa8RK572Zi6W0kA"
      },
      {
        "text": "Try",
        "href": "https://www.typescriptlang.org/play/#code/C4TwDgpgBAysBOBLAdgcwHIFcC2AjC8AQgPbEA2EAhsgM5QC8UA2jQiqgDRTI77xcA6IblIVqTALoSA3ACgA9PKgBaVQGNMwVctlritYFEoAuWGzRY8BEuSq0GzAEQALCGTLFHXAIwzd+1ihcUzgkC15rUTs6RiZHfEpNRAAzTDIvKAAmLgRMCD89Ayg1EPMMCKIo6hinAHdieDIAEwyAZhz4PK5kyjIaCA6uqB6+gahc-OkgA"
      },
      {
        "text": "rest parameters and arguments",
        "href": "/docs/handbook/2/functions.html#rest-parameters-and-arguments"
      },
      {
        "text": "Try",
        "href": "https://www.typescriptlang.org/play/#code/GYVwdgxgLglg9mABAJwKYEMAmAhEUoICSYADngBQB016yA5gM4BciA2g1MjGHQDSJgQAWwBGqZP2qURcOABsMYVgF1lASkQBvAFCJEEBBzZh0Q1PwBu4hvDCTq3MlGWIAvIlqMA3LsQB6P0QpbQBfIA"
      },
      {
        "text": "Try",
        "href": "https://www.typescriptlang.org/play/#code/GYVwdgxgLglg9mABAJwKYEMAmAhEUoICSYADngBRjoC2qAXIgM5TIxgDmANIgG6rKN4YBmBDUARv24A6WWzJQG4uHAA2GMAG0AugEpEAbwBQiRAHoziWdKMBfIA"
      },
      {
        "text": "Try",
        "href": "https://www.typescriptlang.org/play/#code/GYVwdgxgLglg9mABAEzgZTgWwKZQBYxgDmAFAA4CGMATgFyLXYWpgA2AnogNoDOU1hIgBpEYEJgBG2agF0AlIgDeAKESIA9OrXaduvdoB6R4ydNmTqjVoB0t5QF8gA"
      },
      {
        "text": "Try",
        "href": "https://www.typescriptlang.org/play/#code/PTAEAEFMCdoe2gZwFygEwFYAsAGAUAGYCuAdgMYAuAlnCaACZwDKcAtpBQBZUkDmAFAAcAhlWipokYYxIAbAJ6gA2ogrQevADSgSRVgCMYAXQCUoAN55QoEWKU4joALygARJ0izZcAISuA3HgAvkA"
      },
      {
        "text": "Try",
        "href": "https://www.typescriptlang.org/play/#code/PTAEAEFMCdoe2gZwFygEwGYAsBWAUADaQAuoADnAJYB2pAvKANoYA0oWAuqAIaKgDGcaomIBuPHgBmAV2r9ilIaAAmlEdzmQAYvAC2AeWiUA5jQAUjAB5sAnh1SNq03QCMYbJ65gcAlKADeeKCg0CTS0NSgALLcxAAWAHSIAI7QxGaWoABUWeigANSgNtm5aD7iAL4SquqaOnAGRqbUZhQ0xOVAA"
      }
    ],
    "meta": {
      "description": "How TypeScript describes the shapes of JavaScript objects.",
      "keywords": ""
    },
    "summary": "In JavaScript, the fundamental way that we group and pass around data is through objects. In TypeScript, we represent those through object types",
    "tags": [
      "react",
      "javascript",
      "typescript",
      "html",
      "vite",
      "types",
      "property",
      "properties",
      "readonly",
      "intersection"
    ],
    "id": "typescript-documentation-objectshtml-part-1",
    "quality": 100
  },
  {
    "title": "TypeScript: Documentation",
    "url": "https://www.typescriptlang.org/docs/handbook/2/functions.html",
    "category": "typescript",
    "content": "Functions are the basic building block of any application, whether theyre local functions, imported from another module, or methods on a class. Theyre also values, and just like other values, TypeScript has many ways to describe how functions can be called. Lets learn about how to write types that describe functions. Function Type Expressions The simplest way to describe a function is with a function type expression. These types are syntactically similar to arrow functions: tsfunction greeter(fn: (a: string) = void) { fn(\"Hello, World\");} function printToConsole(s: string) { console.log(s);} greeter(printToConsole);Try The syntax (a: string) = void means a function with one parameter, named a, of type string, that doesnt have a return value. Just like with function declarations, if a parameter type isnt specified, its implicitly any. Note that the parameter name is required. The function type (string) = void means a function with a parameter named string of type any! Of course, we can use a type alias to name a function type: tstype GreetFunction = (a: string) = void;function greeter(fn: GreetFunction) { // ...}Try Call Signatures In JavaScript, functions can have properties in addition to being callable. However, the function type expression syntax doesnt allow for declaring properties. If we want to describe something callable with properties, we can write a call signature in an object type: tstype DescribableFunction = { description: string; (someArg: number): boolean;};function doSomething(fn: DescribableFunction) { console.log(fn.description + \" returned \" + fn(6));} function myFunc(someArg: number) { return someArg  3;}myFunc.description = \"default description\"; doSomething(myFunc);Try Note that the syntax is slightly different compared to a function type expression - use : between the parameter list and the return type rather than =. Construct Signatures JavaScript functions can also be invoked with the new operator. TypeScript refers to these as constructors because they usually create a new object. You can write a construct signature by adding the new keyword in front of a call signature: tstype SomeConstructor = { new (s: string): SomeObject;};function fn(ctor: SomeConstructor) { return new ctor(\"hello\");}Try Some objects, like JavaScripts Date object, can be called with or without new. You can combine call and construct signatures in the same type arbitrarily: tsinterface CallOrConstruct { (n?: number): string; new (s: string): Date;} function fn(ctor: CallOrConstruct) { // Passing an argument of type number to ctor matches it against // the first definition in the CallOrConstruct interface. console.log(ctor(10)); (parameter) ctor: CallOrConstruct (n?: number) = string // Similarly, passing an argument of type string to ctor matches it // against the second definition in the CallOrConstruct interface. console.log(new ctor(\"10\")); (parameter) ctor: CallOrConstruct new (s: string) = Date} fn(Date);Try Generic Functions Its common to write a function where the types of the input relate to the type of the output, or where the types of two inputs are related in some way. Lets consider for a moment a function that returns the first element of an array: tsfunction firstElement(arr: any[]) { return arr[0];}Try This function does its job, but unfortunately has the return type any. Itd be better if the function returned the type of the array element. In TypeScript, generics are used when we want to describe a correspondence between two values. We do this by declaring a type parameter in the function signature: tsfunction firstElementType(arr: Type[]): Type  undefined { return arr[0];}Try By adding a type parameter Type to this function and using it in two places, weve created a link between the input of the function (the array) and the output (the return value). Now when we call it, a more specific type comes out: ts// s is of type 'string'const s = firstElement([\"a\", \"b\", \"c\"]);// n is of type 'number'const n = firstElement([1, 2, 3]);// u is of type undefinedconst u = firstElement([]);Try Inference Note that we didnt have to specify Type in this sample. The type was inferred - chosen automatically - by TypeScript. We can use multiple type parameters as well. For example, a standalone version of map would look like this: tsfunction mapInput, Output(arr: Input[], func: (arg: Input) = Output): Output[] { return arr.map(func);} // Parameter 'n' is of type 'string'// 'parsed' is of type 'number[]'const parsed = map([\"1\", \"2\", \"3\"], (n) = parseInt(n));Try Note that in this example, TypeScript could infer both the type of the Input type parameter (from the given string array), as well as the Output type parameter based on the return value of the function expression (number). Constraints Weve written some generic functions that can work on any kind of value. Sometimes we want to relate two values, but can only operate on a certain subset of values. In this case, we can use a constraint to limit the kinds of types that a type parameter can accept. Lets write a function that returns the longer of two values. To do this, we need a length property thats a number. We constrain the type parameter to that type by writing an extends clause: tsfunction longestType extends { length: number }(a: Type, b: Type) { if (a.length = b.length) { return a; } else { return b; }} // longerArray is of type 'number[]'const longerArray = longest([1, 2], [1, 2, 3]);// longerString is of type 'alice'  'bob'const longerString = longest(\"alice\", \"bob\");// Error! Numbers don't have a 'length' propertyconst notOK = longest(10, 100);Argument of type 'number' is not assignable to parameter of type '{ length: number; }'.2345Argument of type 'number' is not assignable to parameter of type '{ length: number; }'.Try There are a few interesting things to note in this example. We allowed TypeScript to infer the return type of longest. Return type inference also works on generic functions. Because we constrained Type to { length: number }, we were allowed to access the .length property of the a and b parameters. Without the type constraint, we wouldnt be able to access those properties because the values might have been some other type without a length property. The types of longerArray and longerString were inferred based on the arguments. Remember, generics are all about relating two or more values with the same type! Finally, just as wed like, the call to longest(10, 100) is rejected because the number type doesnt have a .length property. Working with Constrained Values Heres a common error when working with generic constraints: tsfunction minimumLengthType extends { length: number }( obj: Type, minimum: number): Type { if (obj.length = minimum) { return obj; } else { return { length: minimum };Type '{ length: number; }' is not assignable to type 'Type'. '{ length: number; }' is assignable to the constraint of type 'Type', but 'Type' could be instantiated with a different subtype of constraint '{ length: number; }'.2322Type '{ length: number; }' is not assignable to type 'Type'. '{ length: number; }' is assignable to the constraint of type 'Type', but 'Type' could be instantiated with a different subtype of constraint '{ length: number; }'. }}Try It might look like this function is OK - Type is constrained to { length: number }, and the function either returns Type or a value matching that constraint. The problem is that the function promises to return the same kind of object as was passed in, not just some object matching the constraint. If this code were legal, you could write code that definitely wouldnt work: ts// 'arr' gets value { length: 6 }const arr = minimumLength([1, 2, 3], 6);// and crashes here because arrays have// a 'slice' method, but not the returned object!console.log(arr.slice(0));Try Specifying Type Arguments TypeScript can usually infer the intended type arguments in a generic call, but not always. For example, lets say you wrote a function to combine two arrays: tsfunction combineType(arr1: Type[], arr2: Type[]): Type[] { return arr1.concat(arr2);}Try Normally it would be an error to call this function with mismatched arrays: tsconst arr = combine([1, 2, 3], [\"hello\"]);Type 'string' is not assignable to type 'number'.2322Type 'string' is not assignable to type 'number'.Try If you intended to do this, however, you could manually specify Type: tsconst arr = combinestring  number([1, 2, 3], [\"hello\"]);Try Guidelines for Writing Good Generic Functions Writing generic functions is fun, and it can be easy to get carried away with type parameters. Having too many type parameters or using constraints where they arent needed can make inference less successful, frustrating callers of your function. Push Type Parameters Down Here are two ways of writing a function that appear similar: tsfunction firstElement1Type(arr: Type[]) { return arr[0];} function firstElement2Type extends any[](arr: Type) { return arr[0];} // a: number (good)const a = firstElement1([1, 2, 3]);// b: any (bad)const b = firstElement2([1, 2, 3]);Try These might seem identical at first glance, but firstElement1 is a much better way to write this function. Its inferred return type is Type, but firstElement2s inferred return type is any because TypeScript has to resolve the arr[0] expression using the constraint type, rather than waiting to resolve the element during a call. Rule: When possible, use the type parameter itself rather than constraining it Use Fewer Type Parameters Heres another pair of similar functions: tsfunction filter1Type(arr: Type[], func: (arg: Type) = boolean): Type[] { return arr.filter(func);} function filter2Type, Func extends (arg: Type) = boolean( arr: Type[], func: Func): Type[] { return arr.filter(func);}Try Weve created a type parameter Func that doesnt relate two values. Thats always a red flag, because it means callers wanting to specify type arguments have to manually specify an extra type argument for no reason. Func doesnt do anything but make the function harder to read and reason about! Rule: Always use as few type parameters as possible Type Parameters Should Appear Twice Sometimes we forget that a function might not need to be generic: tsfunction greetStr extends string(s: Str) { console.log(\"Hello, \" + s);} greet(\"world\");Try We could just as easily have written a simpler version: tsfunction greet(s: string) { console.log(\"Hello, \" + s);}Try Remember, type parameters are for relating the types of multiple values. If a type parameter is only used once in the function signature, its not relating anything. This includes the inferred return type; for example, if Str was part of the inferred return type of greet, it would be relating the argument and return types, so would be used twice despite appearing only once in the written code. Rule: If a type parameter only appears in one location, strongly reconsider if you actually need it Optional Parameters Functions in JavaScript often take a variable number of arguments. For example, the toFixed method of number takes an optional digit count: tsfunction f(n: number) { console.log(n.toFixed()); // 0 arguments console.log(n.toFixed(3)); // 1 argument}Try We can model this in TypeScript by marking the parameter as optional with ?: tsfunction f(x?: number) { // ...}f(); // OKf(10); // OKTry Although the parameter is specified as type number, the x parameter will actually have the type number  undefined because unspecified parameters in JavaScript get the value undefined. You can also provide a parameter default: tsfunction f(x = 10) { // ...}Try Now in the body of f, x will have type number because any undefined argument will be replaced with 10. Note that when a parameter is optional, callers can always pass undefined, as this simply simulates a missing argument: ts// All OKf();f(10);f(undefined);Try Optional Parameters in Callbacks Once youve learned about optional parameters and function type expressions, its very easy to make the following mistakes when writing functions that invoke callbacks: tsfunction myForEach(arr: any[], callback: (arg: any, index?: number) = void) { for (let i = 0; i  arr.length; i++) { callback(arr[i], i); }}Try What people usually intend when writing index? as an optional parameter is that they want both of these calls to be legal: tsmyForEach([1, 2, 3], (a) = console.log(a));myForEach([1, 2, 3], (a, i) = console.log(a, i));Try What this actually means is that callback might get invoked with one argument. In other words, the function definition says that the implementation might look like this: tsfunction myForEach(arr: any[], callback: (arg: any, index?: number) = void) { for (let i = 0; i  arr.length; i++) { // I don't feel like providing the index today callback(arr[i]); }}Try In turn, TypeScript will enforce this meaning and issue errors that arent really possible: tsmyForEach([1, 2, 3], (a, i) = { console.log(i.toFixed());'i' is possibly 'undefined'.18048'i' is possibly 'undefined'.});Try In JavaScript, if you call a function with more arguments than there are parameters, the extra arguments are simply ignored. TypeScript behaves the same way. Functions with fewer parameters (of the same types) can always take the place of functions with more parameters. Rule: When writing a function type for a callback, never write an optional parameter unless you intend to call the function without passing that argument Function Overloads Some JavaScript functions can be called in a variety of argument counts and types. For example, you might write a function to produce a Date that takes either a timestamp (one argument) or a month/day/year specification (three arguments). In TypeScript, we can specify a function that can be called in different ways by writing overload signatures. To do this, write some number of function signatures (usually two or more), followed by the body of the function: tsfunction makeDate(timestamp: number): Date;function makeDate(m: number, d: number, y: number): Date;function makeDate(mOrTimestamp: number, d?: number, y?: number): Date { if (d !== undefined && y !== undefined) { return new Date(y, mOrTimestamp, d); } else { return new Date(mOrTimestamp); }}const d1 = makeDate(12345678);const d2 = makeDate(5, 5, 5);const d3 = makeDate(1, 3);No overload expects 2 arguments, but overloads do exist that expect either 1 or 3 arguments.2575No overload expects 2 arguments, but overloads do exist that expect either 1 or 3 arguments.Try In this example, we wrote two overloads: one accepting one argument, and another accepting three arguments. These first two signatures are called the overload signatures. Then, we wrote a function implementation with a compatible signature. Functions have an implementation signature, but this signature cant be called directly. Even though we wrote a function with two optional parameters after the required one, it cant be called with two parameters! Overload Signatures and the Implementation Signature This is a common source of confusion. Often people will write code like this and not understand why there is an error: tsfunction fn(x: string): void;function fn() { // ...}// Expected to be able to call with zero argumentsfn();Expected 1 arguments, but got 0.2554Expected 1 arguments, but got 0.Try Again, the signature used to write the function body cant be seen from the outside. The signature of the implementation is not visible from the outside. When writing an overloaded function, you should always have two or more signatures above the implementation of the function. The implementation signature must also be compatible with the overload signatures. For example, these functions have errors because the implementation signature doesnt match the overloads in a correct way: tsfunction fn(x: boolean): void;// Argument type isn't rightfunction fn(x: string): void;This overload signature is not compatible with its implementation signature.2394This overload signature is not compatible with its implementation signature.function fn(x: boolean) {}Try tsfunction fn(x: string): string;// Return type isn't rightfunction fn(x: number): boolean;This overload signature is not compatible with its implementation signature.2394This overload signature is not compatible with its implementation signature.function fn(x: string  number) { return \"oops\";}Try Writing Good Overloads Like generics, there are a few guidelines you should follow when using function overloads. Following these principles will make your function easier to call, easier to understand, and easier to implement. Lets consider a function that returns the length of a string or an array: tsfunction len(s: string): number;function len(arr: any[]): number;function len(x: any) { return x.length;}Try This function is fine; we can invoke it with strings or arrays. However, we cant invoke it with a value that might be a string or an array, because TypeScript can only resolve a function call to a single overload: tslen(\"\"); // OKlen([0]); // OKlen(Math.random()  0.5 ? \"hello\" : [0]);No overload matches this call. Overload 1 of 2, '(s: string): number', gave the following error. Argument of type 'number[]  \"hello\"' is not assignable to parameter of type 'string'. Type 'number[]' is not assignable to type 'string'. Overload 2 of 2, '(arr: any[]): number', gave the following error. Argument of type 'number[]  \"hello\"' is not assignable to parameter of type 'any[]'. Type 'string' is not assignable to type 'any[]'.2769No overload matches this call. Overload 1 of 2, '(s: string): number', gave the following error. Argument of type 'number[]  \"hello\"' is not assignable to parameter of type 'string'. Type 'number[]' is not assignable to type 'string'. Overload 2 of 2, '(arr: any[]): number', gave the following error. Argument of type 'number[]  \"hello\"' is not assignable to parameter of type 'any[]'. Type 'string' is not assignable to type 'any[]'.Try Because both overloads have the same argument count and same return type, we can instead write a non-overloaded version of the function: tsfunction len(x: any[]  string) { return x.length;}Try This is much better! Callers can invoke this with either sort of value, and as an added bonus, we dont have to figure out a correct implementation signature. Always prefer parameters with union types instead of overloads when possible Declaring this in a Function TypeScript will infer what the this should be in a function via code flow analysis, for example in the following: tsconst user = { id: 123, admin: false, becomeAdmin: function () { this.admin = true; },};Try TypeScript understands that the function user.becomeAdmin has a corresponding this which is the outer object user. this, heh, can be enough for a lot of cases, but there are a lot of cases where you need more control over what object this represents. The JavaScript specification states that you cannot have a parameter called this, and so TypeScript uses that syntax space to let you declare the type for this in the function body. tsinterface DB { filterUsers(filter: (this: User) = boolean): User[];} const db = getDB();const admins = db.filterUsers(function (this: User) { return this.admin;});Try This pattern is common with callback-style APIs, where another object typically controls when your function is called. Note that you need to use function and not arrow functions to get this behavior: tsinterface DB { filterUsers(filter: (this: User) = boolean): User[];} const db = getDB();const admins = db.filterUsers(() = this.admin);The containing arrow function captures the global value of 'this'.Element implicitly has an 'any' type because type 'typeof globalThis' has no index signature.70417017The containing arrow function captures the global value of 'this'.Element implicitly has an 'any' type because type 'typeof globalThis' has no index signature.Try Other Types to Know About There are some additional types youll want to recognize that appear often when working with function types. Like all types, you can use them everywhere, but these are especially relevant in the context of functions. void void represents the return value of functions which dont return a value. Its the inferred type any time a function doesnt have any return statements, or doesnt return any explicit value from those return statements: ts// The inferred return type is voidfunction noop() { return;}Try In JavaScript, a function that doesnt return any value will implicitly return the value undefined. However, void and undefined are not the same thing in TypeScript. There are further details at the end of this chapter. void is not the same as undefined. object The special type object refers to any value that isnt a primitive (string, number, bigint, boolean, symbol, null, or undefined). This is different from the empty object type { }, and also different from the global type Object. Its very likely you will never use Object. object is not Object. Always use object! Note that in JavaScript, function values are objects: They have properties, have Object.prototype in their prototype chain, are instanceof Object, you can call Object.keys on them, and so on. For this reason, function types are considered to be objects in TypeScript. unknown The unknown type represents any value. This is similar to the any type, but is safer because its not legal to do anything with an unknown value: tsfunction f1(a: any) { a.b(); // OK}function f2(a: unknown) { a.b();'a' is of type 'unknown'.18046'a' is of type 'unknown'.}Try This is useful when describing function types because you can describe functions that accept any value without having any values in your function body. Conversely, you can describe a function that returns a value of unknown type: tsfunction safeParse(s: string): unknown { return JSON.parse(s);} // Need to be careful with 'obj'!const obj = safeParse(someRandomString);Try never Some functions never return a value: tsfunction fail(msg: string): never { throw new Error(msg);}Try The never type represents values which are never observed. In a return type, this means that the function throws an exception or terminates execution of the program. never also appears when TypeScript determines theres nothing left in a union. tsfunction fn(x: string  number) { if (typeof x === \"string\") { // do something } else if (typeof x === \"number\") { // do something else } else { x; // has type 'never'! }}Try Function The global type Function describes properties like bind, call, apply, and others present on all function values in JavaScript. It also has the special property that values of type Function can always be called; these calls return any: tsfunction doSomething(f: Function) { return f(1, 2, 3);}Try This is an untyped function call and is generally best avoided because of the unsafe any return type. If you need to accept an arbitrary function but dont intend to call it, the type () = void is generally safer. Rest Parameters and Arguments Background Reading: Rest Parameters Spread Syntax Rest Parameters In addition to using optional parameters or overloads to make functions that can accept a variety of fixed argument counts, we can also define functions that take an unbounded number of arguments using rest parameters. A rest parameter appears after all other parameters, and uses the ... syntax: tsfunction multiply(n: number, ...m: number[]) { return m.map((x) = n * x);}// 'a' gets value [10, 20, 30, 40]const a = multiply(10, 1, 2, 3, 4);Try In TypeScript, the type annotation on these parameters is implicitly any[] instead of any, and any type annotation given must be of the form ArrayT or T[], or a tuple type (which well learn about later). Rest Arguments Conversely, we can provide a variable number of arguments from an iterable object (for example, an array) using the spread syntax. For example, the push method of arrays takes any number of arguments: tsconst arr1 = [1, 2, 3];const arr2 = [4, 5, 6];arr1.push(...arr2);Try Note that in general, TypeScript does not assume that arrays are immutable. This can lead to some surprising behavior: ts// Inferred type is number[] -- \"an array with zero or more numbers\",// not specifically two numbersconst args = [8, 5];const angle = Math.atan2(...args);A spread argument must either have a tuple type or be passed to a rest parameter.2556A spread argument must either have a tuple type or be passed to a rest parameter.Try The best fix for this situation depends a bit on your code, but in general a const context is the most straightforward solution: ts// Inferred as 2-length tupleconst args = [8, 5] as const;// OKconst angle = Math.atan2(...args);Try Using rest arguments may require turning on downlevelIteration when targeting older runtimes. Parameter Destructuring Background Reading: Destructuring Assignment You can use parameter destructuring to conveniently unpack objects provided as an argument into one or more local variables in the function body. In JavaScript, it looks like this: jsfunction sum({ a, b, c }) { console.log(a + b + c);}sum({ a: 10, b: 3, c: 9 }); The type annotation for the object goes after the destructuring syntax: tsfunction sum({ a, b, c }: { a: number; b: number; c: number }) { console.log(a + b + c);}Try This can look a bit verbose, but you can use a named type here as well: ts// Same as prior exampletype ABC = { a: number; b: number; c: number };function sum({ a, b, c }: ABC) { console.log(a + b + c);}Try Assignability of Functions Return type void The void return type for functions can produce some unusual, but expected behavior. Contextual typing with a return type of void does not force functions to not return something. Another way to say this is a contextual function type with a void return type (type voidFunc = () = void), when implemented, can return any other value, but it will be ignored. Thus, the following implementations of the type () = void are valid: tstype voidFunc = () = void; const f1: voidFunc = () = { return true;}; const f2: voidFunc = () = true; const f3: voidFunc = function () { return true;};Try And when the return value of one of these functions is assigned to another variable, it will retain the type of void: tsconst v1 = f1(); const v2 = f2(); const v3 = f3();Try This behavior exists so that the following code is valid even though Array.prototype.push returns a number and the Array.prototype.forEach method expects a function with a return type of void. tsconst src = [1, 2, 3];const dst = [0]; src.forEach((el) = dst.push(el));Try There is one other special case to be aware of, when a literal function definition has a void return type, that function must not return anything. tsfunction f2(): void { // @ts-expect-error return true;} const f3 = function (): void { // @ts-expect-error return true;};Try For more on void please refer to these other documentation entries: FAQ - Why are functions returning non-void assignable to function returning void?",
    "headings": [
      {
        "level": 2,
        "text": "Function Type Expressions",
        "id": "function-type-expressions"
      },
      {
        "level": 2,
        "text": "Call Signatures",
        "id": "call-signatures"
      },
      {
        "level": 2,
        "text": "Construct Signatures",
        "id": "construct-signatures"
      },
      {
        "level": 2,
        "text": "Generic Functions",
        "id": "generic-functions"
      },
      {
        "level": 2,
        "text": "Optional Parameters",
        "id": "optional-parameters"
      },
      {
        "level": 2,
        "text": "Function Overloads",
        "id": "function-overloads"
      },
      {
        "level": 2,
        "text": "Declaring this in a Function",
        "id": "declaring-this-in-a-function"
      },
      {
        "level": 2,
        "text": "Other Types to Know About",
        "id": "other-types-to-know-about"
      },
      {
        "level": 2,
        "text": "Rest Parameters and Arguments",
        "id": "rest-parameters-and-arguments"
      },
      {
        "level": 2,
        "text": "Parameter Destructuring",
        "id": "parameter-destructuring"
      },
      {
        "level": 2,
        "text": "Assignability of Functions",
        "id": "assignability-of-functions"
      },
      {
        "level": 3,
        "text": "Inference",
        "id": "inference"
      },
      {
        "level": 3,
        "text": "Constraints",
        "id": "constraints"
      },
      {
        "level": 3,
        "text": "Working with Constrained Values",
        "id": "working-with-constrained-values"
      },
      {
        "level": 3,
        "text": "Specifying Type Arguments",
        "id": "specifying-type-arguments"
      },
      {
        "level": 3,
        "text": "Guidelines for Writing Good Generic Functions",
        "id": "guidelines-for-writing-good-generic-functions"
      },
      {
        "level": 3,
        "text": "Optional Parameters in Callbacks",
        "id": "optional-parameters-in-callbacks"
      },
      {
        "level": 3,
        "text": "Overload Signatures and the Implementation Signature",
        "id": "overload-signatures-and-the-implementation-signature"
      },
      {
        "level": 3,
        "text": "Writing Good Overloads",
        "id": "writing-good-overloads"
      },
      {
        "level": 3,
        "text": "void",
        "id": "void"
      },
      {
        "level": 3,
        "text": "object",
        "id": "object"
      },
      {
        "level": 3,
        "text": "unknown",
        "id": "unknown"
      },
      {
        "level": 3,
        "text": "never",
        "id": "never"
      },
      {
        "level": 3,
        "text": "Function",
        "id": "function"
      },
      {
        "level": 3,
        "text": "Rest Parameters",
        "id": "rest-parameters"
      },
      {
        "level": 3,
        "text": "Rest Arguments",
        "id": "rest-arguments"
      },
      {
        "level": 3,
        "text": "Return type void",
        "id": "return-type-void"
      },
      {
        "level": 4,
        "text": "Push Type Parameters Down",
        "id": "push-type-parameters-down"
      },
      {
        "level": 4,
        "text": "Use Fewer Type Parameters",
        "id": "use-fewer-type-parameters"
      },
      {
        "level": 4,
        "text": "Type Parameters Should Appear Twice",
        "id": "type-parameters-should-appear-twice"
      }
    ],
    "codeBlocks": [
      {
        "language": "text",
        "code": "tsfunction greeter(fn: (a: string) => void) {  fn(\"Hello, World\");} function printToConsole(s: string) {  console.log(s);} greeter(printToConsole);Try"
      },
      {
        "language": "text",
        "code": "function greeter(fn: (a: string) => void) {  fn(\"Hello, World\");} function printToConsole(s: string) {  console.log(s);} greeter(printToConsole);"
      },
      {
        "language": "text",
        "code": "(a: string) => void"
      },
      {
        "language": "text",
        "code": "(string) => void"
      },
      {
        "language": "text",
        "code": "tstype GreetFunction = (a: string) => void;function greeter(fn: GreetFunction) {  // ...}Try"
      },
      {
        "language": "text",
        "code": "type GreetFunction = (a: string) => void;function greeter(fn: GreetFunction) {  // ...}"
      },
      {
        "language": "text",
        "code": "tstype DescribableFunction = {  description: string;  (someArg: number): boolean;};function doSomething(fn: DescribableFunction) {  console.log(fn.description + \" returned \" + fn(6));} function myFunc(someArg: number) {  return someArg > 3;}myFunc.description = \"default description\"; doSomething(myFunc);Try"
      },
      {
        "language": "text",
        "code": "type DescribableFunction = {  description: string;  (someArg: number): boolean;};function doSomething(fn: DescribableFunction) {  console.log(fn.description + \" returned \" + fn(6));} function myFunc(someArg: number) {  return someArg > 3;}myFunc.description = \"default description\"; doSomething(myFunc);"
      },
      {
        "language": "text",
        "code": "tstype SomeConstructor = {  new (s: string): SomeObject;};function fn(ctor: SomeConstructor) {  return new ctor(\"hello\");}Try"
      },
      {
        "language": "text",
        "code": "type SomeConstructor = {  new (s: string): SomeObject;};function fn(ctor: SomeConstructor) {  return new ctor(\"hello\");}"
      },
      {
        "language": "text",
        "code": "tsinterface CallOrConstruct {  (n?: number): string;  new (s: string): Date;} function fn(ctor: CallOrConstruct) {  // Passing an argument of type `number` to `ctor` matches it against  // the first definition in the `CallOrConstruct` interface.  console.log(ctor(10));               (parameter) ctor: CallOrConstruct\n(n?: number) => string   // Similarly, passing an argument of type `string` to `ctor` matches it  // against the second definition in the `CallOrConstruct` interface.  console.log(new ctor(\"10\"));                   (parameter) ctor: CallOrConstruct\nnew (s: string) => Date} fn(Date);Try"
      },
      {
        "language": "text",
        "code": "interface CallOrConstruct {  (n?: number): string;  new (s: string): Date;} function fn(ctor: CallOrConstruct) {  // Passing an argument of type `number` to `ctor` matches it against  // the first definition in the `CallOrConstruct` interface.  console.log(ctor(10));               (parameter) ctor: CallOrConstruct\n(n?: number) => string   // Similarly, passing an argument of type `string` to `ctor` matches it  // against the second definition in the `CallOrConstruct` interface.  console.log(new ctor(\"10\"));                   (parameter) ctor: CallOrConstruct\nnew (s: string) => Date} fn(Date);"
      },
      {
        "language": "text",
        "code": "tsfunction firstElement(arr: any[]) {  return arr[0];}Try"
      },
      {
        "language": "text",
        "code": "function firstElement(arr: any[]) {  return arr[0];}"
      },
      {
        "language": "text",
        "code": "tsfunction firstElement<Type>(arr: Type[]): Type | undefined {  return arr[0];}Try"
      },
      {
        "language": "text",
        "code": "function firstElement<Type>(arr: Type[]): Type | undefined {  return arr[0];}"
      },
      {
        "language": "text",
        "code": "ts// s is of type 'string'const s = firstElement([\"a\", \"b\", \"c\"]);// n is of type 'number'const n = firstElement([1, 2, 3]);// u is of type undefinedconst u = firstElement([]);Try"
      },
      {
        "language": "text",
        "code": "// s is of type 'string'const s = firstElement([\"a\", \"b\", \"c\"]);// n is of type 'number'const n = firstElement([1, 2, 3]);// u is of type undefinedconst u = firstElement([]);"
      },
      {
        "language": "text",
        "code": "tsfunction map<Input, Output>(arr: Input[], func: (arg: Input) => Output): Output[] {  return arr.map(func);} // Parameter 'n' is of type 'string'// 'parsed' is of type 'number[]'const parsed = map([\"1\", \"2\", \"3\"], (n) => parseInt(n));Try"
      },
      {
        "language": "text",
        "code": "function map<Input, Output>(arr: Input[], func: (arg: Input) => Output): Output[] {  return arr.map(func);} // Parameter 'n' is of type 'string'// 'parsed' is of type 'number[]'const parsed = map([\"1\", \"2\", \"3\"], (n) => parseInt(n));"
      },
      {
        "language": "text",
        "code": "tsfunction longest<Type extends { length: number }>(a: Type, b: Type) {  if (a.length >= b.length) {    return a;  } else {    return b;  }} // longerArray is of type 'number[]'const longerArray = longest([1, 2], [1, 2, 3]);// longerString is of type 'alice' | 'bob'const longerString = longest(\"alice\", \"bob\");// Error! Numbers don't have a 'length' propertyconst notOK = longest(10, 100);Argument of type 'number' is not assignable to parameter of type '{ length: number; }'.2345Argument of type 'number' is not assignable to parameter of type '{ length: number; }'.Try"
      },
      {
        "language": "text",
        "code": "function longest<Type extends { length: number }>(a: Type, b: Type) {  if (a.length >= b.length) {    return a;  } else {    return b;  }} // longerArray is of type 'number[]'const longerArray = longest([1, 2], [1, 2, 3]);// longerString is of type 'alice' | 'bob'const longerString = longest(\"alice\", \"bob\");// Error! Numbers don't have a 'length' propertyconst notOK = longest(10, 100);Argument of type 'number' is not assignable to parameter of type '{ length: number; }'.2345Argument of type 'number' is not assignable to parameter of type '{ length: number; }'."
      },
      {
        "language": "text",
        "code": "{ length: number }"
      },
      {
        "language": "text",
        "code": "longerArray"
      },
      {
        "language": "text",
        "code": "longerString"
      },
      {
        "language": "text",
        "code": "longest(10, 100)"
      },
      {
        "language": "text",
        "code": "tsfunction minimumLength<Type extends { length: number }>(  obj: Type,  minimum: number): Type {  if (obj.length >= minimum) {    return obj;  } else {    return { length: minimum };Type '{ length: number; }' is not assignable to type 'Type'.\n  '{ length: number; }' is assignable to the constraint of type 'Type', but 'Type' could be instantiated with a different subtype of constraint '{ length: number; }'.2322Type '{ length: number; }' is not assignable to type 'Type'.\n  '{ length: number; }' is assignable to the constraint of type 'Type', but 'Type' could be instantiated with a different subtype of constraint '{ length: number; }'.  }}Try"
      },
      {
        "language": "text",
        "code": "function minimumLength<Type extends { length: number }>(  obj: Type,  minimum: number): Type {  if (obj.length >= minimum) {    return obj;  } else {    return { length: minimum };Type '{ length: number; }' is not assignable to type 'Type'.\n  '{ length: number; }' is assignable to the constraint of type 'Type', but 'Type' could be instantiated with a different subtype of constraint '{ length: number; }'.2322Type '{ length: number; }' is not assignable to type 'Type'.\n  '{ length: number; }' is assignable to the constraint of type 'Type', but 'Type' could be instantiated with a different subtype of constraint '{ length: number; }'.  }}"
      },
      {
        "language": "text",
        "code": "{ length: number }"
      },
      {
        "language": "text",
        "code": "ts// 'arr' gets value { length: 6 }const arr = minimumLength([1, 2, 3], 6);// and crashes here because arrays have// a 'slice' method, but not the returned object!console.log(arr.slice(0));Try"
      },
      {
        "language": "text",
        "code": "// 'arr' gets value { length: 6 }const arr = minimumLength([1, 2, 3], 6);// and crashes here because arrays have// a 'slice' method, but not the returned object!console.log(arr.slice(0));"
      },
      {
        "language": "text",
        "code": "tsfunction combine<Type>(arr1: Type[], arr2: Type[]): Type[] {  return arr1.concat(arr2);}Try"
      },
      {
        "language": "text",
        "code": "function combine<Type>(arr1: Type[], arr2: Type[]): Type[] {  return arr1.concat(arr2);}"
      },
      {
        "language": "text",
        "code": "tsconst arr = combine([1, 2, 3], [\"hello\"]);Type 'string' is not assignable to type 'number'.2322Type 'string' is not assignable to type 'number'.Try"
      },
      {
        "language": "text",
        "code": "const arr = combine([1, 2, 3], [\"hello\"]);Type 'string' is not assignable to type 'number'.2322Type 'string' is not assignable to type 'number'."
      },
      {
        "language": "text",
        "code": "tsconst arr = combine<string | number>([1, 2, 3], [\"hello\"]);Try"
      },
      {
        "language": "text",
        "code": "const arr = combine<string | number>([1, 2, 3], [\"hello\"]);"
      },
      {
        "language": "text",
        "code": "tsfunction firstElement1<Type>(arr: Type[]) {  return arr[0];} function firstElement2<Type extends any[]>(arr: Type) {  return arr[0];} // a: number (good)const a = firstElement1([1, 2, 3]);// b: any (bad)const b = firstElement2([1, 2, 3]);Try"
      },
      {
        "language": "text",
        "code": "function firstElement1<Type>(arr: Type[]) {  return arr[0];} function firstElement2<Type extends any[]>(arr: Type) {  return arr[0];} // a: number (good)const a = firstElement1([1, 2, 3]);// b: any (bad)const b = firstElement2([1, 2, 3]);"
      },
      {
        "language": "text",
        "code": "firstElement1"
      },
      {
        "language": "text",
        "code": "firstElement2"
      },
      {
        "language": "text",
        "code": "tsfunction filter1<Type>(arr: Type[], func: (arg: Type) => boolean): Type[] {  return arr.filter(func);} function filter2<Type, Func extends (arg: Type) => boolean>(  arr: Type[],  func: Func): Type[] {  return arr.filter(func);}Try"
      },
      {
        "language": "text",
        "code": "function filter1<Type>(arr: Type[], func: (arg: Type) => boolean): Type[] {  return arr.filter(func);} function filter2<Type, Func extends (arg: Type) => boolean>(  arr: Type[],  func: Func): Type[] {  return arr.filter(func);}"
      },
      {
        "language": "text",
        "code": "tsfunction greet<Str extends string>(s: Str) {  console.log(\"Hello, \" + s);} greet(\"world\");Try"
      },
      {
        "language": "text",
        "code": "function greet<Str extends string>(s: Str) {  console.log(\"Hello, \" + s);} greet(\"world\");"
      },
      {
        "language": "text",
        "code": "tsfunction greet(s: string) {  console.log(\"Hello, \" + s);}Try"
      },
      {
        "language": "text",
        "code": "function greet(s: string) {  console.log(\"Hello, \" + s);}"
      },
      {
        "language": "text",
        "code": "tsfunction f(n: number) {  console.log(n.toFixed()); // 0 arguments  console.log(n.toFixed(3)); // 1 argument}Try"
      },
      {
        "language": "text",
        "code": "function f(n: number) {  console.log(n.toFixed()); // 0 arguments  console.log(n.toFixed(3)); // 1 argument}"
      },
      {
        "language": "text",
        "code": "tsfunction f(x?: number) {  // ...}f(); // OKf(10); // OKTry"
      },
      {
        "language": "text",
        "code": "function f(x?: number) {  // ...}f(); // OKf(10); // OK"
      },
      {
        "language": "text",
        "code": "number | undefined"
      },
      {
        "language": "text",
        "code": "tsfunction f(x = 10) {  // ...}Try"
      },
      {
        "language": "text",
        "code": "function f(x = 10) {  // ...}"
      },
      {
        "language": "text",
        "code": "ts// All OKf();f(10);f(undefined);Try"
      },
      {
        "language": "text",
        "code": "// All OKf();f(10);f(undefined);"
      },
      {
        "language": "text",
        "code": "tsfunction myForEach(arr: any[], callback: (arg: any, index?: number) => void) {  for (let i = 0; i < arr.length; i++) {    callback(arr[i], i);  }}Try"
      },
      {
        "language": "text",
        "code": "function myForEach(arr: any[], callback: (arg: any, index?: number) => void) {  for (let i = 0; i < arr.length; i++) {    callback(arr[i], i);  }}"
      },
      {
        "language": "text",
        "code": "tsmyForEach([1, 2, 3], (a) => console.log(a));myForEach([1, 2, 3], (a, i) => console.log(a, i));Try"
      },
      {
        "language": "text",
        "code": "myForEach([1, 2, 3], (a) => console.log(a));myForEach([1, 2, 3], (a, i) => console.log(a, i));"
      },
      {
        "language": "text",
        "code": "tsfunction myForEach(arr: any[], callback: (arg: any, index?: number) => void) {  for (let i = 0; i < arr.length; i++) {    // I don't feel like providing the index today    callback(arr[i]);  }}Try"
      },
      {
        "language": "text",
        "code": "function myForEach(arr: any[], callback: (arg: any, index?: number) => void) {  for (let i = 0; i < arr.length; i++) {    // I don't feel like providing the index today    callback(arr[i]);  }}"
      },
      {
        "language": "text",
        "code": "tsmyForEach([1, 2, 3], (a, i) => {  console.log(i.toFixed());'i' is possibly 'undefined'.18048'i' is possibly 'undefined'.});Try"
      },
      {
        "language": "text",
        "code": "myForEach([1, 2, 3], (a, i) => {  console.log(i.toFixed());'i' is possibly 'undefined'.18048'i' is possibly 'undefined'.});"
      },
      {
        "language": "text",
        "code": "tsfunction makeDate(timestamp: number): Date;function makeDate(m: number, d: number, y: number): Date;function makeDate(mOrTimestamp: number, d?: number, y?: number): Date {  if (d !== undefined && y !== undefined) {    return new Date(y, mOrTimestamp, d);  } else {    return new Date(mOrTimestamp);  }}const d1 = makeDate(12345678);const d2 = makeDate(5, 5, 5);const d3 = makeDate(1, 3);No overload expects 2 arguments, but overloads do exist that expect either 1 or 3 arguments.2575No overload expects 2 arguments, but overloads do exist that expect either 1 or 3 arguments.Try"
      },
      {
        "language": "text",
        "code": "function makeDate(timestamp: number): Date;function makeDate(m: number, d: number, y: number): Date;function makeDate(mOrTimestamp: number, d?: number, y?: number): Date {  if (d !== undefined && y !== undefined) {    return new Date(y, mOrTimestamp, d);  } else {    return new Date(mOrTimestamp);  }}const d1 = makeDate(12345678);const d2 = makeDate(5, 5, 5);const d3 = makeDate(1, 3);No overload expects 2 arguments, but overloads do exist that expect either 1 or 3 arguments.2575No overload expects 2 arguments, but overloads do exist that expect either 1 or 3 arguments."
      },
      {
        "language": "text",
        "code": "tsfunction fn(x: string): void;function fn() {  // ...}// Expected to be able to call with zero argumentsfn();Expected 1 arguments, but got 0.2554Expected 1 arguments, but got 0.Try"
      },
      {
        "language": "text",
        "code": "function fn(x: string): void;function fn() {  // ...}// Expected to be able to call with zero argumentsfn();Expected 1 arguments, but got 0.2554Expected 1 arguments, but got 0."
      },
      {
        "language": "text",
        "code": "tsfunction fn(x: boolean): void;// Argument type isn't rightfunction fn(x: string): void;This overload signature is not compatible with its implementation signature.2394This overload signature is not compatible with its implementation signature.function fn(x: boolean) {}Try"
      },
      {
        "language": "text",
        "code": "function fn(x: boolean): void;// Argument type isn't rightfunction fn(x: string): void;This overload signature is not compatible with its implementation signature.2394This overload signature is not compatible with its implementation signature.function fn(x: boolean) {}"
      },
      {
        "language": "text",
        "code": "tsfunction fn(x: string): string;// Return type isn't rightfunction fn(x: number): boolean;This overload signature is not compatible with its implementation signature.2394This overload signature is not compatible with its implementation signature.function fn(x: string | number) {  return \"oops\";}Try"
      },
      {
        "language": "text",
        "code": "function fn(x: string): string;// Return type isn't rightfunction fn(x: number): boolean;This overload signature is not compatible with its implementation signature.2394This overload signature is not compatible with its implementation signature.function fn(x: string | number) {  return \"oops\";}"
      },
      {
        "language": "text",
        "code": "tsfunction len(s: string): number;function len(arr: any[]): number;function len(x: any) {  return x.length;}Try"
      },
      {
        "language": "text",
        "code": "function len(s: string): number;function len(arr: any[]): number;function len(x: any) {  return x.length;}"
      },
      {
        "language": "text",
        "code": "tslen(\"\"); // OKlen([0]); // OKlen(Math.random() > 0.5 ? \"hello\" : [0]);No overload matches this call.\n  Overload 1 of 2, '(s: string): number', gave the following error.\n    Argument of type 'number[] | \"hello\"' is not assignable to parameter of type 'string'.\n      Type 'number[]' is not assignable to type 'string'.\n  Overload 2 of 2, '(arr: any[]): number', gave the following error.\n    Argument of type 'number[] | \"hello\"' is not assignable to parameter of type 'any[]'.\n      Type 'string' is not assignable to type 'any[]'.2769No overload matches this call.\n  Overload 1 of 2, '(s: string): number', gave the following error.\n    Argument of type 'number[] | \"hello\"' is not assignable to parameter of type 'string'.\n      Type 'number[]' is not assignable to type 'string'.\n  Overload 2 of 2, '(arr: any[]): number', gave the following error.\n    Argument of type 'number[] | \"hello\"' is not assignable to parameter of type 'any[]'.\n      Type 'string' is not assignable to type 'any[]'.Try"
      },
      {
        "language": "text",
        "code": "len(\"\"); // OKlen([0]); // OKlen(Math.random() > 0.5 ? \"hello\" : [0]);No overload matches this call.\n  Overload 1 of 2, '(s: string): number', gave the following error.\n    Argument of type 'number[] | \"hello\"' is not assignable to parameter of type 'string'.\n      Type 'number[]' is not assignable to type 'string'.\n  Overload 2 of 2, '(arr: any[]): number', gave the following error.\n    Argument of type 'number[] | \"hello\"' is not assignable to parameter of type 'any[]'.\n      Type 'string' is not assignable to type 'any[]'.2769No overload matches this call.\n  Overload 1 of 2, '(s: string): number', gave the following error.\n    Argument of type 'number[] | \"hello\"' is not assignable to parameter of type 'string'.\n      Type 'number[]' is not assignable to type 'string'.\n  Overload 2 of 2, '(arr: any[]): number', gave the following error.\n    Argument of type 'number[] | \"hello\"' is not assignable to parameter of type 'any[]'.\n      Type 'string' is not assignable to type 'any[]'."
      },
      {
        "language": "text",
        "code": "tsfunction len(x: any[] | string) {  return x.length;}Try"
      },
      {
        "language": "text",
        "code": "function len(x: any[] | string) {  return x.length;}"
      },
      {
        "language": "text",
        "code": "tsconst user = {  id: 123,   admin: false,  becomeAdmin: function () {    this.admin = true;  },};Try"
      },
      {
        "language": "text",
        "code": "const user = {  id: 123,   admin: false,  becomeAdmin: function () {    this.admin = true;  },};"
      },
      {
        "language": "text",
        "code": "user.becomeAdmin"
      },
      {
        "language": "text",
        "code": "tsinterface DB {  filterUsers(filter: (this: User) => boolean): User[];} const db = getDB();const admins = db.filterUsers(function (this: User) {  return this.admin;});Try"
      },
      {
        "language": "text",
        "code": "interface DB {  filterUsers(filter: (this: User) => boolean): User[];} const db = getDB();const admins = db.filterUsers(function (this: User) {  return this.admin;});"
      },
      {
        "language": "text",
        "code": "tsinterface DB {  filterUsers(filter: (this: User) => boolean): User[];} const db = getDB();const admins = db.filterUsers(() => this.admin);The containing arrow function captures the global value of 'this'.Element implicitly has an 'any' type because type 'typeof globalThis' has no index signature.70417017The containing arrow function captures the global value of 'this'.Element implicitly has an 'any' type because type 'typeof globalThis' has no index signature.Try"
      },
      {
        "language": "text",
        "code": "interface DB {  filterUsers(filter: (this: User) => boolean): User[];} const db = getDB();const admins = db.filterUsers(() => this.admin);The containing arrow function captures the global value of 'this'.Element implicitly has an 'any' type because type 'typeof globalThis' has no index signature.70417017The containing arrow function captures the global value of 'this'.Element implicitly has an 'any' type because type 'typeof globalThis' has no index signature."
      },
      {
        "language": "text",
        "code": "ts// The inferred return type is voidfunction noop() {  return;}Try"
      },
      {
        "language": "text",
        "code": "// The inferred return type is voidfunction noop() {  return;}"
      },
      {
        "language": "text",
        "code": "Object.prototype"
      },
      {
        "language": "text",
        "code": "instanceof Object"
      },
      {
        "language": "text",
        "code": "Object.keys"
      },
      {
        "language": "text",
        "code": "tsfunction f1(a: any) {  a.b(); // OK}function f2(a: unknown) {  a.b();'a' is of type 'unknown'.18046'a' is of type 'unknown'.}Try"
      },
      {
        "language": "text",
        "code": "function f1(a: any) {  a.b(); // OK}function f2(a: unknown) {  a.b();'a' is of type 'unknown'.18046'a' is of type 'unknown'.}"
      },
      {
        "language": "text",
        "code": "tsfunction safeParse(s: string): unknown {  return JSON.parse(s);} // Need to be careful with 'obj'!const obj = safeParse(someRandomString);Try"
      },
      {
        "language": "text",
        "code": "function safeParse(s: string): unknown {  return JSON.parse(s);} // Need to be careful with 'obj'!const obj = safeParse(someRandomString);"
      },
      {
        "language": "text",
        "code": "tsfunction fail(msg: string): never {  throw new Error(msg);}Try"
      },
      {
        "language": "text",
        "code": "function fail(msg: string): never {  throw new Error(msg);}"
      },
      {
        "language": "text",
        "code": "tsfunction fn(x: string | number) {  if (typeof x === \"string\") {    // do something  } else if (typeof x === \"number\") {    // do something else  } else {    x; // has type 'never'!  }}Try"
      },
      {
        "language": "text",
        "code": "function fn(x: string | number) {  if (typeof x === \"string\") {    // do something  } else if (typeof x === \"number\") {    // do something else  } else {    x; // has type 'never'!  }}"
      },
      {
        "language": "text",
        "code": "tsfunction doSomething(f: Function) {  return f(1, 2, 3);}Try"
      },
      {
        "language": "text",
        "code": "function doSomething(f: Function) {  return f(1, 2, 3);}"
      },
      {
        "language": "text",
        "code": "tsfunction multiply(n: number, ...m: number[]) {  return m.map((x) => n * x);}// 'a' gets value [10, 20, 30, 40]const a = multiply(10, 1, 2, 3, 4);Try"
      },
      {
        "language": "text",
        "code": "function multiply(n: number, ...m: number[]) {  return m.map((x) => n * x);}// 'a' gets value [10, 20, 30, 40]const a = multiply(10, 1, 2, 3, 4);"
      },
      {
        "language": "text",
        "code": "tsconst arr1 = [1, 2, 3];const arr2 = [4, 5, 6];arr1.push(...arr2);Try"
      },
      {
        "language": "text",
        "code": "const arr1 = [1, 2, 3];const arr2 = [4, 5, 6];arr1.push(...arr2);"
      },
      {
        "language": "text",
        "code": "ts// Inferred type is number[] -- \"an array with zero or more numbers\",// not specifically two numbersconst args = [8, 5];const angle = Math.atan2(...args);A spread argument must either have a tuple type or be passed to a rest parameter.2556A spread argument must either have a tuple type or be passed to a rest parameter.Try"
      },
      {
        "language": "text",
        "code": "// Inferred type is number[] -- \"an array with zero or more numbers\",// not specifically two numbersconst args = [8, 5];const angle = Math.atan2(...args);A spread argument must either have a tuple type or be passed to a rest parameter.2556A spread argument must either have a tuple type or be passed to a rest parameter."
      },
      {
        "language": "text",
        "code": "ts// Inferred as 2-length tupleconst args = [8, 5] as const;// OKconst angle = Math.atan2(...args);Try"
      },
      {
        "language": "text",
        "code": "// Inferred as 2-length tupleconst args = [8, 5] as const;// OKconst angle = Math.atan2(...args);"
      },
      {
        "language": "text",
        "code": "downlevelIteration"
      },
      {
        "language": "text",
        "code": "jsfunction sum({ a, b, c }) {  console.log(a + b + c);}sum({ a: 10, b: 3, c: 9 });"
      },
      {
        "language": "text",
        "code": "function sum({ a, b, c }) {  console.log(a + b + c);}sum({ a: 10, b: 3, c: 9 });"
      },
      {
        "language": "text",
        "code": "tsfunction sum({ a, b, c }: { a: number; b: number; c: number }) {  console.log(a + b + c);}Try"
      },
      {
        "language": "text",
        "code": "function sum({ a, b, c }: { a: number; b: number; c: number }) {  console.log(a + b + c);}"
      },
      {
        "language": "text",
        "code": "ts// Same as prior exampletype ABC = { a: number; b: number; c: number };function sum({ a, b, c }: ABC) {  console.log(a + b + c);}Try"
      },
      {
        "language": "text",
        "code": "// Same as prior exampletype ABC = { a: number; b: number; c: number };function sum({ a, b, c }: ABC) {  console.log(a + b + c);}"
      },
      {
        "language": "text",
        "code": "type voidFunc = () => void"
      },
      {
        "language": "text",
        "code": "tstype voidFunc = () => void; const f1: voidFunc = () => {  return true;}; const f2: voidFunc = () => true; const f3: voidFunc = function () {  return true;};Try"
      },
      {
        "language": "text",
        "code": "type voidFunc = () => void; const f1: voidFunc = () => {  return true;}; const f2: voidFunc = () => true; const f3: voidFunc = function () {  return true;};"
      },
      {
        "language": "text",
        "code": "tsconst v1 = f1(); const v2 = f2(); const v3 = f3();Try"
      },
      {
        "language": "text",
        "code": "const v1 = f1(); const v2 = f2(); const v3 = f3();"
      },
      {
        "language": "text",
        "code": "Array.prototype.push"
      },
      {
        "language": "text",
        "code": "Array.prototype.forEach"
      },
      {
        "language": "text",
        "code": "tsconst src = [1, 2, 3];const dst = [0]; src.forEach((el) => dst.push(el));Try"
      },
      {
        "language": "text",
        "code": "const src = [1, 2, 3];const dst = [0]; src.forEach((el) => dst.push(el));"
      },
      {
        "language": "text",
        "code": "tsfunction f2(): void {  // @ts-expect-error  return true;} const f3 = function (): void {  // @ts-expect-error  return true;};Try"
      },
      {
        "language": "text",
        "code": "function f2(): void {  // @ts-expect-error  return true;} const f3 = function (): void {  // @ts-expect-error  return true;};"
      }
    ],
    "links": [
      {
        "text": "Try",
        "href": "https://www.typescriptlang.org/play/#code/GYVwdgxgLglg9mABAcwE4FN1XagFMMALkVwENiBnKVGMZASkQF4A+RANzhgBNGBvALAAoRIgK4ARAAl0AG1lwANIgDqcVLO4T6AbmEBfYcNCRYCRAAcaYKABU4AYQQU4s9LgqVqtBokEjECGdXdAA6BWQPXQMjITRMbDwrWjtHYLddIA"
      },
      {
        "text": "Try",
        "href": "https://www.typescriptlang.org/play/#code/C4TwDgpgBA4gThCwBiBXAdgY2ASwPbpQC8UAFAIYBcUAzsHDugOYCUxAfFAG544AmAbgCwAKABmGbPkJMESCHFJj01eIhSTcBNgG9RUKAHpDUAHTnRAXyA"
      },
      {
        "text": "Try",
        "href": "https://www.typescriptlang.org/play/#code/C4TwDgpgBAIhDOBjATgSwEYEN0BsIDEBXAO0WFQHtioBeKAbwFgAoKKAEwRVTHKoC4o8YGmIBzANws2ACngUAthACCyMYOKEF6CMgCUg9BQp5MxKcwC+FgGYkylauwoBlRRGAALVOJk3ignBIaFi4BPZ8xHoM0lCIVPJ4AHQ4FGJ+xEmcwTyRUADUUABEUMgehMjEEOzFBVD+MgBsenoWliwsdqR5CiBEpHLuqupQmtq60UyspeWVQkNqUAB8UADMbSy9-YhZXGi8jrTFnDaYhDjAHHu5jkUWLM5uSl4+6Vv2rUA"
      },
      {
        "text": "Try",
        "href": "https://www.typescriptlang.org/play/#code/C4TwDgpgBAyg9gWwgeQEYCsIGNhQLxQCGAdiANwCwAUAPQ1QC0TWArsEw9aJLIhAMJxiAZ2AAnFjjhj8UAN7UoUYhADuUABTCAXFFFiAlsQDmASl3wkaTDkpUAvnYBmLYjgNCoT4hqliLfIIi4pLA0qbyilBiEMAsYsTKalB+GgBEABYQADbZcGmmdvZAA"
      },
      {
        "text": "Try",
        "href": "https://www.typescriptlang.org/play/#code/JYOwLgpgTgZghgYwgAgMJwDYYPJVQexAGcwoBXBMZAbwFgAoZZAChAH4AuZEMgWwCNoASi4kooAOYBuBkxAQA7iyKjSkkcgAicSDPoBfBgxhkQlYIWQwQzSvihd0WXAWKkKYITVnIA9L+QABTgiIklkOBAIqAk+CHBkfBhkMABPAAcUAAMeAWgslPxkLLsoAt4dBAALCCJkYCo4CThQEh9-FJqrYCgSZAATCBhQBoso0E7spxw8QjEPAtBIWEQIADofBDn8DHWMfAlbMHtmAEYABiEhPSZbu-uOgD02I0Y-AIBlYF5gDDgoDCpAA0yHSITCIAkESi-1ivHiVCSKQy2TEkgKx2KpXKlRqdQa7QCTRabkmyCIEC2IH6AyGIzAY3qUTAXSy0xcc3clEW4Gg8CQGzeVKIOz2B1YimQpWYACILjKrjd7srlU8XgZXtZmNpINcgA"
      },
      {
        "text": "Try",
        "href": "https://www.typescriptlang.org/play/#code/GYVwdgxgLglg9mABMGAnAzlAogGwKYC2eYUAFAIaqoBci5YAngNoC6AlIgN4CwAUIolR4oIVEkqomABhYBuPgF8gA"
      },
      {
        "text": "Try",
        "href": "https://www.typescriptlang.org/play/#code/GYVwdgxgLglg9mABMGAnAzlAogGwKYC2eYUAPACoCeADngHwAUAhqqgFyJW0DaAugJQcueRAB9E4ACZ4UYPJMQBvALAAoRIlR4oIVEhapuABl4BuNQF8gA"
      },
      {
        "text": "Try",
        "href": "https://www.typescriptlang.org/play/#code/CYUwxgNghgTiAEAzArgOzAFwJYHtVKxgGcMBRCEAWxFQwB4AVATwAcQA+AClhgC55mbANoBdAJT9BCAD7w0oRFlQhgAbgCwAKAD02+AFpDYZBkP6tu+EXhZrORPAysEAchIwlAcxdaweElbwALwExGQU1LScQgBEUDEANPAxAEaJyWAx4ho6evi28PaOzvAuqMiUKSAwPpp+qAH4IYph5FQ0GNEAjEkATEkAzNkWesg2dg5ObHKoCkoqvv4YcsGhJG2RnaJiqkA"
      },
      {
        "text": "Try",
        "href": "https://www.typescriptlang.org/play/#code/PTAEAcCcFMBdYJbUgWgQcwHYHsYFgAoAMwFdMBjRbTUAWwENwAeASU3BNgBpQB5TjrAB8ACnqRIALlBtBAbQC6PUhWljI6abM4BKUAF4hfAbun9Y8haADehUKBiwSkGuMgA6BuBEryOgNyEAL6EhCCgAAri9LRwyKAA5JgJoAgAzqDYRKCwAJ7g0IlpsJAImOgJYWAJ4OJp0AAmKemZ2XkFiZgktABGyIqVBOTUxRB1jQZ0jCJyAEQAjLM8swBMS6CzAMyzSqAimHqGY5D1bLD7OgFAA"
      },
      {
        "text": "Try",
        "href": "https://www.typescriptlang.org/play/#code/PTAEAEFMCdoe2gZwFygEwGYAsBWdG00BYAKADMBXAOwGMAXASzitABtmBzSROgHgBUAngAdIoSAA86kKgBNEoAN5sZHOgAtUVCgFsARjFABfAHwAKAIaohogDSg91kZACUS0qFAMyoSwDpWVQ1QEwBeBwCg9TdFD09QaEg6CmgWCwBuOKNxVkQxWJJ4hKSUlj1MwuNSI1JSEDZOGABBWAtBLwU4HzpnUABybX0YAG0AXT7SGmYeBqouaBboNtBw9jnuOjNhgEZ7NFH7Hb37DFGXCvq1+YBlOmgGOY7QLtAe0X6LVgYaSD7QAB9+no4HoJiQplQZlcYLd7o9Vo0eGYAESfb6QZH2ZHAvTI851MAAUVgCAAhKAAHK6AxIUCyZh9OigdQWABuYgs-UCcw0f2E8FE0B6k2mTKocDoAHkANIrWZcJHbAAM9mVSvOQA"
      },
      {
        "text": "Try",
        "href": "https://www.typescriptlang.org/play/#code/PTAEAEFMCdoe2gZwFygEwGY1oLACgAzAVwDsBjAFwEs4TQBbKkq+o+gGUhIHMKALADwAVAJ4AHSKEgAPClwAmiUAG9QAGy68+qEmwBGMUAF8AfAAp8oUHD0ArVKIkAaSwyYs2O-THwBKB+KSyq5UBKBmNrYAdBo8-KAmALxuzKz0viquVtCQFETQdJEA3K5GUmqIQVmgOXkFKuqa-KiMqWzGJXhWRvhGQA"
      },
      {
        "text": "Try",
        "href": "https://www.typescriptlang.org/play/#code/CYUwxgNghgTiAEAzArgOzAFwJYHtXwFstUsDkCAZEVAcwwAsAeAFQE8AHBEADw2uADO8AN7wI1OvQBc8VOQBGIGPAC+APgAUAWABQ8eDnkArGW04AaXfqIkyBGXIKKYugJSmOIANy6A9L-gAWmCwZAxgwL8AgHJYGGj4GhAMIQA3KAhkBFFxWgYZADZVXTA8AQx4OPgAXkJiUnIqPPoNAG0ARnN4ACYugGYAXS6C1x8df0rUYHgwGCgBehAhRbh4RTAoZAEEOKhWZahUkCjK+GiBCCwwEASCZPocYC75MNkcCoYEOAxkGFQQaaGIzgDAAQhKZRw4gAdBAcDQNHFoRcriANAAGVyjIA"
      },
      {
        "text": "Try",
        "href": "https://www.typescriptlang.org/play/#code/GYVwdgxgLglg9mABBOBbARjMBTAPAFQE8AHbAPgAoBDAJxoEYAuRI0gbQF0AaRWmgJmatsnAJRCSIjogDeAWABQiRDWxQQNJH3oA6FJCpRqdfqIDcigL5A"
      },
      {
        "text": "Try",
        "href": "https://www.typescriptlang.org/play/#code/PTAEAEFMCdoe2gZwFygEwGY1oLACgATSAYwBsBDaSUAMwFcA7YgFwEs4HRi4BbAI1YNIAHgAqATwAOkAHwAKStACMqCdIDaAXQA0oRWlVTIWgJSGNmgNz4QoALQPidZg7v5uDRMz2xQAXi5eASE5dSVdNF0MHVB1ACIAC0hSUjg4zRNLIA"
      },
      {
        "text": "Try",
        "href": "https://www.typescriptlang.org/play/#code/CYUwxgNghgTiAEAzArgOzAFwJYHtXzBwFsAjLVEAHgBUBPABxAD4AKWGARgC547GBtALoAaeOwBMPPiCEBKKQxmCA3AFgAUAHpN8ALT6wyDPt0bCqAM4YxMGPAC8BYmQqUrMcgHN4AH3ipkUhAYVn4OUXFRAGYReH4AIgALEAgIHHjBWWUgA"
      },
      {
        "text": "Try",
        "href": "https://www.typescriptlang.org/play/#code/GYVwdgxgLglg9mABMGAnAzlAogGwKYC2eYUAjADwAqAngA54B8AFAIaqoBciN9A2gLoBKRAG8AsAChEiVHighUSNql4AGfgG5JAX0mTQkWAmRpMuQsSgAmKnTyI8ADyjEAJukQsw1Ac2VcePGFxKRk5BSV2NU0dPQkAenjPLjAQAgAjPFREJgBzODhXQUkIBExPRABeEwxsfCISUiZeUgAaRCt2gGYhLQSk9K4vahz0liKSsqhEdKqas3rLK2a2ju7eoA"
      },
      {
        "text": "Try",
        "href": "https://www.typescriptlang.org/play/#code/GYVwdgxgLglg9mABMGAbKBTATgRgDwAqAngA4YB8AFAIZZYBcixZA2gLoA0y4EjNWAc0bMMASkQBecogBGcOKgzUwo4aQztEAbwCwAKESIsGKCCxJaWAHQp02SqEiiA3PoC++-Y+jwktzFgATITqXABiPIgYAB6YYAAmAM6I-EJM6uJSsvKKylT6hpZqrJwF3JCMEZD6qukl2mXGpuaIljZoAQ48Lu5AA"
      },
      {
        "text": "Try",
        "href": "https://www.typescriptlang.org/play/#code/GYVwdgxgLglg9mABAcwE4FN1QDwGUqqLoAeU6YAJgM6JUExjIB8AFFQFyL6oCUiA3gFgAUIkQQEVOABt0AOmlxkLAEQAJdNMUAaRCsQBqWjwDcIgL4iRaTFFUB3OKmkUVpoA"
      },
      {
        "text": "Try",
        "href": "https://www.typescriptlang.org/play/#code/GYVwdgxgLglg9mABAcwE4FN1QBQGcBciuUqMYyAlIgN4CwAUIohArnADboB07cy2AIgAS6drwA0iAYgDURCgG4GAXyA"
      },
      {
        "text": "Try",
        "href": "https://www.typescriptlang.org/play/#code/GYVwdgxgLglg9mABMAFGAXIsIC2AjAUwCcBKRAbwFgAoRRCBAZzgBsCA6FuAczXajgAxGAA8CAExQkSAbkQB6eYgAMiAIZFuuAmCiMadBmGZtOPPgOFjJAZmlzFiAIzrN23TQC+QA"
      },
      {
        "text": "Try",
        "href": "https://www.typescriptlang.org/play/#code/GYVwdgxgLglg9mABMAFADwPwC5FhAWwCMBTAJwEpEBvAWAChFEB6JxAOg-oF97VyBuZqwDyAaV4oAjAAYBQxGKA"
      },
      {
        "text": "Try",
        "href": "https://www.typescriptlang.org/play/#code/GYVwdgxgLglg9mABMAFAD0QXkQRgAwCUiA3gLABQiiA9NYgHSMUC+QA"
      },
      {
        "text": "Try",
        "href": "https://www.typescriptlang.org/play/#code/CYUwxgNghgTiAEAzArgOzAFwJYHtVIAoAPAfgC55VkBbAIxBgEoKA3HLYAbgFgAoAen7wAtKLDIMo4X0HwAghAjwA8gGk+iAox69NARgAM2jQTShEWVCGDagA"
      },
      {
        "text": "Try",
        "href": "https://www.typescriptlang.org/play/#code/GYVwdgxgLglg9mABAWwJ4DE4CcCiBDCACwAo8ssAuRPMVAbQF0AaRCPAG3YCMCBrK0lgDmVGqhYwwAEwCmADwD8VMCGRcZWAJSIAvAD5EANzgwp2gN4BYAFCJEwbImLsZURDF2IADAG53iAB5qcgA6FzAhKEI-GABqWIsbOzs2Th4IXkEsOhhmd00fJMQAXxtioA"
      },
      {
        "text": "Try",
        "href": "https://www.typescriptlang.org/play/#code/PTAEAEFMCdoe2gZwFygEwFYDMbQEYAOABgBYCBYAKABNIBjAGwENpJQAzAVwDs6AXAJZxuoALYBPAGIIAokzoALABRVQoFtFRNu4gNoBdADSrQdJgwYAjeQGtUSlgHMtOw6AHdaADwD8qbpyiljAAlKAAvAB8oABucALUVCGocQkA3FQgoAC0uXScfLnZVBLS0HKKSrp4bmhuWEagDmFRpsKIcAyQAHQMcI7NIRmUpbLyytW19Y0ObgIt0XTtnT19A0xzIUNAA"
      },
      {
        "text": "Try",
        "href": "https://www.typescriptlang.org/play/#code/PTAEAEFMCdoe2gZwFygEwFYDMbQEYAOABgBYCBYAKADMBXAOwGMAXASzntAFsBPAMQQBRAIaMAFgAphsVMPo8A2gF0ANKEbCANpoBGogNaop0AOaz5a1vQAmkAB4B+VPVpcdMAJSgAvAD5QAG5wrNZeAN5UoKDUCKASmpDMoKw+oEQA3MmgADyg0tAAdAn0JsximawA1JXhkVGgIKAAkqDWHADkSdSQkJqgmqz6kKAADvABIVYmoGXDVrZ2M3DWwjx1URraeoz6xtAKrEoe6XUAvlSnQA"
      },
      {
        "text": "Try",
        "href": "https://www.typescriptlang.org/play/#code/PTAEAEFMCdoe2gZwFygEwFYDMbQEYAOABgBYCBYAKABNIBjAGwENpJQAzAVwDs6AXAJZxuoALYBPAGIIAokzoALABRVQoFtFRNu4gNoBdADSrQdJgwYAjeQGtUSlgHMtOw6AHdaADwD8qbpyiljAAlKAAvAB8oABucALUVCGocQkA3FQgoAC0uXScfLnZVBLS0HKKSrp4bmhuWEagDm4CYVGgAN4mdMKIcAyQAHQMcI5KAoN8cJICXpDUSiEhGZQAvstAA"
      },
      {
        "text": "Try",
        "href": "https://www.typescriptlang.org/play/#code/PTAEAEFMCdoe2gZwFygEwFYDsGCwAoAMwFcA7AYwBcBLOU0AWwEMBrSAEScsgAoaHIiSkwYAHVKWIMARjACUqTtwDcBEhRp1GrDl14MJU2dAA0oACaGZMMwE8rxhaCWRVRMlVr1mbFzwYA8tAAKtQCQiLioJLWphYA-A42oLaJ0UbyinqgAN4EoKDUhKA85qAAhAC8laBk5pCE1KSQZQBkrSkV1bWk9Y3N5nK5+QWg0JCUxND0zQDuzno8tmaBIWGCwmJmg24FAL6gkAA2iJDD+KNjE1MzkPN+q6Hhm6Jyu6B7BJ-45HRCFgBGUA1Hy6bg8AFoADMABYMAA2LAADjeBF+pH+5jQwO0vkWGDMBNAGFRPz+lAsUJxoL8ALMULeQA"
      },
      {
        "text": "Try",
        "href": "https://www.typescriptlang.org/play/#code/PTAEAEFMCdoe2gZwFygEwFYMBYCwAoAMwFcA7AYwBcBLOU0Q0gCgA9VFLprSBzASlQA3ONQAmAbgIkKNOg2Z9QAbwKhQIUADptBAL4ENAURYAHSFUijQlOKABGkUAEM7AG0c3Q5J69egA7tSUABagAF4wtk7QPMQAtpCklIhSCuJAA"
      },
      {
        "text": "Try",
        "href": "https://www.typescriptlang.org/play/#code/PTAEAEFMCdoe2gZwFygEwGYCcAWAsAFABmArgHYDGALgJZxmhFkAUAHqgEZxwA2kAhmQCUqAG5waAEwDchEKACC0AOYkAtpDJVQVAJ4AHSKBqIyAcm3QaygBZVCpSrXqMW7UIipWyykaHFSssTk1HQMTGyc3HyCQqAA3gC+QA"
      },
      {
        "text": "Try",
        "href": "https://www.typescriptlang.org/play/#code/PTAEAEFMCdoe2gZwFygEwGYCcAWAsAFABmArgHYDGALgJZxmhFkAUAHqoldDWQOYCUHLj14BuQiFAAlSFRLQGVAJ4AHSKBqIyAciqhuvABZVCpSrXqMW7UGRIBbAEYxBoR3DgAbSAEMy44nJqOgYmNiFuPlAAH1sHZ2h+UABvQlB9WXkGACIPFURsgIBfIA"
      },
      {
        "text": "Try",
        "href": "https://www.typescriptlang.org/play/#code/GYVwdgxgLglg9mABAGwKZgBQGcBcitQBOMYA5gJR5ggC2ARqoQNwCwAUKJLAiuhgIaFCefmACeAbQC6lRNXqNWHcNHhI0mAB4jx5RAG92iRIVRQQhJJoB0G0lAAWSgL5A"
      },
      {
        "text": "Try",
        "href": "https://www.typescriptlang.org/play/#code/PTAEAEFMCdoe2gZwFygEwHYBsBOAsAFAAmkAxgDYCG0koAZgK4B2pALgJZxOjmRMAUKUIlbR2TAOYBKVEwYBbAEYwA3IRIVqtRiw5cefftWipKTAJ4BtALozQcpasIhQAWnekGrd68K8BAEQBUiqgLgDyANJ+hpYADLahEdEE-vwAspSsABYAdNBmRHDy-FKgAHygcbkArKAA-KAB2ZDk5HABoKjxiUA"
      },
      {
        "text": "Try",
        "href": "https://www.typescriptlang.org/play/#code/GYVwdgxgLglg9mABAGwKZgBQA8BciCGYAngNoC6iAPogM5QBOMYA5gJSIDeAsAFCKL1UUEPSRYAdGhZQAFgG5eAXyA"
      },
      {
        "text": "Try",
        "href": "https://www.typescriptlang.org/play/#code/MYewdgzgLgBArhApgJxgXhgbwLACgYwCWAJgFwwCMATAMwA0eeBAhsQLaFjkBmzANkgb4YAI0Sg2iAILtOPOGGBRC4GAAoAlFiYEYUABaEIAOlYcw6PcjiIA3DoC+Qh7aA"
      },
      {
        "text": "Try",
        "href": "https://www.typescriptlang.org/play/#code/JYOwLgpgTgZghgYwgAgKoGdrIN4FgBQyywAJgFzIgCuAtgEbQDcBRcJNoFdA9twDYQ4IZvgC+BEhAR84UFAm4h0YZAHMIYACIAhCgAoAlMgC8APmQ6RAeivIAtA4RUwDuwVCRYiFDpwtkMMB8nhjQ6HqBwdD6YAAWwOgUoVBGZsg8-IIgBkmYUADaALoi4vgECkoqJHQmaho6hiIVyshsHEq11QB0kSF54TBUIAhgwIrIenEJudBGeITIcmBUUCDIU+hdbaAlBoxAA"
      },
      {
        "text": "Try",
        "href": "https://www.typescriptlang.org/play/#code/PTAEAEFMCdoe2gZwFygOwAYAsBGdGc0BYAKAEsA7AFxgDMBDAY0lAFVEZQBvU0UMgCaoKAVwC2AIxgBuXqHoCxlVBLhwANpHoVZJAL6kBkRuvrQWjOBURVQAc0hUAIgCFUACgCUoALwA+UFddEFAAWnDGESpw0NJKGmgGZkCXbjlaMnUE9hhEdwysmA8qAAsyFDYOaG9-UFUNLQpPVBzoAG0AXV0DElJLa1sBCV97R1cvXX6beUVKRBGhgDoC7Kq8r18A0vLFhSUm6SA"
      },
      {
        "text": "Try",
        "href": "https://www.typescriptlang.org/play/#code/PTAEBUAsFNQSwHYDNoCdXQCagwFwK6oKi4CeADrHAM6gBuA9nJgLABQS+CAxrnA8QQMG5ABQBKUAG92oHNAJEA3OwC+QA"
      },
      {
        "text": "Try",
        "href": "https://www.typescriptlang.org/play/#code/PTAEAEFMCdoe2gZwFygEwFYDsBGUOAOABgBYA2AWACgAzAVwDsBjAFwEs4HQacAKAQ1T8GATwCUoAN7VQofgDoARrzEBuUCFAB5ANLUAvtXrN2nbmgGpGAawZwA7gwnSqshcrUGgA"
      },
      {
        "text": "Try",
        "href": "https://www.typescriptlang.org/play/#code/CYUwxgNghgTiAEYD2A7AzgF3mpBbEASlCsHgMoYwCWKA5gFzaU20DcAsAFAD038AtILABXDIP5cAZsJRgMVVNiiSQABVhoQACjSNM1OgEpGMgNYokAdxTwA3l3jw4GYTBsApMgHkAcgDoABw1tNEMOTgBfLi5eeB8QEGB4DCR4ACMEMFgQaQh4SyoMAAt4AHIkNIArUoBCLmR0LArK+ABeJRV1GE0dPEJiUlwKA1owoA"
      },
      {
        "text": "Try",
        "href": "https://www.typescriptlang.org/play/#code/GYVwdgxgLglg9mABMAhjANgCgLYGcDmAXIrlAE4xj4CUxYApgG71mIDeAsAFCKJQAWZOAHdEDUQFEyQsjgLUA3NwC+QA"
      },
      {
        "text": "Try",
        "href": "https://www.typescriptlang.org/play/#code/GYVwdgxgLglg9mABMMAKAHgLkQZygJxjAHNEAfRMEAWwCMBTfASkQG8BYAKEURmEVRQAngAd6cfukQBeWYgBEeQiXksO3HogD0WxABM4uONXpQAFkWJceAX0T0ANjnq9+g0eMky58qnUaqbNaaOvqGOMamFiT2TvTBdo7OQRo86ADc2rpmAIY4iMJiiADkYPQAbozFAIQJXDZAA"
      },
      {
        "text": "Try",
        "href": "https://www.typescriptlang.org/play/#code/GYVwdgxgLglg9mABAEzgZTgWwKZQBYxgDmAFMAFyIBi408YAlIgN4CwAUIogE64jdJgJAIwAaRACZxAZgYBuDgF8gA"
      },
      {
        "text": "Rest Parameters",
        "href": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Functions/rest_parameters"
      },
      {
        "text": "Spread Syntax",
        "href": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/Spread_syntax"
      },
      {
        "text": "Try",
        "href": "https://www.typescriptlang.org/play/#code/GYVwdgxgLglg9mABAWxAG1gBzQTwBRgBciYIyARgKYBOANIgHRPLGkU0DaAugJSIDeAWABQiRNUpQQ1JMgbIAhpjx4AHnwC8APhKIAVInUBuEQF8RAeguIA5ApuIA5pIDOiAG4K0ISog4BGAAZ6ACZgxABmcIAWQK4RCAQXKEQFRA0UdCxcPCD6f1D6CPponiMgA"
      },
      {
        "text": "Try",
        "href": "https://www.typescriptlang.org/play/#code/MYewdgzgLgBAhgJwQRhgXhgbWQGhgJjwGYBdAbgFgAoUSWRBfdLAFjwFY8A2c6h5AHQAHAK4QAFgAoBMhvgCUZIA"
      },
      {
        "text": "Try",
        "href": "https://www.typescriptlang.org/play/#code/PTAEAEFMCdoe2gZwFygEwFYMDYCwAoEUASQDsAzGaSAE1ABcBPAB0lAEtFRSBXAWwBGMANoBdUAFoJoAEQBDUqDmw5jUAHd29ABagAXjDigEoPgja9BMRDIA0BIqTj1QiVgGN25du7kAbPzV6dSNLISQCdzhSRBdlAHMuAF5QYQAOW1AMUQBuSOjYpVJ4vzYUgFk5HQA6KoU0AApq5oTEAEocoA"
      },
      {
        "text": "Try",
        "href": "https://www.typescriptlang.org/play/#code/PTAEEkDsDMFMCd6wCagIYGdQCYC0AbWSAcwBcALUUgVwAdCBYAKAGMB7SDU9eYrAXlABtABwAaUAFYAuuiztOpANzMQoAPIBpZgq7oShUIICyaCgDozaSNgAU5h2l4YAlEqA"
      },
      {
        "text": "downlevelIteration",
        "href": "/tsconfig#downlevelIteration"
      },
      {
        "text": "Destructuring Assignment",
        "href": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/Destructuring_assignment"
      },
      {
        "text": "Try",
        "href": "https://www.typescriptlang.org/play/#code/GYVwdgxgLglg9mABAZxAWwBQG9EEMA0iARoRIgL4BciOu1Y6RApgE4Dcx9jrHEXazFhQCUNALAAoRIggJkcADZMAdArgBzDLkQBqYrpnC2k8kA"
      },
      {
        "text": "Try",
        "href": "https://www.typescriptlang.org/play/#code/PTAEGUEMFsFNUgZ1ABwE4EsD2bSwB4woA2sAsAFAAuAnivAIIBCAwqALygDeCAXKADsArtABGsNAG5Qo-sLETpAYzkjxuAL6TKAMyEClVbANCIRACh6QANDNtLQG-sxYBKbpVCglWAYiykAHTEWADm5pCgANQy0d6u2hQaQA"
      },
      {
        "text": "Try",
        "href": "https://www.typescriptlang.org/play/#code/C4TwDgpgBAbg9gSwCYDECuA7AxlAvFACgEo8A+WRJAbgFgAoerODAZ2CgDMBGALguXTY8hErnIBvelCgAnCMDQyMUYDLQRadAL6bGzNpwBMfeAMw58xMirUb6e1uw4BmE5UEXO54AmYioknTScgpKNuqaOkA"
      },
      {
        "text": "Try",
        "href": "https://www.typescriptlang.org/play/#code/C4TwDgpgBAbg9gSwCYDECuA7AxlAvFACgEo8A+WRJAbgFgAoerODAZ2CgDMBGALguXTY8hErnIBvelCgAnCMDQyMUYDLQRadAL6bGzNpwBMfeAMw58xMirUb6e1uw4BmE5UEXO54AmYioknTScgpKNuqaOvQA9NFQALSJWGjAifEOBjBcwtzEunRMjrCGOYZ59gX67DDOOc55QA"
      },
      {
        "text": "Try",
        "href": "https://www.typescriptlang.org/play/#code/MYewdgzgLgBBBOwYF4YG0CMAaGAmHAzALoDcAsAFCiSwAm0K6ADKZZQsAHQBmI8AogENgACwAUYgKYAbAJQoAfDHpROABwCuEcTNmySQA"
      },
      {
        "text": "Try",
        "href": "https://www.typescriptlang.org/play/#code/GYVwdgxgLglg9mABMATACgJQC5EDc4wAmiA3gLABQiiA9DYgAJQDOAtAKYAeADu9BwCcBcAZWoD2UEAKRQBIdgG5KAX0qUICZlGQBmRAF5k4aPCSYc+IqTG16TNl1792QkbYlSZiOQuUUVRSA"
      },
      {
        "text": "FAQ - “Why are functions returning non-void assignable to function returning void?”",
        "href": "https://github.com/Microsoft/TypeScript/wiki/FAQ#why-are-functions-returning-non-void-assignable-to-function-returning-void"
      }
    ],
    "meta": {
      "description": "Learn about how Functions work in TypeScript.",
      "keywords": ""
    },
    "summary": "Functions are the basic building block of any application, whether theyre local functions, imported from another module, or methods on a class",
    "tags": [
      "react",
      "angular",
      "javascript",
      "typescript",
      "css",
      "html",
      "node",
      "vite",
      "parameters",
      "type"
    ],
    "id": "typescript-documentation-functionshtml-part-1",
    "quality": 100
  },
  {
    "title": "TypeScript: Documentation",
    "url": "https://www.typescriptlang.org/docs/handbook/2/generics.html",
    "category": "typescript",
    "content": "A major part of software engineering is building components that not only have well-defined and consistent APIs, but are also reusable. Components that are capable of working on the data of today as well as the data of tomorrow will give you the most flexible capabilities for building up large software systems. In languages like C# and Java, one of the main tools in the toolbox for creating reusable components is generics, that is, being able to create a component that can work over a variety of types rather than a single one. This allows users to consume these components and use their own types. Hello World of Generics To start off, lets do the hello world of generics: the identity function. The identity function is a function that will return back whatever is passed in. You can think of this in a similar way to the echo command. Without generics, we would either have to give the identity function a specific type: tsfunction identity(arg: number): number { return arg;}Try Or, we could describe the identity function using the any type: tsfunction identity(arg: any): any { return arg;}Try While using any is certainly generic in that it will cause the function to accept any and all types for the type of arg, we actually are losing the information about what that type was when the function returns. If we passed in a number, the only information we have is that any type could be returned. Instead, we need a way of capturing the type of the argument in such a way that we can also use it to denote what is being returned. Here, we will use a type variable, a special kind of variable that works on types rather than values. tsfunction identityType(arg: Type): Type { return arg;}Try Weve now added a type variable Type to the identity function. This Type allows us to capture the type the user provides (e.g. number), so that we can use that information later. Here, we use Type again as the return type. On inspection, we can now see the same type is used for the argument and the return type. This allows us to traffic that type information in one side of the function and out the other. We say that this version of the identity function is generic, as it works over a range of types. Unlike using any, its also just as precise (i.e., it doesnt lose any information) as the first identity function that used numbers for the argument and return type. Once weve written the generic identity function, we can call it in one of two ways. The first way is to pass all of the arguments, including the type argument, to the function: tslet output = identitystring(\"myString\"); let output: stringTry Here we explicitly set Type to be string as one of the arguments to the function call, denoted using the  around the arguments rather than (). The second way is also perhaps the most common. Here we use type argument inference  that is, we want the compiler to set the value of Type for us automatically based on the type of the argument we pass in: tslet output = identity(\"myString\"); let output: stringTry Notice that we didnt have to explicitly pass the type in the angle brackets (); the compiler just looked at the value \"myString\", and set Type to its type. While type argument inference can be a helpful tool to keep code shorter and more readable, you may need to explicitly pass in the type arguments as we did in the previous example when the compiler fails to infer the type, as may happen in more complex examples. Working with Generic Type Variables When you begin to use generics, youll notice that when you create generic functions like identity, the compiler will enforce that you use any generically typed parameters in the body of the function correctly. That is, that you actually treat these parameters as if they could be any and all types. Lets take our identity function from earlier: tsfunction identityType(arg: Type): Type { return arg;}Try What if we want to also log the length of the argument arg to the console with each call? We might be tempted to write this: tsfunction loggingIdentityType(arg: Type): Type { console.log(arg.length);Property 'length' does not exist on type 'Type'.2339Property 'length' does not exist on type 'Type'. return arg;}Try When we do, the compiler will give us an error that were using the .length member of arg, but nowhere have we said that arg has this member. Remember, we said earlier that these type variables stand in for any and all types, so someone using this function could have passed in a number instead, which does not have a .length member. Lets say that weve actually intended this function to work on arrays of Type rather than Type directly. Since were working with arrays, the .length member should be available. We can describe this just like we would create arrays of other types: tsfunction loggingIdentityType(arg: Type[]): Type[] { console.log(arg.length); return arg;}Try You can read the type of loggingIdentity as the generic function loggingIdentity takes a type parameter Type, and an argument arg which is an array of Types, and returns an array of Types. If we passed in an array of numbers, wed get an array of numbers back out, as Type would bind to number. This allows us to use our generic type variable Type as part of the types were working with, rather than the whole type, giving us greater flexibility. We can alternatively write the sample example this way: tsfunction loggingIdentityType(arg: ArrayType): ArrayType { console.log(arg.length); // Array has a .length, so no more error return arg;}Try You may already be familiar with this style of type from other languages. In the next section, well cover how you can create your own generic types like ArrayType. Generic Types In previous sections, we created generic identity functions that worked over a range of types. In this section, well explore the type of the functions themselves and how to create generic interfaces. The type of generic functions is just like those of non-generic functions, with the type parameters listed first, similarly to function declarations: tsfunction identityType(arg: Type): Type { return arg;} let myIdentity: Type(arg: Type) = Type = identity;Try We could also have used a different name for the generic type parameter in the type, so long as the number of type variables and how the type variables are used line up. tsfunction identityType(arg: Type): Type { return arg;} let myIdentity: Input(arg: Input) = Input = identity;Try We can also write the generic type as a call signature of an object literal type: tsfunction identityType(arg: Type): Type { return arg;} let myIdentity: { Type(arg: Type): Type } = identity;Try Which leads us to writing our first generic interface. Lets take the object literal from the previous example and move it to an interface: tsinterface GenericIdentityFn { Type(arg: Type): Type;} function identityType(arg: Type): Type { return arg;} let myIdentity: GenericIdentityFn = identity;Try In a similar example, we may want to move the generic parameter to be a parameter of the whole interface. This lets us see what type(s) were generic over (e.g. Dictionarystring rather than just Dictionary). This makes the type parameter visible to all the other members of the interface. tsinterface GenericIdentityFnType { (arg: Type): Type;} function identityType(arg: Type): Type { return arg;} let myIdentity: GenericIdentityFnnumber = identity;Try Notice that our example has changed to be something slightly different. Instead of describing a generic function, we now have a non-generic function signature that is a part of a generic type. When we use GenericIdentityFn, we now will also need to specify the corresponding type argument (here: number), effectively locking in what the underlying call signature will use. Understanding when to put the type parameter directly on the call signature and when to put it on the interface itself will be helpful in describing what aspects of a type are generic. In addition to generic interfaces, we can also create generic classes. Note that it is not possible to create generic enums and namespaces. Generic Classes A generic class has a similar shape to a generic interface. Generic classes have a generic type parameter list in angle brackets () following the name of the class. tsclass GenericNumberNumType { zeroValue: NumType; add: (x: NumType, y: NumType) = NumType;} let myGenericNumber = new GenericNumbernumber();myGenericNumber.zeroValue = 0;myGenericNumber.add = function (x, y) { return x + y;};Try This is a pretty literal use of the GenericNumber class, but you may have noticed that nothing is restricting it to only use the number type. We could have instead used string or even more complex objects. tslet stringNumeric = new GenericNumberstring();stringNumeric.zeroValue = \"\";stringNumeric.add = function (x, y) { return x + y;}; console.log(stringNumeric.add(stringNumeric.zeroValue, \"test\"));Try Just as with interface, putting the type parameter on the class itself lets us make sure all of the properties of the class are working with the same type. As we cover in our section on classes, a class has two sides to its type: the static side and the instance side. Generic classes are only generic over their instance side rather than their static side, so when working with classes, static members can not use the classs type parameter. Generic Constraints If you remember from an earlier example, you may sometimes want to write a generic function that works on a set of types where you have some knowledge about what capabilities that set of types will have. In our loggingIdentity example, we wanted to be able to access the .length property of arg, but the compiler could not prove that every type had a .length property, so it warns us that we cant make this assumption. tsfunction loggingIdentityType(arg: Type): Type { console.log(arg.length);Property 'length' does not exist on type 'Type'.2339Property 'length' does not exist on type 'Type'. return arg;}Try Instead of working with any and all types, wed like to constrain this function to work with any and all types that also have the .length property. As long as the type has this member, well allow it, but its required to have at least this member. To do so, we must list our requirement as a constraint on what Type can be. To do so, well create an interface that describes our constraint. Here, well create an interface that has a single .length property and then well use this interface and the extends keyword to denote our constraint: tsinterface Lengthwise { length: number;} function loggingIdentityType extends Lengthwise(arg: Type): Type { console.log(arg.length); // Now we know it has a .length property, so no more error return arg;}Try Because the generic function is now constrained, it will no longer work over any and all types: tsloggingIdentity(3);Argument of type 'number' is not assignable to parameter of type 'Lengthwise'.2345Argument of type 'number' is not assignable to parameter of type 'Lengthwise'.Try Instead, we need to pass in values whose type has all the required properties: tsloggingIdentity({ length: 10, value: 3 });Try Using Type Parameters in Generic Constraints You can declare a type parameter that is constrained by another type parameter. For example, here wed like to get a property from an object given its name. Wed like to ensure that were not accidentally grabbing a property that does not exist on the obj, so well place a constraint between the two types: tsfunction getPropertyType, Key extends keyof Type(obj: Type, key: Key) { return obj[key];} let x = { a: 1, b: 2, c: 3, d: 4 }; getProperty(x, \"a\");getProperty(x, \"m\");Argument of type '\"m\"' is not assignable to parameter of type '\"a\"  \"b\"  \"c\"  \"d\"'.2345Argument of type '\"m\"' is not assignable to parameter of type '\"a\"  \"b\"  \"c\"  \"d\"'.Try Using Class Types in Generics When creating factories in TypeScript using generics, it is necessary to refer to class types by their constructor functions. For example, tsfunction createType(c: { new (): Type }): Type { return new c();}Try A more advanced example uses the prototype property to infer and constrain relationships between the constructor function and the instance side of class types. tsclass BeeKeeper { hasMask: boolean = true;} class ZooKeeper { nametag: string = \"Mikle\";} class Animal { numLegs: number = 4;} class Bee extends Animal { numLegs = 6; keeper: BeeKeeper = new BeeKeeper();} class Lion extends Animal { keeper: ZooKeeper = new ZooKeeper();} function createInstanceA extends Animal(c: new () = A): A { return new c();} createInstance(Lion).keeper.nametag;createInstance(Bee).keeper.hasMask;Try This pattern is used to power the mixins design pattern. Generic Parameter Defaults By declaring a default for a generic type parameter, you make it optional to specify the corresponding type argument. For example, a function which creates a new HTMLElement. Calling the function with no arguments generates a HTMLDivElement; calling the function with an element as the first argument generates an element of the arguments type. You can optionally pass a list of children as well. Previously you would have to define the function as: tsdeclare function create(): ContainerHTMLDivElement, HTMLDivElement[];declare function createT extends HTMLElement(element: T): ContainerT, T[];declare function createT extends HTMLElement, U extends HTMLElement( element: T, children: U[]): ContainerT, U[];Try With generic parameter defaults we can reduce it to: tsdeclare function createT extends HTMLElement = HTMLDivElement, U extends HTMLElement[] = T[]( element?: T, children?: U): ContainerT, U; const div = create(); const div: ContainerHTMLDivElement, HTMLDivElement[] const p = create(new HTMLParagraphElement()); const p: ContainerHTMLParagraphElement, HTMLParagraphElement[]Try A generic parameter default follows the following rules: A type parameter is deemed optional if it has a default. Required type parameters must not follow optional type parameters. Default types for a type parameter must satisfy the constraint for the type parameter, if it exists. When specifying type arguments, you are only required to specify type arguments for the required type parameters. Unspecified type parameters will resolve to their default types. If a default type is specified and inference cannot choose a candidate, the default type is inferred. A class or interface declaration that merges with an existing class or interface declaration may introduce a default for an existing type parameter. A class or interface declaration that merges with an existing class or interface declaration may introduce a new type parameter as long as it specifies a default. Variance Annotations This is an advanced feature for solving a very specific problem, and should only be used in situations where youve identified a reason to use it Covariance and contravariance are type theory terms that describe what the relationship between two generic types is. Heres a brief primer on the concept. For example, if you have an interface representing an object that can make a certain type: tsinterface ProducerT { make(): T;} We can use a ProducerCat where a ProducerAnimal is expected, because a Cat is an Animal. This relationship is called covariance: the relationship from ProducerT to ProducerU is the same as the relationship from T to U. Conversely, if you have an interface that can consume a certain type: tsinterface ConsumerT { consume: (arg: T) = void;} Then we can use a ConsumerAnimal where a ConsumerCat is expected, because any function that is capable of accepting an Animal must also be capable of accepting a Cat. This relationship is called contravariance: the relationship from ConsumerT to ConsumerU is the same as the relationship from U to T. Note the reversal of direction as compared to covariance! This is why contravariance cancels itself out but covariance doesnt. In a structural type system like TypeScripts, covariance and contravariance are naturally emergent behaviors that follow from the definition of types. Even in the absence of generics, we would see covariant (and contravariant) relationships: tsinterface AnimalProducer { make(): Animal;}// A CatProducer can be used anywhere an// Animal producer is expectedinterface CatProducer { make(): Cat;} TypeScript has a structural type system, so when comparing two types, e.g. to see if a ProducerCat can be used where a ProducerAnimal is expected, the usual algorithm would be structurally expand both of those definitions, and compare their structures. However, variance allows for an extremely useful optimization: if ProducerT is covariant on T, then we can simply check Cat and Animal instead, as we know theyll have the same relationship as ProducerCat and ProducerAnimal. Note that this logic can only be used when were examining two instantiations of the same type. If we have a ProducerT and a FastProducerU, theres no guarantee that T and U necessarily refer to the same positions in these types, so this check will always be performed structurally. Because variance is a naturally emergent property of structural types, TypeScript automatically infers the variance of every generic type. In extremely rare cases involving certain kinds of circular types, this measurement can be inaccurate. If this happens, you can add a variance annotation to a type parameter to force a particular variance: ts// Contravariant annotationinterface Consumerin T { consume: (arg: T) = void;}// Covariant annotationinterface Producerout T { make(): T;}// Invariant annotationinterface ProducerConsumerin out T { consume: (arg: T) = void; make(): T;} Only do this if you are writing the same variance that should occur structurally. Never write a variance annotation that doesnt match the structural variance! Its critical to reinforce that variance annotations are only in effect during an instantiation-based comparison. They have no effect during a structural comparison. For example, you cant use variance annotations to force a type to be actually invariant: ts// DON'T DO THIS - variance annotation// does not match structural behaviorinterface Producerin out T { make(): T;}// Not a type error -- this is a structural// comparison, so variance annotations are// not in effectconst p: Producerstring  number = { make(): number { return 42; }} Here, the object literals make function returns number, which we might expect to cause an error because number isnt string  number. However, this isnt an instantiation-based comparison, because the object literal is an anonymous type, not a Producerstring  number. Variance annotations dont change structural behavior and are only consulted in specific situations Its very important to only write variance annotations if you absolutely know why youre doing it, what their limitations are, and when they arent in effect. Whether TypeScript uses an instantiation-based comparison or structural comparison is not a specified behavior and may change from version to version for correctness or performance reasons, so you should only ever write variance annotations when they match the structural behavior of a type. Dont use variance annotations to try to force a particular variance; this will cause unpredictable behavior in your code. Do NOT write variance annotations unless they match the structural behavior of a type Remember, TypeScript can automatically infer variance from your generic types. Its almost never necessary to write a variance annotation, and you should only do so when youve identified a specific need. Variance annotations do not change the structural behavior of a type, and depending on the situation, you might see a structural comparison made when you expected an instantiation-based comparison. Variance annotations cant be used to modify how types behave in these structural contexts, and shouldnt be written unless the annotation is the same as the structural definition. Because this is difficult to get right, and TypeScript can correctly infer variance in the vast majority of cases, you should not find yourself writing variance annotations in normal code. Dont try to use variance annotations to change typechecking behavior; this is not what they are for You may find temporary variance annotations useful in a type debugging situation, because variance annotations are checked. TypeScript will issue an error if the annotated variance is identifiably wrong: ts// Error, this interface is definitely contravariant on Tinterface Fooout T { consume: (arg: T) = void;} However, variance annotations are allowed to be stricter (e.g. in out is valid if the actual variance is covariant). Be sure to remove your variance annotations once youre done debugging. Lastly, if youre trying to maximize your typechecking performance, and have run a profiler, and have identified a specific type thats slow, and have identified variance inference specifically is slow, and have carefully validated the variance annotation you want to write, you may see a small performance benefit in extraordinarily complex types by adding variance annotations. Dont try to use variance annotations to change typechecking behavior; this is not what they are for",
    "headings": [
      {
        "level": 2,
        "text": "Hello World of Generics",
        "id": "hello-world-of-generics"
      },
      {
        "level": 2,
        "text": "Working with Generic Type Variables",
        "id": "working-with-generic-type-variables"
      },
      {
        "level": 2,
        "text": "Generic Types",
        "id": "generic-types"
      },
      {
        "level": 2,
        "text": "Generic Classes",
        "id": "generic-classes"
      },
      {
        "level": 2,
        "text": "Generic Constraints",
        "id": "generic-constraints"
      },
      {
        "level": 2,
        "text": "Using Type Parameters in Generic Constraints",
        "id": "using-type-parameters-in-generic-constraints"
      },
      {
        "level": 2,
        "text": "Using Class Types in Generics",
        "id": "using-class-types-in-generics"
      },
      {
        "level": 2,
        "text": "Generic Parameter Defaults",
        "id": "generic-parameter-defaults"
      },
      {
        "level": 2,
        "text": "Variance Annotations",
        "id": "variance-annotations"
      }
    ],
    "codeBlocks": [
      {
        "language": "text",
        "code": "tsfunction identity(arg: number): number {  return arg;}Try"
      },
      {
        "language": "text",
        "code": "function identity(arg: number): number {  return arg;}"
      },
      {
        "language": "text",
        "code": "tsfunction identity(arg: any): any {  return arg;}Try"
      },
      {
        "language": "text",
        "code": "function identity(arg: any): any {  return arg;}"
      },
      {
        "language": "text",
        "code": "tsfunction identity<Type>(arg: Type): Type {  return arg;}Try"
      },
      {
        "language": "text",
        "code": "function identity<Type>(arg: Type): Type {  return arg;}"
      },
      {
        "language": "text",
        "code": "tslet output = identity<string>(\"myString\");      let output: stringTry"
      },
      {
        "language": "text",
        "code": "let output = identity<string>(\"myString\");      let output: string"
      },
      {
        "language": "text",
        "code": "tslet output = identity(\"myString\");      let output: stringTry"
      },
      {
        "language": "text",
        "code": "let output = identity(\"myString\");      let output: string"
      },
      {
        "language": "text",
        "code": "tsfunction identity<Type>(arg: Type): Type {  return arg;}Try"
      },
      {
        "language": "text",
        "code": "function identity<Type>(arg: Type): Type {  return arg;}"
      },
      {
        "language": "text",
        "code": "tsfunction loggingIdentity<Type>(arg: Type): Type {  console.log(arg.length);Property 'length' does not exist on type 'Type'.2339Property 'length' does not exist on type 'Type'.  return arg;}Try"
      },
      {
        "language": "text",
        "code": "function loggingIdentity<Type>(arg: Type): Type {  console.log(arg.length);Property 'length' does not exist on type 'Type'.2339Property 'length' does not exist on type 'Type'.  return arg;}"
      },
      {
        "language": "text",
        "code": "tsfunction loggingIdentity<Type>(arg: Type[]): Type[] {  console.log(arg.length);  return arg;}Try"
      },
      {
        "language": "text",
        "code": "function loggingIdentity<Type>(arg: Type[]): Type[] {  console.log(arg.length);  return arg;}"
      },
      {
        "language": "text",
        "code": "loggingIdentity"
      },
      {
        "language": "text",
        "code": "loggingIdentity"
      },
      {
        "language": "text",
        "code": "tsfunction loggingIdentity<Type>(arg: Array<Type>): Array<Type> {  console.log(arg.length); // Array has a .length, so no more error  return arg;}Try"
      },
      {
        "language": "text",
        "code": "function loggingIdentity<Type>(arg: Array<Type>): Array<Type> {  console.log(arg.length); // Array has a .length, so no more error  return arg;}"
      },
      {
        "language": "text",
        "code": "Array<Type>"
      },
      {
        "language": "text",
        "code": "tsfunction identity<Type>(arg: Type): Type {  return arg;} let myIdentity: <Type>(arg: Type) => Type = identity;Try"
      },
      {
        "language": "text",
        "code": "function identity<Type>(arg: Type): Type {  return arg;} let myIdentity: <Type>(arg: Type) => Type = identity;"
      },
      {
        "language": "text",
        "code": "tsfunction identity<Type>(arg: Type): Type {  return arg;} let myIdentity: <Input>(arg: Input) => Input = identity;Try"
      },
      {
        "language": "text",
        "code": "function identity<Type>(arg: Type): Type {  return arg;} let myIdentity: <Input>(arg: Input) => Input = identity;"
      },
      {
        "language": "text",
        "code": "tsfunction identity<Type>(arg: Type): Type {  return arg;} let myIdentity: { <Type>(arg: Type): Type } = identity;Try"
      },
      {
        "language": "text",
        "code": "function identity<Type>(arg: Type): Type {  return arg;} let myIdentity: { <Type>(arg: Type): Type } = identity;"
      },
      {
        "language": "text",
        "code": "tsinterface GenericIdentityFn {  <Type>(arg: Type): Type;} function identity<Type>(arg: Type): Type {  return arg;} let myIdentity: GenericIdentityFn = identity;Try"
      },
      {
        "language": "text",
        "code": "interface GenericIdentityFn {  <Type>(arg: Type): Type;} function identity<Type>(arg: Type): Type {  return arg;} let myIdentity: GenericIdentityFn = identity;"
      },
      {
        "language": "text",
        "code": "Dictionary<string>"
      },
      {
        "language": "text",
        "code": "tsinterface GenericIdentityFn<Type> {  (arg: Type): Type;} function identity<Type>(arg: Type): Type {  return arg;} let myIdentity: GenericIdentityFn<number> = identity;Try"
      },
      {
        "language": "text",
        "code": "interface GenericIdentityFn<Type> {  (arg: Type): Type;} function identity<Type>(arg: Type): Type {  return arg;} let myIdentity: GenericIdentityFn<number> = identity;"
      },
      {
        "language": "text",
        "code": "GenericIdentityFn"
      },
      {
        "language": "text",
        "code": "tsclass GenericNumber<NumType> {  zeroValue: NumType;  add: (x: NumType, y: NumType) => NumType;} let myGenericNumber = new GenericNumber<number>();myGenericNumber.zeroValue = 0;myGenericNumber.add = function (x, y) {  return x + y;};Try"
      },
      {
        "language": "text",
        "code": "class GenericNumber<NumType> {  zeroValue: NumType;  add: (x: NumType, y: NumType) => NumType;} let myGenericNumber = new GenericNumber<number>();myGenericNumber.zeroValue = 0;myGenericNumber.add = function (x, y) {  return x + y;};"
      },
      {
        "language": "text",
        "code": "GenericNumber"
      },
      {
        "language": "text",
        "code": "tslet stringNumeric = new GenericNumber<string>();stringNumeric.zeroValue = \"\";stringNumeric.add = function (x, y) {  return x + y;}; console.log(stringNumeric.add(stringNumeric.zeroValue, \"test\"));Try"
      },
      {
        "language": "text",
        "code": "let stringNumeric = new GenericNumber<string>();stringNumeric.zeroValue = \"\";stringNumeric.add = function (x, y) {  return x + y;}; console.log(stringNumeric.add(stringNumeric.zeroValue, \"test\"));"
      },
      {
        "language": "text",
        "code": "loggingIdentity"
      },
      {
        "language": "text",
        "code": "tsfunction loggingIdentity<Type>(arg: Type): Type {  console.log(arg.length);Property 'length' does not exist on type 'Type'.2339Property 'length' does not exist on type 'Type'.  return arg;}Try"
      },
      {
        "language": "text",
        "code": "function loggingIdentity<Type>(arg: Type): Type {  console.log(arg.length);Property 'length' does not exist on type 'Type'.2339Property 'length' does not exist on type 'Type'.  return arg;}"
      },
      {
        "language": "text",
        "code": "tsinterface Lengthwise {  length: number;} function loggingIdentity<Type extends Lengthwise>(arg: Type): Type {  console.log(arg.length); // Now we know it has a .length property, so no more error  return arg;}Try"
      },
      {
        "language": "text",
        "code": "interface Lengthwise {  length: number;} function loggingIdentity<Type extends Lengthwise>(arg: Type): Type {  console.log(arg.length); // Now we know it has a .length property, so no more error  return arg;}"
      },
      {
        "language": "text",
        "code": "tsloggingIdentity(3);Argument of type 'number' is not assignable to parameter of type 'Lengthwise'.2345Argument of type 'number' is not assignable to parameter of type 'Lengthwise'.Try"
      },
      {
        "language": "text",
        "code": "loggingIdentity(3);Argument of type 'number' is not assignable to parameter of type 'Lengthwise'.2345Argument of type 'number' is not assignable to parameter of type 'Lengthwise'."
      },
      {
        "language": "text",
        "code": "tsloggingIdentity({ length: 10, value: 3 });Try"
      },
      {
        "language": "text",
        "code": "loggingIdentity({ length: 10, value: 3 });"
      },
      {
        "language": "text",
        "code": "tsfunction getProperty<Type, Key extends keyof Type>(obj: Type, key: Key) {  return obj[key];} let x = { a: 1, b: 2, c: 3, d: 4 }; getProperty(x, \"a\");getProperty(x, \"m\");Argument of type '\"m\"' is not assignable to parameter of type '\"a\" | \"b\" | \"c\" | \"d\"'.2345Argument of type '\"m\"' is not assignable to parameter of type '\"a\" | \"b\" | \"c\" | \"d\"'.Try"
      },
      {
        "language": "text",
        "code": "function getProperty<Type, Key extends keyof Type>(obj: Type, key: Key) {  return obj[key];} let x = { a: 1, b: 2, c: 3, d: 4 }; getProperty(x, \"a\");getProperty(x, \"m\");Argument of type '\"m\"' is not assignable to parameter of type '\"a\" | \"b\" | \"c\" | \"d\"'.2345Argument of type '\"m\"' is not assignable to parameter of type '\"a\" | \"b\" | \"c\" | \"d\"'."
      },
      {
        "language": "text",
        "code": "tsfunction create<Type>(c: { new (): Type }): Type {  return new c();}Try"
      },
      {
        "language": "text",
        "code": "function create<Type>(c: { new (): Type }): Type {  return new c();}"
      },
      {
        "language": "text",
        "code": "tsclass BeeKeeper {  hasMask: boolean = true;} class ZooKeeper {  nametag: string = \"Mikle\";} class Animal {  numLegs: number = 4;} class Bee extends Animal {  numLegs = 6;  keeper: BeeKeeper = new BeeKeeper();} class Lion extends Animal {  keeper: ZooKeeper = new ZooKeeper();} function createInstance<A extends Animal>(c: new () => A): A {  return new c();} createInstance(Lion).keeper.nametag;createInstance(Bee).keeper.hasMask;Try"
      },
      {
        "language": "text",
        "code": "class BeeKeeper {  hasMask: boolean = true;} class ZooKeeper {  nametag: string = \"Mikle\";} class Animal {  numLegs: number = 4;} class Bee extends Animal {  numLegs = 6;  keeper: BeeKeeper = new BeeKeeper();} class Lion extends Animal {  keeper: ZooKeeper = new ZooKeeper();} function createInstance<A extends Animal>(c: new () => A): A {  return new c();} createInstance(Lion).keeper.nametag;createInstance(Bee).keeper.hasMask;"
      },
      {
        "language": "text",
        "code": "HTMLElement"
      },
      {
        "language": "text",
        "code": "HTMLDivElement"
      },
      {
        "language": "text",
        "code": "tsdeclare function create(): Container<HTMLDivElement, HTMLDivElement[]>;declare function create<T extends HTMLElement>(element: T): Container<T, T[]>;declare function create<T extends HTMLElement, U extends HTMLElement>(  element: T,  children: U[]): Container<T, U[]>;Try"
      },
      {
        "language": "text",
        "code": "declare function create(): Container<HTMLDivElement, HTMLDivElement[]>;declare function create<T extends HTMLElement>(element: T): Container<T, T[]>;declare function create<T extends HTMLElement, U extends HTMLElement>(  element: T,  children: U[]): Container<T, U[]>;"
      },
      {
        "language": "text",
        "code": "tsdeclare function create<T extends HTMLElement = HTMLDivElement, U extends HTMLElement[] = T[]>(  element?: T,  children?: U): Container<T, U>; const div = create();      const div: Container<HTMLDivElement, HTMLDivElement[]> const p = create(new HTMLParagraphElement());     const p: Container<HTMLParagraphElement, HTMLParagraphElement[]>Try"
      },
      {
        "language": "text",
        "code": "declare function create<T extends HTMLElement = HTMLDivElement, U extends HTMLElement[] = T[]>(  element?: T,  children?: U): Container<T, U>; const div = create();      const div: Container<HTMLDivElement, HTMLDivElement[]> const p = create(new HTMLParagraphElement());     const p: Container<HTMLParagraphElement, HTMLParagraphElement[]>"
      },
      {
        "language": "text",
        "code": "tsinterface Producer<T> {  make(): T;}"
      },
      {
        "language": "text",
        "code": "interface Producer<T> {  make(): T;}"
      },
      {
        "language": "text",
        "code": "Producer<Cat>"
      },
      {
        "language": "text",
        "code": "Producer<Animal>"
      },
      {
        "language": "text",
        "code": "Producer<T>"
      },
      {
        "language": "text",
        "code": "Producer<U>"
      },
      {
        "language": "text",
        "code": "tsinterface Consumer<T> {  consume: (arg: T) => void;}"
      },
      {
        "language": "text",
        "code": "interface Consumer<T> {  consume: (arg: T) => void;}"
      },
      {
        "language": "text",
        "code": "Consumer<Animal>"
      },
      {
        "language": "text",
        "code": "Consumer<Cat>"
      },
      {
        "language": "text",
        "code": "Consumer<T>"
      },
      {
        "language": "text",
        "code": "Consumer<U>"
      },
      {
        "language": "text",
        "code": "tsinterface AnimalProducer {  make(): Animal;}// A CatProducer can be used anywhere an// Animal producer is expectedinterface CatProducer {  make(): Cat;}"
      },
      {
        "language": "text",
        "code": "interface AnimalProducer {  make(): Animal;}// A CatProducer can be used anywhere an// Animal producer is expectedinterface CatProducer {  make(): Cat;}"
      },
      {
        "language": "text",
        "code": "Producer<Cat>"
      },
      {
        "language": "text",
        "code": "Producer<Animal>"
      },
      {
        "language": "text",
        "code": "Producer<T>"
      },
      {
        "language": "text",
        "code": "Producer<Cat>"
      },
      {
        "language": "text",
        "code": "Producer<Animal>"
      },
      {
        "language": "text",
        "code": "Producer<T>"
      },
      {
        "language": "text",
        "code": "FastProducer<U>"
      },
      {
        "language": "text",
        "code": "ts// Contravariant annotationinterface Consumer<in T> {  consume: (arg: T) => void;}// Covariant annotationinterface Producer<out T> {  make(): T;}// Invariant annotationinterface ProducerConsumer<in out T> {  consume: (arg: T) => void;  make(): T;}"
      },
      {
        "language": "text",
        "code": "// Contravariant annotationinterface Consumer<in T> {  consume: (arg: T) => void;}// Covariant annotationinterface Producer<out T> {  make(): T;}// Invariant annotationinterface ProducerConsumer<in out T> {  consume: (arg: T) => void;  make(): T;}"
      },
      {
        "language": "text",
        "code": "ts// DON'T DO THIS - variance annotation// does not match structural behaviorinterface Producer<in out T> {  make(): T;}// Not a type error -- this is a structural// comparison, so variance annotations are// not in effectconst p: Producer<string | number> = {    make(): number {        return 42;    }}"
      },
      {
        "language": "text",
        "code": "// DON'T DO THIS - variance annotation// does not match structural behaviorinterface Producer<in out T> {  make(): T;}// Not a type error -- this is a structural// comparison, so variance annotations are// not in effectconst p: Producer<string | number> = {    make(): number {        return 42;    }}"
      },
      {
        "language": "text",
        "code": "string | number"
      },
      {
        "language": "text",
        "code": "Producer<string | number>"
      },
      {
        "language": "text",
        "code": "ts// Error, this interface is definitely contravariant on Tinterface Foo<out T> {  consume: (arg: T) => void;}"
      },
      {
        "language": "text",
        "code": "// Error, this interface is definitely contravariant on Tinterface Foo<out T> {  consume: (arg: T) => void;}"
      }
    ],
    "links": [
      {
        "text": "Try",
        "href": "https://www.typescriptlang.org/play/#code/GYVwdgxgLglg9mABDAJgUzLKBPAFAQwCcBzALkTBAFsAjNQgSnMtvsQG8AoRRQtKEISRFiAbk4BfIA"
      },
      {
        "text": "Try",
        "href": "https://www.typescriptlang.org/play/#code/GYVwdgxgLglg9mABDAJgUzLKBPAFAQwCcBzALkXzGwEpzLtEBvAKEUULShEKSOIG5mAXyA"
      },
      {
        "text": "Try",
        "href": "https://www.typescriptlang.org/play/#code/GYVwdgxgLglg9mABDAJgUzLKBPAPAFWwAc0A+ACgEMAnAcwC5FCSBKR5tRAbwChFFqaKCGpIatANw8AvkA"
      },
      {
        "text": "Try",
        "href": "https://www.typescriptlang.org/play/#code/GYVwdgxgLglg9mABDAJgUzLKBPAPAFWwAc0A+ACgEMAnAcwC5FCSBKR5tRAbwChFFqaKCGpIatANw8AvjwD0cxAFoVEEFBVKeAGyGI46ousQBeZOkwwcuAM5RqMMLQoAiALbYAyvce0XLKQV+YP4APQB+IA"
      },
      {
        "text": "Try",
        "href": "https://www.typescriptlang.org/play/#code/GYVwdgxgLglg9mABDAJgUzLKBPAPAFWwAc0A+ACgEMAnAcwC5FCSBKR5tRAbwChFFqaKCGpIatANw8AvjwD0cxAFoVEEFBVKeAGyGI46ousQBeZOkwwc5AEQBbbAGUo1GGFo2WUhf1-8AegD8QA"
      },
      {
        "text": "Try",
        "href": "https://www.typescriptlang.org/play/#code/GYVwdgxgLglg9mABDAJgUzLKBPAPAFWwAc0A+ACgEMAnAcwC5FCSBKR5tRAbwChFFqaKCGpIatANw8AvkA"
      },
      {
        "text": "Try",
        "href": "https://www.typescriptlang.org/play/#code/PTAEAEFMCdoe2gZwFygEwGYME4BQAzAVwDsBjAFwEs5jQAbOAc0cuMYEkATSYq8gTwA8AFX4AHSAD4AFAENojVKIkBKJeMigA3rlChSNRHDqQAdA0ZyF5no3IALFQG5doaJHKFoteYxcBfIA"
      },
      {
        "text": "Try",
        "href": "https://www.typescriptlang.org/play/#code/GYVwdgxgLglg9mABAGzgczTMaCSATAUzFigE8AeAFVIAcCA+ACgEMAnNALkWroG0BdAJRceBAYgDeAKESIICAM5xkBAHSo0LduqJooAC0EBuGYlYEoIVkjZoTAXyA"
      },
      {
        "text": "Try",
        "href": "https://www.typescriptlang.org/play/#code/GYVwdgxgLglg9mABAGzgczTMaCSATAUzFigE8AeAFVIAcCA+ACgEMAnNALkQEFXXmK1OvQCUXXv0G0GiAN4AoRIggIAznGQEAdKjQt2OomigALEQG5EAeis8+AxCearEzRIeymANInWIwcIgAtnCsBIgEfKGKiGFQIKxIbGjm8gC+QA"
      },
      {
        "text": "Try",
        "href": "https://www.typescriptlang.org/play/#code/GYVwdgxgLglg9mABDAJgUzLKBPAPAFWwAc0A+ACgEMAnAcwC5FCSBKR5tRAbwChFFqaKCGpIatANw8Avjx4AbIYgC22AJLpMMHIwLEyVOu30tEAXlJN955JqzYJQA"
      },
      {
        "text": "Try",
        "href": "https://www.typescriptlang.org/play/#code/GYVwdgxgLglg9mABDAJgUzLKBPAPAFWwAc0A+ACgEMAnAcwC5FCSBKR5tRAbwChFFqaKCGpIatANw8Avjx4AbIYgC22AJLpMMHI1xqwREFArjG+w1BaIAvKUTmjN5JqzYJQA"
      },
      {
        "text": "Try",
        "href": "https://www.typescriptlang.org/play/#code/GYVwdgxgLglg9mABDAJgUzLKBPAPAFWwAc0A+ACgEMAnAcwC5FCSBKR5tRAbwChFFqaKCGpIatANw8Avjx4AbIYgC22AJLpMMHIy6ICxMlTrtDbJocTTEAXmSas2CUA"
      },
      {
        "text": "Try",
        "href": "https://www.typescriptlang.org/play/#code/JYOwLgpgTgZghgYwgAgOIRNYCCSATDMYMATwDERkBvAKGWQB4AVEgBwgD4AKOKAcwBcyFuwCUQkRADcNAL40aMAK4gERAPaVgBcMRLM2nHvwmHxww9TrIoEMEqiVefGfJoAbO8gC2JfIT0hdEwobH9dUgpkAF5kbQDSKSA"
      },
      {
        "text": "Try",
        "href": "https://www.typescriptlang.org/play/#code/JYOwLgpgTgZghgYwgAgOIRNYCCSATDMYMATwDEQAeAFRIAcIA+ZAbwChlkAKOKAcwBcyWgwCUQkRADcbAL5s2MAK4gERAPYhkwAuGIka9Jj34Sj44UdYdkUCGCVQtvPjPlsANveQBbEvkJ9IXRMKGwAvVIKShAlHwAjaGYAXm1dIlIpIA"
      },
      {
        "text": "Try",
        "href": "https://www.typescriptlang.org/play/#code/PTAEAEGcBcCcEsDG0BcoBmBDANpApgFCLaaSSgDieAdngogHICuAtgEZ0A8zLAKgJ4AHPAD5QAbwKhQALzoB7AGo4meNDwHCA3FNCYAJvrQAKAB7rWmvABpQ-C3yF4AlKAC8YjU50BfAgWw8aFAWfipaeh4OWHdQWgB3Sho6JCiualZokWNnHVDwlMZMugA6OVglFTxYgAY8sOTI4tgSg31Y9CZqZHh5alAzW35XSWlYIKZYftNQAGo7Xy0gA"
      },
      {
        "text": "Try",
        "href": "https://www.typescriptlang.org/play/#code/PTAEAEGcBcCcEsDG0BcoBmBDANpApgFCLaaSSgDieAdngogHICuAtgEZ0A8zLAKgJ4AHPAD5QAbwKhQALzoB7AGo4meNDwHCA3FNCYAJvrQAKAB7rWmvABpQ-C3yF4AlKAC8YjU50BfAiFAAWmDEJmhgwIJsPGhQGARqAHMeOiR3UFoAd0oaVMZWDlhOePgkkWNnHRKklPoAOjlYJRU8dIAiNqq4UuTWPLqDfXT0JmpkeHlqUDNbfldJaVgYplgp01AAajtfHSJJyHlouux5RONq3pZ+wfPumr76xubsVVs26DwYNudKoA"
      },
      {
        "text": "our section on classes",
        "href": "/docs/handbook/2/classes.html"
      },
      {
        "text": "Try",
        "href": "https://www.typescriptlang.org/play/#code/PTAEAEFMCdoe2gZwFygEwGYME4BQAzAVwDsBjAFwEs5jQAbOAc0cuMYEkATSYq8gTwA8AFX4AHSAD4AFAENojVKIkBKJeMigA3rlChSNRHDqQAdA0ZyF5no3IALFQG5doaJHKFoteYxcBfIA"
      },
      {
        "text": "Try",
        "href": "https://www.typescriptlang.org/play/#code/JYOwLgpgTgZghgYwgAgDIRAczACwO7ADOKA3gFDLIA2G2OAXMiAK4C2ARtANxkC+ZZGMxAIwwAPYhq4zJlCYAkgBMMYsAE8APABV1ABxQQAHpBBLCaWrgLEAfAAo4UTI10GAlK-2kKyBJMJxGgA6KhlHZ1CrHHcuZAB6eOQAOXE8ZDwUAGsQNORgMGQcOAs4ZCisXGQ9KHEDKA0AGmRApnFkVnEoQyhaqF9usGYoKSdMHl4gA"
      },
      {
        "text": "Try",
        "href": "https://www.typescriptlang.org/play/#code/PTAEAEFMCdoe2gZwFygEwGYAsBWAUAJYB2ALjAGYCGAxpKADKREDmJAFgO4GJ0DeeoUABsmrNqiIBXALYAjGAG48AXzx5ykotRIE4RYXGbNizAJIATJjpIBPADwAVGwAc6kAB5ki5xA1HsuHgA+AApKaGZUJ1cASiiXPgFQaj1EOBEAOiFDMIis-zYYpUFoSBJJaH1w5iVVEFAAWibqSRImhrxsoxMLKwJbEIwioA"
      },
      {
        "text": "Try",
        "href": "https://www.typescriptlang.org/play/#code/JYOwLgpgTgZghgYwgAgDIRAczACwO7ADOKA3gFDLIA2G2OAXMiAK4C2ARtANxkC+ZZGMxAIwwAPYhq4zJlCYAkgBMMYsAE8APABV1ABxQQAHpBBLCaWrgLEAfAAo4UTI10GAlK-2kKyBJMJxGgA6KhlHZ1CrHHceSigIMGYoKSdMHn4AekzkAFp8hGYwfNyyMNl5ZVVgDXsSamjGAEYABgAaZAA3OCpmCEYAZmReWKA"
      },
      {
        "text": "Try",
        "href": "https://www.typescriptlang.org/play/#code/PTAEAEFMCdoe2gZwFygEwGYAsBWAUAGYCuAdgMYAuAlnCaAOaQUAK8ADjBQJ4A8AKlw4AaUAGlIXUJAAeFSCQAmiUAGsJcAqAEcAfAAo4AIwBWqbZBFquqcVwCUoAN55QoaEyLQ6R4wG0rALoA3HgAvnh4ADZMoNKgALxOoACGqACMIoaoaCJkqBgiCqhYoKEheIws7JxcetIiAETJDXYhlaxwHNDcdY0Ati1BQA"
      },
      {
        "text": "Try",
        "href": "https://www.typescriptlang.org/play/#code/GYVwdgxgLglg9mABBATgUwIZTQHgCoCeADmgHwAUEAXIgN6JhoDui5AlDYSYgL4eJc0dAFCJE6KCBRJGLCOwDcwnkA"
      },
      {
        "text": "Try",
        "href": "https://www.typescriptlang.org/play/#code/PTAEAEGcBcCcEsDG0BcoBmBDANpApgFCLaaSSgBCeeA0tQA56ygDeBooAFqQLKkDWaAEYB7EdjyYAdqAC8oOAFc8AbgIBfAkRJlQALTF08jZmw5TMAWzzRMAczQwEUu3NAAiHvH4T3azdqk5ACCUvCWOKzsoFKKlgAyeHaQaLGWQkxuACz+WsRBlNSgeAAe0HhSACYhYRHYUeZxicluAGxqHPwMTGhUtN3M8lJ4AO6F-cZMABQAlLmBuvHwIjKl5VU14ZFmoF2TsGgGIkYmbsNjRyfTcxpa6IpSyMsyiLCS5QCSUjDSiHgAPMFimUKtVQKEttgAHxTRCpUagWZyKHgmZoIE7N7QRSwGTnUCIWbzV7vPBfH6PPBTJYrGYAOj2JjpFmstjsahJmE+31slKmfXpjKYdO4kD4kH4KiAA"
      },
      {
        "text": "mixins",
        "href": "/docs/handbook/mixins.html"
      },
      {
        "text": "Try",
        "href": "https://www.typescriptlang.org/play/#code/C4TwDgpgBAwg9gO2AQwJYIgJwDwBUA0UAqgHxQC8UA3gFBRQQA2EAthEgFxS4DcdUAYwAWqRgBNM7LkT4BfPjQD0iqAFp1AgK7B1qmmIgDGySVABmmhAOCpEgycmAQAFAEou8JGgw4AErgBZABkAEVQANwBRZjYkQn9gsKiY9mAAbQBdEj4DIxNoCysbOwEHJzwGAA8nBDEAZygEoOjWVJJnJlbObndYRBR0LDxCXEzs-UNjU0LrWwR7CEcICohq9nrGwOaUuOIqmo2mltjgdv5Ok64CfmFRCSliTJpezwGfYcesniA"
      },
      {
        "text": "Try",
        "href": "https://www.typescriptlang.org/play/#code/C4TwDgpgBAwg9gO2AQwJYIgJwDwBUA0UAqgHxQC8UA3gFBRQQA2EAthEgFxS4DcdUAYwAWqRgBNM7LkT4BfPjQD0iqAFp1AgK7B1qmmIgDGySVABmmhAOCpEgycmAQ8DAB5OEYgM5QAErgBZABkAUWY2JAo-QKCAEVQANzDWdmBCIjcPb2jg5IjgAG0AXSjcYpIACn4mFKQAfi4CfmFRCXYG4hoASi54JDQMHAJiEgUBRC9gKDFEqIEHJwquvmV6egA9OpoacYRJqDA5hYgKjAB3HKCABRNkAHNMZDAhPNSl5aUVNc2gA"
      },
      {
        "text": "Covariance and contravariance",
        "href": "https://en.wikipedia.org/wiki/Covariance_and_contravariance_(computer_science)"
      }
    ],
    "meta": {
      "description": "Types which take parameters",
      "keywords": ""
    },
    "summary": "A major part of software engineering is building components that not only have well-defined and consistent APIs, but are also reusable",
    "tags": [
      "react",
      "angular",
      "javascript",
      "typescript",
      "css",
      "html",
      "vite",
      "generic",
      "generics",
      "type"
    ],
    "id": "typescript-documentation-genericshtml-part-1",
    "quality": 100
  },
  {
    "title": "TypeScript: Documentation",
    "url": "https://www.typescriptlang.org/docs/handbook/2/classes.html",
    "category": "typescript",
    "content": "Background Reading:Classes (MDN) TypeScript offers full support for the class keyword introduced in ES2015. As with other JavaScript language features, TypeScript adds type annotations and other syntax to allow you to express relationships between classes and other types. Class Members Heres the most basic class - an empty one: tsclass Point {}Try This class isnt very useful yet, so lets start adding some members. Fields A field declaration creates a public writeable property on a class: tsclass Point { x: number; y: number;} const pt = new Point();pt.x = 0;pt.y = 0;Try As with other locations, the type annotation is optional, but will be an implicit any if not specified. Fields can also have initializers; these will run automatically when the class is instantiated: tsclass Point { x = 0; y = 0;} const pt = new Point();// Prints 0, 0console.log(${pt.x}, ${pt.y});Try Just like with const, let, and var, the initializer of a class property will be used to infer its type: tsconst pt = new Point();pt.x = \"0\";Type 'string' is not assignable to type 'number'.2322Type 'string' is not assignable to type 'number'.Try --strictPropertyInitialization The strictPropertyInitialization setting controls whether class fields need to be initialized in the constructor. tsclass BadGreeter { name: string;Property 'name' has no initializer and is not definitely assigned in the constructor.2564Property 'name' has no initializer and is not definitely assigned in the constructor.}Try tsclass GoodGreeter { name: string; constructor() { this.name = \"hello\"; }}Try Note that the field needs to be initialized in the constructor itself. TypeScript does not analyze methods you invoke from the constructor to detect initializations, because a derived class might override those methods and fail to initialize the members. If you intend to definitely initialize a field through means other than the constructor (for example, maybe an external library is filling in part of your class for you), you can use the definite assignment assertion operator, !: tsclass OKGreeter { // Not initialized, but no error name!: string;}Try readonly Fields may be prefixed with the readonly modifier. This prevents assignments to the field outside of the constructor. tsclass Greeter { readonly name: string = \"world\"; constructor(otherName?: string) { if (otherName !== undefined) { this.name = otherName; } } err() { this.name = \"not ok\";Cannot assign to 'name' because it is a read-only property.2540Cannot assign to 'name' because it is a read-only property. }}const g = new Greeter();g.name = \"also not ok\";Cannot assign to 'name' because it is a read-only property.2540Cannot assign to 'name' because it is a read-only property.Try Constructors Background Reading: Constructor (MDN) Class constructors are very similar to functions. You can add parameters with type annotations, default values, and overloads: tsclass Point { x: number; y: number; // Normal signature with defaults constructor(x = 0, y = 0) { this.x = x; this.y = y; }}Try tsclass Point { x: number = 0; y: number = 0; // Constructor overloads constructor(x: number, y: number); constructor(xy: string); constructor(x: string  number, y: number = 0) { // Code logic here }}Try There are just a few differences between class constructor signatures and function signatures: Constructors cant have type parameters - these belong on the outer class declaration, which well learn about later Constructors cant have return type annotations - the class instance type is always whats returned Super Calls Just as in JavaScript, if you have a base class, youll need to call super(); in your constructor body before using any this. members: tsclass Base { k = 4;} class Derived extends Base { constructor() { // Prints a wrong value in ES5; throws exception in ES6 console.log(this.k);'super' must be called before accessing 'this' in the constructor of a derived class.17009'super' must be called before accessing 'this' in the constructor of a derived class. super(); }}Try Forgetting to call super is an easy mistake to make in JavaScript, but TypeScript will tell you when its necessary. Methods Background Reading: Method definitions A function property on a class is called a method. Methods can use all the same type annotations as functions and constructors: tsclass Point { x = 10; y = 10; scale(n: number): void { this.x *= n; this.y *= n; }}Try Other than the standard type annotations, TypeScript doesnt add anything else new to methods. Note that inside a method body, it is still mandatory to access fields and other methods via this.. An unqualified name in a method body will always refer to something in the enclosing scope: tslet x: number = 0; class C { x: string = \"hello\"; m() { // This is trying to modify 'x' from line 1, not the class property x = \"world\";Type 'string' is not assignable to type 'number'.2322Type 'string' is not assignable to type 'number'. }}Try Getters / Setters Classes can also have accessors: tsclass C { _length = 0; get length() { return this._length; } set length(value) { this._length = value; }}Try Note that a field-backed get/set pair with no extra logic is very rarely useful in JavaScript. Its fine to expose public fields if you dont need to add additional logic during the get/set operations. TypeScript has some special inference rules for accessors: If get exists but no set, the property is automatically readonly If the type of the setter parameter is not specified, it is inferred from the return type of the getter Since TypeScript 4.3, it is possible to have accessors with different types for getting and setting. tsclass Thing { _size = 0; get size(): number { return this._size; } set size(value: string  number  boolean) { let num = Number(value); // Don't allow NaN, Infinity, etc if (!Number.isFinite(num)) { this._size = 0; return; } this._size = num; }}Try Index Signatures Classes can declare index signatures; these work the same as Index Signatures for other object types: tsclass MyClass { [s: string]: boolean  ((s: string) = boolean); check(s: string) { return this[s] as boolean; }}Try Because the index signature type needs to also capture the types of methods, its not easy to usefully use these types. Generally its better to store indexed data in another place instead of on the class instance itself. Class Heritage Like other languages with object-oriented features, classes in JavaScript can inherit from base classes. implements Clauses You can use an implements clause to check that a class satisfies a particular interface. An error will be issued if a class fails to correctly implement it: tsinterface Pingable { ping(): void;} class Sonar implements Pingable { ping() { console.log(\"ping!\"); }} class Ball implements Pingable {Class 'Ball' incorrectly implements interface 'Pingable'. Property 'ping' is missing in type 'Ball' but required in type 'Pingable'.2420Class 'Ball' incorrectly implements interface 'Pingable'. Property 'ping' is missing in type 'Ball' but required in type 'Pingable'. pong() { console.log(\"pong!\"); }}Try Classes may also implement multiple interfaces, e.g. class C implements A, B {. Cautions Its important to understand that an implements clause is only a check that the class can be treated as the interface type. It doesnt change the type of the class or its methods at all. A common source of error is to assume that an implements clause will change the class type - it doesnt! tsinterface Checkable { check(name: string): boolean;} class NameChecker implements Checkable { check(s) {Parameter 's' implicitly has an 'any' type.7006Parameter 's' implicitly has an 'any' type. // Notice no error here return s.toLowerCase() === \"ok\"; any }}Try In this example, we perhaps expected that ss type would be influenced by the name: string parameter of check. It is not - implements clauses dont change how the class body is checked or its type inferred. Similarly, implementing an interface with an optional property doesnt create that property: tsinterface A { x: number; y?: number;}class C implements A { x = 0;}const c = new C();c.y = 10;Property 'y' does not exist on type 'C'.2339Property 'y' does not exist on type 'C'.Try extends Clauses Background Reading: extends keyword (MDN) Classes may extend from a base class. A derived class has all the properties and methods of its base class, and can also define additional members. tsclass Animal { move() { console.log(\"Moving along!\"); }} class Dog extends Animal { woof(times: number) { for (let i = 0; i  times; i++) { console.log(\"woof!\"); } }} const d = new Dog();// Base class methodd.move();// Derived class methodd.woof(3);Try Overriding Methods Background Reading: super keyword (MDN) A derived class can also override a base class field or property. You can use the super. syntax to access base class methods. Note that because JavaScript classes are a simple lookup object, there is no notion of a super field. TypeScript enforces that a derived class is always a subtype of its base class. For example, heres a legal way to override a method: tsclass Base { greet() { console.log(\"Hello, world!\"); }} class Derived extends Base { greet(name?: string) { if (name === undefined) { super.greet(); } else { console.log(Hello, ${name.toUpperCase()}); } }} const d = new Derived();d.greet();d.greet(\"reader\");Try Its important that a derived class follow its base class contract. Remember that its very common (and always legal!) to refer to a derived class instance through a base class reference: ts// Alias the derived instance through a base class referenceconst b: Base = d;// No problemb.greet();Try What if Derived didnt follow Bases contract? tsclass Base { greet() { console.log(\"Hello, world!\"); }} class Derived extends Base { // Make this parameter required greet(name: string) {Property 'greet' in type 'Derived' is not assignable to the same property in base type 'Base'. Type '(name: string) = void' is not assignable to type '() = void'. Target signature provides too few arguments. Expected 1 or more, but got 0.2416Property 'greet' in type 'Derived' is not assignable to the same property in base type 'Base'. Type '(name: string) = void' is not assignable to type '() = void'. Target signature provides too few arguments. Expected 1 or more, but got 0. console.log(Hello, ${name.toUpperCase()}); }}Try If we compiled this code despite the error, this sample would then crash: tsconst b: Base = new Derived();// Crashes because \"name\" will be undefinedb.greet();Try Type-only Field Declarations When target = ES2022 or useDefineForClassFields is true, class fields are initialized after the parent class constructor completes, overwriting any value set by the parent class. This can be a problem when you only want to re-declare a more accurate type for an inherited field. To handle these cases, you can write declare to indicate to TypeScript that there should be no runtime effect for this field declaration. tsinterface Animal { dateOfBirth: any;} interface Dog extends Animal { breed: any;} class AnimalHouse { resident: Animal; constructor(animal: Animal) { this.resident = animal; }} class DogHouse extends AnimalHouse { // Does not emit JavaScript code, // only ensures the types are correct declare resident: Dog; constructor(dog: Dog) { super(dog); }}Try Initialization Order The order that JavaScript classes initialize can be surprising in some cases. Lets consider this code: tsclass Base { name = \"base\"; constructor() { console.log(\"My name is \" + this.name); }} class Derived extends Base { name = \"derived\";} // Prints \"base\", not \"derived\"const d = new Derived();Try What happened here? The order of class initialization, as defined by JavaScript, is: The base class fields are initialized The base class constructor runs The derived class fields are initialized The derived class constructor runs This means that the base class constructor saw its own value for name during its own constructor, because the derived class field initializations hadnt run yet. Inheriting Built-in Types Note: If you dont plan to inherit from built-in types like Array, Error, Map, etc. or your compilation target is explicitly set to ES6/ES2015 or above, you may skip this section In ES2015, constructors which return an object implicitly substitute the value of this for any callers of super(...). It is necessary for generated constructor code to capture any potential return value of super(...) and replace it with this. As a result, subclassing Error, Array, and others may no longer work as expected. This is due to the fact that constructor functions for Error, Array, and the like use ECMAScript 6s new.target to adjust the prototype chain; however, there is no way to ensure a value for new.target when invoking a constructor in ECMAScript 5. Other downlevel compilers generally have the same limitation by default. For a subclass like the following: tsclass MsgError extends Error { constructor(m: string) { super(m); } sayHello() { return \"hello \" + this.message; }}Try you may find that: methods may be undefined on objects returned by constructing these subclasses, so calling sayHello will result in an error. instanceof will be broken between instances of the subclass and their instances, so (new MsgError()) instanceof MsgError will return false. As a recommendation, you can manually adjust the prototype immediately after any super(...) calls. tsclass MsgError extends Error { constructor(m: string) { super(m); // Set the prototype explicitly. Object.setPrototypeOf(this, MsgError.prototype); } sayHello() { return \"hello \" + this.message; }}Try However, any subclass of MsgError will have to manually set the prototype as well. For runtimes that dont support Object.setPrototypeOf, you may instead be able to use __proto__. Unfortunately, these workarounds will not work on Internet Explorer 10 and prior. One can manually copy methods from the prototype onto the instance itself (i.e. MsgError.prototype onto this), but the prototype chain itself cannot be fixed. Member Visibility You can use TypeScript to control whether certain methods or properties are visible to code outside the class. public The default visibility of class members is public. A public member can be accessed anywhere: tsclass Greeter { public greet() { console.log(\"hi!\"); }}const g = new Greeter();g.greet();Try Because public is already the default visibility modifier, you dont ever need to write it on a class member, but might choose to do so for style/readability reasons. protected protected members are only visible to subclasses of the class theyre declared in. tsclass Greeter { public greet() { console.log(\"Hello, \" + this.getName()); } protected getName() { return \"hi\"; }} class SpecialGreeter extends Greeter { public howdy() { // OK to access protected member here console.log(\"Howdy, \" + this.getName()); }}const g = new SpecialGreeter();g.greet(); // OKg.getName();Property 'getName' is protected and only accessible within class 'Greeter' and its subclasses.2445Property 'getName' is protected and only accessible within class 'Greeter' and its subclasses.Try Exposure of protected members Derived classes need to follow their base class contracts, but may choose to expose a subtype of base class with more capabilities. This includes making protected members public: tsclass Base { protected m = 10;}class Derived extends Base { // No modifier, so default is 'public' m = 15;}const d = new Derived();console.log(d.m); // OKTry Note that Derived was already able to freely read and write m, so this doesnt meaningfully alter the security of this situation. The main thing to note here is that in the derived class, we need to be careful to repeat the protected modifier if this exposure isnt intentional. Cross-hierarchy protected access TypeScript doesnt allow accessing protected members of a sibling class in a class hierarchy: tsclass Base { protected x: number = 1;}class Derived1 extends Base { protected x: number = 5;}class Derived2 extends Base { f1(other: Derived2) { other.x = 10; } f2(other: Derived1) { other.x = 10;Property 'x' is protected and only accessible within class 'Derived1' and its subclasses.2445Property 'x' is protected and only accessible within class 'Derived1' and its subclasses. }}Try This is because accessing x in Derived2 should only be legal from Derived2s subclasses, and Derived1 isnt one of them. Moreover, if accessing x through a Derived1 reference is illegal (which it certainly should be!), then accessing it through a base class reference should never improve the situation. See also Why Cant I Access A Protected Member From A Derived Class? which explains more of C#s reasoning on the same topic. private private is like protected, but doesnt allow access to the member even from subclasses: tsclass Base { private x = 0;}const b = new Base();// Can't access from outside the classconsole.log(b.x);Property 'x' is private and only accessible within class 'Base'.2341Property 'x' is private and only accessible within class 'Base'.Try tsclass Derived extends Base { showX() { // Can't access in subclasses console.log(this.x);Property 'x' is private and only accessible within class 'Base'.2341Property 'x' is private and only accessible within class 'Base'. }}Try Because private members arent visible to derived classes, a derived class cant increase their visibility: tsclass Base { private x = 0;}class Derived extends Base {Class 'Derived' incorrectly extends base class 'Base'. Property 'x' is private in type 'Base' but not in type 'Derived'.2415Class 'Derived' incorrectly extends base class 'Base'. Property 'x' is private in type 'Base' but not in type 'Derived'. x = 1;}Try Cross-instance private access Different OOP languages disagree about whether different instances of the same class may access each others private members. While languages like Java, C#, C++, Swift, and PHP allow this, Ruby does not. TypeScript does allow cross-instance private access: tsclass A { private x = 10; public sameAs(other: A) { // No error return other.x === this.x; }}Try Caveats Like other aspects of TypeScripts type system, private and protected are only enforced during type checking. This means that JavaScript runtime constructs like in or simple property lookup can still access a private or protected member: tsclass MySafe { private secretKey = 12345;}Try js// In a JavaScript file...const s = new MySafe();// Will print 12345console.log(s.secretKey); private also allows access using bracket notation during type checking. This makes private-declared fields potentially easier to access for things like unit tests, with the drawback that these fields are soft private and dont strictly enforce privacy. tsclass MySafe { private secretKey = 12345;} const s = new MySafe(); // Not allowed during type checkingconsole.log(s.secretKey);Property 'secretKey' is private and only accessible within class 'MySafe'.2341Property 'secretKey' is private and only accessible within class 'MySafe'. // OKconsole.log(s[\"secretKey\"]);Try Unlike TypeScriptss private, JavaScripts private fields (#) remain private after compilation and do not provide the previously mentioned escape hatches like bracket notation access, making them hard private. tsclass Dog { #barkAmount = 0; personality = \"happy\"; constructor() {}}Try ts\"use strict\";class Dog { #barkAmount = 0; personality = \"happy\"; constructor() { }} Try When compiling to ES2021 or less, TypeScript will use WeakMaps in place of #. ts\"use strict\";var _Dog_barkAmount;class Dog { constructor() { _Dog_barkAmount.set(this, 0); this.personality = \"happy\"; }}_Dog_barkAmount = new WeakMap(); Try If you need to protect values in your class from malicious actors, you should use mechanisms that offer hard runtime privacy, such as closures, WeakMaps, or private fields. Note that these added privacy checks during runtime could affect performance. Static Members Background Reading: Static Members (MDN) Classes may have static members. These members arent associated with a particular instance of the class. They can be accessed through the class constructor object itself: tsclass MyClass { static x = 0; static printX() { console.log(MyClass.x); }}console.log(MyClass.x);MyClass.printX();Try Static members can also use the same public, protected, and private visibility modifiers: tsclass MyClass { private static x = 0;}console.log(MyClass.x);Property 'x' is private and only accessible within class 'MyClass'.2341Property 'x' is private and only accessible within class 'MyClass'.Try Static members are also inherited: tsclass Base { static getGreeting() { return \"Hello world\"; }}class Derived extends Base { myGreeting = Derived.getGreeting();}Try Special Static Names Its generally not safe/possible to overwrite properties from the Function prototype. Because classes are themselves functions that can be invoked with new, certain static names cant be used. Function properties like name, length, and call arent valid to define as static members: tsclass S { static name = \"S!\";Static property 'name' conflicts with built-in property 'Function.name' of constructor function 'S'.2699Static property 'name' conflicts with built-in property 'Function.name' of constructor function 'S'.}Try Why No Static Classes? TypeScript (and JavaScript) dont have a construct called static class the same way as, for example, C# does. Those constructs only exist because those languages force all data and functions to be inside a class; because that restriction doesnt exist in TypeScript, theres no need for them. A class with only a single instance is typically just represented as a normal object in JavaScript/TypeScript. For example, we dont need a static class syntax in TypeScript because a regular object (or even top-level function) will do the job just as well: ts// Unnecessary \"static\" classclass MyStaticClass { static doSomething() {}} // Preferred (alternative 1)function doSomething() {} // Preferred (alternative 2)const MyHelperObject = { dosomething() {},};Try static Blocks in Classes Static blocks allow you to write a sequence of statements with their own scope that can access private fields within the containing class. This means that we can write initialization code with all the capabilities of writing statements, no leakage of variables, and full access to our classs internals. tsclass Foo { static #count = 0; get count() { return Foo.#count; } static { try { const lastInstances = loadLastInstances(); Foo.#count += lastInstances.length; } catch {} }}Try Generic Classes Classes, much like interfaces, can be generic. When a generic class is instantiated with new, its type parameters are inferred the same way as in a function call: tsclass BoxType { contents: Type; constructor(value: Type) { this.contents = value; }} const b = new Box(\"hello!\"); const b: BoxstringTry Classes can use generic constraints and defaults the same way as interfaces. Type Parameters in Static Members This code isnt legal, and it may not be obvious why: tsclass BoxType { static defaultValue: Type;Static members cannot reference class type parameters.2302Static members cannot reference class type parameters.}Try Remember that types are always fully erased! At runtime, theres only one Box.defaultValue property slot. This means that setting Boxstring.defaultValue (if that were possible) would also change Boxnumber.defaultValue - not good. The static members of a generic class can never refer to the classs type parameters. this at Runtime in Classes Background Reading: this keyword (MDN) Its important to remember that TypeScript doesnt change the runtime behavior of JavaScript, and that JavaScript is somewhat famous for having some peculiar runtime behaviors. JavaScripts handling of this is indeed unusual: tsclass MyClass { name = \"MyClass\"; getName() { return this.name; }}const c = new MyClass();const obj = { name: \"obj\", getName: c.getName,}; // Prints \"obj\", not \"MyClass\"console.log(obj.getName());Try Long story short, by default, the value of this inside a function depends on how the function was called. In this example, because the function was called through the obj reference, its value of this was obj rather than the class instance. This is rarely what you want to happen! TypeScript provides some ways to mitigate or prevent this kind of error. Arrow Functions Background Reading: Arrow functions (MDN) If you have a function that will often be called in a way that loses its this context, it can make sense to use an arrow function property instead of a method definition: tsclass MyClass { name = \"MyClass\"; getName = () = { return this.name; };}const c = new MyClass();const g = c.getName;// Prints \"MyClass\" instead of crashingconsole.log(g());Try This has some trade-offs: The this value is guaranteed to be correct at runtime, even for code not checked with TypeScript This will use more memory, because each class instance will have its own copy of each function defined this way You cant use super.getName in a derived class, because theres no entry in the prototype chain to fetch the base class method from this parameters In a method or function definition, an initial parameter named this has special meaning in TypeScript. These parameters are erased during compilation: ts// TypeScript input with 'this' parameterfunction fn(this: SomeType, x: number) { /* ... */}Try js// JavaScript outputfunction fn(x) { /* ... */} TypeScript checks that calling a function with a this parameter is done so with a correct context. Instead of using an arrow function, we can add a this parameter to method definitions to statically enforce that the method is called correctly: tsclass MyClass { name = \"MyClass\"; getName(this: MyClass) { return this.name; }}const c = new MyClass();// OKc.getName(); // Error, would crashconst g = c.getName;console.log(g());The 'this' context of type 'void' is not assignable to method's 'this' of type 'MyClass'.2684The 'this' context of type 'void' is not assignable to method's 'this' of type 'MyClass'.Try This method makes the opposite trade-offs of the arrow function approach: JavaScript callers might still use the class method incorrectly without realizing it Only one function per class definition gets allocated, rather than one per class instance Base method definitions can still be called via super. this Types In classes, a special type called this refers dynamically to the type of the current class. Lets see how this is useful: tsclass Box { contents: string = \"\"; set(value: string) { (method) Box.set(value: string): this this.contents = value; return this; }}Try Here, TypeScript inferred the return type of set to be this, rather than Box. Now lets make a subclass of Box: tsclass ClearableBox extends Box { clear() { this.contents = \"\"; }} const a = new ClearableBox();const b = a.set(\"hello\"); const b: ClearableBoxTry You can also use this in a parameter type annotation: tsclass Box { content: string = \"\"; sameAs(other: this) { return other.content === this.content; }}Try This is different from writing other: Box  if you have a derived class, its sameAs method will now only accept other instances of that same derived class: tsclass Box { content: string = \"\"; sameAs(other: this) { return other.content === this.content; }} class DerivedBox extends Box { otherContent: string = \"?\";} const base = new Box();const derived = new DerivedBox();derived.sameAs(base);Argument of type 'Box' is not assignable to parameter of type 'DerivedBox'. Property 'otherContent' is missing in type 'Box' but required in type 'DerivedBox'.2345Argument of type 'Box' is not assignable to parameter of type 'DerivedBox'. Property 'otherContent' is missing in type 'Box' but required in type 'DerivedBox'.Try this-based type guards You can use this is Type in the return position for methods in classes and interfaces. When mixed with a type narrowing (e.g. if statements) the type of the target object would be narrowed to the specified Type. tsclass FileSystemObject { isFile(): this is FileRep { return this instanceof FileRep; } isDirectory(): this is Directory { return this instanceof Directory; } isNetworked(): this is Networked & this { return this.networked; } constructor(public path: string, private networked: boolean) {}} class FileRep extends FileSystemObject { constructor(path: string, public content: string) { super(path, false); }} class Directory extends FileSystemObject { children: FileSystemObject[];} interface Networked { host: string;} const fso: FileSystemObject = new FileRep(\"foo/bar.txt\", \"foo\"); if (fso.isFile()) { fso.content; const fso: FileRep} else if (fso.isDirectory()) { fso.children; const fso: Directory} else if (fso.isNetworked()) { fso.host; const fso: Networked & FileSystemObject}Try A common use-case for a this-based type guard is to allow for lazy validation of a particular field. For example, this case removes an undefined from the value held inside box when hasValue has been verified to be true: tsclass BoxT { value?: T; hasValue(): this is { value: T } { return this.value !== undefined; }} const box = new Boxstring();box.value = \"Gameboy\"; box.value; (property) Boxstring.value?: string if (box.hasValue()) { box.value; (property) value: string}Try Parameter Properties TypeScript offers special syntax for turning a constructor parameter into a class property with the same name and value. These are called parameter properties and are created by prefixing a constructor argument with one of the visibility modifiers public, private, protected, or readonly. The resulting field gets those modifier(s): tsclass Params { constructor( public readonly x: number, protected y: number, private z: number ) { // No body necessary }}const a = new Params(1, 2, 3);console.log(a.x); (property) Params.x: numberconsole.log(a.z);Property 'z' is private and only accessible within class 'Params'.2341Property 'z' is private and only accessible within class 'Params'.Try Class Expressions Background Reading: Class expressions (MDN) Class expressions are very similar to class declarations. The only real difference is that class expressions dont need a name, though we can refer to them via whatever identifier they ended up bound to: tsconst someClass = classType { content: Type; constructor(value: Type) { this.content = value; }}; const m = new someClass(\"Hello, world\"); const m: someClassstringTry Constructor Signatures JavaScript classes are instantiated with the new operator. Given the type of a class itself, the InstanceType utility type models this operation. tsclass Point { createdAt: number; x: number; y: number constructor(x: number, y: number) { this.createdAt = Date.now() this.x = x; this.y = y; }}type PointInstance = InstanceTypetypeof Point function moveRight(point: PointInstance) { point.x += 5;} const point = new Point(3, 4);moveRight(point);point.x; // = 8Try abstract Classes and Members Classes, methods, and fields in TypeScript may be abstract. An abstract method or abstract field is one that hasnt had an implementation provided. These members must exist inside an abstract class, which cannot be directly instantiated. The role of abstract classes is to serve as a base class for subclasses which do implement all the abstract members. When a class doesnt have any abstract members, it is said to be concrete. Lets look at an example: tsabstract class Base { abstract getName(): string; printName() { console.log(\"Hello, \" + this.getName()); }} const b = new Base();Cannot create an instance of an abstract class.2511Cannot create an instance of an abstract class.Try We cant instantiate Base with new because its abstract. Instead, we need to make a derived class and implement the abstract members: tsclass Derived extends Base { getName() { return \"world\"; }} const d = new Derived();d.printName();Try Notice that if we forget to implement the base classs abstract members, well get an error: tsclass Derived extends Base {Non-abstract class 'Derived' does not implement inherited abstract member getName from class 'Base'.2515Non-abstract class 'Derived' does not implement inherited abstract member getName from class 'Base'. // forgot to do anything}Try Abstract Construct Signatures Sometimes you want to accept some class constructor function that produces an instance of a class which derives from some abstract class. For example, you might want to write this code: tsfunction greet(ctor: typeof Base) { const instance = new ctor();Cannot create an instance of an abstract class.2511Cannot create an instance of an abstract class. instance.printName();}Try TypeScript is correctly telling you that youre trying to instantiate an abstract class. After all, given the definition of greet, its perfectly legal to write this code, which would end up constructing an abstract class: ts// Bad!greet(Base);Try Instead, you want to write a function that accepts something with a construct signature: tsfunction greet(ctor: new () = Base) { const instance = new ctor(); instance.printName();}greet(Derived);greet(Base);Argument of type 'typeof Base' is not assignable to parameter of type 'new () = Base'. Cannot assign an abstract constructor type to a non-abstract constructor type.2345Argument of type 'typeof Base' is not assignable to parameter of type 'new () = Base'. Cannot assign an abstract constructor type to a non-abstract constructor type.Try Now TypeScript correctly tells you about which class constructor functions can be invoked - Derived can because its concrete, but Base cannot. Relationships Between Classes In most cases, classes in TypeScript are compared structurally, the same as other types. For example, these two classes can be used in place of each other because theyre identical: tsclass Point1 { x = 0; y = 0;} class Point2 { x = 0; y = 0;} // OKconst p: Point1 = new Point2();Try Similarly, subtype relationships between classes exist even if theres no explicit inheritance: tsclass Person { name: string; age: number;} class Employee { name: string; age: number; salary: number;} // OKconst p: Person = new Employee();Try This sounds straightforward, but there are a few cases that seem stranger than others. Empty classes have no members. In a structural type system, a type with no members is generally a supertype of anything else. So if you write an empty class (dont!), anything can be used in place of it: tsclass Empty {} function fn(x: Empty) { // can't do anything with 'x', so I won't} // All OK!fn(window);fn({});fn(fn);Try",
    "headings": [
      {
        "level": 2,
        "text": "Class Members",
        "id": "class-members"
      },
      {
        "level": 2,
        "text": "Class Heritage",
        "id": "class-heritage"
      },
      {
        "level": 2,
        "text": "Member Visibility",
        "id": "member-visibility"
      },
      {
        "level": 2,
        "text": "Static Members",
        "id": "static-members"
      },
      {
        "level": 2,
        "text": "static Blocks in Classes",
        "id": "static-blocks-in-classes"
      },
      {
        "level": 2,
        "text": "Generic Classes",
        "id": "generic-classes"
      },
      {
        "level": 2,
        "text": "this at Runtime in Classes",
        "id": "this-at-runtime-in-classes"
      },
      {
        "level": 2,
        "text": "this Types",
        "id": "this-types"
      },
      {
        "level": 2,
        "text": "Parameter Properties",
        "id": "parameter-properties"
      },
      {
        "level": 2,
        "text": "Class Expressions",
        "id": "class-expressions"
      },
      {
        "level": 2,
        "text": "Constructor Signatures",
        "id": "constructor-signatures"
      },
      {
        "level": 2,
        "text": "abstract Classes and Members",
        "id": "abstract-classes-and-members"
      },
      {
        "level": 2,
        "text": "Relationships Between Classes",
        "id": "relationships-between-classes"
      },
      {
        "level": 3,
        "text": "Fields",
        "id": "fields"
      },
      {
        "level": 3,
        "text": "readonly",
        "id": "readonly"
      },
      {
        "level": 3,
        "text": "Constructors",
        "id": "constructors"
      },
      {
        "level": 3,
        "text": "Methods",
        "id": "methods"
      },
      {
        "level": 3,
        "text": "Getters / Setters",
        "id": "getters--setters"
      },
      {
        "level": 3,
        "text": "Index Signatures",
        "id": "index-signatures"
      },
      {
        "level": 3,
        "text": "implements Clauses",
        "id": "implements-clauses"
      },
      {
        "level": 3,
        "text": "extends Clauses",
        "id": "extends-clauses"
      },
      {
        "level": 3,
        "text": "public",
        "id": "public"
      },
      {
        "level": 3,
        "text": "protected",
        "id": "protected"
      },
      {
        "level": 3,
        "text": "private",
        "id": "private"
      },
      {
        "level": 3,
        "text": "Special Static Names",
        "id": "special-static-names"
      },
      {
        "level": 3,
        "text": "Why No Static Classes?",
        "id": "why-no-static-classes"
      },
      {
        "level": 3,
        "text": "Type Parameters in Static Members",
        "id": "type-parameters-in-static-members"
      },
      {
        "level": 3,
        "text": "Arrow Functions",
        "id": "arrow-functions"
      },
      {
        "level": 3,
        "text": "this parameters",
        "id": "this-parameters"
      },
      {
        "level": 3,
        "text": "this-based type guards",
        "id": "this-based-type-guards"
      },
      {
        "level": 3,
        "text": "Abstract Construct Signatures",
        "id": "abstract-construct-signatures"
      },
      {
        "level": 4,
        "text": "--strictPropertyInitialization",
        "id": "--strictpropertyinitialization"
      },
      {
        "level": 4,
        "text": "Super Calls",
        "id": "super-calls"
      },
      {
        "level": 4,
        "text": "Cautions",
        "id": "cautions"
      },
      {
        "level": 4,
        "text": "Overriding Methods",
        "id": "overriding-methods"
      },
      {
        "level": 4,
        "text": "Type-only Field Declarations",
        "id": "type-only-field-declarations"
      },
      {
        "level": 4,
        "text": "Initialization Order",
        "id": "initialization-order"
      },
      {
        "level": 4,
        "text": "Inheriting Built-in Types",
        "id": "inheriting-built-in-types"
      },
      {
        "level": 4,
        "text": "Exposure of protected members",
        "id": "exposure-of-protected-members"
      },
      {
        "level": 4,
        "text": "Cross-hierarchy protected access",
        "id": "cross-hierarchy-protected-access"
      },
      {
        "level": 4,
        "text": "Cross-instance private access",
        "id": "cross-instance-private-access"
      },
      {
        "level": 4,
        "text": "Caveats",
        "id": "caveats"
      }
    ],
    "codeBlocks": [
      {
        "language": "text",
        "code": "tsclass Point {}Try"
      },
      {
        "language": "text",
        "code": "class Point {}"
      },
      {
        "language": "text",
        "code": "tsclass Point {  x: number;  y: number;} const pt = new Point();pt.x = 0;pt.y = 0;Try"
      },
      {
        "language": "text",
        "code": "class Point {  x: number;  y: number;} const pt = new Point();pt.x = 0;pt.y = 0;"
      },
      {
        "language": "text",
        "code": "tsclass Point {  x = 0;  y = 0;} const pt = new Point();// Prints 0, 0console.log(`${pt.x}, ${pt.y}`);Try"
      },
      {
        "language": "text",
        "code": "class Point {  x = 0;  y = 0;} const pt = new Point();// Prints 0, 0console.log(`${pt.x}, ${pt.y}`);"
      },
      {
        "language": "text",
        "code": "tsconst pt = new Point();pt.x = \"0\";Type 'string' is not assignable to type 'number'.2322Type 'string' is not assignable to type 'number'.Try"
      },
      {
        "language": "text",
        "code": "const pt = new Point();pt.x = \"0\";Type 'string' is not assignable to type 'number'.2322Type 'string' is not assignable to type 'number'."
      },
      {
        "language": "text",
        "code": "--strictPropertyInitialization"
      },
      {
        "language": "text",
        "code": "strictPropertyInitialization"
      },
      {
        "language": "text",
        "code": "tsclass BadGreeter {  name: string;Property 'name' has no initializer and is not definitely assigned in the constructor.2564Property 'name' has no initializer and is not definitely assigned in the constructor.}Try"
      },
      {
        "language": "text",
        "code": "class BadGreeter {  name: string;Property 'name' has no initializer and is not definitely assigned in the constructor.2564Property 'name' has no initializer and is not definitely assigned in the constructor.}"
      },
      {
        "language": "text",
        "code": "tsclass GoodGreeter {  name: string;   constructor() {    this.name = \"hello\";  }}Try"
      },
      {
        "language": "text",
        "code": "class GoodGreeter {  name: string;   constructor() {    this.name = \"hello\";  }}"
      },
      {
        "language": "text",
        "code": "tsclass OKGreeter {  // Not initialized, but no error  name!: string;}Try"
      },
      {
        "language": "text",
        "code": "class OKGreeter {  // Not initialized, but no error  name!: string;}"
      },
      {
        "language": "text",
        "code": "tsclass Greeter {  readonly name: string = \"world\";   constructor(otherName?: string) {    if (otherName !== undefined) {      this.name = otherName;    }  }   err() {    this.name = \"not ok\";Cannot assign to 'name' because it is a read-only property.2540Cannot assign to 'name' because it is a read-only property.  }}const g = new Greeter();g.name = \"also not ok\";Cannot assign to 'name' because it is a read-only property.2540Cannot assign to 'name' because it is a read-only property.Try"
      },
      {
        "language": "text",
        "code": "class Greeter {  readonly name: string = \"world\";   constructor(otherName?: string) {    if (otherName !== undefined) {      this.name = otherName;    }  }   err() {    this.name = \"not ok\";Cannot assign to 'name' because it is a read-only property.2540Cannot assign to 'name' because it is a read-only property.  }}const g = new Greeter();g.name = \"also not ok\";Cannot assign to 'name' because it is a read-only property.2540Cannot assign to 'name' because it is a read-only property."
      },
      {
        "language": "text",
        "code": "tsclass Point {  x: number;  y: number;   // Normal signature with defaults  constructor(x = 0, y = 0) {    this.x = x;    this.y = y;  }}Try"
      },
      {
        "language": "text",
        "code": "class Point {  x: number;  y: number;   // Normal signature with defaults  constructor(x = 0, y = 0) {    this.x = x;    this.y = y;  }}"
      },
      {
        "language": "text",
        "code": "tsclass Point {  x: number = 0;  y: number = 0;   // Constructor overloads  constructor(x: number, y: number);  constructor(xy: string);  constructor(x: string | number, y: number = 0) {    // Code logic here  }}Try"
      },
      {
        "language": "text",
        "code": "class Point {  x: number = 0;  y: number = 0;   // Constructor overloads  constructor(x: number, y: number);  constructor(xy: string);  constructor(x: string | number, y: number = 0) {    // Code logic here  }}"
      },
      {
        "language": "text",
        "code": "tsclass Base {  k = 4;} class Derived extends Base {  constructor() {    // Prints a wrong value in ES5; throws exception in ES6    console.log(this.k);'super' must be called before accessing 'this' in the constructor of a derived class.17009'super' must be called before accessing 'this' in the constructor of a derived class.    super();  }}Try"
      },
      {
        "language": "text",
        "code": "class Base {  k = 4;} class Derived extends Base {  constructor() {    // Prints a wrong value in ES5; throws exception in ES6    console.log(this.k);'super' must be called before accessing 'this' in the constructor of a derived class.17009'super' must be called before accessing 'this' in the constructor of a derived class.    super();  }}"
      },
      {
        "language": "text",
        "code": "tsclass Point {  x = 10;  y = 10;   scale(n: number): void {    this.x *= n;    this.y *= n;  }}Try"
      },
      {
        "language": "text",
        "code": "class Point {  x = 10;  y = 10;   scale(n: number): void {    this.x *= n;    this.y *= n;  }}"
      },
      {
        "language": "text",
        "code": "tslet x: number = 0; class C {  x: string = \"hello\";   m() {    // This is trying to modify 'x' from line 1, not the class property    x = \"world\";Type 'string' is not assignable to type 'number'.2322Type 'string' is not assignable to type 'number'.  }}Try"
      },
      {
        "language": "text",
        "code": "let x: number = 0; class C {  x: string = \"hello\";   m() {    // This is trying to modify 'x' from line 1, not the class property    x = \"world\";Type 'string' is not assignable to type 'number'.2322Type 'string' is not assignable to type 'number'.  }}"
      },
      {
        "language": "text",
        "code": "tsclass C {  _length = 0;  get length() {    return this._length;  }  set length(value) {    this._length = value;  }}Try"
      },
      {
        "language": "text",
        "code": "class C {  _length = 0;  get length() {    return this._length;  }  set length(value) {    this._length = value;  }}"
      },
      {
        "language": "text",
        "code": "tsclass Thing {  _size = 0;   get size(): number {    return this._size;  }   set size(value: string | number | boolean) {    let num = Number(value);     // Don't allow NaN, Infinity, etc     if (!Number.isFinite(num)) {      this._size = 0;      return;    }     this._size = num;  }}Try"
      },
      {
        "language": "text",
        "code": "class Thing {  _size = 0;   get size(): number {    return this._size;  }   set size(value: string | number | boolean) {    let num = Number(value);     // Don't allow NaN, Infinity, etc     if (!Number.isFinite(num)) {      this._size = 0;      return;    }     this._size = num;  }}"
      },
      {
        "language": "text",
        "code": "tsclass MyClass {  [s: string]: boolean | ((s: string) => boolean);   check(s: string) {    return this[s] as boolean;  }}Try"
      },
      {
        "language": "text",
        "code": "class MyClass {  [s: string]: boolean | ((s: string) => boolean);   check(s: string) {    return this[s] as boolean;  }}"
      },
      {
        "language": "text",
        "code": "tsinterface Pingable {  ping(): void;} class Sonar implements Pingable {  ping() {    console.log(\"ping!\");  }} class Ball implements Pingable {Class 'Ball' incorrectly implements interface 'Pingable'.\n  Property 'ping' is missing in type 'Ball' but required in type 'Pingable'.2420Class 'Ball' incorrectly implements interface 'Pingable'.\n  Property 'ping' is missing in type 'Ball' but required in type 'Pingable'.  pong() {    console.log(\"pong!\");  }}Try"
      },
      {
        "language": "text",
        "code": "interface Pingable {  ping(): void;} class Sonar implements Pingable {  ping() {    console.log(\"ping!\");  }} class Ball implements Pingable {Class 'Ball' incorrectly implements interface 'Pingable'.\n  Property 'ping' is missing in type 'Ball' but required in type 'Pingable'.2420Class 'Ball' incorrectly implements interface 'Pingable'.\n  Property 'ping' is missing in type 'Ball' but required in type 'Pingable'.  pong() {    console.log(\"pong!\");  }}"
      },
      {
        "language": "text",
        "code": "class C implements A, B {"
      },
      {
        "language": "text",
        "code": "tsinterface Checkable {  check(name: string): boolean;} class NameChecker implements Checkable {  check(s) {Parameter 's' implicitly has an 'any' type.7006Parameter 's' implicitly has an 'any' type.    // Notice no error here    return s.toLowerCase() === \"ok\";                 any  }}Try"
      },
      {
        "language": "text",
        "code": "interface Checkable {  check(name: string): boolean;} class NameChecker implements Checkable {  check(s) {Parameter 's' implicitly has an 'any' type.7006Parameter 's' implicitly has an 'any' type.    // Notice no error here    return s.toLowerCase() === \"ok\";                 any  }}"
      },
      {
        "language": "text",
        "code": "name: string"
      },
      {
        "language": "text",
        "code": "tsinterface A {  x: number;  y?: number;}class C implements A {  x = 0;}const c = new C();c.y = 10;Property 'y' does not exist on type 'C'.2339Property 'y' does not exist on type 'C'.Try"
      },
      {
        "language": "text",
        "code": "interface A {  x: number;  y?: number;}class C implements A {  x = 0;}const c = new C();c.y = 10;Property 'y' does not exist on type 'C'.2339Property 'y' does not exist on type 'C'."
      },
      {
        "language": "text",
        "code": "tsclass Animal {  move() {    console.log(\"Moving along!\");  }} class Dog extends Animal {  woof(times: number) {    for (let i = 0; i < times; i++) {      console.log(\"woof!\");    }  }} const d = new Dog();// Base class methodd.move();// Derived class methodd.woof(3);Try"
      },
      {
        "language": "text",
        "code": "class Animal {  move() {    console.log(\"Moving along!\");  }} class Dog extends Animal {  woof(times: number) {    for (let i = 0; i < times; i++) {      console.log(\"woof!\");    }  }} const d = new Dog();// Base class methodd.move();// Derived class methodd.woof(3);"
      },
      {
        "language": "text",
        "code": "tsclass Base {  greet() {    console.log(\"Hello, world!\");  }} class Derived extends Base {  greet(name?: string) {    if (name === undefined) {      super.greet();    } else {      console.log(`Hello, ${name.toUpperCase()}`);    }  }} const d = new Derived();d.greet();d.greet(\"reader\");Try"
      },
      {
        "language": "text",
        "code": "class Base {  greet() {    console.log(\"Hello, world!\");  }} class Derived extends Base {  greet(name?: string) {    if (name === undefined) {      super.greet();    } else {      console.log(`Hello, ${name.toUpperCase()}`);    }  }} const d = new Derived();d.greet();d.greet(\"reader\");"
      },
      {
        "language": "text",
        "code": "ts// Alias the derived instance through a base class referenceconst b: Base = d;// No problemb.greet();Try"
      },
      {
        "language": "text",
        "code": "// Alias the derived instance through a base class referenceconst b: Base = d;// No problemb.greet();"
      },
      {
        "language": "text",
        "code": "tsclass Base {  greet() {    console.log(\"Hello, world!\");  }} class Derived extends Base {  // Make this parameter required  greet(name: string) {Property 'greet' in type 'Derived' is not assignable to the same property in base type 'Base'.\n  Type '(name: string) => void' is not assignable to type '() => void'.\n    Target signature provides too few arguments. Expected 1 or more, but got 0.2416Property 'greet' in type 'Derived' is not assignable to the same property in base type 'Base'.\n  Type '(name: string) => void' is not assignable to type '() => void'.\n    Target signature provides too few arguments. Expected 1 or more, but got 0.    console.log(`Hello, ${name.toUpperCase()}`);  }}Try"
      },
      {
        "language": "text",
        "code": "class Base {  greet() {    console.log(\"Hello, world!\");  }} class Derived extends Base {  // Make this parameter required  greet(name: string) {Property 'greet' in type 'Derived' is not assignable to the same property in base type 'Base'.\n  Type '(name: string) => void' is not assignable to type '() => void'.\n    Target signature provides too few arguments. Expected 1 or more, but got 0.2416Property 'greet' in type 'Derived' is not assignable to the same property in base type 'Base'.\n  Type '(name: string) => void' is not assignable to type '() => void'.\n    Target signature provides too few arguments. Expected 1 or more, but got 0.    console.log(`Hello, ${name.toUpperCase()}`);  }}"
      },
      {
        "language": "text",
        "code": "tsconst b: Base = new Derived();// Crashes because \"name\" will be undefinedb.greet();Try"
      },
      {
        "language": "text",
        "code": "const b: Base = new Derived();// Crashes because \"name\" will be undefinedb.greet();"
      },
      {
        "language": "text",
        "code": "target >= ES2022"
      },
      {
        "language": "text",
        "code": "useDefineForClassFields"
      },
      {
        "language": "text",
        "code": "tsinterface Animal {  dateOfBirth: any;} interface Dog extends Animal {  breed: any;} class AnimalHouse {  resident: Animal;  constructor(animal: Animal) {    this.resident = animal;  }} class DogHouse extends AnimalHouse {  // Does not emit JavaScript code,  // only ensures the types are correct  declare resident: Dog;  constructor(dog: Dog) {    super(dog);  }}Try"
      },
      {
        "language": "text",
        "code": "interface Animal {  dateOfBirth: any;} interface Dog extends Animal {  breed: any;} class AnimalHouse {  resident: Animal;  constructor(animal: Animal) {    this.resident = animal;  }} class DogHouse extends AnimalHouse {  // Does not emit JavaScript code,  // only ensures the types are correct  declare resident: Dog;  constructor(dog: Dog) {    super(dog);  }}"
      },
      {
        "language": "text",
        "code": "tsclass Base {  name = \"base\";  constructor() {    console.log(\"My name is \" + this.name);  }} class Derived extends Base {  name = \"derived\";} // Prints \"base\", not \"derived\"const d = new Derived();Try"
      },
      {
        "language": "text",
        "code": "class Base {  name = \"base\";  constructor() {    console.log(\"My name is \" + this.name);  }} class Derived extends Base {  name = \"derived\";} // Prints \"base\", not \"derived\"const d = new Derived();"
      },
      {
        "language": "text",
        "code": "tsclass MsgError extends Error {  constructor(m: string) {    super(m);  }  sayHello() {    return \"hello \" + this.message;  }}Try"
      },
      {
        "language": "text",
        "code": "class MsgError extends Error {  constructor(m: string) {    super(m);  }  sayHello() {    return \"hello \" + this.message;  }}"
      },
      {
        "language": "text",
        "code": "(new MsgError()) instanceof MsgError"
      },
      {
        "language": "text",
        "code": "tsclass MsgError extends Error {  constructor(m: string) {    super(m);     // Set the prototype explicitly.    Object.setPrototypeOf(this, MsgError.prototype);  }   sayHello() {    return \"hello \" + this.message;  }}Try"
      },
      {
        "language": "text",
        "code": "class MsgError extends Error {  constructor(m: string) {    super(m);     // Set the prototype explicitly.    Object.setPrototypeOf(this, MsgError.prototype);  }   sayHello() {    return \"hello \" + this.message;  }}"
      },
      {
        "language": "text",
        "code": "Object.setPrototypeOf"
      },
      {
        "language": "text",
        "code": "MsgError.prototype"
      },
      {
        "language": "text",
        "code": "tsclass Greeter {  public greet() {    console.log(\"hi!\");  }}const g = new Greeter();g.greet();Try"
      },
      {
        "language": "text",
        "code": "class Greeter {  public greet() {    console.log(\"hi!\");  }}const g = new Greeter();g.greet();"
      },
      {
        "language": "text",
        "code": "tsclass Greeter {  public greet() {    console.log(\"Hello, \" + this.getName());  }  protected getName() {    return \"hi\";  }} class SpecialGreeter extends Greeter {  public howdy() {    // OK to access protected member here    console.log(\"Howdy, \" + this.getName());  }}const g = new SpecialGreeter();g.greet(); // OKg.getName();Property 'getName' is protected and only accessible within class 'Greeter' and its subclasses.2445Property 'getName' is protected and only accessible within class 'Greeter' and its subclasses.Try"
      },
      {
        "language": "text",
        "code": "class Greeter {  public greet() {    console.log(\"Hello, \" + this.getName());  }  protected getName() {    return \"hi\";  }} class SpecialGreeter extends Greeter {  public howdy() {    // OK to access protected member here    console.log(\"Howdy, \" + this.getName());  }}const g = new SpecialGreeter();g.greet(); // OKg.getName();Property 'getName' is protected and only accessible within class 'Greeter' and its subclasses.2445Property 'getName' is protected and only accessible within class 'Greeter' and its subclasses."
      },
      {
        "language": "text",
        "code": "tsclass Base {  protected m = 10;}class Derived extends Base {  // No modifier, so default is 'public'  m = 15;}const d = new Derived();console.log(d.m); // OKTry"
      },
      {
        "language": "text",
        "code": "class Base {  protected m = 10;}class Derived extends Base {  // No modifier, so default is 'public'  m = 15;}const d = new Derived();console.log(d.m); // OK"
      },
      {
        "language": "text",
        "code": "tsclass Base {  protected x: number = 1;}class Derived1 extends Base {  protected x: number = 5;}class Derived2 extends Base {  f1(other: Derived2) {    other.x = 10;  }  f2(other: Derived1) {    other.x = 10;Property 'x' is protected and only accessible within class 'Derived1' and its subclasses.2445Property 'x' is protected and only accessible within class 'Derived1' and its subclasses.  }}Try"
      },
      {
        "language": "text",
        "code": "class Base {  protected x: number = 1;}class Derived1 extends Base {  protected x: number = 5;}class Derived2 extends Base {  f1(other: Derived2) {    other.x = 10;  }  f2(other: Derived1) {    other.x = 10;Property 'x' is protected and only accessible within class 'Derived1' and its subclasses.2445Property 'x' is protected and only accessible within class 'Derived1' and its subclasses.  }}"
      },
      {
        "language": "text",
        "code": "tsclass Base {  private x = 0;}const b = new Base();// Can't access from outside the classconsole.log(b.x);Property 'x' is private and only accessible within class 'Base'.2341Property 'x' is private and only accessible within class 'Base'.Try"
      },
      {
        "language": "text",
        "code": "class Base {  private x = 0;}const b = new Base();// Can't access from outside the classconsole.log(b.x);Property 'x' is private and only accessible within class 'Base'.2341Property 'x' is private and only accessible within class 'Base'."
      },
      {
        "language": "text",
        "code": "tsclass Derived extends Base {  showX() {    // Can't access in subclasses    console.log(this.x);Property 'x' is private and only accessible within class 'Base'.2341Property 'x' is private and only accessible within class 'Base'.  }}Try"
      },
      {
        "language": "text",
        "code": "class Derived extends Base {  showX() {    // Can't access in subclasses    console.log(this.x);Property 'x' is private and only accessible within class 'Base'.2341Property 'x' is private and only accessible within class 'Base'.  }}"
      },
      {
        "language": "text",
        "code": "tsclass Base {  private x = 0;}class Derived extends Base {Class 'Derived' incorrectly extends base class 'Base'.\n  Property 'x' is private in type 'Base' but not in type 'Derived'.2415Class 'Derived' incorrectly extends base class 'Base'.\n  Property 'x' is private in type 'Base' but not in type 'Derived'.  x = 1;}Try"
      },
      {
        "language": "text",
        "code": "class Base {  private x = 0;}class Derived extends Base {Class 'Derived' incorrectly extends base class 'Base'.\n  Property 'x' is private in type 'Base' but not in type 'Derived'.2415Class 'Derived' incorrectly extends base class 'Base'.\n  Property 'x' is private in type 'Base' but not in type 'Derived'.  x = 1;}"
      },
      {
        "language": "text",
        "code": "tsclass A {  private x = 10;   public sameAs(other: A) {    // No error    return other.x === this.x;  }}Try"
      },
      {
        "language": "text",
        "code": "class A {  private x = 10;   public sameAs(other: A) {    // No error    return other.x === this.x;  }}"
      },
      {
        "language": "text",
        "code": "tsclass MySafe {  private secretKey = 12345;}Try"
      },
      {
        "language": "text",
        "code": "class MySafe {  private secretKey = 12345;}"
      },
      {
        "language": "text",
        "code": "js// In a JavaScript file...const s = new MySafe();// Will print 12345console.log(s.secretKey);"
      },
      {
        "language": "text",
        "code": "// In a JavaScript file...const s = new MySafe();// Will print 12345console.log(s.secretKey);"
      },
      {
        "language": "text",
        "code": "tsclass MySafe {  private secretKey = 12345;} const s = new MySafe(); // Not allowed during type checkingconsole.log(s.secretKey);Property 'secretKey' is private and only accessible within class 'MySafe'.2341Property 'secretKey' is private and only accessible within class 'MySafe'. // OKconsole.log(s[\"secretKey\"]);Try"
      },
      {
        "language": "text",
        "code": "class MySafe {  private secretKey = 12345;} const s = new MySafe(); // Not allowed during type checkingconsole.log(s.secretKey);Property 'secretKey' is private and only accessible within class 'MySafe'.2341Property 'secretKey' is private and only accessible within class 'MySafe'. // OKconsole.log(s[\"secretKey\"]);"
      },
      {
        "language": "text",
        "code": "tsclass Dog {  #barkAmount = 0;  personality = \"happy\";   constructor() {}}Try"
      },
      {
        "language": "text",
        "code": "class Dog {  #barkAmount = 0;  personality = \"happy\";   constructor() {}}"
      },
      {
        "language": "text",
        "code": "ts\"use strict\";class Dog {    #barkAmount = 0;    personality = \"happy\";    constructor() { }} Try"
      },
      {
        "language": "text",
        "code": "\"use strict\";class Dog {    #barkAmount = 0;    personality = \"happy\";    constructor() { }}"
      },
      {
        "language": "text",
        "code": "ts\"use strict\";var _Dog_barkAmount;class Dog {    constructor() {        _Dog_barkAmount.set(this, 0);        this.personality = \"happy\";    }}_Dog_barkAmount = new WeakMap(); Try"
      },
      {
        "language": "text",
        "code": "\"use strict\";var _Dog_barkAmount;class Dog {    constructor() {        _Dog_barkAmount.set(this, 0);        this.personality = \"happy\";    }}_Dog_barkAmount = new WeakMap();"
      },
      {
        "language": "text",
        "code": "tsclass MyClass {  static x = 0;  static printX() {    console.log(MyClass.x);  }}console.log(MyClass.x);MyClass.printX();Try"
      },
      {
        "language": "text",
        "code": "class MyClass {  static x = 0;  static printX() {    console.log(MyClass.x);  }}console.log(MyClass.x);MyClass.printX();"
      },
      {
        "language": "text",
        "code": "tsclass MyClass {  private static x = 0;}console.log(MyClass.x);Property 'x' is private and only accessible within class 'MyClass'.2341Property 'x' is private and only accessible within class 'MyClass'.Try"
      },
      {
        "language": "text",
        "code": "class MyClass {  private static x = 0;}console.log(MyClass.x);Property 'x' is private and only accessible within class 'MyClass'.2341Property 'x' is private and only accessible within class 'MyClass'."
      },
      {
        "language": "text",
        "code": "tsclass Base {  static getGreeting() {    return \"Hello world\";  }}class Derived extends Base {  myGreeting = Derived.getGreeting();}Try"
      },
      {
        "language": "text",
        "code": "class Base {  static getGreeting() {    return \"Hello world\";  }}class Derived extends Base {  myGreeting = Derived.getGreeting();}"
      },
      {
        "language": "text",
        "code": "tsclass S {  static name = \"S!\";Static property 'name' conflicts with built-in property 'Function.name' of constructor function 'S'.2699Static property 'name' conflicts with built-in property 'Function.name' of constructor function 'S'.}Try"
      },
      {
        "language": "text",
        "code": "class S {  static name = \"S!\";Static property 'name' conflicts with built-in property 'Function.name' of constructor function 'S'.2699Static property 'name' conflicts with built-in property 'Function.name' of constructor function 'S'.}"
      },
      {
        "language": "text",
        "code": "static class"
      },
      {
        "language": "text",
        "code": "ts// Unnecessary \"static\" classclass MyStaticClass {  static doSomething() {}} // Preferred (alternative 1)function doSomething() {} // Preferred (alternative 2)const MyHelperObject = {  dosomething() {},};Try"
      },
      {
        "language": "text",
        "code": "// Unnecessary \"static\" classclass MyStaticClass {  static doSomething() {}} // Preferred (alternative 1)function doSomething() {} // Preferred (alternative 2)const MyHelperObject = {  dosomething() {},};"
      },
      {
        "language": "text",
        "code": "tsclass Foo {    static #count = 0;     get count() {        return Foo.#count;    }     static {        try {            const lastInstances = loadLastInstances();            Foo.#count += lastInstances.length;        }        catch {}    }}Try"
      },
      {
        "language": "text",
        "code": "class Foo {    static #count = 0;     get count() {        return Foo.#count;    }     static {        try {            const lastInstances = loadLastInstances();            Foo.#count += lastInstances.length;        }        catch {}    }}"
      },
      {
        "language": "text",
        "code": "tsclass Box<Type> {  contents: Type;  constructor(value: Type) {    this.contents = value;  }} const b = new Box(\"hello!\");     const b: Box<string>Try"
      },
      {
        "language": "text",
        "code": "class Box<Type> {  contents: Type;  constructor(value: Type) {    this.contents = value;  }} const b = new Box(\"hello!\");     const b: Box<string>"
      },
      {
        "language": "text",
        "code": "tsclass Box<Type> {  static defaultValue: Type;Static members cannot reference class type parameters.2302Static members cannot reference class type parameters.}Try"
      },
      {
        "language": "text",
        "code": "class Box<Type> {  static defaultValue: Type;Static members cannot reference class type parameters.2302Static members cannot reference class type parameters.}"
      },
      {
        "language": "text",
        "code": "Box.defaultValue"
      },
      {
        "language": "text",
        "code": "Box<string>.defaultValue"
      },
      {
        "language": "text",
        "code": "Box<number>.defaultValue"
      },
      {
        "language": "text",
        "code": "tsclass MyClass {  name = \"MyClass\";  getName() {    return this.name;  }}const c = new MyClass();const obj = {  name: \"obj\",  getName: c.getName,}; // Prints \"obj\", not \"MyClass\"console.log(obj.getName());Try"
      },
      {
        "language": "text",
        "code": "class MyClass {  name = \"MyClass\";  getName() {    return this.name;  }}const c = new MyClass();const obj = {  name: \"obj\",  getName: c.getName,}; // Prints \"obj\", not \"MyClass\"console.log(obj.getName());"
      },
      {
        "language": "text",
        "code": "tsclass MyClass {  name = \"MyClass\";  getName = () => {    return this.name;  };}const c = new MyClass();const g = c.getName;// Prints \"MyClass\" instead of crashingconsole.log(g());Try"
      },
      {
        "language": "text",
        "code": "class MyClass {  name = \"MyClass\";  getName = () => {    return this.name;  };}const c = new MyClass();const g = c.getName;// Prints \"MyClass\" instead of crashingconsole.log(g());"
      },
      {
        "language": "text",
        "code": "super.getName"
      },
      {
        "language": "text",
        "code": "ts// TypeScript input with 'this' parameterfunction fn(this: SomeType, x: number) {  /* ... */}Try"
      },
      {
        "language": "text",
        "code": "// TypeScript input with 'this' parameterfunction fn(this: SomeType, x: number) {  /* ... */}"
      },
      {
        "language": "text",
        "code": "js// JavaScript outputfunction fn(x) {  /* ... */}"
      },
      {
        "language": "text",
        "code": "// JavaScript outputfunction fn(x) {  /* ... */}"
      },
      {
        "language": "text",
        "code": "tsclass MyClass {  name = \"MyClass\";  getName(this: MyClass) {    return this.name;  }}const c = new MyClass();// OKc.getName(); // Error, would crashconst g = c.getName;console.log(g());The 'this' context of type 'void' is not assignable to method's 'this' of type 'MyClass'.2684The 'this' context of type 'void' is not assignable to method's 'this' of type 'MyClass'.Try"
      },
      {
        "language": "text",
        "code": "class MyClass {  name = \"MyClass\";  getName(this: MyClass) {    return this.name;  }}const c = new MyClass();// OKc.getName(); // Error, would crashconst g = c.getName;console.log(g());The 'this' context of type 'void' is not assignable to method's 'this' of type 'MyClass'.2684The 'this' context of type 'void' is not assignable to method's 'this' of type 'MyClass'."
      },
      {
        "language": "text",
        "code": "tsclass Box {  contents: string = \"\";  set(value: string) {  (method) Box.set(value: string): this    this.contents = value;    return this;  }}Try"
      },
      {
        "language": "text",
        "code": "class Box {  contents: string = \"\";  set(value: string) {  (method) Box.set(value: string): this    this.contents = value;    return this;  }}"
      },
      {
        "language": "text",
        "code": "tsclass ClearableBox extends Box {  clear() {    this.contents = \"\";  }} const a = new ClearableBox();const b = a.set(\"hello\");     const b: ClearableBoxTry"
      },
      {
        "language": "text",
        "code": "class ClearableBox extends Box {  clear() {    this.contents = \"\";  }} const a = new ClearableBox();const b = a.set(\"hello\");     const b: ClearableBox"
      },
      {
        "language": "text",
        "code": "tsclass Box {  content: string = \"\";  sameAs(other: this) {    return other.content === this.content;  }}Try"
      },
      {
        "language": "text",
        "code": "class Box {  content: string = \"\";  sameAs(other: this) {    return other.content === this.content;  }}"
      },
      {
        "language": "text",
        "code": "tsclass Box {  content: string = \"\";  sameAs(other: this) {    return other.content === this.content;  }} class DerivedBox extends Box {  otherContent: string = \"?\";} const base = new Box();const derived = new DerivedBox();derived.sameAs(base);Argument of type 'Box' is not assignable to parameter of type 'DerivedBox'.\n  Property 'otherContent' is missing in type 'Box' but required in type 'DerivedBox'.2345Argument of type 'Box' is not assignable to parameter of type 'DerivedBox'.\n  Property 'otherContent' is missing in type 'Box' but required in type 'DerivedBox'.Try"
      },
      {
        "language": "text",
        "code": "class Box {  content: string = \"\";  sameAs(other: this) {    return other.content === this.content;  }} class DerivedBox extends Box {  otherContent: string = \"?\";} const base = new Box();const derived = new DerivedBox();derived.sameAs(base);Argument of type 'Box' is not assignable to parameter of type 'DerivedBox'.\n  Property 'otherContent' is missing in type 'Box' but required in type 'DerivedBox'.2345Argument of type 'Box' is not assignable to parameter of type 'DerivedBox'.\n  Property 'otherContent' is missing in type 'Box' but required in type 'DerivedBox'."
      },
      {
        "language": "text",
        "code": "this is Type"
      },
      {
        "language": "text",
        "code": "tsclass FileSystemObject {  isFile(): this is FileRep {    return this instanceof FileRep;  }  isDirectory(): this is Directory {    return this instanceof Directory;  }  isNetworked(): this is Networked & this {    return this.networked;  }  constructor(public path: string, private networked: boolean) {}} class FileRep extends FileSystemObject {  constructor(path: string, public content: string) {    super(path, false);  }} class Directory extends FileSystemObject {  children: FileSystemObject[];} interface Networked {  host: string;} const fso: FileSystemObject = new FileRep(\"foo/bar.txt\", \"foo\"); if (fso.isFile()) {  fso.content;  const fso: FileRep} else if (fso.isDirectory()) {  fso.children;  const fso: Directory} else if (fso.isNetworked()) {  fso.host;  const fso: Networked & FileSystemObject}Try"
      },
      {
        "language": "text",
        "code": "class FileSystemObject {  isFile(): this is FileRep {    return this instanceof FileRep;  }  isDirectory(): this is Directory {    return this instanceof Directory;  }  isNetworked(): this is Networked & this {    return this.networked;  }  constructor(public path: string, private networked: boolean) {}} class FileRep extends FileSystemObject {  constructor(path: string, public content: string) {    super(path, false);  }} class Directory extends FileSystemObject {  children: FileSystemObject[];} interface Networked {  host: string;} const fso: FileSystemObject = new FileRep(\"foo/bar.txt\", \"foo\"); if (fso.isFile()) {  fso.content;  const fso: FileRep} else if (fso.isDirectory()) {  fso.children;  const fso: Directory} else if (fso.isNetworked()) {  fso.host;  const fso: Networked & FileSystemObject}"
      },
      {
        "language": "text",
        "code": "tsclass Box<T> {  value?: T;   hasValue(): this is { value: T } {    return this.value !== undefined;  }} const box = new Box<string>();box.value = \"Gameboy\"; box.value;     (property) Box<string>.value?: string if (box.hasValue()) {  box.value;       (property) value: string}Try"
      },
      {
        "language": "text",
        "code": "class Box<T> {  value?: T;   hasValue(): this is { value: T } {    return this.value !== undefined;  }} const box = new Box<string>();box.value = \"Gameboy\"; box.value;     (property) Box<string>.value?: string if (box.hasValue()) {  box.value;       (property) value: string}"
      },
      {
        "language": "text",
        "code": "tsclass Params {  constructor(    public readonly x: number,    protected y: number,    private z: number  ) {    // No body necessary  }}const a = new Params(1, 2, 3);console.log(a.x);             (property) Params.x: numberconsole.log(a.z);Property 'z' is private and only accessible within class 'Params'.2341Property 'z' is private and only accessible within class 'Params'.Try"
      },
      {
        "language": "text",
        "code": "class Params {  constructor(    public readonly x: number,    protected y: number,    private z: number  ) {    // No body necessary  }}const a = new Params(1, 2, 3);console.log(a.x);             (property) Params.x: numberconsole.log(a.z);Property 'z' is private and only accessible within class 'Params'.2341Property 'z' is private and only accessible within class 'Params'."
      },
      {
        "language": "text",
        "code": "tsconst someClass = class<Type> {  content: Type;  constructor(value: Type) {    this.content = value;  }}; const m = new someClass(\"Hello, world\");     const m: someClass<string>Try"
      },
      {
        "language": "text",
        "code": "const someClass = class<Type> {  content: Type;  constructor(value: Type) {    this.content = value;  }}; const m = new someClass(\"Hello, world\");     const m: someClass<string>"
      },
      {
        "language": "text",
        "code": "tsclass Point {  createdAt: number;  x: number;  y: number  constructor(x: number, y: number) {    this.createdAt = Date.now()    this.x = x;    this.y = y;  }}type PointInstance = InstanceType<typeof Point> function moveRight(point: PointInstance) {  point.x += 5;} const point = new Point(3, 4);moveRight(point);point.x; // => 8Try"
      },
      {
        "language": "text",
        "code": "class Point {  createdAt: number;  x: number;  y: number  constructor(x: number, y: number) {    this.createdAt = Date.now()    this.x = x;    this.y = y;  }}type PointInstance = InstanceType<typeof Point> function moveRight(point: PointInstance) {  point.x += 5;} const point = new Point(3, 4);moveRight(point);point.x; // => 8"
      },
      {
        "language": "text",
        "code": "tsabstract class Base {  abstract getName(): string;   printName() {    console.log(\"Hello, \" + this.getName());  }} const b = new Base();Cannot create an instance of an abstract class.2511Cannot create an instance of an abstract class.Try"
      },
      {
        "language": "text",
        "code": "abstract class Base {  abstract getName(): string;   printName() {    console.log(\"Hello, \" + this.getName());  }} const b = new Base();Cannot create an instance of an abstract class.2511Cannot create an instance of an abstract class."
      },
      {
        "language": "text",
        "code": "tsclass Derived extends Base {  getName() {    return \"world\";  }} const d = new Derived();d.printName();Try"
      },
      {
        "language": "text",
        "code": "class Derived extends Base {  getName() {    return \"world\";  }} const d = new Derived();d.printName();"
      },
      {
        "language": "text",
        "code": "tsclass Derived extends Base {Non-abstract class 'Derived' does not implement inherited abstract member getName from class 'Base'.2515Non-abstract class 'Derived' does not implement inherited abstract member getName from class 'Base'.  // forgot to do anything}Try"
      },
      {
        "language": "text",
        "code": "class Derived extends Base {Non-abstract class 'Derived' does not implement inherited abstract member getName from class 'Base'.2515Non-abstract class 'Derived' does not implement inherited abstract member getName from class 'Base'.  // forgot to do anything}"
      },
      {
        "language": "text",
        "code": "tsfunction greet(ctor: typeof Base) {  const instance = new ctor();Cannot create an instance of an abstract class.2511Cannot create an instance of an abstract class.  instance.printName();}Try"
      },
      {
        "language": "text",
        "code": "function greet(ctor: typeof Base) {  const instance = new ctor();Cannot create an instance of an abstract class.2511Cannot create an instance of an abstract class.  instance.printName();}"
      },
      {
        "language": "text",
        "code": "ts// Bad!greet(Base);Try"
      },
      {
        "language": "text",
        "code": "// Bad!greet(Base);"
      },
      {
        "language": "text",
        "code": "tsfunction greet(ctor: new () => Base) {  const instance = new ctor();  instance.printName();}greet(Derived);greet(Base);Argument of type 'typeof Base' is not assignable to parameter of type 'new () => Base'.\n  Cannot assign an abstract constructor type to a non-abstract constructor type.2345Argument of type 'typeof Base' is not assignable to parameter of type 'new () => Base'.\n  Cannot assign an abstract constructor type to a non-abstract constructor type.Try"
      },
      {
        "language": "text",
        "code": "function greet(ctor: new () => Base) {  const instance = new ctor();  instance.printName();}greet(Derived);greet(Base);Argument of type 'typeof Base' is not assignable to parameter of type 'new () => Base'.\n  Cannot assign an abstract constructor type to a non-abstract constructor type.2345Argument of type 'typeof Base' is not assignable to parameter of type 'new () => Base'.\n  Cannot assign an abstract constructor type to a non-abstract constructor type."
      },
      {
        "language": "text",
        "code": "tsclass Point1 {  x = 0;  y = 0;} class Point2 {  x = 0;  y = 0;} // OKconst p: Point1 = new Point2();Try"
      },
      {
        "language": "text",
        "code": "class Point1 {  x = 0;  y = 0;} class Point2 {  x = 0;  y = 0;} // OKconst p: Point1 = new Point2();"
      },
      {
        "language": "text",
        "code": "tsclass Person {  name: string;  age: number;} class Employee {  name: string;  age: number;  salary: number;} // OKconst p: Person = new Employee();Try"
      },
      {
        "language": "text",
        "code": "class Person {  name: string;  age: number;} class Employee {  name: string;  age: number;  salary: number;} // OKconst p: Person = new Employee();"
      },
      {
        "language": "text",
        "code": "tsclass Empty {} function fn(x: Empty) {  // can't do anything with 'x', so I won't} // All OK!fn(window);fn({});fn(fn);Try"
      },
      {
        "language": "text",
        "code": "class Empty {} function fn(x: Empty) {  // can't do anything with 'x', so I won't} // All OK!fn(window);fn({});fn(fn);"
      }
    ],
    "links": [
      {
        "text": "Classes (MDN)",
        "href": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Classes"
      },
      {
        "text": "Try",
        "href": "https://www.typescriptlang.org/play/#code/MYGwhgzhAEAKD2BLAdgF2gbwL5A"
      },
      {
        "text": "Try",
        "href": "https://www.typescriptlang.org/play/#code/PTAEAEGcBcCcEsDG0AKsD2AHApraBPASQDt5p4BDAG3gC8Lz1iAuUAM2smwFgAoRKhUiRQKdPGLRQAbz6hQAD1bEArgFsARrgDcc0PmXqtsXbwC+fPoiYxQmKQF5QxbAHdR4yQAoAlKfsAdAqgTgAM-tAB+CGg4UA"
      },
      {
        "text": "Try",
        "href": "https://www.typescriptlang.org/play/#code/MYGwhgzhAEAKD2BLAdgF2gbwLAChrQA9oBeaABgG5d8BPE8qnAX112HmQnQAd1TkApgHc4SNAAoAlIwD0MuACcUqGGQA05NhwjwQAgHQh4Ac3EADACQZe+gkw1WbNJmelA"
      },
      {
        "text": "Try",
        "href": "https://www.typescriptlang.org/play/#code/PTAEAEFMCdoe2gZwFygEwGY1oLACgBjAGwENFFQAFOASwDsAXUAb31FAA9QBeUABgDcbUAE8e-IXgC++EKAC0iggFcGi+fgJw6iJgAcmvOpADuVWowAUASkkGAdF14AiPs4FA"
      },
      {
        "text": "strictPropertyInitialization",
        "href": "/tsconfig#strictPropertyInitialization"
      },
      {
        "text": "Try",
        "href": "https://www.typescriptlang.org/play/#code/PTAEAEFMCdoe2gZwFygEwFYBsAWAsAFADGANgIaKKgBCZAJgOLSSQAuMoA3oaKAHZkAtpFSJW0AJZ8A5gG5CAXyA"
      },
      {
        "text": "Try",
        "href": "https://www.typescriptlang.org/play/#code/MYGwhgzhAEDiD28AmsBOBTdAXdroG8BYAKGmgDswBbdALmgi1QEtyBzAbhJLOHnMaoArsCzxUACgCUBHmWhYAFswgA6SjWgBeaACJF6ECHi6upaAF8SFoA"
      },
      {
        "text": "Try",
        "href": "https://www.typescriptlang.org/play/#code/MYGwhgzhAEDyDSBxATgU1QF1c6BvAsAFDTQD0p0AcgPYbQCWAdvRvWCPQF6oAmANNABGAVzqNq0bMmrIiJRmAC2qAIQAuaBAzImAcwDcRAL5A"
      },
      {
        "text": "Try",
        "href": "https://www.typescriptlang.org/play/#code/PTAEAEFMCdoe2gZwFygEwFYAsAGd2cBYAKAGMAbAQ0UVAHFpJIAXGUAbxNFEcoBM4AO3IBPUIMoBbSKkTNoAS0EBzUAF5QAIgDuCcn00BuEl1Ckhc6AFdSzBAAo4zABYwAclMgB+WfKXKASg5TbgUAM1BHF3dPUABCNQ0rQT5IMKVIPiDOYm480BcFRAA6CWl1UCdXaA9pY1y8gF9TZuJTGGh7bJCC5yLS2I1NQSdKgGsjFpJW80E5UFUNQUhtekYWGC765QHyocpyRDhxUbgJwyA"
      },
      {
        "text": "Constructor (MDN)",
        "href": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Classes/constructor"
      },
      {
        "text": "Try",
        "href": "https://www.typescriptlang.org/play/#code/MYGwhgzhAEAKD2BLAdgF2gbwLAChrQA8AuaZAVwFsAjAUwCcBuXfATxPOvqZ2egHo+0AHLw6FMCGgREAc2RhUZOjWgB3RKgAW0ACY0AZmDIhUEXsHjIIqOmWCpRACgLQAvNAAMAGmgs3ngEpMXnwtRAgAOhd3Am58UM1wiL93FjjoAF9cDKA"
      },
      {
        "text": "Try",
        "href": "https://www.typescriptlang.org/play/#code/MYGwhgzhAEAKD2BLAdgF2gbwLAChrQA8AuaZAVwFsAjAUwCdoBeaABgG5d8BPE86+pqw45O0APRjoAYXjIIqOmWCp4DeADd6IeGAAmEUcFnzFy1QApipSrToAaaD2v86ASmH4jchUpV1LTiYoAObuhsY+Zv5WQcjB0AA+zrYOTny2giyumKL4EtLwujTQ2sGIwNAAFvQ0ogC+uHVAA"
      },
      {
        "text": "Try",
        "href": "https://www.typescriptlang.org/play/#code/PTAEAEFMCdoe2gZwFygIwHYAMWCcBYAKAGMAbAQ0UVACFLJQBvI0UAa1AF5QAWAbiIBfIkTKVqAERgBLAG6QAJqEgAPAC6QAdgup1EDZoVbE4mxGugBXYmoQAKAJRMWrUCFAAFaNM1rq5UAB3eE0Ac1BZclJLBh9QAFEAZQBWPlA1AAt4QOpVYkgABzVpU1A4pIA2F2NTRDhSSAA6UjhQu0zpREa2BwEjV0RLAphHPtZhQkEgA"
      },
      {
        "text": "Method definitions",
        "href": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Functions/Method_definitions"
      },
      {
        "text": "Try",
        "href": "https://www.typescriptlang.org/play/#code/MYGwhgzhAEAKD2BLAdgF2gbwLAChrQA9oBeaARgAYBuXfATxPOt1ugmDBAFMAKZALmjIArgFsARlwBOASkEA3JABNMrfKgAWiCADoiAKlLIaefNE3adDQ0JP4AvrntA"
      },
      {
        "text": "Try",
        "href": "https://www.typescriptlang.org/play/#code/PTAEAEFMCdoe2gZwFygEwGY1oLACgAbSAF1AA9UA7AVwFsAjGUAXlAAYBuffAYwIENEiUAGFQAb3yhyqRMWgBLSgHMWoAEQALSAQJx1XPFNC0AFAEoJx6SFAAVTQuFPQ8gJ5LVxOCbgATBQAzN1AAcjJQ0ED4WlACJUhQAEYAGlBKOFJibVA+QWEAB3gCmGI3a3I1dQB3BAI-A2MAX3wmoA"
      },
      {
        "text": "Try",
        "href": "https://www.typescriptlang.org/play/#code/MYGwhgzhAEDC0G8CwAoa0D6ICmA7A5gC4AW0AvNAAwDcq6+2h0OBJAFAJSJ3rQBOjAK59c0EgEsIAOix4ixWmmgBfHhEbM57AG5gQg7F2RL0E6bNakKu-dkXpVKZUA"
      },
      {
        "text": "TypeScript 4.3",
        "href": "https://devblogs.microsoft.com/typescript/announcing-typescript-4-3/"
      },
      {
        "text": "Try",
        "href": "https://www.typescriptlang.org/play/#code/MYGwhgzhAEAqAWBLAdgc2gbwLAChrQH0JEAvAU2gF5oAGAbl131TIBdpjyAKASgC5oyAK4BbAEZkATpib5oktkMnJorJBAB0RUmQZ5oAX0b6IbDjq4A3MCCFkBEVpJToAPoNETp7sQHtfIGRgyDwy+viB7MIiVNAAcp5SVjZ2PHqy+AD0mdAAIr7IAOTsNiC+AO7xYHEANNAAksgAZiiIrACedWzAxnLQiE3QXACECeJSGogQAGKtrGRc0Tyh2OFyalNanBTU9BlyCqxKyHp9Rjj7G5ra5LHRp4a4BkA"
      },
      {
        "text": "Index Signatures for other object types",
        "href": "/docs/handbook/2/objects.html#index-signatures"
      },
      {
        "text": "Try",
        "href": "https://www.typescriptlang.org/play/#code/MYGwhgzhAECyCeBhcVoG8CwAoa0DaEAXNBAC4BOAlgHYDmAusQEYD2LIApmNdAD7QAKAURIUatAJTQAvAD5ordl2oSA3Nmy5gACw7AA1sOJkqdKZhy5o5DqQCu5HqW2UIBetEgK2nbussAvtgBQA"
      },
      {
        "text": "Try",
        "href": "https://www.typescriptlang.org/play/#code/PTAEAEFMCdoe2gZwFygEwBY0AYCwAoASwDsAXGAMwEMBjSUABRIHMqAjAG3oG8DRQADiwAUASlQA3OIQAmAbgIBfAgRocqiRKADKcYlWihCAWwFdjkMlqbFWnHn0EjRoXvn78aexHC4A6DjhmYQAiIVsAQhDRBXdQZXwE1XVNUAAhKg4OI1NzS1JrFnYuV0cBPWCXNw9QL2Iff0DgsIqomMcExSA"
      },
      {
        "text": "Try",
        "href": "https://www.typescriptlang.org/play/#code/PTAEAEFMCdoe2gZwFygOwAYMDYCwAoASwDsAXGAMwEMBjSUAYQAtIaBrKgIwBt6BvAqFA0W7ABTEqAW0ipEpaCQDmASlSc4cXlWIBuAgF8CBGtyqJEoAHLTIzVmxihCUgA68ZZS-fZdeoAXwhEQcxRBUAwSFQEGs4UkI6UGI4UBh4aFAWaEgooRzSAFdoYlBEADpSOAAZOAB3GAZzSDEIgF4O0AAiODYu-SDo2OiR0AA9AH4oo3wDIA"
      },
      {
        "text": "Try",
        "href": "https://www.typescriptlang.org/play/#code/PTAEAEFMCdoe2gZwFygEwGYME4CwAoASwDsAXGAMwEMBjSUAQVAG8DRQAPVYgVwFsARjADcbUAE8A-N35Doo-AF8CNADZVEiUAGFQhPgAdVkPpDJamrfOw6gAvKAAMC5fhpxiiUqBr3QxSAB3HQAKAEoFGgA6cT8ARmcgA"
      },
      {
        "text": "extends keyword (MDN)",
        "href": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Classes/extends"
      },
      {
        "text": "Try",
        "href": "https://www.typescriptlang.org/play/#code/MYGwhgzhAECCB2BLAtmE0DeBYAUNayA9gG4CmAFAJSa777CHwSEikB0IhA5uQEQCyJRPC7Q0jLgEJelANy1oAX1zKcuUJBgARbtFIAPAC6l4AExgIUaGnmgB3QoQBm5QylIQAXNHgBXZABGpABO1Ni2+E6EwdDkrIbQiNAAvNAADLKJ0AA80G7IHpmIANTFYQp00AxMLOycPLwOztJyFUoKqqrqjBAJpik+pHbQOjytOAD0E9AAQpCkVeBQBKSGABaEprimbERkVPKT01ohiGT9GssF65vbbE0uAMxyQA"
      },
      {
        "text": "super keyword (MDN)",
        "href": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/super"
      },
      {
        "text": "Try",
        "href": "https://www.typescriptlang.org/play/#code/MYGwhgzhAEBCkFNoG8CwAoa0DmAnBCALgBQCUKGWWwA9gHYQ0gIB0IN2xARABIIjsANNADuNXCAAmAQi6kA3JWgBfDKvQZQkGABEEuAJYA3BJOgIAHoQR1JMeBCRpMOfEWJ0wAWwQB+AFzQEISGdNjkzlTQBgBm0B7eSAC8KdAArrYIMQZ0phFKURBpAA76LHgEJAoFKuYgjhQuUbQMTKzsnAAGfAI0wgAkyJ4+LIQ0AKrFpbgAwohkyp3VTSpK6uqa9MHQZknQuSLQeoYmkmSK6JLlblUXVxXuXPhgkvpy8kA"
      },
      {
        "text": "Try",
        "href": "https://www.typescriptlang.org/play/#code/MYGwhgzhAEBCkFNoG8CwAoa0DmAnBCALgBQCUKGWWwA9gHYQ0gIB0IN2xARABIIjsANNADuNXCAAmAQi6kA3JWgBfDKvShIMACIJcASwBuCSdAQAPQgjqSY8CEmTraDQtFMBeaHQQjoug2NJMkV0AHow6ABaGOAAV0IYqIwI6ABBEH1IaEIACyRJPSMTaH1XMDpgJDzcGjjsXOgwaAAjRGhNKGh8ADM9ayqMFwg3FoAuOHavSVDUgDkaaAAHWpbmAFsMFpY8AhIFIA"
      },
      {
        "text": "Try",
        "href": "https://www.typescriptlang.org/play/#code/PTAEAEFMCdoe2gZwFygEwBYCMA2AsAFADGANgIaKKgBCFkoA3oaKAObSSQAuAFAJSNmLUETgA7RHBKQAdCTiseAIgASkEvIA0oAO4ISAEwCESvgG4hAX0LWChUhSoARGAEsAbpAOhIADy6QYgZUtIj0TAQsIKAAsmQA1vRcABauVAAOZNBkALbcMKAcAI4Arq4cBkLsnLxiuZCoiFzQrmKsAhHCIuKS0nIKPAAGahpw2gAkDHV5MlxwAKrp6TAAwnT8loPmVjZAA"
      },
      {
        "text": "Try",
        "href": "https://www.typescriptlang.org/play/#code/CYUwxgNghgTiAEkoGdnwEIoQbwLACh54BzOEAFwAoBKALngDcB7AS2AG4CBfA0JORNFTwAIiBgsGIYPBAAPciAB2wNJmQ4e+APTb4AWkNgAruUP6CYJkuTl4AI3rqEAXnhKQAd1HjJ0mpw6egDCMCgAFiBo9uBQxhrwAERKUAC2IInwniwQEA4IxiogAGYsHsAE9gB0pCAUAUA"
      },
      {
        "text": "useDefineForClassFields",
        "href": "/tsconfig#useDefineForClassFields"
      },
      {
        "text": "Try",
        "href": "https://www.typescriptlang.org/play/#code/JYOwLgpgTgZghgYwgAgIImAWzgG2QbwFgAoZZAEzkgHkYAhYKMACwC5k4QBPAbhIF8SJUJFiIUAEQD2Ac2QQAHpBDkAzmgzY8RUsgBGUCBHLtOvAUOIIccVevRZcACSkBXVSh1lDq4OQjg7A5afLoIUiCqYFCuCGBSUAAUnI44QZq4AJQEJGRkLMCqAHQ+fgFgyAC8HBk4oWSCxI0k1rbq0jIu7iiKymoaqV0eOboA9KPI0hDqIFIVEJjAFQBScABucADKCFDAAA4V4f4ANLnI48gROFzyka4+yCwoYFx70xyGyOFQhnFn-q1PqV-IFJrJ6l8IlEYnEEolyLJ2B1sl48qpXG8kgiZJkIY1+EA"
      },
      {
        "text": "Try",
        "href": "https://www.typescriptlang.org/play/#code/MYGwhgzhAEBCkFNoG8CwAoa0B2YC2SAvNAEQBGiJA3BlsAPbYQAuATgK7DP2sAUAlClpZoDJvRAIAdCHoBzXiQCyATxz4kASxgloAamjMAFtqm4C-GpmgBfDHfQZQkGABEErTQDcEAE2gIAB7MCNi+MPAQSGjW5kSkvh7eftT2GBgA9BnQAAqe2Mw6FFEkADQ49MwJST6+JE6MLND+xNgIAO7Q7p61AlRAA"
      },
      {
        "text": "Try",
        "href": "https://www.typescriptlang.org/play/#code/MYGwhgzhAECyEHMCiAnFB7F0CmAPALtgHYAmMqGWA3gLABQ00w6RE+KArsPpgBQC2ALmhsUASyIIAlNFoNGIjgAdsKAVIDc9RgF9tIsAE8AEthAh0vGXIXQU2fBxRFoAIgAWZi2+gBqaPjuYhAAdPzYUGAI2FryenQ6QA"
      },
      {
        "text": "Try",
        "href": "https://www.typescriptlang.org/play/#code/MYGwhgzhAECyEHMCiAnFB7F0CmAPALtgHYAmMqGWA3gLABQ00w6RE+KArsPpgBQC2ALmhsUASyIIAlNFoNGIjgAdsKAVIDc9egugB6PdADK2fNHwALbNCUYe+AJ4qcuJSDHAx+EA4B0OhQB5ACMAK2xuXwhTAAU7dEcVQIAzXksxCAAaOEQKTF9bBISnbE0AgF9teQgwBwAJbBAQdF4ZOV0UUw4UImgAIism9H7oAGpzCwzffmwoMARsLXlKunKgA"
      },
      {
        "text": "Object.setPrototypeOf",
        "href": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/setPrototypeOf"
      },
      {
        "text": "__proto__",
        "href": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/proto"
      },
      {
        "text": "these workarounds will not work on Internet Explorer 10 and prior",
        "href": "https://msdn.microsoft.com/en-us/library/s4esdbwz(v=vs.94).aspx"
      },
      {
        "text": "Try",
        "href": "https://www.typescriptlang.org/play/#code/MYGwhgzhAEDiBOBTRAXR9oG8CwAoa0ADgK4BGIAlsNAOZKoAUAlFngQcAPYB2EnIiAHQhONBgCIAFhQCE4pgG420AL541uLrxS1oAXmjdEAdzj008Zktw1BdZCitA"
      },
      {
        "text": "Try",
        "href": "https://www.typescriptlang.org/play/#code/PTAEAEFMCdoe2gZwFygEwBYMFYCwAoAYwBsBDRRUAcWkkgBcZQBvA0UABwFcAjYgS0KgA5rQYAKAJQs27UITgA7RHGKQAdMTjDxAIgASkYloA0oXaADUoegAt+idcIYA5UgFtIUyQG5ZAX1kOeEZCRgATEVcPL2lWfDlQWnouaEVze10-BNBA-DyCEnJKAGUOSEJ+UmIaOkZoUEgAD0ZFcMpahiZ49m4+QVBbOAB3cIBPKRkc9hBQAHkAaRs4UFJCQkgKThCKiNBPdx4mWxhIWXYFZVUNLR0DEfGzC2s7Bydoz29sxNnEv-+AXIAHog0FgsEBAh5S6IegiUAAXlAikgw1AZQqVRqYnqUmywicOLxoFmiwIBOc9Dcn18QA"
      },
      {
        "text": "Try",
        "href": "https://www.typescriptlang.org/play/#code/MYGwhgzhAEBCkFNoG8CwAoa0AOAnA9gC4LDEAm0AttALzQCMADANwYC+GokMAIgrgEsAbggoIAHsQB2ZGPAhI0maAHoV0AHL4q+MgIBmA-gBpoEbWQT6wAVxCFoAmAHJsNgEYgBwZxizU6egBWVnQOdGB8KQgHCjopBAB3aD5BETIACgBKUMjo-BAEADoQfABzDLIiyhzVdQB5AGkgA"
      },
      {
        "text": "Try",
        "href": "https://www.typescriptlang.org/play/#code/PTAEAEFMCdoe2gZwFygEwBYMDYCwAoAYwBsBDRRUAIXMlAG8DRQAHeAF0kM4BNQAPVADsArgFsARjFABeUAEYA3AQC+BEuUoARGAEsAbpB7zQkfpyE9KNRHUb5mbOJ25GBw8VOizQAVmX4akRkFKA60AZGaKbmkJbWtAxMoABm8gAUzgAWMKjhkTxoAJRJDsyg2TAAdPw+8gAMAcxBzClomew50Hl6hsYl9uUVndW1cg1NoEEqQA"
      },
      {
        "text": "Why Can’t I Access A Protected Member From A Derived Class?",
        "href": "https://blogs.msdn.microsoft.com/ericlippert/2005/11/09/why-cant-i-access-a-protected-member-from-a-derived-class/"
      },
      {
        "text": "Try",
        "href": "https://www.typescriptlang.org/play/#code/PTAEAEFMCdoe2gZwFygEwGYAsBGAsAFADGANgIaKKgBCFkoA3oaKAA7QCWAbmQC70APUAF5QABgDchAL6EicAHaJeoAEYjQCyAHcadABQBKKQRCgAwmQUByFWSJFIlUADN4AW1BwArr0QcAE3peAAt6UgpEOUVEOBJIADoSOABzfVUEgWMgA"
      },
      {
        "text": "Try",
        "href": "https://www.typescriptlang.org/play/#code/PTAEAEFMCdoe2gZwFygEwGYAsBGAsAFADGANgIaKKgBCFkoA3oaKAA7QCWAbmQC70APUAF5QABgDchAL6EQoALRKiAV15KFhUhSoARGN0gATUJAH8Adkaq1E9JgRaIAFnADuADQAUASkbMWUHkAYTILAHJeUDIiIkhKUA4LUEQVACNtSniAliI4C0Q4EkgAOhI4AHMvXmcORBKBHylHUFkCaSA"
      },
      {
        "text": "Try",
        "href": "https://www.typescriptlang.org/play/#code/PTAEAEFMCdoe2gZwFygEwBYCMBWAsAFADGANgIaKKgBCFkoA3oaKAA7QCWAbmQC70APUAF5QABgDchAL6FSFKgBEY3SABNQkAfwB2aqrUT0mBFkNFYpBaUA"
      },
      {
        "text": "Try",
        "href": "https://www.typescriptlang.org/play/#code/MYGwhgzhAECC0G8CwAoa0AOAnAlgNzABcBTaAD2gF5oBGABgG5VV0MBXAIxB2GgjAC2xWBAAUAe0IALYlgBccAJSIW6aAHp10AHLjosrOKyr0WYoTZYAdtEkysAOgqUX0aTghOmaaAF9UvkA"
      },
      {
        "text": "are only enforced during type checking",
        "href": "https://www.typescriptlang.org/play?removeComments=true&target=99&ts=4.3.4#code/PTAEGMBsEMGddAEQPYHNQBMCmVoCcsEAHPASwDdoAXLUAM1K0gwQFdZSA7dAKWkoDK4MkSoByBAGJQJLAwAeAWABQIUH0HDSoiTLKUaoUggAW+DHorUsAOlABJcQlhUy4KpACeoLJzrI8cCwMGxU1ABVPIiwhESpMZEJQTmR4lxFQaQxWMm4IZABbIlIYKlJkTlDlXHgkNFAAbxVQTIAjfABrAEEC5FZOeIBeUAAGAG5mmSw8WAroSFIqb2GAIjMiIk8VieVJ8Ar01ncAgAoASkaAXxVr3dUwGoQAYWpMHBgCYn1rekZmNg4eUi0Vi2icoBWJCsNBWoA6WE8AHcAiEwmBgTEtDovtDaMZQLM6PEoQZbA5wSk0q5SO4vD4-AEghZoJwLGYEIRwNBoqAzFRwCZCFUIlFMXECdSiAhId8YZgclx0PsiiVqOVOAAaUAFLAsxWgKiC35MFigfC0FKgSAVVDTSyk+W5dB4fplHVVR6gF7xJrKFotEk-HXIRE9PoDUDDcaTAPTWaceaLZYQlmoPBbHYx-KcQ7HPDnK43FQqfY5+IMDDISPJLCIuqoc47UsuUCofAME3Vzi1r3URvF5QV5A2STtPDdXqunZDgDaYlHnTDrrEAF0dm28B3mDZg6HJwN1+2-hg57ulwNV2NQGoZbjYfNrYiENBwEFaojFiZQK08C-4fFKTVCozWfTgfFgLkeT5AUqiAA"
      },
      {
        "text": "Try",
        "href": "https://www.typescriptlang.org/play/#code/MYGwhgzhAECyCeBlMAzAptA3gWAFDWgAcAnASwDcwAXDCNYYtKgaTXmgF5oBGAJgGYALAFYA3HgC+QA"
      },
      {
        "text": "Try",
        "href": "https://www.typescriptlang.org/play/#code/PTAEAEFMCdoe2gZwFygEwGYAsBGAsAFADGANgIaKKgCyAngMpkBmkoA3oaKAA7QCWANzIAXVokhFokYQGlItUAF5QOTFgCsAbkIBfQoSJwAdomGgqyo5ADuNBs0gAKAJTaChEKABycM2RIkcNaQACagIQCu-EYA5qDCtNysRAAWEgDWfLEGxohwJJAAdIExjoiF4pLScrSu+gSeAPIyOSb5RSVlANoARJVSsvI9ALquQA"
      },
      {
        "text": "private fields",
        "href": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Classes/Private_class_fields"
      },
      {
        "text": "Try",
        "href": "https://www.typescriptlang.org/play/#code/MYGwhgzhAEAiD2BzaBvAsAKGtAxAIzACcBrAQQFt4BXAOwBdoBeaABgG5NsAHAU0Ing0wIAJZ0Ank2gAiABZguXcdI4ZO0YIIh1CVYHXiEAFAEpUAX0zmgA"
      },
      {
        "text": "Try",
        "href": "https://www.typescriptlang.org/play/#code/PTAEAEBcEMCcHMCmkBcpEGcB2iAekBYAKBAgwAsB7AdwFEBbAS0KIGMAbaDDUAEUvigA3sVCgAxACM4AawCC9SgFcskUAF5QABgDco0AAdEsDJSzR2zAJ4bQAInLQDBq3b1F9rMxkiwlrSEpYAAoASmEAX2IIoA"
      },
      {
        "text": "Try",
        "href": "https://www.typescriptlang.org/play/#code/PTAEAEBcEMCcHMCmkBcpEGcBMAGAjAKwCwAUCBBgBYD2A7gKIC2AlpKQMYA20GGoAItXigA3qVCgAxACM4AawCCjagFcAdpFABeUDgDc40AAdEsDNTXROrAJ7bQAIkrQjRmw4MlD7CxkiwVdkhqWAAKAEpRAF9SKKA"
      },
      {
        "text": "Static Members (MDN)",
        "href": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Classes/static"
      },
      {
        "text": "Try",
        "href": "https://www.typescriptlang.org/play/#code/MYGwhgzhAECyCeBhcVoG8CwAoa0IBcx8BLYaAD2gF5oAGAbm1wKNOgAcAnYgO3wA0AFAEp0TXNGAB7HhCkgApgDoQUgOaCEySBCXlhjHNAC+2U1mmz5y1Rq0pd+w-Z1KuvASPpA"
      },
      {
        "text": "Try",
        "href": "https://www.typescriptlang.org/play/#code/PTAEAEFMCdoe2gZwFygEwGYAsBGAsAFADGANgIaKKgCyAngMLmWgDehooADtAJYBuZAC6RQiQUJ5FQAD1ABeUAAYA3IQC+hInAB2iOCUgA6EnADmACjqMKiQ9ICUyoA"
      },
      {
        "text": "Try",
        "href": "https://www.typescriptlang.org/play/#code/MYGwhgzhAEBCkFNoG8CwAoa0IBcw4EthoBzBHAcQCcFyCA7EgCgEoUMssacBXK+6ACIAEghAgA9tADuEqiAAmggNwdoAXwyb0oSDAAiCKgQBuCBdAQAPHAnoKY8CEjSZoAWwCe1WoUbQAXmhDYzMFADoySho6RlZVdHUgA"
      },
      {
        "text": "Try",
        "href": "https://www.typescriptlang.org/play/#code/PTAEAEFMCdoe2gZwFygEwDYCcWCwAoAYwBsBDRRUAZVAG8DRREAXU5gS0NADtSBbSKAC8oAERUAhKIDcBAL5A"
      },
      {
        "text": "Try",
        "href": "https://www.typescriptlang.org/play/#code/PTAEFUDtIUwYxgZ0QQwE4E9QCJEBcU8BLObUOAGxWQFgAoS6xUAWQwGUDi4BhK5UAG96oUPkIlQAEwD27GQFsYeABZFIAcwAUASiEBfeobr0QoAApoYAMxhorU0FpQU8dyBIBuMUAEYd9NYArpBwxDKQ0nKKymqaugb0pmCWNnYOTi5uaB7E3qAATAEMEfisGAASMBQADnYA8gBGAFbweKAAvEIiUYgxquraeoL6ADRGANxAA"
      },
      {
        "text": "Try",
        "href": "https://www.typescriptlang.org/play/#code/CYUwxgNghgTiAEAzArgOzAFwJYHtXwhymABkoBnDASVUqnRHIAoBKALnnoE8BtAXQCwAKAD0I+AFopYZBikThkCuXgAxHDngBvYfD3w62MPADEYHGgzwAvPAAMAbmG79AcxBXzl1tpf79cBjIMPjqOAB0ZhaoGE5C-gC+zvH6hljGOin+ehgwXL5Z2f7mtFbQlDR0DCq2hMRkFaX0YIyscUVFYZFeMfAA1LUU1E3V4RAgqK4YABbtHUmFxVAYYNPaC4nCCUA"
      },
      {
        "text": "Try",
        "href": "https://www.typescriptlang.org/play/#code/MYGwhgzhAEBCD2APAPAFQJ4AcCmA+aA3gLABQ00w8AdgC7a0QBc0GOA3KeZVRDQE4BXYDXh8AFADcwIAdmatsASkKdy0GgAsAlhAB03Og2gBeaFJnYOZaAF9SdkqW69oAIxPQq2AO5wkYgCINbBAQeABCAMUrAHoYtWgAPQB+IA"
      },
      {
        "text": "Try",
        "href": "https://www.typescriptlang.org/play/#code/PTAEAEFMCdoe2gZwFygEwGYAMaCwAoAYwBsBDRRUAITgA8AeAFQE8AHSAPlAG8DRREAF1KCAloVAATSADNSAV2KCAaqWLzIqFuwDcBAL5A"
      },
      {
        "text": "this keyword (MDN)",
        "href": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/this"
      },
      {
        "text": "Try",
        "href": "https://www.typescriptlang.org/play/#code/MYGwhgzhAECyCeBhcVoG8CwAoa0B2YAtgKbQC80ARAspBJQNza4DmxALgHJHEAUAlOma5oAJw4BXUXmjsAFgEsIAOgIkmOaAF9sOrMAD2eCO2jBy+YgHc4SFBAEbDx0wYBGAKwuZNa4gC4qdw9KABphNi4eQOBlSO4ScKwtDWwAejToAAVRBTx2GEpgsPwDU2o7OkpsZwgDEGJlEAMWXmC4jgS+fn4GIA"
      },
      {
        "text": "Arrow functions (MDN)",
        "href": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Functions/Arrow_functions"
      },
      {
        "text": "Try",
        "href": "https://www.typescriptlang.org/play/#code/MYGwhgzhAECyCeBhcVoG8CwAoa0B2YAtgKbQC80ARAspBJQNza4DmxALgHJGkUAUASnIA+dM1zQAThwCukvNHYALAJYQAdARJMc0AL4692YAHs8EdtGDl8xAO5wkKCIJ2nzlljeDq2XHjoA9IHQAAqSKnjsMNROdJTQkRbEYAAm0CYAZlaSkKp4LMZmECYgxOogJix81QICDEA"
      },
      {
        "text": "Try",
        "href": "https://www.typescriptlang.org/play/#code/C4TwDgpgBAyg9gWwgFXNAvFAhgOxAbgFgAoAelKgFpqBjAV2GspPKlUhhoCcBLMYKDxxgGUAO49gACygByaTwDOsqGCxcsSYBC4kAZnRw1gPODih6cACgWKAXLEQo0AGigAPBzjoIARjoBKKABvEigoUgAqKAA6OKhI0hIAXyA"
      },
      {
        "text": "Try",
        "href": "https://www.typescriptlang.org/play/#code/PTAEAEFMCdoe2gZwFygEwDYAcAWAsAFADGANgIaKKgCyAngMLmWgDehooAdmQLaSgBeUACI6jComEBudqADmkAC4A5XpAAUigBYBLFDQZNEASlayO0JQFdonUNr0A6bnxkEOAX0JficTokVQIkEuSAB3A3FKdWM3EFAAeQBpQiJHBRU1GLdCeIBRWAQAGlAwuCsSABMg6AotVL8A+RC0jNVXBv84EkhHEjg5dUHjWKA"
      },
      {
        "text": "Try",
        "href": "https://www.typescriptlang.org/play/#code/MYGwhgzhAEBCD2APaBvAsAKGtY8B2ALgKaEQBc0EBATgJZ4Dm0AvNAERsDcm2ERBACgBuYEAFciFKnUYBKVJgD0i7AD0A-D2zQCAC1oQAdLkIkCMViPFFuWbdX5jqeHfoi3sAX0yegA"
      },
      {
        "text": "Try",
        "href": "https://www.typescriptlang.org/play/#code/MYGwhgzhAEBCD2APaBvAsAKGtY8B2ALgKaEQBc0EBATgJZ4Dm0AvNAERsDcm2ERBACgBuYEAFciFKnUYBKVD2zQCAC1oQAdLkIkCMViPFFuWJdX5jqeZWognsAX0xOMAelfQAtN+BiC3z0xQSBgAYRAiMGowACMIhGQiRGI8ABMYBIVTUEjqAXl0U2xVdS18FL0Wdi5FFxcg-CpoMCq8IgB3aHDc2PikfJNtJpiqsA0+QTYVIhAQeDZZE3claAA9AH4gA"
      },
      {
        "text": "Try",
        "href": "https://www.typescriptlang.org/play/#code/MYGwhgzhAEBCD2APaBvAsAKGtY8B2ALgKaEBc0EBATgJZ4Dm0AvNAESsDcm2EYAtkQCCEABTwCACyJVykmhACUqbtmhUiBAK5U80cVKoA6XIRIFmTFnIjH8xQlyzQAvpmdA"
      },
      {
        "text": "Try",
        "href": "https://www.typescriptlang.org/play/#code/PTAEAEFMCdoe2gZwFygEwGYAsBWAsAFADGANgIaKKgBCcAHqAN6GihFwB2ALpN6ol2gBLDgHNQAXlAAiaQG4WoRGQC2kAIKIAFHC4ALGKn1DEASiaLW0SFwCu0DqF0HoAOnbdeXSRKnHE7pw83AoErAC+hJEEhKQUVAAiMEIAbpAAJrQMkHTB6VRZFmFO+jAAwkFe-IIi4lLSAPzyUYSxnAKgAEYUkJKgHJAA7jT0WqahHh3pyWnpfQPDScKzWWOh08sZrspqmlrdiJDjQA"
      },
      {
        "text": "Try",
        "href": "https://www.typescriptlang.org/play/#code/PTAEAEGcBcCcEsDG0AKsD2AHApraBPASQDt5p4BDAG3gC8Lz1iAuUAM2smwFgAoRKhUiRQAMXhVsAZXwxsAWwDyAIwBW2ZKADefUKHiRxkgBQBKVtAAWB-SKPYAStkzbde0LGzQArrGKgrG3hiGApiRGx0NjEJR2cAbjcAXzcDABF4T2R0WHwzC2sRGwys6Bz8V153Dy9ff0CikOgwiKjQEo0y3MSq0BTegwA5LwB3HIBrbAATfIDC21Bh6DHYSanQADI5mx1evU8fP23IADpiUYnpnr1+vUQmGFhvbNhjTG9lGkRQTAZLVkewQA5gAaH4IABuDGwoHOy0uU1YynQ6EkYVM2n6-T4AiEdliThc2AAHtBsMQpvjJDI5Eo1J1KncHnBnl03n8AXBgWD3p8kKB7sQyULOQhiECMbtqpBvDhXr8rGCOFQuKZrn0+Nj+IJhO1Mp1yqAScLKTFqbIyXT1JopQLrFQpp4WGbpBaFCprdAANoAXR6WuCZNgHAiiwuq2mjNAlnQMFFwP9fBxzPYkHQrHsNMtHoZAF5YdgRi7CcYAERsFHAZQUWAnaCk0tg8so0tqpO8eDRYxsNMnAz2MyStw99AnQXC6A9ECgAB6AH5NUaVTDO6Bu730vqXnlTEPeiOx-bHeSp2B54vsMv9F2D0Nw2tB1GDzGYKfZwveEkgA"
      },
      {
        "text": "Try",
        "href": "https://www.typescriptlang.org/play/#code/MYGwhgzhAEBCD2APAPAFQHzQN4FgBQ00AbmCAK4CmA-AFzSoDc++hAFpAGqmUAUAlHQAurAJYwx2Ytwp1U0AL7YWhaACcKgsqoB20YWIB0JchWgBCALwXoZbQBMKAMxHaKdpgQX55zPMHjaEILQAEZI0NauAO5wSMhBqi4A5uj8HmGIRtIR0ABEAOJgALYUYQCeuR74GVkmHgD09YQAelS+Io7QPDXsEFwm-HxKnjXGlB6EjS1tePJAA"
      },
      {
        "text": "Try",
        "href": "https://www.typescriptlang.org/play/#code/PTAEAEFMCdoe2gZwFygEwGYAsBGAsAFADGANgIaKKgAKZ0ZAtlQN6GihFwB2iALtAFcivBAAo27UAAcBAIxIBLIqGiQyAE24kAnqAAeqLgIayYAGgnsp8XpGGR1obYeOnoFgpOnQFANzK2oABeLiYwEgCUoKyekiCgAHJwoLJw6rpcdpCUdNoSAL6EhcTcfKBkoAC8oJkA7jR0jIiiOGbobRgRANyEnDxwJJAAdCRwAOaiZEN63YTxXgvsAHoA-L2lA8OjE1NB3UA"
      },
      {
        "text": "Class expressions (MDN)",
        "href": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/class"
      },
      {
        "text": "Try",
        "href": "https://www.typescriptlang.org/play/#code/MYewdgzgLgBBIFsCmBhANgQwhGBeGwm2APACoCeADkgHwwDeAsAFAwHhRJhQBcMF1ANws2oSFABOAV2BQQEgBQA3DGilI+ApAEoGItjCgALAJYQAdGM7c8MFWqTDWMAL4sXTlmOgwEtsEgA7nCIqEQQCgBEABJIaGggADQwgfJoACaR2k4A9DkGMAB6APxAA"
      },
      {
        "text": "InstanceType",
        "href": "/docs/handbook/utility-types.html#instancetypetype"
      },
      {
        "text": "Try",
        "href": "https://www.typescriptlang.org/play/#code/MYGwhgzhAEAKD2BLAdgF2gbwLAChrWACcBTMVYgEwEFUAuaZAVwFsAjYwgbl3wA96mbDtzzQAngJbtCPAvGQRUhRsFTxCACn4MpHADTjJQwgEpMs-KgAWiCADoipctXQBeaABEyxO8ngB3DRMLaGtbO15od14RfEsbezEo8VjoAF9cDJxUMQAHYjgkNABJBVQwZGAC91LFCqqAFTziAB4c-PgAM0KUVAA+XFxOxkrURHloZngAN2IAJUQAcytUDVyiuh6SsvriM2xRdd6I6ABqdwBWESzcYHlFaCO0ZORify3VgGYDABYTESmswWy1WT1Q-1wYIinGgAHpYVE+tAABxAA"
      },
      {
        "text": "Try",
        "href": "https://www.typescriptlang.org/play/#code/PTAEAEFMCdoe2gZwFygEwFYCMWCwAoAQwCNEAXaQgYzNCoBtDFFQAhJyUAbwNFBPKUaoAOaQyAOUIBbSAAoAlKkEBLAHYiA3AV6gADtHWSZ8hd118qcNYjj1IAOnpwRcgEQAJSPWcAaUG6gANSgZAAWKogOYsayigra+HwAvgSp+ARWNrTEoAC8oGqQAO5sHIqaQA"
      },
      {
        "text": "Try",
        "href": "https://www.typescriptlang.org/play/#code/IYIwzgLgTsDGEAJYBthjAgQmgpgg3gLABQCCokM8CA5jhAHLAC2OAFAJQBcClAlgDsaAbhJkADlEGMW7DgQC+JJcQD0qhAFptsAK4RtmkijQYAIjikA3HABMEOAB4QcA2xmxg8RUrXpNWTgIxMgQoel0oAQQAIgB3AHsoZFsY0V8VFWMEgUgEewBeBAEcOIQLaztOdNsAOklpALlhIA"
      },
      {
        "text": "Try",
        "href": "https://www.typescriptlang.org/play/#code/PTAEAEFMCdoe2gZwFygEwFYCMGCwAoAQwCNEAXaQgYzNCoBtDFFQAhJyUAbwNFBPKUaoAOaQyAOUIBbSAAoAlKkEBLAHYiA3L1AAHaOskz5C7gF8CF-CFABae1QCuZe7YIMmLACIwVAN0gAE1BIAA8ySDVAlnZETh58PhsAMwQROFoyOFBA7MI1AE8yAAt1EUsgA"
      },
      {
        "text": "Try",
        "href": "https://www.typescriptlang.org/play/#code/PTAEAEFMCdoe2gZwFygEwFYCMWCwAoAQwCNEAXaQgYzNCoBtDFFQAhJyUAbwNFBPKUaoAOaQyAOUIBbSAAoAlKkEBLAHYiA3L1AAHaOskz5C7gF8CF-AyYsAIjBUA3SABNQkAB5lIa1y3ZETh58PjEjWUVuHT5ocQBXaDVQACIU7VDQKysQUABaAqp4sgK8ggAzeLUaFThkkTjxORoEVDIAT11IOHK2DlMQvio68lB1ckJqzgBeUDVIAHc6MgRFDL5xskmqSAA6fUMpSIUMsyA"
      },
      {
        "text": "Try",
        "href": "https://www.typescriptlang.org/play/#code/CYUwxgNghgTiAEYD2A7AzgF3gcziDAXPFCgJ4A08AQlGiESaQNwCwAUAPQfwC0fYAVwx8e7LtSjAAhO1wh8AChp0AlEyA"
      },
      {
        "text": "Try",
        "href": "https://www.typescriptlang.org/play/#code/PTAEAEFMCdoe2gZwFygEwGYAsBWAsAFACGARogC7REDG5o1ANkYoqAELOSgDehoopClVqgA5pHIA5IgFtIACgCUqIQEsAdqIDcfUAAdoGqbIWKeAX0KWCjZqwAiMVQDdIAE1CQAHuUjq3rByIXLwE-OLGcko8uvzQEgCu0OqgAESpOmGg1tYgoAC0hdQJ5IX5hABmCeq0qnApovES8rQIqOqQAO6g0QC8AHzsnGah-NT1FKAaFEQ1XL2gHd2t0EqZ-NPks9SQAHQGRtJRipnWjZDNjoaubieE581BkCdAA"
      },
      {
        "text": "Try",
        "href": "https://www.typescriptlang.org/play/#code/MYGwhgzhAEAKD2BLAdgFwIzQN4FgBQ00AHtALzQAMA3PoQJ5mU14C+++okMCKqATNlrFG1IQ3KjW7PAHoZ0APIBpDvGQRU0AA4AuOEjSZyyAKYB3fbz4AKAJRUgA"
      },
      {
        "text": "Try",
        "href": "https://www.typescriptlang.org/play/#code/PTAEAEGcBcCcEsDG0BcoBmBDANpApgLABQi2mkkoACnrJAPYB2oA3saKI5gLZ5owJGAcwDc7UJiF9OAV24AjWmKIBfYsVLlKAUW4AHbPQCeePK3Fde-OPGHKOk6YzmLY90JByZYRtM4VKxGpExCCgAPIA0hpMMKB6aDR0TKAAvJx4AO6gugbGpgAUAJQiQA"
      },
      {
        "text": "Try",
        "href": "https://www.typescriptlang.org/play/#code/MYGwhgzhAECiC2AHALgT2gbwL4FgBQ+AZgK4B2wyAlgPanSGkAUAHgFxxJoCUm+00AegHRgYUgHJk0ACbVoY1MgAWlUgHNoAd0rLo45uIA00CHICSW2pPy4CeIdACCIENADyAaQCERJttKymlwA3L6M2CFhDCFAA"
      }
    ],
    "meta": {
      "description": "How classes work in TypeScript",
      "keywords": ""
    },
    "summary": "Background Reading:Classes (MDN) TypeScript offers full support for the class keyword introduced in ES2015",
    "tags": [
      "react",
      "javascript",
      "typescript",
      "css",
      "html",
      "classes",
      "members",
      "static",
      "this",
      "class"
    ],
    "id": "typescript-documentation-classeshtml-part-1",
    "quality": 100
  },
  {
    "title": "TypeScript: Documentation",
    "url": "https://www.typescriptlang.org/docs/handbook/2/modules.html",
    "category": "typescript",
    "content": "JavaScript has a long history of different ways to handle modularizing code. Having been around since 2012, TypeScript has implemented support for a lot of these formats, but over time the community and the JavaScript specification has converged on a format called ES Modules (or ES6 modules). You might know it as the import/export syntax. ES Modules was added to the JavaScript spec in 2015, and by 2020 had broad support in most web browsers and JavaScript runtimes. For focus, the handbook will cover both ES Modules and its popular pre-cursor CommonJS module.exports = syntax, and you can find information about the other module patterns in the reference section under Modules. How JavaScript Modules are Defined In TypeScript, just as in ECMAScript 2015, any file containing a top-level import or export is considered a module. Conversely, a file without any top-level import or export declarations is treated as a script whose contents are available in the global scope (and therefore to modules as well). Modules are executed within their own scope, not in the global scope. This means that variables, functions, classes, etc. declared in a module are not visible outside the module unless they are explicitly exported using one of the export forms. Conversely, to consume a variable, function, class, interface, etc. exported from a different module, it has to be imported using one of the import forms. Non-modules Before we start, its important to understand what TypeScript considers a module. The JavaScript specification declares that any JavaScript files without an import declaration, export, or top-level await should be considered a script and not a module. Inside a script file variables and types are declared to be in the shared global scope, and its assumed that youll either use the outFile compiler option to join multiple input files into one output file, or use multiple script tags in your HTML to load these files (in the correct order!). If you have a file that doesnt currently have any imports or exports, but you want to be treated as a module, add the line: tsexport {};Try which will change the file to be a module exporting nothing. This syntax works regardless of your module target. Modules in TypeScript Additional Reading: Impatient JS (Modules) MDN: JavaScript Modules There are three main things to consider when writing module-based code in TypeScript: Syntax: What syntax do I want to use to import and export things? Module Resolution: What is the relationship between module names (or paths) and files on disk? Module Output Target: What should my emitted JavaScript module look like? ES Module Syntax A file can declare a main export via export default: ts// @filename: hello.tsexport default function helloWorld() { console.log(\"Hello, world!\");}Try This is then imported via: tsimport helloWorld from \"./hello.js\";helloWorld();Try In addition to the default export, you can have more than one export of variables and functions via the export by omitting default: ts// @filename: maths.tsexport var pi = 3.14;export let squareTwo = 1.41;export const phi = 1.61; export class RandomNumberGenerator {} export function absolute(num: number) { if (num  0) return num * -1; return num;}Try These can be used in another file via the import syntax: tsimport { pi, phi, absolute } from \"./maths.js\"; console.log(pi);const absPhi = absolute(phi); const absPhi: numberTry Additional Import Syntax An import can be renamed using a format like import {old as new}: tsimport { pi as  } from \"./maths.js\"; console.log(); (alias) var : number import Try You can mix and match the above syntax into a single import: ts// @filename: maths.tsexport const pi = 3.14;export default class RandomNumberGenerator {} // @filename: app.tsimport RandomNumberGenerator, { pi as  } from \"./maths.js\"; RandomNumberGenerator; (alias) class RandomNumberGenerator import RandomNumberGenerator console.log(); (alias) const : 3.14 import Try You can take all of the exported objects and put them into a single namespace using * as name: ts// @filename: app.tsimport * as math from \"./maths.js\"; console.log(math.pi);const positivePhi = math.absolute(math.phi); const positivePhi: numberTry You can import a file and not include any variables into your current module via import \"./file\": ts// @filename: app.tsimport \"./maths.js\"; console.log(\"3.14\");Try In this case, the import does nothing. However, all of the code in maths.ts was evaluated, which could trigger side-effects which affect other objects. TypeScript Specific ES Module Syntax Types can be exported and imported using the same syntax as JavaScript values: ts// @filename: animal.tsexport type Cat = { breed: string; yearOfBirth: number }; export interface Dog { breeds: string[]; yearOfBirth: number;} // @filename: app.tsimport { Cat, Dog } from \"./animal.js\";type Animals = Cat  Dog;Try TypeScript has extended the import syntax with two concepts for declaring an import of a type: import type Which is an import statement which can only import types: ts// @filename: animal.tsexport type Cat = { breed: string; yearOfBirth: number };export type Dog = { breeds: string[]; yearOfBirth: number };export const createCatName = () = \"fluffy\"; // @filename: valid.tsimport type { Cat, Dog } from \"./animal.js\";export type Animals = Cat  Dog; // @filename: app.tsimport type { createCatName } from \"./animal.js\";const name = createCatName();'createCatName' cannot be used as a value because it was imported using 'import type'.1361'createCatName' cannot be used as a value because it was imported using 'import type'.Try Inline type imports TypeScript 4.5 also allows for individual imports to be prefixed with type to indicate that the imported reference is a type: ts// @filename: app.tsimport { createCatName, type Cat, type Dog } from \"./animal.js\"; export type Animals = Cat  Dog;const name = createCatName();Try Together these allow a non-TypeScript transpiler like Babel, swc or esbuild to know what imports can be safely removed. ES Module Syntax with CommonJS Behavior TypeScript has ES Module syntax which directly correlates to a CommonJS and AMD require. Imports using ES Module are for most cases the same as the require from those environments, but this syntax ensures you have a 1 to 1 match in your TypeScript file with the CommonJS output: tsimport fs = require(\"fs\");const code = fs.readFileSync(\"hello.ts\", \"utf8\");Try You can learn more about this syntax in the modules reference page. CommonJS Syntax CommonJS is the format which most modules on npm are delivered in. Even if you are writing using the ES Modules syntax above, having a brief understanding of how CommonJS syntax works will help you debug easier. Exporting Identifiers are exported via setting the exports property on a global called module. tsfunction absolute(num: number) { if (num  0) return num * -1; return num;} module.exports = { pi: 3.14, squareTwo: 1.41, phi: 1.61, absolute,};Try Then these files can be imported via a require statement: tsconst maths = require(\"./maths\");maths.pi; anyTry Or you can simplify a bit using the destructuring feature in JavaScript: tsconst { squareTwo } = require(\"./maths\");squareTwo; const squareTwo: anyTry CommonJS and ES Modules interop There is a mis-match in features between CommonJS and ES Modules regarding the distinction between a default import and a module namespace object import. TypeScript has a compiler flag to reduce the friction between the two different sets of constraints with esModuleInterop. TypeScripts Module Resolution Options Module resolution is the process of taking a string from the import or require statement, and determining what file that string refers to. TypeScript includes two resolution strategies: Classic and Node. Classic, the default when the compiler option module is not commonjs, is included for backwards compatibility. The Node strategy replicates how Node.js works in CommonJS mode, with additional checks for .ts and .d.ts. There are many TSConfig flags which influence the module strategy within TypeScript: moduleResolution, baseUrl, paths, rootDirs. For the full details on how these strategies work, you can consult the Module Resolution reference page. TypeScripts Module Output Options There are two options which affect the emitted JavaScript output: target which determines which JS features are downleveled (converted to run in older JavaScript runtimes) and which are left intact module which determines what code is used for modules to interact with each other Which target you use is determined by the features available in the JavaScript runtime you expect to run the TypeScript code in. That could be: the oldest web browser you support, the lowest version of Node.js you expect to run on or could come from unique constraints from your runtime - like Electron for example. All communication between modules happens via a module loader, the compiler option module determines which one is used. At runtime the module loader is responsible for locating and executing all dependencies of a module before executing it. For example, here is a TypeScript file using ES Modules syntax, showcasing a few different options for module: tsimport { valueOfPi } from \"./constants.js\"; export const twoPi = valueOfPi * 2;Try ES2020 tsimport { valueOfPi } from \"./constants.js\";export const twoPi = valueOfPi * 2; Try CommonJS ts\"use strict\";Object.defineProperty(exports, \"__esModule\", { value: true });exports.twoPi = void 0;const constants_js_1 = require(\"./constants.js\");exports.twoPi = constants_js_1.valueOfPi * 2; Try UMD ts(function (factory) { if (typeof module === \"object\" && typeof module.exports === \"object\") { var v = factory(require, exports); if (v !== undefined) module.exports = v; } else if (typeof define === \"function\" && define.amd) { define([\"require\", \"exports\", \"./constants.js\"], factory); }})(function (require, exports) { \"use strict\"; Object.defineProperty(exports, \"__esModule\", { value: true }); exports.twoPi = void 0; const constants_js_1 = require(\"./constants.js\"); exports.twoPi = constants_js_1.valueOfPi * 2;}); Try Note that ES2020 is effectively the same as the original index.ts. You can see all of the available options and what their emitted JavaScript code looks like in the TSConfig Reference for module. TypeScript namespaces TypeScript has its own module format called namespaces which pre-dates the ES Modules standard. This syntax has a lot of useful features for creating complex definition files, and still sees active use in DefinitelyTyped. While not deprecated, the majority of the features in namespaces exist in ES Modules and we recommend you use that to align with JavaScripts direction. You can learn more about namespaces in the namespaces reference page.",
    "headings": [
      {
        "level": 2,
        "text": "How JavaScript Modules are Defined",
        "id": "how-javascript-modules-are-defined"
      },
      {
        "level": 2,
        "text": "Non-modules",
        "id": "non-modules"
      },
      {
        "level": 2,
        "text": "Modules in TypeScript",
        "id": "modules-in-typescript"
      },
      {
        "level": 2,
        "text": "CommonJS Syntax",
        "id": "commonjs-syntax"
      },
      {
        "level": 2,
        "text": "TypeScript’s Module Resolution Options",
        "id": "typescripts-module-resolution-options"
      },
      {
        "level": 2,
        "text": "TypeScript’s Module Output Options",
        "id": "typescripts-module-output-options"
      },
      {
        "level": 2,
        "text": "TypeScript namespaces",
        "id": "typescript-namespaces"
      },
      {
        "level": 3,
        "text": "ES Module Syntax",
        "id": "es-module-syntax"
      },
      {
        "level": 3,
        "text": "Additional Import Syntax",
        "id": "additional-import-syntax"
      },
      {
        "level": 3,
        "text": "CommonJS and ES Modules interop",
        "id": "commonjs-and-es-modules-interop"
      },
      {
        "level": 4,
        "text": "TypeScript Specific ES Module Syntax",
        "id": "typescript-specific-es-module-syntax"
      },
      {
        "level": 4,
        "text": "ES Module Syntax with CommonJS Behavior",
        "id": "es-module-syntax-with-commonjs-behavior"
      },
      {
        "level": 4,
        "text": "Exporting",
        "id": "exporting"
      },
      {
        "level": 4,
        "text": "ES2020",
        "id": "es2020"
      },
      {
        "level": 4,
        "text": "CommonJS",
        "id": "commonjs"
      },
      {
        "level": 4,
        "text": "UMD",
        "id": "umd"
      },
      {
        "level": 6,
        "text": "import type",
        "id": "import-type"
      },
      {
        "level": 6,
        "text": "Inline type imports",
        "id": "inline-type-imports"
      }
    ],
    "codeBlocks": [
      {
        "language": "text",
        "code": "module.exports ="
      },
      {
        "language": "text",
        "code": "tsexport {};Try"
      },
      {
        "language": "text",
        "code": "export default"
      },
      {
        "language": "text",
        "code": "ts// @filename: hello.tsexport default function helloWorld() {  console.log(\"Hello, world!\");}Try"
      },
      {
        "language": "text",
        "code": "// @filename: hello.tsexport default function helloWorld() {  console.log(\"Hello, world!\");}"
      },
      {
        "language": "text",
        "code": "tsimport helloWorld from \"./hello.js\";helloWorld();Try"
      },
      {
        "language": "text",
        "code": "import helloWorld from \"./hello.js\";helloWorld();"
      },
      {
        "language": "text",
        "code": "ts// @filename: maths.tsexport var pi = 3.14;export let squareTwo = 1.41;export const phi = 1.61; export class RandomNumberGenerator {} export function absolute(num: number) {  if (num < 0) return num * -1;  return num;}Try"
      },
      {
        "language": "text",
        "code": "// @filename: maths.tsexport var pi = 3.14;export let squareTwo = 1.41;export const phi = 1.61; export class RandomNumberGenerator {} export function absolute(num: number) {  if (num < 0) return num * -1;  return num;}"
      },
      {
        "language": "text",
        "code": "tsimport { pi, phi, absolute } from \"./maths.js\"; console.log(pi);const absPhi = absolute(phi);        const absPhi: numberTry"
      },
      {
        "language": "text",
        "code": "import { pi, phi, absolute } from \"./maths.js\"; console.log(pi);const absPhi = absolute(phi);        const absPhi: number"
      },
      {
        "language": "text",
        "code": "import {old as new}"
      },
      {
        "language": "text",
        "code": "tsimport { pi as π } from \"./maths.js\"; console.log(π);           (alias) var π: number\nimport πTry"
      },
      {
        "language": "text",
        "code": "import { pi as π } from \"./maths.js\"; console.log(π);           (alias) var π: number\nimport π"
      },
      {
        "language": "text",
        "code": "ts// @filename: maths.tsexport const pi = 3.14;export default class RandomNumberGenerator {} // @filename: app.tsimport RandomNumberGenerator, { pi as π } from \"./maths.js\"; RandomNumberGenerator;         (alias) class RandomNumberGenerator\nimport RandomNumberGenerator console.log(π);           (alias) const π: 3.14\nimport πTry"
      },
      {
        "language": "text",
        "code": "// @filename: maths.tsexport const pi = 3.14;export default class RandomNumberGenerator {} // @filename: app.tsimport RandomNumberGenerator, { pi as π } from \"./maths.js\"; RandomNumberGenerator;         (alias) class RandomNumberGenerator\nimport RandomNumberGenerator console.log(π);           (alias) const π: 3.14\nimport π"
      },
      {
        "language": "text",
        "code": "ts// @filename: app.tsimport * as math from \"./maths.js\"; console.log(math.pi);const positivePhi = math.absolute(math.phi);          const positivePhi: numberTry"
      },
      {
        "language": "text",
        "code": "// @filename: app.tsimport * as math from \"./maths.js\"; console.log(math.pi);const positivePhi = math.absolute(math.phi);          const positivePhi: number"
      },
      {
        "language": "text",
        "code": "import \"./file\""
      },
      {
        "language": "text",
        "code": "ts// @filename: app.tsimport \"./maths.js\"; console.log(\"3.14\");Try"
      },
      {
        "language": "text",
        "code": "// @filename: app.tsimport \"./maths.js\"; console.log(\"3.14\");"
      },
      {
        "language": "text",
        "code": "ts// @filename: animal.tsexport type Cat = { breed: string; yearOfBirth: number }; export interface Dog {  breeds: string[];  yearOfBirth: number;} // @filename: app.tsimport { Cat, Dog } from \"./animal.js\";type Animals = Cat | Dog;Try"
      },
      {
        "language": "text",
        "code": "// @filename: animal.tsexport type Cat = { breed: string; yearOfBirth: number }; export interface Dog {  breeds: string[];  yearOfBirth: number;} // @filename: app.tsimport { Cat, Dog } from \"./animal.js\";type Animals = Cat | Dog;"
      },
      {
        "language": "text",
        "code": "import type"
      },
      {
        "language": "text",
        "code": "ts// @filename: animal.tsexport type Cat = { breed: string; yearOfBirth: number };export type Dog = { breeds: string[]; yearOfBirth: number };export const createCatName = () => \"fluffy\"; // @filename: valid.tsimport type { Cat, Dog } from \"./animal.js\";export type Animals = Cat | Dog; // @filename: app.tsimport type { createCatName } from \"./animal.js\";const name = createCatName();'createCatName' cannot be used as a value because it was imported using 'import type'.1361'createCatName' cannot be used as a value because it was imported using 'import type'.Try"
      },
      {
        "language": "text",
        "code": "// @filename: animal.tsexport type Cat = { breed: string; yearOfBirth: number };export type Dog = { breeds: string[]; yearOfBirth: number };export const createCatName = () => \"fluffy\"; // @filename: valid.tsimport type { Cat, Dog } from \"./animal.js\";export type Animals = Cat | Dog; // @filename: app.tsimport type { createCatName } from \"./animal.js\";const name = createCatName();'createCatName' cannot be used as a value because it was imported using 'import type'.1361'createCatName' cannot be used as a value because it was imported using 'import type'."
      },
      {
        "language": "text",
        "code": "ts// @filename: app.tsimport { createCatName, type Cat, type Dog } from \"./animal.js\"; export type Animals = Cat | Dog;const name = createCatName();Try"
      },
      {
        "language": "text",
        "code": "// @filename: app.tsimport { createCatName, type Cat, type Dog } from \"./animal.js\"; export type Animals = Cat | Dog;const name = createCatName();"
      },
      {
        "language": "text",
        "code": "tsimport fs = require(\"fs\");const code = fs.readFileSync(\"hello.ts\", \"utf8\");Try"
      },
      {
        "language": "text",
        "code": "import fs = require(\"fs\");const code = fs.readFileSync(\"hello.ts\", \"utf8\");"
      },
      {
        "language": "text",
        "code": "tsfunction absolute(num: number) {  if (num < 0) return num * -1;  return num;} module.exports = {  pi: 3.14,  squareTwo: 1.41,  phi: 1.61,  absolute,};Try"
      },
      {
        "language": "text",
        "code": "function absolute(num: number) {  if (num < 0) return num * -1;  return num;} module.exports = {  pi: 3.14,  squareTwo: 1.41,  phi: 1.61,  absolute,};"
      },
      {
        "language": "text",
        "code": "tsconst maths = require(\"./maths\");maths.pi;      anyTry"
      },
      {
        "language": "text",
        "code": "const maths = require(\"./maths\");maths.pi;      any"
      },
      {
        "language": "text",
        "code": "tsconst { squareTwo } = require(\"./maths\");squareTwo;   const squareTwo: anyTry"
      },
      {
        "language": "text",
        "code": "const { squareTwo } = require(\"./maths\");squareTwo;   const squareTwo: any"
      },
      {
        "language": "text",
        "code": "esModuleInterop"
      },
      {
        "language": "text",
        "code": "moduleResolution"
      },
      {
        "language": "text",
        "code": "tsimport { valueOfPi } from \"./constants.js\"; export const twoPi = valueOfPi * 2;Try"
      },
      {
        "language": "text",
        "code": "import { valueOfPi } from \"./constants.js\"; export const twoPi = valueOfPi * 2;"
      },
      {
        "language": "text",
        "code": "tsimport { valueOfPi } from \"./constants.js\";export const twoPi = valueOfPi * 2; Try"
      },
      {
        "language": "text",
        "code": "import { valueOfPi } from \"./constants.js\";export const twoPi = valueOfPi * 2;"
      },
      {
        "language": "text",
        "code": "ts\"use strict\";Object.defineProperty(exports, \"__esModule\", { value: true });exports.twoPi = void 0;const constants_js_1 = require(\"./constants.js\");exports.twoPi = constants_js_1.valueOfPi * 2; Try"
      },
      {
        "language": "text",
        "code": "\"use strict\";Object.defineProperty(exports, \"__esModule\", { value: true });exports.twoPi = void 0;const constants_js_1 = require(\"./constants.js\");exports.twoPi = constants_js_1.valueOfPi * 2;"
      },
      {
        "language": "text",
        "code": "ts(function (factory) {    if (typeof module === \"object\" && typeof module.exports === \"object\") {        var v = factory(require, exports);        if (v !== undefined) module.exports = v;    }    else if (typeof define === \"function\" && define.amd) {        define([\"require\", \"exports\", \"./constants.js\"], factory);    }})(function (require, exports) {    \"use strict\";    Object.defineProperty(exports, \"__esModule\", { value: true });    exports.twoPi = void 0;    const constants_js_1 = require(\"./constants.js\");    exports.twoPi = constants_js_1.valueOfPi * 2;}); Try"
      },
      {
        "language": "text",
        "code": "(function (factory) {    if (typeof module === \"object\" && typeof module.exports === \"object\") {        var v = factory(require, exports);        if (v !== undefined) module.exports = v;    }    else if (typeof define === \"function\" && define.amd) {        define([\"require\", \"exports\", \"./constants.js\"], factory);    }})(function (require, exports) {    \"use strict\";    Object.defineProperty(exports, \"__esModule\", { value: true });    exports.twoPi = void 0;    const constants_js_1 = require(\"./constants.js\");    exports.twoPi = constants_js_1.valueOfPi * 2;});"
      }
    ],
    "links": [
      {
        "text": "Modules",
        "href": "/docs/handbook/modules.html"
      },
      {
        "text": "outFile",
        "href": "/tsconfig#outFile"
      },
      {
        "text": "Try",
        "href": "https://www.typescriptlang.org/play/#code/KYDwDg9gTgLgBAbwL4G4g"
      },
      {
        "text": "Impatient JS (Modules)",
        "href": "https://exploringjs.com/impatient-js/ch_modules.html#overview-syntax-of-ecmascript-modules"
      },
      {
        "text": "MDN: JavaScript Modules",
        "href": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Guide/Modules"
      },
      {
        "text": "Try",
        "href": "https://www.typescriptlang.org/play/#code/PTAEAEDMEsBsFMB2BDAtvAXKAFvWsB7AOgBcBnAWACh4APABwICcTQATeSZAV1lcm6IAxiWgFEOPIQDqzWGwAUASlABvaqFBDxZAgiKEA5goBEACSkEANKADuctgEITSgNzUAvkA"
      },
      {
        "text": "Try",
        "href": "https://www.typescriptlang.org/play/#code/PTAEAEDMEsBsFMB2BDAtvAXKAFvWsB7AOgBcBnAWACh4APABwICcTQATeSZAV1lcm6IAxiWgFEOPIQDqzWGwAUASlABvaqFBDxZAgiKEA5goBEACSkEANKADuctgEITSgNzUAvtRAQYCFOhY0IgctKSUVD4AtDFC3CQxUdTQqIwskvgEskzyoJBMBKigJkTAuJlEAFZkJu5U5TIOyq5AA"
      },
      {
        "text": "Try",
        "href": "https://www.typescriptlang.org/play/#code/PTAEAEDMEsBsFMB2BDAtvAXKVyAuALAZwDpdCBYAKHgA8AHAewCddQA3ZJ0O6UAXlABmYgEYALAG4qtRi1AJWhAI4BXTvAAqAdwb9QI4mJFTq9ZqwDGDRIVZ18vAQYBsxqtLNyLsZIUKgAJWREABMGVAA5FVQAI3gmAHEkeLxmUABvAF93U1lWSBVEC1xoa1BkGMIGWBVceAAKRGisJtj4gEoMqlBQaEhQRujQAB5QAAZOpnhcFSZEUFbQACpQAFo3Sh6pmbmF6JNMoA"
      },
      {
        "text": "Try",
        "href": "https://www.typescriptlang.org/play/#code/PTAEAEDMEsBsFMB2BDAtvAXKVyAuALAZwDpdCBYAKHgA8AHAewCddQA3ZJ0O6UAXlABmYgEYALAG4qtRi1AJWhAI4BXTvAAqAdwb9QI4mJFTq9ZqwDGDRIVZ18vAQYBsx6WbkXYyQoVAAlZEQAEwZUADkVVAAjeCYAcSQ4vGZQAG8AX3dZVkgVRAtcaGtQZGjCBlgVXHgACkQorAaYuIBKdKpQUGhIUHqo0AAeUAAGdqZ4XBUmRFBm0AAqUABaN0ouiamZuaiTLMoQCBgEFHQsZDo6UgoDsGX7i2r75apoVBz07mgAGm4HX7KFSqNVAGVAkCYYVAACJiMAcAQSAArQjQkxUKw2SrwYiwBgAc1qPFaJkxtlK5QACg49IDKtU6vZoCSqIcuqAAHoAfiAA"
      },
      {
        "text": "Try",
        "href": "https://www.typescriptlang.org/play/#code/PTAEAEDMEsBsFMB2BDAtvAXKVyAuALAZwDpdCBYAKHgA8AHAewCddQA3ZJ0O6UAXlABmYgEYALAG4qICDAQp0WZHTqkKlGQFptAYwCuubZqrRUjFqADe3XskKhAA8CgAvqEhMGqUACJiwHAQkAFaE3lKUVDoMiIQMCMSwDADmABQOAJThMqA5ubkAegD8QA"
      },
      {
        "text": "Try",
        "href": "https://www.typescriptlang.org/play/#code/PTAEAEDMEsBsFMB2BDAtvAXKVyAuALAZwDpdCBYAKHgA8AHAewCddQBjBxQ1u6UAXlABmYgEYALAG4qtRi1AATeJGQBXWKzaxkhQqABKyRAoaoAcqtQAjeEwDiSW3magA3gF8qVEBBgIU6FjIdHSkFJTQqHKshsamFta2DohOuMwANG6gvKA6oIADwKDuoJBMpqAARMTAOAQkAFaEFdKUVLEm5pY29o5MzkwtPgB6APxelBxcDAjEsAwA5gAU+QCUg2Cgm1tbo0A"
      },
      {
        "text": "Try",
        "href": "https://www.typescriptlang.org/play/#code/PTAEAEDMEsBsFMB2BDAtvAXKVyAuALAZwDpdCBYAKHgA8AHAewCddQA3ZJ0O6UAXlABmYgEYALAG4qtRi1AJWhAI4BXTvAAqAdwb9QI4mJFTq9ZqwDGDRIVZ18vAQYBsxqtLNzIKxBdzRrUGQAI0IGWBVceAAKRBVULDjUYPgmAEpQAG8qUFBoSFBY+NAAHlAABgymeFwVJkRQJNAAKlAAWjdKXOra+sb4kwBfKhB2traLSPG2kbAoOCQ0TCC6OlIKSmhUWVZW5EJsPHxQSCYGVFAAImJgHAISACtCS5MqKxtw+GJYBgBzaLu+GIPDSJnetm4DEI0H8bHgAAUHHpAcQQmEIlEAUdgQ5QbNcrkAHoAfiAA"
      },
      {
        "text": "Try",
        "href": "https://www.typescriptlang.org/play/#code/PTAEAEDMEsBsFMB2BDAtvAXKVyAuALAZwDpdCBYAKHgA8AHAewCddQA3ZJ0O6UAXlABmYgEYALAG4qIUAFp5AYwCuuebOlgocJGkyhkdOqQqVoqRi1AAiYsBwESAK0JWplKgoaJCDBMVgMAOYAFFbC4lYAlBJAA"
      },
      {
        "text": "Try",
        "href": "https://www.typescriptlang.org/play/#code/PTAEAEDMEsBsFMB2BDAtvAXKZjqubAHQAuAzgLABQ8AHgA4D2ATsaMQJ53ygDCyrAXlABvUACMm8eABMspYk2iIA5gG5Q7eMiYB5SACFoLABZZEAV1Rj4TUAF9VVKrUYtQS4jcjIAxtwAiDMoiVKDikjKkcgpKygDaALqOlGGa2nqGJmaW1kzJdk6UIBAwCCjoWMh0dCQUlHiurKJ8xAA0oIHBdqCQTAyooABEhMA4eASEAFakg8kcXKAAgrj4sKSgQi2gAD4dQapAA"
      },
      {
        "text": "Try",
        "href": "https://www.typescriptlang.org/play/#code/PTAEAEDMEsBsFMB2BDAtvAXKZjqubAHQAuAzgLABQ8AHgA4D2ATsaMQJ53ygDCyrAXlABvUACMm8eABMspYk2iIA5gG5Q7eMiYB5SACFoLABZZEAV1Rj4TUAF9VVWoxZtO3ACINloIaIlS0qRyCkrKANoAuuqa2nqGJmaW1rYOTvTMrADGDIjyoFmS-PB8xAByaNxCABQAlL4AfKAARJCw5pCQ7M2OlFQgEDAIKOhYAG4E0NIkFJR4LqwcXCK8-AA0oF4+dqCQTAyoLYTAOHgEhABWpD3pC27LAIK4+LCkvqusAD6b3r39YFA4EhKlhkHQ6DN-hAbPsmMFQABGADMADYEVR5pl7txRIUtMQSvwKuh7Lt9odmsdTi9Ltdejk8qwRlUCkUCaVifA6qogA"
      },
      {
        "text": "Try",
        "href": "https://www.typescriptlang.org/play/#code/PTAEAEDMEsBsFMB2BDAtvAXKZjqubAHQAuAzgLABQ8AHgA4D2ATsaMQJ53ygDCyrAXlABvUACMm8eABMspYk2iIA5gG5Q7eMiYB5SACFoLABZZEAV1Rj4TUAF9VVWoxZtO3ACINloIaIlS0qRyCkrKANoAuuqa2nqGJmaW1rYOTvTMrADGDIjyoFmS-PB8xAByaNxCABQAlL4AfKAARJCw5pCQ7M2OlCCgALRDWebEQwNU-VBwSJVYyHR0JBSUeC6sooVaxCX8FegANG5cvPxHHCdePnagkEwMqC2EwDh4BIQAVqQ9VOnrx9wAIK4fCwUi+U6sAA+oCuvRyeVYKHQEK2xVK+3gdVUQA"
      },
      {
        "text": "Try",
        "href": "https://www.typescriptlang.org/play/#code/PQgEB4CcFMDNpgOwMbVAFwJ4AdoGcBeAIkQHsATaI0YAPgFgAoMAAQFsKBXAG2gC5QyUmw6IAVniZgAtLOSd0s6UwCWbbKUjpQsPKAKgYAR04qYACiK6iASgDcTIYjzahlfTrwA6GAENyAGIqvADKmCiWABbQ3NykXuh4RAA0oEQKsAActnZAA"
      },
      {
        "text": "modules reference page",
        "href": "/docs/handbook/modules.html#export--and-import--require"
      },
      {
        "text": "Try",
        "href": "https://www.typescriptlang.org/play/#code/PQgEB4CcFMDNpgOwMbVAFwJ4AdoGcBeAIkQHsATaI0YAPgFgAoMAWjeQFd02WnYOU6AJalEoAIYAjPKQA2XaAApEHALYAuUCtWSEASlABvJqFBDYoZWoigADAZjoOkMdtAAqUCwCMAbhOgjs6uav6MAL5MTKoUHLLQAHTQAB7YpJDoeKAERgHYQpoAzAneACwANAF4AI4c4jAAKgDupJreCaXelYym2AAWBaDtAGxdAVIy8ujQ3eG+QA"
      },
      {
        "text": "Try",
        "href": "https://www.typescriptlang.org/play/#code/PTAEAEFsHsBMFcA2BTAXKAxtSMB2ArAZwFgAoECAMwEsVcBDSNUSegFwAtCA6Nk8igB4ATskrJRuDMlBsAngAdkhALwAiXHGRrQwAHxlK8KW2rRcoegCNC0RPDbIAFLniR0ryFYkBKUAG8yUFBqSlAXN1BBUAAGP1E2eGELT1AAKlAAWgBGAG4g0ASklLd80gBfMjIYBBRuZAAPBWhhPlAVAIKFanQAZm5sgBYAGgLCAEd4elEAFQB3aHRs7kHs0dJghQ4e0GWANjWC61t7R3XysopwGjpGZmpcWEbefgpM94wHd8yyLFxCNgsdhcdqFZCTaiiJxqbjAVicQhqHxleFcbjdS5gYKgAB6AH4gA"
      },
      {
        "text": "Try",
        "href": "https://www.typescriptlang.org/play/#code/PTAEAEFsHsBMFcA2BTAXKAxtSMB2ArAZwFgAoECAMwEsVcBDSNUSegFwAtCA6Nk8igB4ATskrJRuDMlBsAngAdkhALwAiXHGRrQwAHxlK8KW2rRcoegCNC0RPDbIAFLniR0ryFYkBKUAG8yUFBqSlAXN1BBUAAGP1E2eGELT1AAKlAAWgBGAG4g0ASklLd80gBfMjIYBBRuZAAPBWhhPlAVAIKFanQAZm5sgBYAGgLCAEd4elEAFQB3aHRs7kHs0dJghQ4e0GWANjWC61t7R3XysopwGjpGZmpcWEbefgpM94wHd8yyLFxCNgBUATKazBagcrtQrISbUURONTcYCsTiENQ+Mog6bIebQS5gAB6AH4gA"
      },
      {
        "text": "esModuleInterop",
        "href": "/tsconfig#esModuleInterop"
      },
      {
        "text": "module",
        "href": "/tsconfig#module"
      },
      {
        "text": "moduleResolution",
        "href": "/tsconfig#moduleResolution"
      },
      {
        "text": "baseUrl",
        "href": "/tsconfig#baseUrl"
      },
      {
        "text": "paths",
        "href": "/tsconfig#paths"
      },
      {
        "text": "rootDirs",
        "href": "/tsconfig#rootDirs"
      },
      {
        "text": "Module Resolution",
        "href": "/docs/handbook/modules/reference.html#the-moduleresolution-compiler-option"
      },
      {
        "text": "target",
        "href": "/tsconfig#target"
      },
      {
        "text": "module",
        "href": "/tsconfig#module"
      },
      {
        "text": "target",
        "href": "/tsconfig#target"
      },
      {
        "text": "module",
        "href": "/tsconfig#module"
      },
      {
        "text": "module",
        "href": "/tsconfig#module"
      },
      {
        "text": "Try",
        "href": "https://www.typescriptlang.org/play/#code/PTAEAEDMEsBsFMB2BDAtvAXKAxge0QM4AuyiRBAdOQLABQ8AHgA64BORO+xoAbsrAFd4AeUgAFaKAC8oAMwUAjABYATAG46ICDAQp0WaIgAmjKgU1gAtNewCi1y3WioW7UAG9e-IaImgAvqCQrLiooABEFMB4hCRklABWBOEatHSMrhwx3EQA7rh+MnyCIuKSAFSg6kA"
      },
      {
        "text": "Try",
        "href": "https://www.typescriptlang.org/play/#code/PTAEAEGcAsHsHcCiBbAlgFwLACgQWbACYCuANgKYBco5kATAAyM57gB2siATl7F5DlTIADn3SgA3qABuAQ1LFyAeQBmABVSgAvqBW9koAEQA6YAGNYbSOllt0kYwCtIhgNw4c5AB6iu4i1bi6PCwGqAAvDLyiqphAFSgdK5AA"
      },
      {
        "text": "Try",
        "href": "https://www.typescriptlang.org/play/#code/PTAEAEGcAsHsHcCiBbAlgFwLACgQWbACYCuANgKYBcoAxrMgQHYBWkOe4jsiATj7DzbZUyAA4D0oAN6gAbgENSxcgHkAZgAVUoAL6g1-ZKABEAOmB1GkdPMbpIp1sYDcOHOQAe4npMvXQ6PCwWqAAvHKKyuohAFSgAEzOQA"
      },
      {
        "text": "Try",
        "href": "https://www.typescriptlang.org/play/#code/PTAEAEGcAsHsHcCiBbAlgFwLACgQWbACYCuANgKYBcoxyhOe4AdrIgE5uxuQ6rIAOXdKADeoAG4BDUsXIB5AGYAFVKAC+oBZ2SgARADpgAY1hNI6SU3SR9AK0i6A3DhzkAHoLbCTZ4eniwKqAAvBLSsopBAFSgAEyOQA"
      },
      {
        "text": "TSConfig Reference for module",
        "href": "/tsconfig#module"
      },
      {
        "text": "in DefinitelyTyped",
        "href": "https://github.com/DefinitelyTyped/DefinitelyTyped"
      },
      {
        "text": "the namespaces reference page",
        "href": "/docs/handbook/namespaces.html"
      }
    ],
    "meta": {
      "description": "How JavaScript handles communicating across file boundaries.",
      "keywords": ""
    },
    "summary": "JavaScript has a long history of different ways to handle modularizing code",
    "tags": [
      "react",
      "angular",
      "javascript",
      "typescript",
      "html",
      "node",
      "webpack",
      "vite",
      "module",
      "syntax"
    ],
    "id": "typescript-documentation-moduleshtml-part-1",
    "quality": 100
  }
]