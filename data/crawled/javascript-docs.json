[
  {
    "title": "async function",
    "url": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Statements/async_function",
    "category": "javascript",
    "content": "async function Baseline Widely available This feature is well established and works across many devices and browser versions. Its been available across browsers since April 2017. Learn more See full compatibility Report feedback The async function declaration creates a binding of a new async function to a given name. The await keyword is permitted within the function body, enabling asynchronous, promise-based behavior to be written in a cleaner style and avoiding the need to explicitly configure promise chains. You can also define async functions using the async function expression. Try it Syntax Note: There cannot be a line terminator between async and function, otherwise a semicolon is automatically inserted, causing async to become an identifier and the rest to become a function declaration. Parameters name The function's name. param Optional The name of a formal parameter for the function. For the parameters' syntax, see the Functions reference. statements Optional The statements comprising the body of the function. The await mechanism may be used. Description An async function declaration creates an AsyncFunction object. Each time when an async function is called, it returns a new Promise which will be resolved with the value returned by the async function, or rejected with an exception uncaught within the async function. Async functions can contain zero or more await expressions. Await expressions make promise-returning functions behave as though they're synchronous by suspending execution until the returned promise is fulfilled or rejected. The resolved value of the promise is treated as the return value of the await expression. Use of async and await enables the use of ordinary try / catch blocks around asynchronous code. Note: The await keyword is only valid inside async functions within regular JavaScript code. If you use it outside of an async function's body, you will get a SyntaxError. await can be used on its own with JavaScript modules. Note: The purpose of async/await is to simplify the syntax necessary to consume promise-based APIs. The behavior of async/await is similar to combining generators and promises. Async functions always return a promise. If the return value of an async function is not explicitly a promise, it will be implicitly wrapped in a promise. For example, consider the following code: It is similar to: Note that even though the return value of an async function behaves as if it's wrapped in a Promise.resolve, they are not equivalent. An async function will return a different reference, whereas Promise.resolve returns the same reference if the given value is a promise. It can be a problem when you want to check the equality of a promise and a return value of an async function. The body of an async function can be thought of as being split by zero or more await expressions. Top-level code, up to and including the first await expression (if there is one), is run synchronously. In this way, an async function without an await expression will run synchronously. If there is an await expression inside the function body, however, the async function will always complete asynchronously. For example: It is also equivalent to: Code after each await expression can be thought of as existing in a .then callback. In this way a promise chain is progressively constructed with each reentrant step through the function. The return value forms the final link in the chain. In the following example, we successively await two promises. Progress moves through function foo in three stages. The first line of the body of function foo is executed synchronously, with the await expression configured with the pending promise. Progress through foo is then suspended and control is yielded back to the function that called foo. Some time later, when the first promise has either been fulfilled or rejected, control moves back into foo. The result of the first promise fulfillment (if it was not rejected) is returned from the await expression. Here 1 is assigned to result1. Progress continues, and the second await expression is evaluated. Again, progress through foo is suspended and control is yielded. Some time later, when the second promise has either been fulfilled or rejected, control re-enters foo. The result of the second promise resolution is returned from the second await expression. Here 2 is assigned to result2. Control moves to the return expression (if any). The default return value of undefined is returned as the resolution value of the current promise. Note how the promise chain is not built-up in one go. Instead, the promise chain is constructed in stages as control is successively yielded from and returned to the async function. As a result, we must be mindful of error handling behavior when dealing with concurrent asynchronous operations. For example, in the following code an unhandled promise rejection error will be thrown, even if a .catch handler has been configured further along the promise chain. This is because p2 will not be \"wired into\" the promise chain until control returns from p1. async function declarations behave similar to function declarations  they are hoisted to the top of their scope and can be called anywhere in their scope, and they can be redeclared only in certain contexts. Examples Async functions and execution order await and concurrency In sequentialStart, execution suspends 2 seconds for the first await, and then another second for the second await. The second timer is not created until the first has already fired, so the code finishes after 3 seconds. In sequentialWait, both timers are created and then awaited. The timers run concurrently, which means the code finishes in 2 rather than 3 seconds, i.e., the slowest timer. However, the await calls still run in series, which means the second await will wait for the first one to finish. In this case, the result of the fastest timer is processed after the slowest. If you wish to safely perform other jobs after two or more jobs run concurrently and are complete, you must await a call to Promise.all() or Promise.allSettled() before that job. Warning: The functions sequentialWait and concurrent1 are not functionally equivalent. In sequentialWait, if promise fast rejects before promise slow is fulfilled, then an unhandled promise rejection error will be raised, regardless of whether the caller has configured a catch clause. In concurrent1, Promise.all wires up the promise chain in one go, meaning that the operation will fail-fast regardless of the order of rejection of the promises, and the error will always occur within the configured promise chain, enabling it to be caught in the normal way. Rewriting a Promise chain with an async function An API that returns a Promise will result in a promise chain, and it splits the function into many parts. Consider the following code: it can be rewritten with a single async function as follows: Alternatively, you can chain the promise with catch(): In the two rewritten versions, notice there is no await statement after the return keyword, although that would be valid too: The return value of an async function is implicitly wrapped in Promise.resolve - if it's not already a promise itself (as in the examples). Specifications Specification ECMAScript 2026 Language Specification# sec-async-function-definitions Browser compatibility See also Functions guide Using promises guide Functions AsyncFunction async function expression function function* async function* await Promise Decorating async JavaScript functions on innolitics.com (2016) Help improve MDN Learn how to contribute This page was last modified on Jul 8, 2025 by MDN contributors. View this page on GitHub  Report a problem with this content",
    "headings": [
      {
        "level": 1,
        "text": "async function",
        "id": ""
      },
      {
        "level": 2,
        "text": "Try it",
        "id": "try_it"
      },
      {
        "level": 2,
        "text": "Syntax",
        "id": "syntax"
      },
      {
        "level": 2,
        "text": "Description",
        "id": "description"
      },
      {
        "level": 2,
        "text": "Examples",
        "id": "examples"
      },
      {
        "level": 2,
        "text": "Specifications",
        "id": "specifications"
      },
      {
        "level": 2,
        "text": "Browser compatibility",
        "id": "browser_compatibility"
      },
      {
        "level": 2,
        "text": "See also",
        "id": "see_also"
      },
      {
        "level": 2,
        "text": "Help improve MDN",
        "id": "feedback"
      },
      {
        "level": 3,
        "text": "Parameters",
        "id": "parameters"
      },
      {
        "level": 3,
        "text": "Async functions and execution order",
        "id": "async_functions_and_execution_order"
      },
      {
        "level": 3,
        "text": "Rewriting a Promise chain with an async function",
        "id": "rewriting_a_promise_chain_with_an_async_function"
      },
      {
        "level": 4,
        "text": "await and concurrency",
        "id": "await_and_concurrency"
      }
    ],
    "codeBlocks": [
      {
        "language": "text",
        "code": "async function"
      },
      {
        "language": "text",
        "code": "async function"
      },
      {
        "language": "text",
        "code": "async function"
      },
      {
        "language": "text",
        "code": "AsyncFunction"
      },
      {
        "language": "text",
        "code": "SyntaxError"
      },
      {
        "language": "text",
        "code": "Promise.resolve"
      },
      {
        "language": "text",
        "code": "Promise.resolve"
      },
      {
        "language": "text",
        "code": "async function"
      },
      {
        "language": "text",
        "code": "sequentialStart"
      },
      {
        "language": "text",
        "code": "sequentialWait"
      },
      {
        "language": "text",
        "code": "Promise.all()"
      },
      {
        "language": "text",
        "code": "Promise.allSettled()"
      },
      {
        "language": "text",
        "code": "sequentialWait"
      },
      {
        "language": "text",
        "code": "concurrent1"
      },
      {
        "language": "text",
        "code": "sequentialWait"
      },
      {
        "language": "text",
        "code": "concurrent1"
      },
      {
        "language": "text",
        "code": "Promise.all"
      },
      {
        "language": "text",
        "code": "Promise.resolve"
      },
      {
        "language": "text",
        "code": "AsyncFunction"
      },
      {
        "language": "text",
        "code": "async function"
      },
      {
        "language": "text",
        "code": "async function*"
      }
    ],
    "links": [
      {
        "text": "Learn more",
        "href": "/en-US/docs/Glossary/Baseline/Compatibility"
      },
      {
        "text": "Report feedback",
        "href": "https://survey.alchemer.com/s3/7634825/MDN-baseline-feedback?page=%2Fen-US%2Fdocs%2FWeb%2FJavaScript%2FReference%2FStatements%2Fasync_function&level=high"
      },
      {
        "text": "binding",
        "href": "/en-US/docs/Glossary/Binding"
      },
      {
        "text": "async function expression",
        "href": "/en-US/docs/Web/JavaScript/Reference/Operators/async_function"
      },
      {
        "text": "automatically inserted",
        "href": "/en-US/docs/Web/JavaScript/Reference/Lexical_grammar#automatic_semicolon_insertion"
      },
      {
        "text": "Functions reference",
        "href": "/en-US/docs/Web/JavaScript/Guide/Functions#function_parameters"
      },
      {
        "text": "AsyncFunction",
        "href": "/en-US/docs/Web/JavaScript/Reference/Global_Objects/AsyncFunction"
      },
      {
        "text": "Promise",
        "href": "/en-US/docs/Web/JavaScript/Reference/Global_Objects/Promise"
      },
      {
        "text": "await",
        "href": "/en-US/docs/Web/JavaScript/Reference/Operators/await"
      },
      {
        "text": "SyntaxError",
        "href": "/en-US/docs/Web/JavaScript/Reference/Global_Objects/SyntaxError"
      },
      {
        "text": "JavaScript modules.",
        "href": "/en-US/docs/Web/JavaScript/Guide/Modules"
      },
      {
        "text": "generators",
        "href": "/en-US/docs/Web/JavaScript/Guide/Iterators_and_generators"
      },
      {
        "text": "function",
        "href": "/en-US/docs/Web/JavaScript/Reference/Statements/function"
      },
      {
        "text": "hoisted",
        "href": "/en-US/docs/Glossary/Hoisting"
      },
      {
        "text": "Promise.all()",
        "href": "/en-US/docs/Web/JavaScript/Reference/Global_Objects/Promise/all"
      },
      {
        "text": "Promise.allSettled()",
        "href": "/en-US/docs/Web/JavaScript/Reference/Global_Objects/Promise/allSettled"
      },
      {
        "text": "Promise",
        "href": "/en-US/docs/Web/JavaScript/Reference/Global_Objects/Promise"
      },
      {
        "text": "Promise.resolve",
        "href": "/en-US/docs/Web/JavaScript/Reference/Global_Objects/Promise/resolve"
      },
      {
        "text": "ECMAScript® 2026 Language Specification# sec-async-function-definitions",
        "href": "https://tc39.es/ecma262/multipage/ecmascript-language-functions-and-classes.html#sec-async-function-definitions"
      },
      {
        "text": "Functions",
        "href": "/en-US/docs/Web/JavaScript/Guide/Functions"
      },
      {
        "text": "Using promises",
        "href": "/en-US/docs/Web/JavaScript/Guide/Using_promises"
      },
      {
        "text": "Functions",
        "href": "/en-US/docs/Web/JavaScript/Reference/Functions"
      },
      {
        "text": "AsyncFunction",
        "href": "/en-US/docs/Web/JavaScript/Reference/Global_Objects/AsyncFunction"
      },
      {
        "text": "async function expression",
        "href": "/en-US/docs/Web/JavaScript/Reference/Operators/async_function"
      },
      {
        "text": "function",
        "href": "/en-US/docs/Web/JavaScript/Reference/Statements/function"
      },
      {
        "text": "function*",
        "href": "/en-US/docs/Web/JavaScript/Reference/Statements/function*"
      },
      {
        "text": "async function*",
        "href": "/en-US/docs/Web/JavaScript/Reference/Statements/async_function*"
      },
      {
        "text": "await",
        "href": "/en-US/docs/Web/JavaScript/Reference/Operators/await"
      },
      {
        "text": "Promise",
        "href": "/en-US/docs/Web/JavaScript/Reference/Global_Objects/Promise"
      },
      {
        "text": "Decorating async JavaScript functions",
        "href": "https://innolitics.com/10x/javascript-decorators-for-promise-returning-functions/"
      },
      {
        "text": "Learn how to contribute",
        "href": "/en-US/docs/MDN/Community/Getting_started"
      },
      {
        "text": "MDN contributors",
        "href": "/en-US/docs/Web/JavaScript/Reference/Statements/async_function/contributors.txt"
      },
      {
        "text": "View this page on GitHub",
        "href": "https://github.com/mdn/content/blob/main/files/en-us/web/javascript/reference/statements/async_function/index.md?plain=1"
      },
      {
        "text": "Report a problem with this content",
        "href": "https://github.com/mdn/content/issues/new?template=page-report.yml&mdn-url=https%3A%2F%2Fdeveloper.mozilla.org%2Fen-US%2Fdocs%2FWeb%2FJavaScript%2FReference%2FStatements%2Fasync_function&metadata=%3C%21--+Do+not+make+changes+below+this+line+--%3E%0A%3Cdetails%3E%0A%3Csummary%3EPage+report+details%3C%2Fsummary%3E%0A%0A*+Folder%3A+%60en-us%2Fweb%2Fjavascript%2Freference%2Fstatements%2Fasync_function%60%0A*+MDN+URL%3A+https%3A%2F%2Fdeveloper.mozilla.org%2Fen-US%2Fdocs%2FWeb%2FJavaScript%2FReference%2FStatements%2Fasync_function%0A*+GitHub+URL%3A+https%3A%2F%2Fgithub.com%2Fmdn%2Fcontent%2Fblob%2Fmain%2Ffiles%2Fen-us%2Fweb%2Fjavascript%2Freference%2Fstatements%2Fasync_function%2Findex.md%0A*+Last+commit%3A+https%3A%2F%2Fgithub.com%2Fmdn%2Fcontent%2Fcommit%2Ffad67be4431d8e6c2a89ac880735233aa76c41d4%0A*+Document+last+modified%3A+2025-07-08T13%3A18%3A45.000Z%0A%0A%3C%2Fdetails%3E"
      }
    ],
    "meta": {
      "description": "The async function declaration creates a binding of a new async function to a given name. The await keyword is permitted within the function body, enabling asynchronous, promise-based behavior to be written in a cleaner style and avoiding the need to explicitly configure promise chains.",
      "keywords": ""
    },
    "summary": "async function Baseline Widely available This feature is well established and works across many devices and browser versions. Its been available across browsers since April 2017",
    "tags": [
      "react",
      "angular",
      "javascript",
      "typescript",
      "css",
      "html",
      "node",
      "vite",
      "async",
      "function"
    ],
    "id": "async-function-async_function-part-1",
    "quality": 100
  },
  {
    "title": "Promise",
    "url": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Promise",
    "category": "javascript",
    "content": "Promise Baseline Widely available * This feature is well established and works across many devices and browser versions. Its been available across browsers since July 2015. * Some parts of this feature may have varying levels of support. Learn more See full compatibility Report feedback The Promise object represents the eventual completion (or failure) of an asynchronous operation and its resulting value. To learn about the way promises work and how you can use them, we advise you to read Using promises first. Description A Promise is a proxy for a value not necessarily known when the promise is created. It allows you to associate handlers with an asynchronous action's eventual success value or failure reason. This lets asynchronous methods return values like synchronous methods: instead of immediately returning the final value, the asynchronous method returns a promise to supply the value at some point in the future. A Promise is in one of these states: pending: initial state, neither fulfilled nor rejected. fulfilled: meaning that the operation was completed successfully. rejected: meaning that the operation failed. The eventual state of a pending promise can either be fulfilled with a value or rejected with a reason (error). When either of these options occur, the associated handlers queued up by a promise's then method are called. If the promise has already been fulfilled or rejected when a corresponding handler is attached, the handler will be called, so there is no race condition between an asynchronous operation completing and its handlers being attached. A promise is said to be settled if it is either fulfilled or rejected, but not pending. You will also hear the term resolved used with promises  this means that the promise is settled or \"locked-in\" to match the eventual state of another promise, and further resolving or rejecting it has no effect. The States and fates document from the original Promise proposal contains more details about promise terminology. Colloquially, \"resolved\" promises are often equivalent to \"fulfilled\" promises, but as illustrated in \"States and fates\", resolved promises can be pending or rejected as well. For example: This promise is already resolved at the time when it's created (because the resolveOuter is called synchronously), but it is resolved with another promise, and therefore won't be fulfilled until 1 second later, when the inner promise fulfills. In practice, the \"resolution\" is often done behind the scenes and not observable, and only its fulfillment or rejection are. Note: Several other languages have mechanisms for lazy evaluation and deferring a computation, which they also call \"promises\", e.g., Scheme. Promises in JavaScript represent processes that are already happening, which can be chained with callback functions. If you are looking to lazily evaluate an expression, consider using a function with no arguments e.g., f = () = expression to create the lazily-evaluated expression, and f() to evaluate the expression immediately. Promise itself has no first-class protocol for cancellation, but you may be able to directly cancel the underlying asynchronous operation, typically using AbortController. Chained Promises The promise methods then(), catch(), and finally() are used to associate further action with a promise that becomes settled. The then() method takes up to two arguments; the first argument is a callback function for the fulfilled case of the promise, and the second argument is a callback function for the rejected case. The catch() and finally() methods call then() internally and make error handling less verbose. For example, a catch() is really just a then() without passing the fulfillment handler. As these methods return promises, they can be chained. For example: We will use the following terminology: initial promise is the promise on which then is called; new promise is the promise returned by then. The two callbacks passed to then are called fulfillment handler and rejection handler, respectively. The settled state of the initial promise determines which handler to execute. If the initial promise is fulfilled, the fulfillment handler is called with the fulfillment value. If the initial promise is rejected, the rejection handler is called with the rejection reason. The completion of the handler determines the settled state of the new promise. If the handler returns a thenable value, the new promise settles in the same state as the returned value. If the handler returns a non-thenable value, the new promise is fulfilled with the returned value. If the handler throws an error, the new promise is rejected with the thrown error. If the initial promise has no corresponding handler attached, the new promise will settle to the same state as the initial promise  that is, without a rejection handler, a rejected promise stays rejected with the same reason. For example, in the code above, if myPromise rejects, handleRejectedA will be called, and if handleRejectedA completes normally (without throwing or returning a rejected promise), the promise returned by the first then will be fulfilled instead of staying rejected. Therefore, if an error must be handled immediately, but we want to maintain the error state down the chain, we must throw an error of some type in the rejection handler. On the other hand, in the absence of an immediate need, we can leave out error handling until the final catch() handler. Using arrow functions for the callback functions, implementation of the promise chain might look something like this: Note: For faster execution, all synchronous actions should preferably be done within one handler, otherwise it would take several ticks to execute all handlers in sequence. JavaScript maintains a job queue. Each time, JavaScript picks a job from the queue and executes it to completion. The jobs are defined by the executor of the Promise() constructor, the handlers passed to then, or any platform API that returns a promise. The promises in a chain represent the dependency relationship between these jobs. When a promise settles, the respective handlers associated with it are added to the back of the job queue. A promise can participate in more than one chain. For the following code, the fulfillment of promiseA will cause both handleFulfilled1 and handleFulfilled2 to be added to the job queue. Because handleFulfilled1 is registered first, it will be invoked first. An action can be assigned to an already settled promise. In this case, the action is added immediately to the back of the job queue and will be performed when all existing jobs are completed. Therefore, an action for an already \"settled\" promise will occur only after the current synchronous code completes and at least one loop-tick has passed. This guarantees that promise actions are asynchronous. Thenables The JavaScript ecosystem had made multiple Promise implementations long before it became part of the language. Despite being represented differently internally, at the minimum, all Promise-like objects implement the Thenable interface. A thenable implements the .then() method, which is called with two callbacks: one for when the promise is fulfilled, one for when it's rejected. Promises are thenables as well. To interoperate with the existing Promise implementations, the language allows using thenables in place of promises. For example, Promise.resolve will not only resolve promises, but also trace thenables. Promise concurrency The Promise class offers four static methods to facilitate async task concurrency: Promise.all() Fulfills when all of the promises fulfill; rejects when any of the promises rejects. Promise.allSettled() Fulfills when all promises settle. Promise.any() Fulfills when any of the promises fulfills; rejects when all of the promises reject. Promise.race() Settles when any of the promises settles. In other words, fulfills when any of the promises fulfills; rejects when any of the promises rejects. All these methods take an iterable of promises (thenables, to be exact) and return a new promise. They all support subclassing, which means they can be called on subclasses of Promise, and the result will be a promise of the subclass type. To do so, the subclass's constructor must implement the same signature as the Promise() constructor  accepting a single executor function that can be called with the resolve and reject callbacks as parameters. The subclass must also have a resolve static method that can be called like Promise.resolve() to resolve values to promises. Note that JavaScript is single-threaded by nature, so at a given instant, only one task will be executing, although control can shift between different promises, making execution of the promises appear concurrent. Parallel execution in JavaScript can only be achieved through worker threads. Constructor Promise() Creates a new Promise object. The constructor is primarily used to wrap functions that do not already support promises. Static properties Promise[Symbol.species] Returns the constructor used to construct return values from promise methods. Static methods Promise.all() Takes an iterable of promises as input and returns a single Promise. This returned promise fulfills when all of the input's promises fulfill (including when an empty iterable is passed), with an array of the fulfillment values. It rejects when any of the input's promises reject, with this first rejection reason. Promise.allSettled() Takes an iterable of promises as input and returns a single Promise. This returned promise fulfills when all of the input's promises settle (including when an empty iterable is passed), with an array of objects that describe the outcome of each promise. Promise.any() Takes an iterable of promises as input and returns a single Promise. This returned promise fulfills when any of the input's promises fulfill, with this first fulfillment value. It rejects when all of the input's promises reject (including when an empty iterable is passed), with an AggregateError containing an array of rejection reasons. Promise.race() Takes an iterable of promises as input and returns a single Promise. This returned promise settles with the eventual state of the first promise that settles. Promise.reject() Returns a new Promise object that is rejected with the given reason. Promise.resolve() Returns a Promise object that is resolved with the given value. If the value is a thenable (i.e., has a then method), the returned promise will \"follow\" that thenable, adopting its eventual state; otherwise, the returned promise will be fulfilled with the value. Promise.try() Takes a callback of any kind (returns or throws, synchronously or asynchronously) and wraps its result in a Promise. Promise.withResolvers() Returns an object containing a new Promise object and two functions to resolve or reject it, corresponding to the two parameters passed to the executor of the Promise() constructor. Instance properties These properties are defined on Promise.prototype and shared by all Promise instances. Promise.prototype.constructor The constructor function that created the instance object. For Promise instances, the initial value is the Promise constructor. Promise.prototype[Symbol.toStringTag] The initial value of the [Symbol.toStringTag] property is the string \"Promise\". This property is used in Object.prototype.toString(). Instance methods Promise.prototype.catch() Appends a rejection handler callback to the promise, and returns a new promise resolving to the return value of the callback if it is called, or to its original fulfillment value if the promise is instead fulfilled. Promise.prototype.finally() Appends a handler to the promise, and returns a new promise that is resolved when the original promise is resolved. The handler is called when the promise is settled, whether fulfilled or rejected. Promise.prototype.then() Appends fulfillment and rejection handlers to the promise, and returns a new promise resolving to the return value of the called handler, or to its original settled value if the promise was not handled (i.e., if the relevant handler onFulfilled or onRejected is not a function). Examples Basic Example In this example, we use setTimeout(...) to simulate async code. In reality, you will probably be using something like XHR or an HTML API. Example with diverse situations This example shows diverse techniques for using Promise capabilities and diverse situations that can occur. To understand this, start by scrolling to the bottom of the code block, and examine the promise chain. Upon provision of an initial promise, a chain of promises can follow. The chain is composed of .then() calls, and typically (but not necessarily) has a single .catch() at the end, optionally followed by .finally(). In this example, the promise chain is initiated by a custom-written new Promise() construct; but in actual practice, promise chains more typically start with an API function (written by someone else) that returns a promise. The example function tetheredGetNumber() shows that a promise generator will utilize reject() while setting up an asynchronous call, or within the call-back, or both. The function promiseGetWord() illustrates how an API function might generate and return a promise in a self-contained manner. Note that the function troubleWithGetNumber() ends with a throw. That is forced because a promise chain goes through all the .then() promises, even after an error, and without the throw, the error would seem \"fixed\". This is a hassle, and for this reason, it is common to omit onRejected throughout the chain of .then() promises, and just have a single onRejected in the final catch(). This code can be run under NodeJS. Comprehension is enhanced by seeing the errors actually occur. To force more errors, change the threshold values. Advanced Example This small example shows the mechanism of a Promise. The testPromise() method is called each time the button is clicked. It creates a promise that will be fulfilled, using setTimeout(), to the promise count (number starting from 1) every 1-3 seconds, at random. The Promise() constructor is used to create the promise. The fulfillment of the promise is logged, via a fulfill callback set using p1.then(). A few logs show how the synchronous part of the method is decoupled from the asynchronous completion of the promise. By clicking the button several times in a short amount of time, you'll even see the different promises being fulfilled one after another. HTML JavaScript Result Loading an image with XHR Another example using Promise and XMLHttpRequest to load an image is shown below. Each step is commented on and allows you to follow the Promise and XHR architecture closely. Incumbent settings object tracking A settings object is an environment that provides additional information when JavaScript code is running. This includes the realm and module map, as well as HTML specific information such as the origin. The incumbent settings object is tracked in order to ensure that the browser knows which one to use for a given piece of user code. To better picture this, we can take a closer look at how the realm might be an issue. A realm can be roughly thought of as the global object. What is unique about realms is that they hold all of the necessary information to run JavaScript code. This includes objects like Array and Error. Each settings object has its own \"copy\" of these and they are not shared. That can cause some unexpected behavior in relation to promises. In order to get around this, we track something called the incumbent settings object. This represents information specific to the context of the user code responsible for a certain function call. To illustrate this a bit further we can take a look at how an iframe embedded in a document communicates with its host. Since all web APIs are aware of the incumbent settings object, the following will work in all browsers: The same concept applies to promises. If we modify the above example a little bit, we get this: If we change this so that the iframe in the document is listening to post messages, we can observe the effect of the incumbent settings object: In the above example, the inner text of the iframe will be updated only if the incumbent settings object is tracked. This is because without tracking the incumbent, we may end up using the wrong environment to send the message. Note: Currently, incumbent realm tracking is fully implemented in Firefox, and has partial implementations in Chrome and Safari. Specifications Specification ECMAScript 2026 Language Specification# sec-promise-objects Browser compatibility See also Polyfill of Promise in core-js Using promises guide Promises/A+ specification JavaScript Promises: an introduction on web.dev (2013) Callbacks, Promises, and Coroutines: Asynchronous Programming Patterns in JavaScript slide show by Domenic Denicola (2011) Help improve MDN Learn how to contribute This page was last modified on Aug 19, 2025 by MDN contributors. View this page on GitHub  Report a problem with this content",
    "headings": [
      {
        "level": 1,
        "text": "Promise",
        "id": ""
      },
      {
        "level": 2,
        "text": "Description",
        "id": "description"
      },
      {
        "level": 2,
        "text": "Constructor",
        "id": "constructor"
      },
      {
        "level": 2,
        "text": "Static properties",
        "id": "static_properties"
      },
      {
        "level": 2,
        "text": "Static methods",
        "id": "static_methods"
      },
      {
        "level": 2,
        "text": "Instance properties",
        "id": "instance_properties"
      },
      {
        "level": 2,
        "text": "Instance methods",
        "id": "instance_methods"
      },
      {
        "level": 2,
        "text": "Examples",
        "id": "examples"
      },
      {
        "level": 2,
        "text": "Specifications",
        "id": "specifications"
      },
      {
        "level": 2,
        "text": "Browser compatibility",
        "id": "browser_compatibility"
      },
      {
        "level": 2,
        "text": "See also",
        "id": "see_also"
      },
      {
        "level": 2,
        "text": "Help improve MDN",
        "id": "feedback"
      },
      {
        "level": 3,
        "text": "Chained Promises",
        "id": "chained_promises"
      },
      {
        "level": 3,
        "text": "Thenables",
        "id": "thenables"
      },
      {
        "level": 3,
        "text": "Promise concurrency",
        "id": "promise_concurrency"
      },
      {
        "level": 3,
        "text": "Basic Example",
        "id": "basic_example"
      },
      {
        "level": 3,
        "text": "Example with diverse situations",
        "id": "example_with_diverse_situations"
      },
      {
        "level": 3,
        "text": "Advanced Example",
        "id": "advanced_example"
      },
      {
        "level": 3,
        "text": "Loading an image with XHR",
        "id": "loading_an_image_with_xhr"
      },
      {
        "level": 3,
        "text": "Incumbent settings object tracking",
        "id": "incumbent_settings_object_tracking"
      },
      {
        "level": 4,
        "text": "HTML",
        "id": "html"
      },
      {
        "level": 4,
        "text": "JavaScript",
        "id": "javascript"
      },
      {
        "level": 4,
        "text": "Result",
        "id": "result"
      }
    ],
    "codeBlocks": [
      {
        "language": "text",
        "code": "resolveOuter"
      },
      {
        "language": "text",
        "code": "f = () => expression"
      },
      {
        "language": "text",
        "code": "AbortController"
      },
      {
        "language": "text",
        "code": "handleRejectedA"
      },
      {
        "language": "text",
        "code": "handleRejectedA"
      },
      {
        "language": "text",
        "code": "handleFulfilled1"
      },
      {
        "language": "text",
        "code": "handleFulfilled2"
      },
      {
        "language": "text",
        "code": "handleFulfilled1"
      },
      {
        "language": "text",
        "code": "Promise.resolve"
      },
      {
        "language": "text",
        "code": "Promise.all()"
      },
      {
        "language": "text",
        "code": "Promise.allSettled()"
      },
      {
        "language": "text",
        "code": "Promise.any()"
      },
      {
        "language": "text",
        "code": "Promise.race()"
      },
      {
        "language": "text",
        "code": "Promise.resolve()"
      },
      {
        "language": "text",
        "code": "Promise[Symbol.species]"
      },
      {
        "language": "text",
        "code": "Promise.all()"
      },
      {
        "language": "text",
        "code": "Promise.allSettled()"
      },
      {
        "language": "text",
        "code": "Promise.any()"
      },
      {
        "language": "text",
        "code": "AggregateError"
      },
      {
        "language": "text",
        "code": "Promise.race()"
      },
      {
        "language": "text",
        "code": "Promise.reject()"
      },
      {
        "language": "text",
        "code": "Promise.resolve()"
      },
      {
        "language": "text",
        "code": "Promise.try()"
      },
      {
        "language": "text",
        "code": "Promise.withResolvers()"
      },
      {
        "language": "text",
        "code": "Promise.prototype"
      },
      {
        "language": "text",
        "code": "Promise.prototype.constructor"
      },
      {
        "language": "text",
        "code": "Promise.prototype[Symbol.toStringTag]"
      },
      {
        "language": "text",
        "code": "[Symbol.toStringTag]"
      },
      {
        "language": "text",
        "code": "Object.prototype.toString()"
      },
      {
        "language": "text",
        "code": "Promise.prototype.catch()"
      },
      {
        "language": "text",
        "code": "Promise.prototype.finally()"
      },
      {
        "language": "text",
        "code": "Promise.prototype.then()"
      },
      {
        "language": "text",
        "code": "onFulfilled"
      },
      {
        "language": "text",
        "code": "setTimeout(...)"
      },
      {
        "language": "text",
        "code": "new Promise()"
      },
      {
        "language": "text",
        "code": "tetheredGetNumber()"
      },
      {
        "language": "text",
        "code": "promiseGetWord()"
      },
      {
        "language": "text",
        "code": "troubleWithGetNumber()"
      },
      {
        "language": "text",
        "code": "testPromise()"
      },
      {
        "language": "text",
        "code": "setTimeout()"
      },
      {
        "language": "text",
        "code": "XMLHttpRequest"
      }
    ],
    "links": [
      {
        "text": "Learn more",
        "href": "/en-US/docs/Glossary/Baseline/Compatibility"
      },
      {
        "text": "Report feedback",
        "href": "https://survey.alchemer.com/s3/7634825/MDN-baseline-feedback?page=%2Fen-US%2Fdocs%2FWeb%2FJavaScript%2FReference%2FGlobal_Objects%2FPromise&level=high"
      },
      {
        "text": "Using promises",
        "href": "/en-US/docs/Web/JavaScript/Guide/Using_promises"
      },
      {
        "text": "States and fates",
        "href": "https://github.com/domenic/promises-unwrapping/blob/master/docs/states-and-fates.md"
      },
      {
        "text": "AbortController",
        "href": "/en-US/docs/Web/API/AbortController"
      },
      {
        "text": "then()",
        "href": "/en-US/docs/Web/JavaScript/Reference/Global_Objects/Promise/then"
      },
      {
        "text": "catch()",
        "href": "/en-US/docs/Web/JavaScript/Reference/Global_Objects/Promise/catch"
      },
      {
        "text": "finally()",
        "href": "/en-US/docs/Web/JavaScript/Reference/Global_Objects/Promise/finally"
      },
      {
        "text": "arrow functions",
        "href": "/en-US/docs/Web/JavaScript/Reference/Functions/Arrow_functions"
      },
      {
        "text": "job queue",
        "href": "/en-US/docs/Web/JavaScript/Reference/Execution_model"
      },
      {
        "text": ".then()",
        "href": "/en-US/docs/Web/JavaScript/Reference/Global_Objects/Promise/then"
      },
      {
        "text": "Promise.resolve",
        "href": "/en-US/docs/Web/JavaScript/Reference/Global_Objects/Promise/resolve"
      },
      {
        "text": "concurrency",
        "href": "https://en.wikipedia.org/wiki/Concurrent_computing"
      },
      {
        "text": "Promise.all()",
        "href": "/en-US/docs/Web/JavaScript/Reference/Global_Objects/Promise/all"
      },
      {
        "text": "Promise.allSettled()",
        "href": "/en-US/docs/Web/JavaScript/Reference/Global_Objects/Promise/allSettled"
      },
      {
        "text": "Promise.any()",
        "href": "/en-US/docs/Web/JavaScript/Reference/Global_Objects/Promise/any"
      },
      {
        "text": "Promise.race()",
        "href": "/en-US/docs/Web/JavaScript/Reference/Global_Objects/Promise/race"
      },
      {
        "text": "iterable",
        "href": "/en-US/docs/Web/JavaScript/Reference/Iteration_protocols#the_iterable_protocol"
      },
      {
        "text": "Promise()",
        "href": "/en-US/docs/Web/JavaScript/Reference/Global_Objects/Promise/Promise"
      },
      {
        "text": "Promise.resolve()",
        "href": "/en-US/docs/Web/JavaScript/Reference/Global_Objects/Promise/resolve"
      },
      {
        "text": "single-threaded",
        "href": "/en-US/docs/Glossary/Thread"
      },
      {
        "text": "Parallel execution",
        "href": "https://en.wikipedia.org/wiki/Parallel_computing"
      },
      {
        "text": "worker threads",
        "href": "/en-US/docs/Web/API/Web_Workers_API"
      },
      {
        "text": "Promise()",
        "href": "/en-US/docs/Web/JavaScript/Reference/Global_Objects/Promise/Promise"
      },
      {
        "text": "Promise[Symbol.species]",
        "href": "/en-US/docs/Web/JavaScript/Reference/Global_Objects/Promise/Symbol.species"
      },
      {
        "text": "Promise.all()",
        "href": "/en-US/docs/Web/JavaScript/Reference/Global_Objects/Promise/all"
      },
      {
        "text": "Promise.allSettled()",
        "href": "/en-US/docs/Web/JavaScript/Reference/Global_Objects/Promise/allSettled"
      },
      {
        "text": "Promise.any()",
        "href": "/en-US/docs/Web/JavaScript/Reference/Global_Objects/Promise/any"
      },
      {
        "text": "AggregateError",
        "href": "/en-US/docs/Web/JavaScript/Reference/Global_Objects/AggregateError"
      },
      {
        "text": "Promise.race()",
        "href": "/en-US/docs/Web/JavaScript/Reference/Global_Objects/Promise/race"
      },
      {
        "text": "Promise.reject()",
        "href": "/en-US/docs/Web/JavaScript/Reference/Global_Objects/Promise/reject"
      },
      {
        "text": "Promise.resolve()",
        "href": "/en-US/docs/Web/JavaScript/Reference/Global_Objects/Promise/resolve"
      },
      {
        "text": "Promise.try()",
        "href": "/en-US/docs/Web/JavaScript/Reference/Global_Objects/Promise/try"
      },
      {
        "text": "Promise.withResolvers()",
        "href": "/en-US/docs/Web/JavaScript/Reference/Global_Objects/Promise/withResolvers"
      },
      {
        "text": "Promise()",
        "href": "/en-US/docs/Web/JavaScript/Reference/Global_Objects/Promise/Promise"
      },
      {
        "text": "Promise.prototype.constructor",
        "href": "/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/constructor"
      },
      {
        "text": "Promise",
        "href": "/en-US/docs/Web/JavaScript/Reference/Global_Objects/Promise/Promise"
      },
      {
        "text": "[Symbol.toStringTag]",
        "href": "/en-US/docs/Web/JavaScript/Reference/Global_Objects/Symbol/toStringTag"
      },
      {
        "text": "Object.prototype.toString()",
        "href": "/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/toString"
      },
      {
        "text": "Promise.prototype.catch()",
        "href": "/en-US/docs/Web/JavaScript/Reference/Global_Objects/Promise/catch"
      },
      {
        "text": "Promise.prototype.finally()",
        "href": "/en-US/docs/Web/JavaScript/Reference/Global_Objects/Promise/finally"
      },
      {
        "text": "Promise.prototype.then()",
        "href": "/en-US/docs/Web/JavaScript/Reference/Global_Objects/Promise/then"
      },
      {
        "text": "<button>",
        "href": "/en-US/docs/Web/HTML/Reference/Elements/button"
      },
      {
        "text": "setTimeout()",
        "href": "/en-US/docs/Web/API/Window/setTimeout"
      },
      {
        "text": "p1.then()",
        "href": "/en-US/docs/Web/JavaScript/Reference/Global_Objects/Promise/then"
      },
      {
        "text": "XMLHttpRequest",
        "href": "/en-US/docs/Web/API/XMLHttpRequest"
      },
      {
        "text": "environment",
        "href": "https://html.spec.whatwg.org/multipage/webappapis.html#environment-settings-object"
      },
      {
        "text": "Array",
        "href": "/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array"
      },
      {
        "text": "Error",
        "href": "/en-US/docs/Web/JavaScript/Reference/Global_Objects/Error"
      },
      {
        "text": "<iframe>",
        "href": "/en-US/docs/Web/HTML/Reference/Elements/iframe"
      },
      {
        "text": "ECMAScript® 2026 Language Specification# sec-promise-objects",
        "href": "https://tc39.es/ecma262/multipage/control-abstraction-objects.html#sec-promise-objects"
      },
      {
        "text": "Polyfill of Promise in core-js",
        "href": "https://github.com/zloirock/core-js#ecmascript-promise"
      },
      {
        "text": "Using promises",
        "href": "/en-US/docs/Web/JavaScript/Guide/Using_promises"
      },
      {
        "text": "Promises/A+ specification",
        "href": "https://promisesaplus.com/"
      },
      {
        "text": "JavaScript Promises: an introduction",
        "href": "https://web.dev/articles/promises"
      },
      {
        "text": "Callbacks, Promises, and Coroutines: Asynchronous Programming Patterns in JavaScript",
        "href": "https://www.slideshare.net/slideshow/callbacks-promises-and-coroutines-oh-my-the-evolution-of-asynchronicity-in-javascript/9953720"
      },
      {
        "text": "Learn how to contribute",
        "href": "/en-US/docs/MDN/Community/Getting_started"
      },
      {
        "text": "MDN contributors",
        "href": "/en-US/docs/Web/JavaScript/Reference/Global_Objects/Promise/contributors.txt"
      },
      {
        "text": "View this page on GitHub",
        "href": "https://github.com/mdn/content/blob/main/files/en-us/web/javascript/reference/global_objects/promise/index.md?plain=1"
      },
      {
        "text": "Report a problem with this content",
        "href": "https://github.com/mdn/content/issues/new?template=page-report.yml&mdn-url=https%3A%2F%2Fdeveloper.mozilla.org%2Fen-US%2Fdocs%2FWeb%2FJavaScript%2FReference%2FGlobal_Objects%2FPromise&metadata=%3C%21--+Do+not+make+changes+below+this+line+--%3E%0A%3Cdetails%3E%0A%3Csummary%3EPage+report+details%3C%2Fsummary%3E%0A%0A*+Folder%3A+%60en-us%2Fweb%2Fjavascript%2Freference%2Fglobal_objects%2Fpromise%60%0A*+MDN+URL%3A+https%3A%2F%2Fdeveloper.mozilla.org%2Fen-US%2Fdocs%2FWeb%2FJavaScript%2FReference%2FGlobal_Objects%2FPromise%0A*+GitHub+URL%3A+https%3A%2F%2Fgithub.com%2Fmdn%2Fcontent%2Fblob%2Fmain%2Ffiles%2Fen-us%2Fweb%2Fjavascript%2Freference%2Fglobal_objects%2Fpromise%2Findex.md%0A*+Last+commit%3A+https%3A%2F%2Fgithub.com%2Fmdn%2Fcontent%2Fcommit%2F79fdc26fea835d65c9361541bb8ab1896f307475%0A*+Document+last+modified%3A+2025-08-19T18%3A15%3A59.000Z%0A%0A%3C%2Fdetails%3E"
      }
    ],
    "meta": {
      "description": "The Promise object represents the eventual completion (or failure) of an asynchronous operation and its resulting value.",
      "keywords": ""
    },
    "summary": "Promise Baseline Widely available * This feature is well established and works across many devices and browser versions. Its been available across browsers since July 2015",
    "tags": [
      "react",
      "angular",
      "javascript",
      "typescript",
      "html",
      "node",
      "vite",
      "promise",
      "description",
      "chained"
    ],
    "id": "promise-Promise-part-1",
    "quality": 90
  },
  {
    "title": "Arrow function expressions",
    "url": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Functions/Arrow_functions",
    "category": "javascript",
    "content": "Arrow function expressions Baseline Widely available This feature is well established and works across many devices and browser versions. Its been available across browsers since September 2016. Learn more See full compatibility Report feedback An arrow function expression is a compact alternative to a traditional function expression, with some semantic differences and deliberate limitations in usage: Arrow functions don't have their own bindings to this, arguments, or super, and should not be used as methods. Arrow functions cannot be used as constructors. Calling them with new throws a TypeError. They also don't have access to the new.target keyword. Arrow functions cannot use yield within their body and cannot be created as generator functions. Try it Syntax Rest parameters, default parameters, and destructuring within params are supported, and always require parentheses: Arrow functions can be async by prefixing the expression with the async keyword. Description Let's decompose a traditional anonymous function down to the simplest arrow function step-by-step. Each step along the way is a valid arrow function. Note: Traditional function expressions and arrow functions have more differences than their syntax. We will introduce their behavior differences in more detail in the next few subsections. In the example above, both the parentheses around the parameter and the braces around the function body may be omitted. However, they can only be omitted in certain cases. The parentheses can only be omitted if the function has a single simple parameter. If it has multiple parameters, no parameters, or default, destructured, or rest parameters, the parentheses around the parameter list are required. The braces can only be omitted if the function directly returns an expression. If the body has statements, the braces are required  and so is the return keyword. Arrow functions cannot guess what or when you want to return. Arrow functions are not inherently associated with a name. If the arrow function needs to call itself, use a named function expression instead. You can also assign the arrow function to a variable, allowing you to refer to it through that variable. Function body Arrow functions can have either an expression body or the usual block body. In an expression body, only a single expression is specified, which becomes the implicit return value. In a block body, you must use an explicit return statement. Returning object literals using the expression body syntax (params) = { object: literal } does not work as expected. This is because JavaScript only sees the arrow function as having an expression body if the token following the arrow is not a left brace, so the code inside braces ({}) is parsed as a sequence of statements, where foo is a label, not a key in an object literal. To fix this, wrap the object literal in parentheses: Cannot be used as methods Arrow function expressions should only be used for non-method functions because they do not have their own this. Let's see what happens when we try to use them as methods: Another example involving Object.defineProperty(): Because a class's body has a this context, arrow functions as class fields close over the class's this context, and the this inside the arrow function's body will correctly point to the instance (or the class itself, for static fields). However, because it is a closure, not the function's own binding, the value of this will not change based on the execution context. Arrow function properties are often said to be \"auto-bound methods\", because the equivalent with normal methods is: Note: Class fields are defined on the instance, not on the prototype, so every instance creation would create a new function reference and allocate a new closure, potentially leading to more memory usage than a normal unbound method. For similar reasons, the call(), apply(), and bind() methods are not useful when called on arrow functions, because arrow functions establish this based on the scope the arrow function is defined within, and the this value does not change based on how the function is invoked. No binding of arguments Arrow functions do not have their own arguments object. Thus, in this example, arguments is a reference to the arguments of the enclosing scope: In most cases, using rest parameters is a good alternative to using an arguments object. Cannot be used as constructors Arrow functions cannot be used as constructors and will throw an error when called with new. They also do not have a prototype property. Cannot be used as generators The yield keyword cannot be used in an arrow function's body (except when used within generator functions further nested within the arrow function). As a consequence, arrow functions cannot be used as generators. Line break before arrow An arrow function cannot contain a line break between its parameters and its arrow. For the purpose of formatting, you may put the line break after the arrow or use parentheses/braces around the function body, as shown below. You can also put line breaks between parameters. Precedence of arrow Although the arrow in an arrow function is not an operator, arrow functions have special parsing rules that interact differently with operator precedence compared to regular functions. Because = has a lower precedence than most operators, parentheses are necessary to avoid callback  () being parsed as the arguments list of the arrow function. Examples Using arrow functions Using call, bind, and apply The call(), apply(), and bind() methods work as expected with traditional functions, because we establish the scope for each of the methods: With arrow functions, since our add function is essentially created on the globalThis (global) scope, it will assume this is the globalThis. Perhaps the greatest benefit of using arrow functions is with methods like setTimeout() and EventTarget.prototype.addEventListener() that usually require some kind of closure, call(), apply(), or bind() to ensure that the function is executed in the proper scope. With traditional function expressions, code like this does not work as expected: With arrow functions, the this scope is more easily preserved: Specifications Specification ECMAScript 2026 Language Specification# sec-arrow-function-definitions Browser compatibility See also Functions guide Functions function function expression ES6 In Depth: Arrow functions on hacks.mozilla.org (2015) Help improve MDN Learn how to contribute This page was last modified on Jul 8, 2025 by MDN contributors. View this page on GitHub  Report a problem with this content",
    "headings": [
      {
        "level": 1,
        "text": "Arrow function expressions",
        "id": ""
      },
      {
        "level": 2,
        "text": "Try it",
        "id": "try_it"
      },
      {
        "level": 2,
        "text": "Syntax",
        "id": "syntax"
      },
      {
        "level": 2,
        "text": "Description",
        "id": "description"
      },
      {
        "level": 2,
        "text": "Examples",
        "id": "examples"
      },
      {
        "level": 2,
        "text": "Specifications",
        "id": "specifications"
      },
      {
        "level": 2,
        "text": "Browser compatibility",
        "id": "browser_compatibility"
      },
      {
        "level": 2,
        "text": "See also",
        "id": "see_also"
      },
      {
        "level": 2,
        "text": "Help improve MDN",
        "id": "feedback"
      },
      {
        "level": 3,
        "text": "Function body",
        "id": "function_body"
      },
      {
        "level": 3,
        "text": "Cannot be used as methods",
        "id": "cannot_be_used_as_methods"
      },
      {
        "level": 3,
        "text": "No binding of arguments",
        "id": "no_binding_of_arguments"
      },
      {
        "level": 3,
        "text": "Cannot be used as constructors",
        "id": "cannot_be_used_as_constructors"
      },
      {
        "level": 3,
        "text": "Cannot be used as generators",
        "id": "cannot_be_used_as_generators"
      },
      {
        "level": 3,
        "text": "Line break before arrow",
        "id": "line_break_before_arrow"
      },
      {
        "level": 3,
        "text": "Precedence of arrow",
        "id": "precedence_of_arrow"
      },
      {
        "level": 3,
        "text": "Using arrow functions",
        "id": "using_arrow_functions"
      },
      {
        "level": 3,
        "text": "Using call, bind, and apply",
        "id": "using_call_bind_and_apply"
      }
    ],
    "codeBlocks": [
      {
        "language": "text",
        "code": "(params) => { object: literal }"
      },
      {
        "language": "text",
        "code": "Object.defineProperty()"
      },
      {
        "language": "text",
        "code": "callback || ()"
      },
      {
        "language": "text",
        "code": "setTimeout()"
      },
      {
        "language": "text",
        "code": "EventTarget.prototype.addEventListener()"
      }
    ],
    "links": [
      {
        "text": "Learn more",
        "href": "/en-US/docs/Glossary/Baseline/Compatibility"
      },
      {
        "text": "Report feedback",
        "href": "https://survey.alchemer.com/s3/7634825/MDN-baseline-feedback?page=%2Fen-US%2Fdocs%2FWeb%2FJavaScript%2FReference%2FFunctions%2FArrow_functions&level=high"
      },
      {
        "text": "function expression",
        "href": "/en-US/docs/Web/JavaScript/Reference/Operators/function"
      },
      {
        "text": "bindings",
        "href": "/en-US/docs/Glossary/Binding"
      },
      {
        "text": "this",
        "href": "/en-US/docs/Web/JavaScript/Reference/Operators/this"
      },
      {
        "text": "arguments",
        "href": "/en-US/docs/Web/JavaScript/Reference/Functions/arguments"
      },
      {
        "text": "super",
        "href": "/en-US/docs/Web/JavaScript/Reference/Operators/super"
      },
      {
        "text": "methods",
        "href": "/en-US/docs/Glossary/Method"
      },
      {
        "text": "constructors",
        "href": "/en-US/docs/Glossary/Constructor"
      },
      {
        "text": "new",
        "href": "/en-US/docs/Web/JavaScript/Reference/Operators/new"
      },
      {
        "text": "TypeError",
        "href": "/en-US/docs/Web/JavaScript/Reference/Global_Objects/TypeError"
      },
      {
        "text": "new.target",
        "href": "/en-US/docs/Web/JavaScript/Reference/Operators/new.target"
      },
      {
        "text": "yield",
        "href": "/en-US/docs/Web/JavaScript/Reference/Operators/yield"
      },
      {
        "text": "Rest parameters",
        "href": "/en-US/docs/Web/JavaScript/Reference/Functions/rest_parameters"
      },
      {
        "text": "default parameters",
        "href": "/en-US/docs/Web/JavaScript/Reference/Functions/Default_parameters"
      },
      {
        "text": "destructuring",
        "href": "/en-US/docs/Web/JavaScript/Reference/Operators/Destructuring"
      },
      {
        "text": "async",
        "href": "/en-US/docs/Web/JavaScript/Reference/Statements/async_function"
      },
      {
        "text": "label",
        "href": "/en-US/docs/Web/JavaScript/Reference/Statements/label"
      },
      {
        "text": "Object.defineProperty()",
        "href": "/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/defineProperty"
      },
      {
        "text": "class",
        "href": "/en-US/docs/Web/JavaScript/Reference/Classes"
      },
      {
        "text": "class fields",
        "href": "/en-US/docs/Web/JavaScript/Reference/Classes/Public_class_fields"
      },
      {
        "text": "static fields",
        "href": "/en-US/docs/Web/JavaScript/Reference/Classes/static"
      },
      {
        "text": "closure",
        "href": "/en-US/docs/Web/JavaScript/Guide/Closures"
      },
      {
        "text": "call()",
        "href": "/en-US/docs/Web/JavaScript/Reference/Global_Objects/Function/call"
      },
      {
        "text": "apply()",
        "href": "/en-US/docs/Web/JavaScript/Reference/Global_Objects/Function/apply"
      },
      {
        "text": "bind()",
        "href": "/en-US/docs/Web/JavaScript/Reference/Global_Objects/Function/bind"
      },
      {
        "text": "arguments",
        "href": "/en-US/docs/Web/JavaScript/Reference/Functions/arguments"
      },
      {
        "text": "rest parameters",
        "href": "/en-US/docs/Web/JavaScript/Reference/Functions/rest_parameters"
      },
      {
        "text": "new",
        "href": "/en-US/docs/Web/JavaScript/Reference/Operators/new"
      },
      {
        "text": "prototype",
        "href": "/en-US/docs/Web/JavaScript/Reference/Global_Objects/Function/prototype"
      },
      {
        "text": "yield",
        "href": "/en-US/docs/Web/JavaScript/Reference/Operators/yield"
      },
      {
        "text": "operator precedence",
        "href": "/en-US/docs/Web/JavaScript/Reference/Operators/Operator_precedence"
      },
      {
        "text": "call()",
        "href": "/en-US/docs/Web/JavaScript/Reference/Global_Objects/Function/call"
      },
      {
        "text": "apply()",
        "href": "/en-US/docs/Web/JavaScript/Reference/Global_Objects/Function/apply"
      },
      {
        "text": "bind()",
        "href": "/en-US/docs/Web/JavaScript/Reference/Global_Objects/Function/bind"
      },
      {
        "text": "setTimeout()",
        "href": "/en-US/docs/Web/API/Window/setTimeout"
      },
      {
        "text": "EventTarget.prototype.addEventListener()",
        "href": "/en-US/docs/Web/API/EventTarget/addEventListener"
      },
      {
        "text": "ECMAScript® 2026 Language Specification# sec-arrow-function-definitions",
        "href": "https://tc39.es/ecma262/multipage/ecmascript-language-functions-and-classes.html#sec-arrow-function-definitions"
      },
      {
        "text": "Functions",
        "href": "/en-US/docs/Web/JavaScript/Guide/Functions"
      },
      {
        "text": "Functions",
        "href": "/en-US/docs/Web/JavaScript/Reference/Functions"
      },
      {
        "text": "function",
        "href": "/en-US/docs/Web/JavaScript/Reference/Statements/function"
      },
      {
        "text": "function expression",
        "href": "/en-US/docs/Web/JavaScript/Reference/Operators/function"
      },
      {
        "text": "ES6 In Depth: Arrow functions",
        "href": "https://hacks.mozilla.org/2015/06/es6-in-depth-arrow-functions/"
      },
      {
        "text": "Learn how to contribute",
        "href": "/en-US/docs/MDN/Community/Getting_started"
      },
      {
        "text": "MDN contributors",
        "href": "/en-US/docs/Web/JavaScript/Reference/Functions/Arrow_functions/contributors.txt"
      },
      {
        "text": "View this page on GitHub",
        "href": "https://github.com/mdn/content/blob/main/files/en-us/web/javascript/reference/functions/arrow_functions/index.md?plain=1"
      },
      {
        "text": "Report a problem with this content",
        "href": "https://github.com/mdn/content/issues/new?template=page-report.yml&mdn-url=https%3A%2F%2Fdeveloper.mozilla.org%2Fen-US%2Fdocs%2FWeb%2FJavaScript%2FReference%2FFunctions%2FArrow_functions&metadata=%3C%21--+Do+not+make+changes+below+this+line+--%3E%0A%3Cdetails%3E%0A%3Csummary%3EPage+report+details%3C%2Fsummary%3E%0A%0A*+Folder%3A+%60en-us%2Fweb%2Fjavascript%2Freference%2Ffunctions%2Farrow_functions%60%0A*+MDN+URL%3A+https%3A%2F%2Fdeveloper.mozilla.org%2Fen-US%2Fdocs%2FWeb%2FJavaScript%2FReference%2FFunctions%2FArrow_functions%0A*+GitHub+URL%3A+https%3A%2F%2Fgithub.com%2Fmdn%2Fcontent%2Fblob%2Fmain%2Ffiles%2Fen-us%2Fweb%2Fjavascript%2Freference%2Ffunctions%2Farrow_functions%2Findex.md%0A*+Last+commit%3A+https%3A%2F%2Fgithub.com%2Fmdn%2Fcontent%2Fcommit%2Ffad67be4431d8e6c2a89ac880735233aa76c41d4%0A*+Document+last+modified%3A+2025-07-08T13%3A18%3A45.000Z%0A%0A%3C%2Fdetails%3E"
      }
    ],
    "meta": {
      "description": "An arrow function expression is a compact alternative to a traditional function expression, with some semantic differences and deliberate limitations in usage:",
      "keywords": ""
    },
    "summary": "Arrow function expressions Baseline Widely available This feature is well established and works across many devices and browser versions. Its been available across browsers since September 2016",
    "tags": [
      "react",
      "javascript",
      "typescript",
      "html",
      "vite",
      "arrow",
      "function",
      "cannot",
      "used",
      "expressions"
    ],
    "id": "arrow-function-expressions-Arrow_functions-part-1",
    "quality": 100
  },
  {
    "title": "Classes",
    "url": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Classes",
    "category": "javascript",
    "content": "Classes Baseline Widely available * This feature is well established and works across many devices and browser versions. Its been available across browsers since March 2016. * Some parts of this feature may have varying levels of support. Learn more See full compatibility Report feedback Classes are a template for creating objects. They encapsulate data with code to work on that data. Classes in JS are built on prototypes but also have some syntax and semantics that are unique to classes. For more examples and explanations, see the Using classes guide. Description Defining classes Classes are in fact \"special functions\", and just as you can define function expressions and function declarations, a class can be defined in two ways: a class expression or a class declaration. Like function expressions, class expressions may be anonymous, or have a name that's different from the variable that it's assigned to. However, unlike function declarations, class declarations have the same temporal dead zone restrictions as let or const and behave as if they are not hoisted. Class body The body of a class is the part that is in curly braces {}. This is where you define class members, such as methods or constructor. The body of a class is executed in strict mode even without the \"use strict\" directive. A class element can be characterized by three aspects: Kind: Getter, setter, method, or field Location: Static or instance Visibility: Public or private Together, they add up to 16 possible combinations. To divide the reference more logically and avoid overlapping content, the different elements are introduced in detail in different pages: Method definitions Public instance method getter Public instance getter setter Public instance setter Public class fields Public instance field static Public static method, getter, setter, and field Private elements Everything that's private Note: Private elements have the restriction that all private names declared in the same class must be unique. All other public properties do not have this restriction  you can have multiple public properties with the same name, and the last one overwrites the others. This is the same behavior as in object initializers. In addition, there are two special class element syntaxes: constructor and static initialization blocks, with their own references. Constructor The constructor method is a special method for creating and initializing an object created with a class. There can only be one special method with the name \"constructor\" in a class  a SyntaxError is thrown if the class contains more than one occurrence of a constructor method. A constructor can use the super keyword to call the constructor of the super class. You can create instance properties inside the constructor: Alternatively, if your instance properties' values do not depend on the constructor's arguments, you can define them as class fields. Static initialization blocks Static initialization blocks allow flexible initialization of static properties, including the evaluation of statements during initialization, while granting access to the private scope. Multiple static blocks can be declared, and these can be interleaved with the declaration of static fields and methods (all static items are evaluated in declaration order). Methods Methods are defined on the prototype of each class instance and are shared by all instances. Methods can be plain functions, async functions, generator functions, or async generator functions. For more information, see method definitions. Static methods and fields The static keyword defines a static method or field for a class. Static properties (fields and methods) are defined on the class itself instead of each instance. Static methods are often used to create utility functions for an application, whereas static fields are useful for caches, fixed-configuration, or any other data that doesn't need to be replicated across instances. Field declarations With the class field declaration syntax, the constructor example can be written as: Class fields are similar to object properties, not variables, so we don't use keywords such as const to declare them. In JavaScript, private elements use a special identifier syntax, so modifier keywords like public and private should not be used either. As seen above, the fields can be declared with or without a default value. Fields without default values default to undefined. By declaring fields up-front, class definitions become more self-documenting, and the fields are always present, which help with optimizations. See public class fields for more information. Private elements Using private fields, the definition can be refined as below. It's an error to reference private fields from outside of the class; they can only be read or written within the class body. By defining things that are not visible outside of the class, you ensure that your classes' users can't depend on internals, which may change from version to version. Private fields can only be declared up-front in a field declaration. They cannot be created later through assigning to them, the way that normal properties can. Private methods and accessors can also be defined using the same syntax as their public counterparts, but with the identifier starting with #. For more information, see private elements. Inheritance The extends keyword is used in class declarations or class expressions to create a class as a child of another constructor (either a class or a function). If there is a constructor present in the subclass, it needs to first call super() before using this. The super keyword can also be used to call corresponding methods of super class. Evaluation order When a class declaration or class expression is evaluated, its various components are evaluated in the following order: The extends clause, if present, is first evaluated. It must evaluate to a valid constructor function or null, or a TypeError is thrown. The constructor method is extracted, substituted with a default implementation if constructor is not present. However, because the constructor definition is only a method definition, this step is not observable. The class elements' property keys are evaluated in the order of declaration. If the property key is computed, the computed expression is evaluated, with the this value set to the this value surrounding the class (not the class itself). None of the property values are evaluated yet. Methods and accessors are installed in the order of declaration. Instance methods and accessors are installed on the prototype property of the current class, and static methods and accessors are installed on the class itself. Private instance methods and accessors are saved to be installed on the instance directly later. This step is not observable. The class is now initialized with the prototype specified by extends and implementation specified by constructor. For all steps above, if an evaluated expression tries to access the name of the class, a ReferenceError is thrown because the class is not initialized yet. The class elements' values are evaluated in the order of declaration: For each instance field (public or private), its initializer expression is saved. The initializer is evaluated during instance creation, at the start of the constructor (for base classes) or immediately before the super() call returns (for derived classes). For each static field (public or private), its initializer is evaluated with this set to the class itself, and the property is created on the class. Static initialization blocks are evaluated with this set to the class itself. The class is now fully initialized and can be used as a constructor function. For how instances are created, see the constructor reference. Examples Binding this with instance and static methods When a static or instance method is called without a value for this, such as by assigning the method to a variable and then calling it, the this value will be undefined inside the method. This behavior is the same even if the \"use strict\" directive isn't present, because code within the class body is always executed in strict mode. If we rewrite the above using traditional function-based syntax in nonstrict mode, then this method calls are automatically bound to globalThis. In strict mode, the value of this remains as undefined. Specifications Specification ECMAScript 2026 Language Specification# sec-class-definitions Browser compatibility See also Using classes guide class class expression Functions ES6 In Depth: Classes on hacks.mozilla.org (2015) Help improve MDN Learn how to contribute This page was last modified on Jul 8, 2025 by MDN contributors. View this page on GitHub  Report a problem with this content",
    "headings": [
      {
        "level": 1,
        "text": "Classes",
        "id": ""
      },
      {
        "level": 2,
        "text": "Description",
        "id": "description"
      },
      {
        "level": 2,
        "text": "Examples",
        "id": "examples"
      },
      {
        "level": 2,
        "text": "Specifications",
        "id": "specifications"
      },
      {
        "level": 2,
        "text": "Browser compatibility",
        "id": "browser_compatibility"
      },
      {
        "level": 2,
        "text": "See also",
        "id": "see_also"
      },
      {
        "level": 2,
        "text": "Help improve MDN",
        "id": "feedback"
      },
      {
        "level": 3,
        "text": "Defining classes",
        "id": "defining_classes"
      },
      {
        "level": 3,
        "text": "Class body",
        "id": "class_body"
      },
      {
        "level": 3,
        "text": "Inheritance",
        "id": "inheritance"
      },
      {
        "level": 3,
        "text": "Evaluation order",
        "id": "evaluation_order"
      },
      {
        "level": 3,
        "text": "Binding this with instance and static methods",
        "id": "binding_this_with_instance_and_static_methods"
      },
      {
        "level": 4,
        "text": "Constructor",
        "id": "constructor"
      },
      {
        "level": 4,
        "text": "Static initialization blocks",
        "id": "static_initialization_blocks"
      },
      {
        "level": 4,
        "text": "Methods",
        "id": "methods"
      },
      {
        "level": 4,
        "text": "Static methods and fields",
        "id": "static_methods_and_fields"
      },
      {
        "level": 4,
        "text": "Field declarations",
        "id": "field_declarations"
      },
      {
        "level": 4,
        "text": "Private elements",
        "id": "private_elements"
      }
    ],
    "codeBlocks": [
      {
        "language": "text",
        "code": "\"use strict\""
      },
      {
        "language": "text",
        "code": "constructor"
      },
      {
        "language": "text",
        "code": "constructor"
      },
      {
        "language": "text",
        "code": "SyntaxError"
      },
      {
        "language": "text",
        "code": "constructor"
      },
      {
        "language": "text",
        "code": "constructor"
      },
      {
        "language": "text",
        "code": "constructor"
      },
      {
        "language": "text",
        "code": "constructor"
      },
      {
        "language": "text",
        "code": "constructor"
      },
      {
        "language": "text",
        "code": "ReferenceError"
      },
      {
        "language": "text",
        "code": "constructor"
      },
      {
        "language": "text",
        "code": "\"use strict\""
      }
    ],
    "links": [
      {
        "text": "Learn more",
        "href": "/en-US/docs/Glossary/Baseline/Compatibility"
      },
      {
        "text": "Report feedback",
        "href": "https://survey.alchemer.com/s3/7634825/MDN-baseline-feedback?page=%2Fen-US%2Fdocs%2FWeb%2FJavaScript%2FReference%2FClasses&level=high"
      },
      {
        "text": "prototypes",
        "href": "/en-US/docs/Web/JavaScript/Guide/Inheritance_and_the_prototype_chain"
      },
      {
        "text": "Using classes",
        "href": "/en-US/docs/Web/JavaScript/Guide/Using_classes"
      },
      {
        "text": "functions",
        "href": "/en-US/docs/Web/JavaScript/Reference/Functions"
      },
      {
        "text": "function expressions",
        "href": "/en-US/docs/Web/JavaScript/Reference/Operators/function"
      },
      {
        "text": "function declarations",
        "href": "/en-US/docs/Web/JavaScript/Reference/Statements/function"
      },
      {
        "text": "class expression",
        "href": "/en-US/docs/Web/JavaScript/Reference/Operators/class"
      },
      {
        "text": "class declaration",
        "href": "/en-US/docs/Web/JavaScript/Reference/Statements/class"
      },
      {
        "text": "temporal dead zone",
        "href": "/en-US/docs/Web/JavaScript/Reference/Statements/let#temporal_dead_zone_tdz"
      },
      {
        "text": "not hoisted",
        "href": "/en-US/docs/Web/JavaScript/Guide/Using_classes#class_declaration_hoisting"
      },
      {
        "text": "strict mode",
        "href": "/en-US/docs/Web/JavaScript/Reference/Strict_mode"
      },
      {
        "text": "Method definitions",
        "href": "/en-US/docs/Web/JavaScript/Reference/Functions/Method_definitions"
      },
      {
        "text": "getter",
        "href": "/en-US/docs/Web/JavaScript/Reference/Functions/get"
      },
      {
        "text": "setter",
        "href": "/en-US/docs/Web/JavaScript/Reference/Functions/set"
      },
      {
        "text": "Public class fields",
        "href": "/en-US/docs/Web/JavaScript/Reference/Classes/Public_class_fields"
      },
      {
        "text": "static",
        "href": "/en-US/docs/Web/JavaScript/Reference/Classes/static"
      },
      {
        "text": "Private elements",
        "href": "/en-US/docs/Web/JavaScript/Reference/Classes/Private_elements"
      },
      {
        "text": "object initializers",
        "href": "/en-US/docs/Web/JavaScript/Reference/Operators/Object_initializer#duplicate_property_names"
      },
      {
        "text": "constructor",
        "href": "/en-US/docs/Web/JavaScript/Reference/Classes/constructor"
      },
      {
        "text": "SyntaxError",
        "href": "/en-US/docs/Web/JavaScript/Reference/Global_Objects/SyntaxError"
      },
      {
        "text": "super",
        "href": "/en-US/docs/Web/JavaScript/Reference/Operators/super"
      },
      {
        "text": "Static initialization blocks",
        "href": "/en-US/docs/Web/JavaScript/Reference/Classes/Static_initialization_blocks"
      },
      {
        "text": "method definitions",
        "href": "/en-US/docs/Web/JavaScript/Reference/Functions/Method_definitions"
      },
      {
        "text": "static",
        "href": "/en-US/docs/Web/JavaScript/Reference/Classes/static"
      },
      {
        "text": "public class fields",
        "href": "/en-US/docs/Web/JavaScript/Reference/Classes/Public_class_fields"
      },
      {
        "text": "private elements",
        "href": "/en-US/docs/Web/JavaScript/Reference/Classes/Private_elements"
      },
      {
        "text": "extends",
        "href": "/en-US/docs/Web/JavaScript/Reference/Classes/extends"
      },
      {
        "text": "super",
        "href": "/en-US/docs/Web/JavaScript/Reference/Operators/super"
      },
      {
        "text": "class declaration",
        "href": "/en-US/docs/Web/JavaScript/Reference/Statements/class"
      },
      {
        "text": "class expression",
        "href": "/en-US/docs/Web/JavaScript/Reference/Operators/class"
      },
      {
        "text": "extends",
        "href": "/en-US/docs/Web/JavaScript/Reference/Classes/extends"
      },
      {
        "text": "TypeError",
        "href": "/en-US/docs/Web/JavaScript/Reference/Global_Objects/TypeError"
      },
      {
        "text": "constructor",
        "href": "/en-US/docs/Web/JavaScript/Reference/Classes/constructor"
      },
      {
        "text": "ReferenceError",
        "href": "/en-US/docs/Web/JavaScript/Reference/Global_Objects/ReferenceError"
      },
      {
        "text": "instance field",
        "href": "/en-US/docs/Web/JavaScript/Reference/Classes/Public_class_fields"
      },
      {
        "text": "static field",
        "href": "/en-US/docs/Web/JavaScript/Reference/Classes/static"
      },
      {
        "text": "Static initialization blocks",
        "href": "/en-US/docs/Web/JavaScript/Reference/Classes/Static_initialization_blocks"
      },
      {
        "text": "constructor",
        "href": "/en-US/docs/Web/JavaScript/Reference/Classes/constructor"
      },
      {
        "text": "this",
        "href": "/en-US/docs/Web/JavaScript/Reference/Operators/this"
      },
      {
        "text": "\"use strict\"",
        "href": "/en-US/docs/Web/JavaScript/Reference/Strict_mode"
      },
      {
        "text": "globalThis",
        "href": "/en-US/docs/Web/JavaScript/Reference/Global_Objects/globalThis"
      },
      {
        "text": "ECMAScript® 2026 Language Specification# sec-class-definitions",
        "href": "https://tc39.es/ecma262/multipage/ecmascript-language-functions-and-classes.html#sec-class-definitions"
      },
      {
        "text": "Using classes",
        "href": "/en-US/docs/Web/JavaScript/Guide/Using_classes"
      },
      {
        "text": "class",
        "href": "/en-US/docs/Web/JavaScript/Reference/Statements/class"
      },
      {
        "text": "class expression",
        "href": "/en-US/docs/Web/JavaScript/Reference/Operators/class"
      },
      {
        "text": "Functions",
        "href": "/en-US/docs/Web/JavaScript/Reference/Functions"
      },
      {
        "text": "ES6 In Depth: Classes",
        "href": "https://hacks.mozilla.org/2015/07/es6-in-depth-classes/"
      },
      {
        "text": "Learn how to contribute",
        "href": "/en-US/docs/MDN/Community/Getting_started"
      },
      {
        "text": "MDN contributors",
        "href": "/en-US/docs/Web/JavaScript/Reference/Classes/contributors.txt"
      },
      {
        "text": "View this page on GitHub",
        "href": "https://github.com/mdn/content/blob/main/files/en-us/web/javascript/reference/classes/index.md?plain=1"
      },
      {
        "text": "Report a problem with this content",
        "href": "https://github.com/mdn/content/issues/new?template=page-report.yml&mdn-url=https%3A%2F%2Fdeveloper.mozilla.org%2Fen-US%2Fdocs%2FWeb%2FJavaScript%2FReference%2FClasses&metadata=%3C%21--+Do+not+make+changes+below+this+line+--%3E%0A%3Cdetails%3E%0A%3Csummary%3EPage+report+details%3C%2Fsummary%3E%0A%0A*+Folder%3A+%60en-us%2Fweb%2Fjavascript%2Freference%2Fclasses%60%0A*+MDN+URL%3A+https%3A%2F%2Fdeveloper.mozilla.org%2Fen-US%2Fdocs%2FWeb%2FJavaScript%2FReference%2FClasses%0A*+GitHub+URL%3A+https%3A%2F%2Fgithub.com%2Fmdn%2Fcontent%2Fblob%2Fmain%2Ffiles%2Fen-us%2Fweb%2Fjavascript%2Freference%2Fclasses%2Findex.md%0A*+Last+commit%3A+https%3A%2F%2Fgithub.com%2Fmdn%2Fcontent%2Fcommit%2Ffad67be4431d8e6c2a89ac880735233aa76c41d4%0A*+Document+last+modified%3A+2025-07-08T13%3A18%3A45.000Z%0A%0A%3C%2Fdetails%3E"
      }
    ],
    "meta": {
      "description": "Classes are a template for creating objects. They encapsulate data with code to work on that data. Classes in JS are built on prototypes but also have some syntax and semantics that are unique to classes.",
      "keywords": ""
    },
    "summary": "Classes Baseline Widely available * This feature is well established and works across many devices and browser versions. Its been available across browsers since March 2016",
    "tags": [
      "react",
      "vue",
      "angular",
      "javascript",
      "typescript",
      "html",
      "vite",
      "classes",
      "methods",
      "description"
    ],
    "id": "classes-Classes-part-1",
    "quality": 90
  },
  {
    "title": "Destructuring",
    "url": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/Destructuring",
    "category": "javascript",
    "content": "Destructuring Baseline Widely available This feature is well established and works across many devices and browser versions. Its been available across browsers since August 2016. Learn more See full compatibility Report feedback The destructuring syntax is a JavaScript syntax that makes it possible to unpack values from arrays, or properties from objects, into distinct variables. It can be used in locations that receive data (such as the left-hand side of an assignment or anywhere that creates new identifier bindings). Try it Syntax Description The object and array literal expressions provide an easy way to create ad hoc packages of data. The destructuring uses similar syntax but uses it on the left-hand side of the assignment instead. It performs the reverse operation of an array declaration, by declaring each element in the collection as a separate variable. As for objects, compare the two pairs of lines below, and see how there's a direct correspondence within each pair. This capability is similar to features present in languages such as Perl and Python. For features specific to array or object destructuring, refer to the individual examples below. Binding and assignment For both object and array destructuring, there are two kinds of destructuring patterns: binding pattern and assignment pattern, with slightly different syntaxes. In binding patterns, the pattern starts with a declaration keyword (var, let, or const). Then, each individual property must either be bound to a variable or further destructured. All variables share the same declaration, so if you want some variables to be re-assignable but others to be read-only, you may have to destructure twice  once with let, once with const. In many other syntaxes where the language binds a variable for you, you can use a binding destructuring pattern. These include: The looping variable of for...in for...of, and for await...of loops; Function parameters; The catch binding variable. In assignment patterns, the pattern does not start with a keyword. Each destructured property is assigned to a target of assignment  which may either be declared beforehand with var or let, or is a property of another object  in general, anything that can appear on the left-hand side of an assignment expression. Note: The parentheses ( ... ) around the assignment statement are required when using object literal destructuring without a declaration. { a, b } = { a: 1, b: 2 } is not valid stand-alone syntax, as the { a, b } on the left-hand side is considered a block and not an object literal according to the rules of expression statements. However, ({ a, b } = { a: 1, b: 2 }) is valid, as is const { a, b } = { a: 1, b: 2 }. If your coding style does not include trailing semicolons, the ( ... ) expression needs to be preceded by a semicolon, or it may be used to execute a function on the previous line. Note that the equivalent binding pattern of the code above is not valid syntax: You can only use assignment patterns as the left-hand side of the assignment operator. You cannot use them with compound assignment operators such as += or *=. Default value Each destructured property can have a default value. The default value is used when the property is not present, or has value undefined. It is not used if the property has value null. The default value can be any expression. It will only be evaluated when necessary. Rest properties and rest elements You can end a destructuring pattern with a rest property ...rest. For array destructuring, it collects remaining elements of the iterable into a new array called rest (or any name you give it). For object destructuring, it copies all enumerable own properties of the object that are not already picked off by the destructuring pattern into a new object called rest. More formally, the ...rest syntax is called \"rest elements\" in array destructuring and \"rest properties\" in object destructuring, but we often just collectively call them \"rest property\". The rest property must be the last in the pattern, and must not have a trailing comma. Examples Array destructuring Basic variable assignment Destructuring with more elements than the source In an array destructuring from an array of length N specified on the right-hand side of the assignment, if the number of variables specified on the left-hand side of the assignment is greater than N, only the first N variables are assigned values. The values of the remaining variables will be undefined. Swapping variables Two variables values can be swapped in one destructuring expression. Without destructuring, swapping two values requires a temporary variable (or, in some low-level languages, the XOR-swap trick). Parsing an array returned from a function It's always been possible to return an array from a function. Destructuring can make working with an array return value more concise. In this example, f() returns the values [1, 2] as its output, which can be parsed in a single line with destructuring. Ignoring some returned values You can ignore return values that you're not interested in: You can also ignore all returned values: Though in this case, it's probably clearer to just call the function and not use destructuring at all. You don't have to use the return value. Using a binding pattern as the rest property The rest property of array destructuring can be another array or object binding pattern. The inner destructuring destructures from the array created after collecting the rest elements, so you cannot access any properties present on the original iterable in this way. These binding patterns can even be nested, as long as each rest property is the last in the list. On the other hand, object destructuring can only have an identifier as the rest property. Unpacking values from a regular expression match When the regular expression exec() method finds a match, it returns an array containing first the entire matched portion of the string and then the portions of the string that matched each parenthesized group in the regular expression. Destructuring allows you to unpack the parts out of this array easily, ignoring the full match if it is not needed. Using array destructuring on any iterable Array destructuring calls the iterable protocol of the right-hand side. Therefore, any iterable, not necessarily arrays, can be destructured. Non-iterables cannot be destructured as arrays. Iterables are only iterated until all bindings are assigned. The rest binding is eagerly evaluated and creates a new array, instead of using the old iterable. Object destructuring Basic assignment Assigning to new variable names A property can be unpacked from an object and assigned to a variable with a different name than the object property. Here, for example, const { p: foo } = o takes from the object o the property named p and assigns it to a local variable named foo. Assigning to new variable names and providing default values A property can be both Unpacked from an object and assigned to a variable with a different name. Assigned a default value in case the unpacked value is undefined. Unpacking properties from objects passed as a function parameter Objects passed into function parameters can also be unpacked into variables, which may then be accessed within the function body. As for object assignment, the destructuring syntax allows for the new variable to have the same name or a different name than the original property, and to assign default values for the case when the original object does not define the property. Consider this object, which contains information about a user. Here we show how to unpack a property of the passed object into a variable with the same name. The parameter value { id } indicates that the id property of the object passed to the function should be unpacked into a variable with the same name, which can then be used within the function. You can define the name of the unpacked variable. Here we unpack the property named displayName, and rename it to dname for use within the function body. Nested objects can also be unpacked. The example below shows the property fullname.firstName being unpacked into a variable called name. Setting a function parameter's default value Default values can be specified using =, and will be used as variable values if a specified property does not exist in the passed object. Below we show a function where the default size is 'big', default co-ordinates are x: 0, y: 0 and default radius is 25. In the function signature for drawChart above, the destructured left-hand side has a default value of an empty object = {}. You could have also written the function without that default. However, if you leave out that default value, the function will look for at least one argument to be supplied when invoked, whereas in its current form, you can call drawChart() without supplying any parameters. Otherwise, you need to at least supply an empty object literal. For more information, see Default parameters  Destructured parameter with default value assignment. Nested object and array destructuring For of iteration and destructuring Computed object property names and destructuring Computed property names, like on object literals, can be used with destructuring. Invalid JavaScript identifier as a property name Destructuring can be used with property names that are not valid JavaScript identifiers by providing an alternative identifier that is valid. Destructuring primitive values Object destructuring is almost equivalent to property accessing. This means if you try to destruct a primitive value, the value will get wrapped into the corresponding wrapper object and the property is accessed on the wrapper object. Same as accessing properties, destructuring null or undefined throws a TypeError. This happens even when the pattern is empty. Combined array and object destructuring Array and object destructuring can be combined. Say you want the third element in the array props below, and then you want the name property in the object, you can do the following: The prototype chain is looked up when the object is deconstructed When deconstructing an object, if a property is not accessed in itself, it will continue to look up along the prototype chain. Specifications Specification ECMAScript 2026 Language Specification# sec-destructuring-assignment ECMAScript 2026 Language Specification# sec-destructuring-binding-patterns Browser compatibility See also Assignment operators ES6 in Depth: Destructuring on hacks.mozilla.org (2015) Help improve MDN Learn how to contribute This page was last modified on Jul 8, 2025 by MDN contributors. View this page on GitHub  Report a problem with this content",
    "headings": [
      {
        "level": 1,
        "text": "Destructuring",
        "id": ""
      },
      {
        "level": 2,
        "text": "Try it",
        "id": "try_it"
      },
      {
        "level": 2,
        "text": "Syntax",
        "id": "syntax"
      },
      {
        "level": 2,
        "text": "Description",
        "id": "description"
      },
      {
        "level": 2,
        "text": "Examples",
        "id": "examples"
      },
      {
        "level": 2,
        "text": "Specifications",
        "id": "specifications"
      },
      {
        "level": 2,
        "text": "Browser compatibility",
        "id": "browser_compatibility"
      },
      {
        "level": 2,
        "text": "See also",
        "id": "see_also"
      },
      {
        "level": 2,
        "text": "Help improve MDN",
        "id": "feedback"
      },
      {
        "level": 3,
        "text": "Binding and assignment",
        "id": "binding_and_assignment"
      },
      {
        "level": 3,
        "text": "Default value",
        "id": "default_value"
      },
      {
        "level": 3,
        "text": "Rest properties and rest elements",
        "id": "rest_properties_and_rest_elements"
      },
      {
        "level": 3,
        "text": "Array destructuring",
        "id": "array_destructuring"
      },
      {
        "level": 3,
        "text": "Object destructuring",
        "id": "object_destructuring"
      },
      {
        "level": 3,
        "text": "Destructuring primitive values",
        "id": "destructuring_primitive_values"
      },
      {
        "level": 4,
        "text": "Basic variable assignment",
        "id": "basic_variable_assignment"
      },
      {
        "level": 4,
        "text": "Destructuring with more elements than the source",
        "id": "destructuring_with_more_elements_than_the_source"
      },
      {
        "level": 4,
        "text": "Swapping variables",
        "id": "swapping_variables"
      },
      {
        "level": 4,
        "text": "Parsing an array returned from a function",
        "id": "parsing_an_array_returned_from_a_function"
      },
      {
        "level": 4,
        "text": "Ignoring some returned values",
        "id": "ignoring_some_returned_values"
      },
      {
        "level": 4,
        "text": "Using a binding pattern as the rest property",
        "id": "using_a_binding_pattern_as_the_rest_property"
      },
      {
        "level": 4,
        "text": "Unpacking values from a regular expression match",
        "id": "unpacking_values_from_a_regular_expression_match"
      },
      {
        "level": 4,
        "text": "Using array destructuring on any iterable",
        "id": "using_array_destructuring_on_any_iterable"
      },
      {
        "level": 4,
        "text": "Basic assignment",
        "id": "basic_assignment"
      },
      {
        "level": 4,
        "text": "Assigning to new variable names",
        "id": "assigning_to_new_variable_names"
      },
      {
        "level": 4,
        "text": "Assigning to new variable names and providing default values",
        "id": "assigning_to_new_variable_names_and_providing_default_values"
      },
      {
        "level": 4,
        "text": "Unpacking properties from objects passed as a function parameter",
        "id": "unpacking_properties_from_objects_passed_as_a_function_parameter"
      },
      {
        "level": 4,
        "text": "Setting a function parameter's default value",
        "id": "setting_a_function_parameters_default_value"
      },
      {
        "level": 4,
        "text": "Nested object and array destructuring",
        "id": "nested_object_and_array_destructuring"
      },
      {
        "level": 4,
        "text": "For of iteration and destructuring",
        "id": "for_of_iteration_and_destructuring"
      },
      {
        "level": 4,
        "text": "Computed object property names and destructuring",
        "id": "computed_object_property_names_and_destructuring"
      },
      {
        "level": 4,
        "text": "Invalid JavaScript identifier as a property name",
        "id": "invalid_javascript_identifier_as_a_property_name"
      },
      {
        "level": 4,
        "text": "Combined array and object destructuring",
        "id": "combined_array_and_object_destructuring"
      },
      {
        "level": 4,
        "text": "The prototype chain is looked up when the object is deconstructed",
        "id": "the_prototype_chain_is_looked_up_when_the_object_is_deconstructed"
      }
    ],
    "codeBlocks": [
      {
        "language": "text",
        "code": "for await...of"
      },
      {
        "language": "text",
        "code": "{ a, b } = { a: 1, b: 2 }"
      },
      {
        "language": "text",
        "code": "({ a, b } = { a: 1, b: 2 })"
      },
      {
        "language": "text",
        "code": "const { a, b } = { a: 1, b: 2 }"
      },
      {
        "language": "text",
        "code": "const { p: foo } = o"
      },
      {
        "language": "text",
        "code": "displayName"
      },
      {
        "language": "text",
        "code": "fullname.firstName"
      },
      {
        "language": "text",
        "code": "drawChart()"
      }
    ],
    "links": [
      {
        "text": "Learn more",
        "href": "/en-US/docs/Glossary/Baseline/Compatibility"
      },
      {
        "text": "Report feedback",
        "href": "https://survey.alchemer.com/s3/7634825/MDN-baseline-feedback?page=%2Fen-US%2Fdocs%2FWeb%2FJavaScript%2FReference%2FOperators%2FDestructuring&level=high"
      },
      {
        "text": "binding",
        "href": "/en-US/docs/Glossary/Binding"
      },
      {
        "text": "for...in",
        "href": "/en-US/docs/Web/JavaScript/Reference/Statements/for...in"
      },
      {
        "text": "for...of",
        "href": "/en-US/docs/Web/JavaScript/Reference/Statements/for...of"
      },
      {
        "text": "for await...of",
        "href": "/en-US/docs/Web/JavaScript/Reference/Statements/for-await...of"
      },
      {
        "text": "Function",
        "href": "/en-US/docs/Web/JavaScript/Reference/Functions"
      },
      {
        "text": "catch",
        "href": "/en-US/docs/Web/JavaScript/Reference/Statements/try...catch"
      },
      {
        "text": "expression statements",
        "href": "/en-US/docs/Web/JavaScript/Reference/Statements/Expression_statement"
      },
      {
        "text": "assignment",
        "href": "/en-US/docs/Web/JavaScript/Reference/Operators/Assignment"
      },
      {
        "text": "XOR-swap trick",
        "href": "https://en.wikipedia.org/wiki/XOR_swap_algorithm"
      },
      {
        "text": "exec()",
        "href": "/en-US/docs/Web/JavaScript/Reference/Global_Objects/RegExp/exec"
      },
      {
        "text": "iterable protocol",
        "href": "/en-US/docs/Web/JavaScript/Reference/Iteration_protocols"
      },
      {
        "text": "Default parameters > Destructured parameter with default value assignment",
        "href": "/en-US/docs/Web/JavaScript/Reference/Functions/Default_parameters#destructured_parameter_with_default_value_assignment"
      },
      {
        "text": "object literals",
        "href": "/en-US/docs/Web/JavaScript/Reference/Operators/Object_initializer#computed_property_names"
      },
      {
        "text": "identifiers",
        "href": "/en-US/docs/Glossary/Identifier"
      },
      {
        "text": "property accessing",
        "href": "/en-US/docs/Web/JavaScript/Reference/Operators/Property_accessors"
      },
      {
        "text": "TypeError",
        "href": "/en-US/docs/Web/JavaScript/Reference/Global_Objects/TypeError"
      },
      {
        "text": "ECMAScript® 2026 Language Specification# sec-destructuring-assignment",
        "href": "https://tc39.es/ecma262/multipage/ecmascript-language-expressions.html#sec-destructuring-assignment"
      },
      {
        "text": "ECMAScript® 2026 Language Specification# sec-destructuring-binding-patterns",
        "href": "https://tc39.es/ecma262/multipage/ecmascript-language-statements-and-declarations.html#sec-destructuring-binding-patterns"
      },
      {
        "text": "Assignment operators",
        "href": "/en-US/docs/Web/JavaScript/Reference/Operators#assignment_operators"
      },
      {
        "text": "ES6 in Depth: Destructuring",
        "href": "https://hacks.mozilla.org/2015/05/es6-in-depth-destructuring/"
      },
      {
        "text": "Learn how to contribute",
        "href": "/en-US/docs/MDN/Community/Getting_started"
      },
      {
        "text": "MDN contributors",
        "href": "/en-US/docs/Web/JavaScript/Reference/Operators/Destructuring/contributors.txt"
      },
      {
        "text": "View this page on GitHub",
        "href": "https://github.com/mdn/content/blob/main/files/en-us/web/javascript/reference/operators/destructuring/index.md?plain=1"
      },
      {
        "text": "Report a problem with this content",
        "href": "https://github.com/mdn/content/issues/new?template=page-report.yml&mdn-url=https%3A%2F%2Fdeveloper.mozilla.org%2Fen-US%2Fdocs%2FWeb%2FJavaScript%2FReference%2FOperators%2FDestructuring&metadata=%3C%21--+Do+not+make+changes+below+this+line+--%3E%0A%3Cdetails%3E%0A%3Csummary%3EPage+report+details%3C%2Fsummary%3E%0A%0A*+Folder%3A+%60en-us%2Fweb%2Fjavascript%2Freference%2Foperators%2Fdestructuring%60%0A*+MDN+URL%3A+https%3A%2F%2Fdeveloper.mozilla.org%2Fen-US%2Fdocs%2FWeb%2FJavaScript%2FReference%2FOperators%2FDestructuring%0A*+GitHub+URL%3A+https%3A%2F%2Fgithub.com%2Fmdn%2Fcontent%2Fblob%2Fmain%2Ffiles%2Fen-us%2Fweb%2Fjavascript%2Freference%2Foperators%2Fdestructuring%2Findex.md%0A*+Last+commit%3A+https%3A%2F%2Fgithub.com%2Fmdn%2Fcontent%2Fcommit%2Ffad67be4431d8e6c2a89ac880735233aa76c41d4%0A*+Document+last+modified%3A+2025-07-08T13%3A18%3A45.000Z%0A%0A%3C%2Fdetails%3E"
      }
    ],
    "meta": {
      "description": "The destructuring syntax is a JavaScript syntax that makes it possible to unpack values from arrays, or properties from objects, into distinct variables. It can be used in locations that receive data (such as the left-hand side of an assignment or anywhere that creates new identifier bindings).",
      "keywords": ""
    },
    "summary": "Destructuring Baseline Widely available This feature is well established and works across many devices and browser versions. Its been available across browsers since August 2016",
    "tags": [
      "react",
      "javascript",
      "typescript",
      "css",
      "html",
      "vite",
      "destructuring",
      "array",
      "object",
      "values"
    ],
    "id": "destructuring-Destructuring-part-1",
    "quality": 100
  },
  {
    "title": "JavaScript modules",
    "url": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Guide/Modules",
    "category": "javascript",
    "content": "JavaScript modules Previous This guide gives you all you need to get started with JavaScript module syntax. A background on modules JavaScript programs started off pretty small  most of its usage in the early days was to do isolated scripting tasks, providing a bit of interactivity to your web pages where needed, so large scripts were generally not needed. Fast forward a few years and we now have complete applications being run in browsers with a lot of JavaScript, as well as JavaScript being used in other contexts (Node.js, for example). Complex projects necessitate a mechanism for splitting JavaScript programs into separate modules that can be imported when needed. Node.js has had this ability for a long time, and there are a number of JavaScript libraries and frameworks that enable module usage (for example, other CommonJS and AMD-based module systems like RequireJS, webpack, and Babel). All modern browsers support module features natively without needing transpilation. It can only be a good thing  browsers can optimize loading of modules, making it more efficient than having to use a library and do all of that extra client-side processing and extra round trips. It does not obsolete bundlers like webpack, though  bundlers still do a good job at partitioning code into reasonably sized chunks, and are able to do other optimizations like minification, dead code elimination, and tree-shaking. Introducing an example To demonstrate usage of modules, we've created a set of examples that you can find on GitHub. These examples demonstrate a set of modules that create a canvas element on a webpage, and then draw (and report information about) different shapes on the canvas. These are fairly trivial, but have been kept deliberately simple to demonstrate modules clearly. Note: If you want to download the examples and run them locally, you'll need to run them through a local web server. Basic example structure In our first example (see basic-modules) we have a file structure as follows: index.html main.js modules/ canvas.js square.js Note: All of the examples in this guide have basically the same structure; the above should start getting pretty familiar. The modules directory's two modules are described below: canvas.js  contains functions related to setting up the canvas: create()  creates a canvas with a specified width and height inside a wrapper div with a specified ID, which is itself appended inside a specified parent element. Returns an object containing the canvas's 2D context and the wrapper's ID. createReportList()  creates an unordered list appended inside a specified wrapper element, which can be used to output report data into. Returns the list's ID. square.js  contains: name  a constant containing the string 'square'. draw()  draws a square on a specified canvas, with a specified size, position, and color. Returns an object containing the square's size, position, and color. reportArea()  writes a square's area to a specific report list, given its length. reportPerimeter()  writes a square's perimeter to a specific report list, given its length. Aside  .mjs versus .js Throughout this article, we've used .js extensions for our module files, but in other resources you may see the .mjs extension used instead. V8's documentation recommends this, for example. The reasons given are: It is good for clarity, i.e., it makes it clear which files are modules, and which are regular JavaScript. It ensures that your module files are parsed as a module by runtimes such as Node.js, and build tools such as Babel. However, we decided to keep using .js, at least for the moment. To get modules to work correctly in a browser, you need to make sure that your server is serving them with a Content-Type header that contains a JavaScript MIME type such as text/javascript. If you don't, you'll get a strict MIME type checking error along the lines of \"The server responded with a non-JavaScript MIME type\" and the browser won't run your JavaScript. Most servers already set the correct type for .js files, but not yet for .mjs files. Servers that already serve .mjs files correctly include GitHub Pages and http-server for Node.js. This is OK if you are using such an environment already, or if you aren't but you know what you are doing and have access (i.e., you can configure your server to set the correct Content-Type for .mjs files). It could however cause confusion if you don't control the server you are serving files from, or are publishing files for public use, as we are here. For learning and portability purposes, we decided to keep to .js. If you really value the clarity of using .mjs for modules versus using .js for \"normal\" JavaScript files, but don't want to run into the problem described above, you could always use .mjs during development and convert them to .js during your build step. It is also worth noting that: Some tools may never support .mjs. The script type=\"module\" attribute is used to denote when a module is being pointed to, as you'll see below. Exporting module features The first thing you do to get access to module features is export them. This is done using the export statement. The easiest way to use it is to place it in front of any items you want exported out of the module, for example: You can export functions, var, let, const, and  as we'll see later  classes. They need to be top-level items: for example, you can't use export inside a function. A more convenient way of exporting all the items you want to export is to use a single export statement at the end of your module file, followed by a comma-separated list of the features you want to export wrapped in curly braces. For example: Importing features into your script Once you've exported some features out of your module, you need to import them into your script to be able to use them. The simplest way to do this is as follows: You use the import statement, followed by a comma-separated list of the features you want to import wrapped in curly braces, followed by the keyword from, followed by the module specifier. The module specifier provides a string that the JavaScript environment can resolve to a path to the module file. In a browser, this could be a path relative to the site root, which for our basic-modules example would be /js-examples/module-examples/basic-modules. However, here we are instead using the dot (.) syntax to mean \"the current location\", followed by the relative path to the file we are trying to find. This is much better than writing out the entire absolute path each time, as relative paths are shorter and make the URL portable  the example will still work if you move it to a different location in the site hierarchy. So for example: becomes You can see such lines in action in main.js. Note: In some module systems, you can use a module specifier like modules/square that isn't a relative or absolute path, and that doesn't have a file extension. This kind of specifier can be used in a browser environment if you first define an import map. Once you've imported the features into your script, you can use them just like they were defined inside the same file. The following is found in main.js, below the import lines: Note: The imported values are read-only views of the features that were exported. Similar to const variables, you cannot re-assign the variable that was imported, but you can still modify properties of object values. The value can only be re-assigned by the module exporting it. See the import reference for an example. Importing modules using import maps Above we saw how a browser can import a module using a module specifier that is either an absolute URL, or a relative URL that is resolved using the base URL of the document: Import maps allow developers to instead specify almost any text they want in the module specifier when importing a module; the map provides a corresponding value that will replace the text when the module URL is resolved. For example, the imports key in the import map below defines a \"module specifier map\" JSON object where the property names can be used as module specifiers, and the corresponding values will be substituted when the browser resolves the module URL. The values must be absolute or relative URLs. Relative URLs are resolved to absolute URL addresses using the base URL of the document containing the import map. The import map is defined using a JSON object inside a script element with the type attribute set to importmap. Note that an import map only applies to the document  the specification does not cover how to apply an import map in a worker or worklet context. With this map you can now use the property names above as module specifiers. If there is no trailing forward slash on the module specifier key then the whole module specifier key is matched and substituted. For example, below we match bare module names, and remap a URL to another path. If the module specifier has a trailing forward slash then the value must have one as well, and the key is matched as a \"path prefix\". This allows remapping of whole classes of URLs. It is possible for multiple keys in an import map to be valid matches for a module specifier. For example, a module specifier of shapes/circle/ could match the module specifier keys shapes/ and shapes/circle/. In this case the browser will select the most specific (longest) matching module specifier key. Import maps allow modules to be imported using bare module names (as in Node.js), and can also simulate importing modules from packages, both with and without file extensions. While not shown above, they also allow particular versions of a library to be imported, based on the path of the script that is importing the module. Generally they let developers write more ergonomic import code, and make it easier to manage the different versions and dependencies of modules used by a site. This can reduce the effort required to use the same JavaScript libraries in both browser and server. The following sections expand on the various features outlined above. Feature detection You can check support for import maps using the HTMLScriptElement.supports() static method (which is itself broadly supported): Importing modules as bare names In some JavaScript environments, such as Node.js, you can use bare names for the module specifier. This works because the environment can resolve module names to a standard location in the file system. For example, you might use the following syntax to import the \"square\" module. To use bare names on a browser you need an import map, which provides the information needed by the browser to resolve module specifiers to URLs (JavaScript will throw a TypeError if it attempts to import a module specifier that can't be resolved to a module location). Below you can see a map that defines a square module specifier key, which in this case maps to a relative address value. With this map we can now use a bare name when we import the module: Remapping module paths Module specifier map entries, where both the specifier key and its associated value have a trailing forward slash (/), can be used as a path-prefix. This allows the remapping of a whole set of import URLs from one location to another. It can also be used to emulate working with \"packages and modules\", such as you might see in the Node ecosystem. Note: The trailing / indicates that the module specifier key can be substituted as part of a module specifier. If this is not present, the browser will only match (and substitute) the whole module specifier key. Packages of modules The following JSON import map definition maps lodash as a bare name, and the module specifier prefix lodash/ to the path /node_modules/lodash-es/ (resolved to the document base URL): With this mapping you can import both the whole \"package\", using the bare name, and modules within it (using the path mapping): It is possible to import fp above without the .js file extension, but you would need to create a bare module specifier key for that file, such as lodash/fp, rather than using the path. This may be reasonable for just one module, but scales poorly if you wish to import many modules. General URL remapping A module specifier key doesn't have to be path  it can also be an absolute URL (or a URL-like relative path like ./, ../, /). This may be useful if you want to remap a module that has absolute paths to a resource with your own local resources. Scoped modules for version management Ecosystems like Node use package managers such as npm to manage modules and their dependencies. The package manager ensures that each module is separated from other modules and their dependencies. As a result, while a complex application might include the same module multiple times with several different versions in different parts of the module graph, users do not need to think about this complexity. Note: You can also achieve version management using relative paths, but this is subpar because, among other things, this forces a particular structure on your project, and prevents you from using bare module names. Import maps similarly allow you to have multiple versions of dependencies in your application and refer to them using the same module specifier. You implement this with the scopes key, which allows you to provide module specifier maps that will be used depending on the path of the script performing the import. The example below demonstrates this. With this mapping, if a script with an URL that contains /node_modules/dependency/ imports cool-module, the version in /node_modules/some/other/location/cool-module/index.js will be used. The map in imports is used as a fallback if there is no matching scope in the scoped map, or the matching scopes don't contain a matching specifier. For example, if cool-module is imported from a script with a non-matching scope path, then the module specifier map in imports will be used instead, mapping to the version in /node_modules/cool-module/index.js. Note that the path used to select a scope does not affect how the address is resolved. The value in the mapped path does not have to match the scopes path, and relative paths are still resolved to the base URL of the script that contains the import map. Just as for module specifier maps, you can have many scope keys, and these may contain overlapping paths. If multiple scopes match the referrer URL, then the most specific scope path is checked first (the longest scope key) for a matching specifier. The browsers will fall back to the next most specific matching scoped path if there is no matching specifier, and so on. If there is no matching specifier in any of the matching scopes, the browser checks for a match in the module specifier map in the imports key. Improve caching by mapping away hashed filenames Script files used by websites often have hashed filenames to simplify caching. The downside of this approach is that if a module changes, any modules that import it using its hashed filename will also need to be updated/regenerated. This potentially results in a cascade of updates, which is wasteful of network resources. Import maps provide a convenient solution to this problem. Rather than depending on specific hashed filenames, applications and scripts instead depend on an un-hashed version of the module name (address). An import map like the one below then provides a mapping to the actual script file. If dependency_script changes, then its hash contained in the file name changes as well. In this case, we only need to update the import map to reflect the changed name of the module. We don't have to update the source of any JavaScript code that depends on it, because the specifier in the import statement does not change. Loading non-JavaScript resources One exciting feature that a unified module architecture brings is the ability to load non-JavaScript resources as modules. For example, you can import JSON as a JavaScript object, or import CSS as a CSSStyleSheet object. You must explicitly declare what kind of resource you are importing. By default, the browser assumes that the resource is JavaScript, and will throw an error if the resolved resource is something else. To import JSON, CSS, or other types of resource, use the import attributes syntax: Browsers will also perform validation on the module type, and fail if, for example, ./data.json does not resolve to a JSON file. This ensures that you don't accidentally execute code when you just intend to import data. Once imported successfully, you can now use the imported value as a normal JavaScript object or CSSStyleSheet object. Applying the module to your HTML Now we just need to apply the main.js module to our HTML page. This is very similar to how we apply a regular script to a page, with a few notable differences. First of all, you need to include type=\"module\" in the script element, to declare this script as a module. To import the main.js script, we use this: You can also embed the module's script directly into the HTML file by placing the JavaScript code within the body of the script element: You can only use import and export statements inside modules, not regular scripts. An error will be thrown if your script element doesn't have the type=\"module\" attribute and attempts to import other modules. For example: You should generally define all your modules in separate files. Modules declared inline in HTML can only import other modules, but anything they export will not be accessible by other modules (because they don't have a URL). Note: Modules and their dependencies can be preloaded by specifying them in link elements with rel=\"modulepreload\". This can significantly reduce load time when the modules are used. Other differences between modules and classic scripts You need to pay attention to local testing  if you try to load the HTML file locally (i.e., with a file:// URL), you'll run into CORS errors due to JavaScript module security requirements. You need to do your testing through a server. Also, note that you might get different behavior from sections of script defined inside modules as opposed to in classic scripts. This is because modules use strict mode automatically. There is no need to use the defer attribute (see script attributes) when loading a module script; modules are deferred automatically. Modules are only executed once, even if they have been referenced in multiple script tags. Last but not least, let's make this clear  module features are imported into the scope of a single script  they aren't available in the global scope. Therefore, you will only be able to access imported features in the script they are imported into, and you won't be able to access them from the JavaScript console, for example. You'll still get syntax errors shown in the DevTools, but you'll not be able to use some of the debugging techniques you might have expected to use. Module-defined variables are scoped to the module unless explicitly attached to the global object. On the other hand, globally-defined variables are available within the module. For example, given the following code: The page would still render Hello, because the global variables text and document are available in the module. (Also note from this example that a module doesn't necessarily need an import/export statement  the only thing needed is for the entry point to have type=\"module\".) Default exports versus named exports The functionality we've exported so far has been comprised of named exports  each item (be it a function, const, etc.) has been referred to by its name upon export, and that name has been used to refer to it on import as well. There is also a type of export called the default export  this is designed to make it easy to have a default function provided by a module, and also helps JavaScript modules to interoperate with existing CommonJS and AMD module systems (as explained nicely in ES6 In Depth: Modules by Jason Orendorff; search for \"Default exports\"). Let's look at an example as we explain how it works. In our basic-modules square.js you can find a function called randomSquare() that creates a square with a random color, size, and position. We want to export this as our default, so at the bottom of the file we write this: Note the lack of curly braces. We could instead prepend export default onto the function and define it as an anonymous function, like this: Over in our main.js file, we import the default function using this line: Again, note the lack of curly braces. This is because there is only one default export allowed per module, and we know that randomSquare is it. The above line is basically shorthand for: Note: The as syntax for renaming exported items is explained below in the Renaming imports and exports section. Avoiding naming conflicts So far, our canvas shape drawing modules seem to be working OK. But what happens if we try to add a module that deals with drawing another shape, like a circle or triangle? These shapes would probably have associated functions like draw(), reportArea(), etc. too; if we tried to import different functions of the same name into the same top-level module file, we'd end up with conflicts and errors. Fortunately there are a number of ways to get around this. We'll look at these in the following sections. Renaming imports and exports Inside your import and export statement's curly braces, you can use the keyword as along with a new feature name, to change the identifying name you will use for a feature inside the top-level module. So for example, both of the following would do the same job, albeit in a slightly different way: Let's look at a real example. In our renaming directory you'll see the same module system as in the previous example, except that we've added circle.js and triangle.js modules to draw and report on circles and triangles. Inside each of these modules, we've got features with the same names being exported, and therefore each has the same export statement at the bottom: When importing these into main.js, if we tried to use The browser would throw an error such as \"SyntaxError: redeclaration of import name\" (Firefox). Instead we need to rename the imports so that they are unique: Note that you could solve the problem in the module files instead, e.g. And it would work just the same. What style you use is up to you, however it arguably makes more sense to leave your module code alone, and make the changes in the imports. This especially makes sense when you are importing from third party modules that you don't have any control over. Creating a module object The above method works OK, but it's a little messy and long-winded. An even better solution is to import each module's features inside a module object. The following syntax form does that: This grabs all the exports available inside module.js, and makes them available as members of an object Module, effectively giving it its own namespace. So for example: Again, let's look at a real example. If you go to our module-objects directory, you'll see the same example again, but rewritten to take advantage of this new syntax. In the modules, the exports are all in the following simple form: The imports on the other hand look like this: In each case, you can now access the module's imports underneath the specified object name, for example: So you can now write the code just the same as before (as long as you include the object names where needed), and the imports are much neater. Modules and classes As we hinted at earlier, you can also export and import classes; this is another option for avoiding conflicts in your code, and is especially useful if you've already got your module code written in an object-oriented style. You can see an example of our shape drawing module rewritten with ES classes in our classes directory. As an example, the square.js file now contains all its functionality in a single class: which we then export: Over in main.js, we import it like this: And then use the class to draw our square: Aggregating modules There will be times where you'll want to aggregate modules together. You might have multiple levels of dependencies, where you want to simplify things, combining several submodules into one parent module. This is possible using export syntax of the following forms in the parent module: For an example, see our module-aggregation directory. In this example (based on our earlier classes example) we've got an extra module called shapes.js, which aggregates all the functionality from circle.js, square.js, and triangle.js together. We've also moved our submodules inside a subdirectory inside the modules directory called shapes. So the module structure in this example is: modules/ canvas.js shapes.js shapes/ circle.js square.js triangle.js In each of the submodules, the export is of the same form, e.g. Next up comes the aggregation part. Inside shapes.js, we include the following lines: These grab the exports from the individual submodules and effectively make them available from the shapes.js module. Note: The exports referenced in shapes.js basically get redirected through the file and don't really exist there, so you won't be able to write any useful related code inside the same file. So now in the main.js file, we can get access to all three module classes by replacing with the following single line: Dynamic module loading A recent addition to JavaScript modules functionality is dynamic module loading. This allows you to dynamically load modules only when they are needed, rather than having to load everything up front. This has some obvious performance advantages; let's read on and see how it works. This new functionality allows you to call import() as a function, passing it the path to the module as a parameter. It returns a Promise, which fulfills with a module object (see Creating a module object) giving you access to that object's exports. For example: Note: Dynamic import is permitted in the browser main thread, and in shared and dedicated workers. However import() will throw if called in a service worker or worklet. Let's look at an example. In the dynamic-module-imports directory we've got another example based on our classes example. This time however we are not drawing anything on the canvas when the example loads. Instead, we include three buttons  \"Circle\", \"Square\", and \"Triangle\"  that, when pressed, dynamically load the required module and then use it to draw the associated shape. In this example we've only made changes to our index.html and main.js files  the module exports remain the same as before. Over in main.js we've grabbed a reference to each button using a document.querySelector() call, for example: We then attach an event listener to each button so that when pressed, the relevant module is dynamically loaded and used to draw the shape: Note that, because the promise fulfillment returns a module object, the class is then made a subfeature of the object, hence we now need to access the constructor with Module. prepended to it, e.g., Module.Square( /*  */ ). Another advantage of dynamic imports is that they are always available, even in script environments. Therefore, if you have an existing script tag in your HTML that doesn't have type=\"module\", you can still reuse code distributed as modules by dynamically importing it. Top level await Top level await is a feature available within modules. This means the await keyword can be used. It allows modules to act as big asynchronous functions meaning code can be evaluated before use in parent modules, but without blocking sibling modules from loading. Let's take a look at an example. You can find all the files and code described in this section within the top-level-await directory, which extends from the previous examples. Firstly we'll declare our color palette in a separate colors.json file: Then we'll create a module called getColors.js which uses a fetch request to load the colors.json file and return the data as an object. Notice the last export line here. We're using the keyword await before specifying the constant colors to export. This means any other modules which include this one will wait until colors has been downloaded and parsed before using it. Let's include this module in our main.js file: We'll use colors instead of the previously used strings when calling our shape functions: This is useful because the code within main.js won't execute until the code in getColors.js has run. However it won't block other modules being loaded. For instance our canvas.js module will continue to load while colors is being fetched. Import declarations are hoisted Import declarations are hoisted. In this case, it means that the imported values are available in the module's code even before the place that declares them, and that the imported module's side effects are produced before the rest of the module's code starts running. So for example, in main.js, importing Canvas in the middle of the code would still work: Still, it is considered good practice to put all your imports at the top of the code, which makes it easier to analyze dependencies. Cyclic imports Modules can import other modules, and those modules can import other modules, and so on. This forms a directed graph called the \"dependency graph\". In an ideal world, this graph is acyclic. In this case, the graph can be evaluated using a depth-first traversal. However, cycles are often inevitable. Cyclic import arises if module a imports module b, but b directly or indirectly depends on a. For example: Cyclic imports don't always fail. The imported variable's value is only retrieved when the variable is actually used (hence allowing live bindings), and only if the variable remains uninitialized at that time will a ReferenceError be thrown. In this example, both a and b are used asynchronously. Therefore, at the time the module is evaluated, neither b nor a is actually read, so the rest of the code is executed as normal, and the two export declarations produce the values of a and b. Then, after the timeout, both a and b are available, so the two console.log statements also execute as normal. If you change the code to use a synchronously, the module evaluation fails: This is because when JavaScript evaluates a.js, it needs to first evaluate b.js, the dependency of a.js. However, b.js uses a, which is not yet available. On the other hand, if you change the code to use b synchronously but a asynchronously, the module evaluation succeeds: This is because the evaluation of b.js completes normally, so the value of b is available when a.js is evaluated. You should usually avoid cyclic imports in your project, because they make your code more error-prone. Some common cycle-elimination techniques are: Merge the two modules into one. Move the shared code into a third module. Move some code from one module to the other. However, cyclic imports can also occur if the libraries depend on each other, which is harder to fix. Authoring \"isomorphic\" modules The introduction of modules encourages the JavaScript ecosystem to distribute and reuse code in a modular fashion. However, that doesn't necessarily mean a piece of JavaScript code can run in every environment. Suppose you discovered a module that generates SHA hashes of your user's password. Can you use it in the browser front end? Can you use it on your Node.js server? The answer is: it depends. Modules still have access to global variables, as demonstrated previously. If the module references globals like window, it can run in the browser, but will throw an error in your Node.js server, because window is not available there. Similarly, if the code requires access to process to be functional, it can only be used in Node.js. In order to maximize the reusability of a module, it is often advised to make the code \"isomorphic\"  that is, exhibits the same behavior in every runtime. This is commonly achieved in three ways: Separate your modules into \"core\" and \"binding\". For the \"core\", focus on pure JavaScript logic like computing the hash, without any DOM, network, filesystem access, and expose utility functions. For the \"binding\" part, you can read from and write to the global context. For example, the \"browser binding\" may choose to read the value from an input box, while the \"Node binding\" may read it from process.env, but values read from either place will be piped to the same core function and handled in the same way. The core can be imported in every environment and used in the same way, while only the binding, which is usually lightweight, needs to be platform-specific. Detect whether a particular global exists before using it. For example, if you test that typeof window === \"undefined\", you know that you are probably in a Node.js environment, and should not read DOM. This is preferable if the two branches actually end up with the same behavior (\"isomorphic\"). If it's impossible to provide the same functionality, or if doing so involves loading significant amounts of code while a large part remains unused, better use different \"bindings\" instead. Use a polyfill to provide a fallback for missing features. For example, if you want to use the fetch function, which is only supported in Node.js since v18, you can use a similar API, like the one provided by node-fetch. You can do so conditionally through dynamic imports: The globalThis variable is a global object that is available in every environment and is useful if you want to read or create global variables within modules. These practices are not unique to modules. Still, with the trend of code reusability and modularization, you are encouraged to make your code cross-platform so that it can be enjoyed by as many people as possible. Runtimes like Node.js are also actively implementing web APIs where possible to improve interoperability with the web. Troubleshooting Here are a few tips that may help you if you are having trouble getting your modules to work. Feel free to add to the list if you discover more! We mentioned this before, but to reiterate: .mjs files need to be loaded with a MIME-type of text/javascript (or another JavaScript-compatible MIME-type, but text/javascript is recommended), otherwise you'll get a strict MIME type checking error like \"The server responded with a non-JavaScript MIME type\". If you try to load the HTML file locally (i.e., with a file:// URL), you'll run into CORS errors due to JavaScript module security requirements. You need to do your testing through a server. GitHub pages is ideal as it also serves .mjs files with the correct MIME type. Because .mjs is a non-standard file extension, some operating systems might not recognize it, or try to replace it with something else. For example, we found that macOS was silently adding on .js to the end of .mjs files and then automatically hiding the file extension. So all of our files were actually coming out as x.mjs.js. Once we turned off automatically hiding file extensions, and trained it to accept .mjs, it was OK. See also JavaScript modules on v8.dev (2018) ES modules: A cartoon deep-dive on hacks.mozilla.org (2018) ES6 in Depth: Modules on hacks.mozilla.org (2015) Exploring JS, Ch.16: Modules by Dr. Axel Rauschmayer Previous Help improve MDN Learn how to contribute This page was last modified on Jul 20, 2025 by MDN contributors. View this page on GitHub  Report a problem with this content",
    "headings": [
      {
        "level": 1,
        "text": "JavaScript modules",
        "id": ""
      },
      {
        "level": 2,
        "text": "A background on modules",
        "id": "a_background_on_modules"
      },
      {
        "level": 2,
        "text": "Introducing an example",
        "id": "introducing_an_example"
      },
      {
        "level": 2,
        "text": "Basic example structure",
        "id": "basic_example_structure"
      },
      {
        "level": 2,
        "text": "Exporting module features",
        "id": "exporting_module_features"
      },
      {
        "level": 2,
        "text": "Importing features into your script",
        "id": "importing_features_into_your_script"
      },
      {
        "level": 2,
        "text": "Importing modules using import maps",
        "id": "importing_modules_using_import_maps"
      },
      {
        "level": 2,
        "text": "Loading non-JavaScript resources",
        "id": "loading_non-javascript_resources"
      },
      {
        "level": 2,
        "text": "Applying the module to your HTML",
        "id": "applying_the_module_to_your_html"
      },
      {
        "level": 2,
        "text": "Other differences between modules and classic scripts",
        "id": "other_differences_between_modules_and_classic_scripts"
      },
      {
        "level": 2,
        "text": "Default exports versus named exports",
        "id": "default_exports_versus_named_exports"
      },
      {
        "level": 2,
        "text": "Avoiding naming conflicts",
        "id": "avoiding_naming_conflicts"
      },
      {
        "level": 2,
        "text": "Renaming imports and exports",
        "id": "renaming_imports_and_exports"
      },
      {
        "level": 2,
        "text": "Creating a module object",
        "id": "creating_a_module_object"
      },
      {
        "level": 2,
        "text": "Modules and classes",
        "id": "modules_and_classes"
      },
      {
        "level": 2,
        "text": "Aggregating modules",
        "id": "aggregating_modules"
      },
      {
        "level": 2,
        "text": "Dynamic module loading",
        "id": "dynamic_module_loading"
      },
      {
        "level": 2,
        "text": "Top level await",
        "id": "top_level_await"
      },
      {
        "level": 2,
        "text": "Import declarations are hoisted",
        "id": "import_declarations_are_hoisted"
      },
      {
        "level": 2,
        "text": "Cyclic imports",
        "id": "cyclic_imports"
      },
      {
        "level": 2,
        "text": "Authoring \"isomorphic\" modules",
        "id": "authoring_isomorphic_modules"
      },
      {
        "level": 2,
        "text": "Troubleshooting",
        "id": "troubleshooting"
      },
      {
        "level": 2,
        "text": "See also",
        "id": "see_also"
      },
      {
        "level": 2,
        "text": "Help improve MDN",
        "id": "feedback"
      },
      {
        "level": 3,
        "text": "Aside — .mjs versus .js",
        "id": "aside_—_.mjs_versus_.js"
      },
      {
        "level": 3,
        "text": "Feature detection",
        "id": "feature_detection"
      },
      {
        "level": 3,
        "text": "Importing modules as bare names",
        "id": "importing_modules_as_bare_names"
      },
      {
        "level": 3,
        "text": "Remapping module paths",
        "id": "remapping_module_paths"
      },
      {
        "level": 3,
        "text": "Scoped modules for version management",
        "id": "scoped_modules_for_version_management"
      },
      {
        "level": 3,
        "text": "Improve caching by mapping away hashed filenames",
        "id": "improve_caching_by_mapping_away_hashed_filenames"
      },
      {
        "level": 4,
        "text": "Packages of modules",
        "id": "packages_of_modules"
      },
      {
        "level": 4,
        "text": "General URL remapping",
        "id": "general_url_remapping"
      }
    ],
    "codeBlocks": [
      {
        "language": "text",
        "code": "index.html\nmain.js\nmodules/\n    canvas.js\n    square.js"
      },
      {
        "language": "text",
        "code": "createReportList()"
      },
      {
        "language": "text",
        "code": "reportArea()"
      },
      {
        "language": "text",
        "code": "reportPerimeter()"
      },
      {
        "language": "text",
        "code": "Content-Type"
      },
      {
        "language": "text",
        "code": "text/javascript"
      },
      {
        "language": "text",
        "code": "http-server"
      },
      {
        "language": "text",
        "code": "Content-Type"
      },
      {
        "language": "text",
        "code": "<script type=\"module\">"
      },
      {
        "language": "text",
        "code": "basic-modules"
      },
      {
        "language": "text",
        "code": "/js-examples/module-examples/basic-modules"
      },
      {
        "language": "text",
        "code": "modules/square"
      },
      {
        "language": "text",
        "code": "shapes/circle/"
      },
      {
        "language": "text",
        "code": "shapes/circle/"
      },
      {
        "language": "text",
        "code": "HTMLScriptElement.supports()"
      },
      {
        "language": "text",
        "code": "/node_modules/lodash-es/"
      },
      {
        "language": "text",
        "code": "/node_modules/dependency/"
      },
      {
        "language": "text",
        "code": "cool-module"
      },
      {
        "language": "text",
        "code": "/node_modules/some/other/location/cool-module/index.js"
      },
      {
        "language": "text",
        "code": "cool-module"
      },
      {
        "language": "text",
        "code": "/node_modules/cool-module/index.js"
      },
      {
        "language": "text",
        "code": "dependency_script"
      },
      {
        "language": "text",
        "code": "CSSStyleSheet"
      },
      {
        "language": "text",
        "code": "./data.json"
      },
      {
        "language": "text",
        "code": "CSSStyleSheet"
      },
      {
        "language": "text",
        "code": "type=\"module\""
      },
      {
        "language": "text",
        "code": "type=\"module\""
      },
      {
        "language": "text",
        "code": "rel=\"modulepreload\""
      },
      {
        "language": "text",
        "code": "type=\"module\""
      },
      {
        "language": "text",
        "code": "randomSquare()"
      },
      {
        "language": "text",
        "code": "export default"
      },
      {
        "language": "text",
        "code": "randomSquare"
      },
      {
        "language": "text",
        "code": "reportArea()"
      },
      {
        "language": "text",
        "code": "triangle.js"
      },
      {
        "language": "text",
        "code": "triangle.js"
      },
      {
        "language": "text",
        "code": "modules/\n  canvas.js\n  shapes.js\n  shapes/\n    circle.js\n    square.js\n    triangle.js"
      },
      {
        "language": "text",
        "code": "document.querySelector()"
      },
      {
        "language": "text",
        "code": "Module.Square( /* … */ )"
      },
      {
        "language": "text",
        "code": "type=\"module\""
      },
      {
        "language": "text",
        "code": "top-level-await"
      },
      {
        "language": "text",
        "code": "colors.json"
      },
      {
        "language": "text",
        "code": "getColors.js"
      },
      {
        "language": "text",
        "code": "colors.json"
      },
      {
        "language": "text",
        "code": "getColors.js"
      },
      {
        "language": "text",
        "code": "ReferenceError"
      },
      {
        "language": "text",
        "code": "console.log"
      },
      {
        "language": "text",
        "code": "process.env"
      },
      {
        "language": "text",
        "code": "typeof window === \"undefined\""
      },
      {
        "language": "text",
        "code": "text/javascript"
      },
      {
        "language": "text",
        "code": "text/javascript"
      }
    ],
    "links": [
      {
        "text": "Previous",
        "href": "/en-US/docs/Web/JavaScript/Guide/Internationalization"
      },
      {
        "text": "Node.js",
        "href": "/en-US/docs/Glossary/Node.js"
      },
      {
        "text": "CommonJS",
        "href": "https://en.wikipedia.org/wiki/CommonJS"
      },
      {
        "text": "AMD",
        "href": "https://github.com/amdjs/amdjs-api/blob/master/AMD.md"
      },
      {
        "text": "RequireJS",
        "href": "https://requirejs.org/"
      },
      {
        "text": "webpack",
        "href": "https://webpack.js.org/"
      },
      {
        "text": "Babel",
        "href": "https://babeljs.io/"
      },
      {
        "text": "set of examples",
        "href": "https://github.com/mdn/js-examples/tree/main/module-examples"
      },
      {
        "text": "<canvas>",
        "href": "/en-US/docs/Web/HTML/Reference/Elements/canvas"
      },
      {
        "text": "basic-modules",
        "href": "https://github.com/mdn/js-examples/tree/main/module-examples/basic-modules"
      },
      {
        "text": "<div>",
        "href": "/en-US/docs/Web/HTML/Reference/Elements/div"
      },
      {
        "text": "V8's documentation recommends this",
        "href": "https://v8.dev/features/modules#mjs"
      },
      {
        "text": "Node.js",
        "href": "https://nodejs.org/api/esm.html#esm_enabling"
      },
      {
        "text": "Babel",
        "href": "https://babeljs.io/docs/options#sourcetype"
      },
      {
        "text": "GitHub Pages",
        "href": "https://pages.github.com/"
      },
      {
        "text": "http-server",
        "href": "https://github.com/http-party/http-server#readme"
      },
      {
        "text": "Content-Type",
        "href": "/en-US/docs/Web/HTTP/Reference/Headers/Content-Type"
      },
      {
        "text": "export",
        "href": "/en-US/docs/Web/JavaScript/Reference/Statements/export"
      },
      {
        "text": "import",
        "href": "/en-US/docs/Web/JavaScript/Reference/Statements/import"
      },
      {
        "text": "main.js",
        "href": "https://github.com/mdn/js-examples/blob/main/module-examples/basic-modules/main.js"
      },
      {
        "text": "import reference",
        "href": "/en-US/docs/Web/JavaScript/Reference/Statements/import#imported_values_can_only_be_modified_by_the_exporter"
      },
      {
        "text": "Import maps",
        "href": "/en-US/docs/Web/HTML/Reference/Elements/script/type/importmap"
      },
      {
        "text": "base URL",
        "href": "/en-US/docs/Web/HTML/Reference/Elements/base"
      },
      {
        "text": "JSON object",
        "href": "/en-US/docs/Web/HTML/Reference/Elements/script/type/importmap#import_map_json_representation"
      },
      {
        "text": "importmap",
        "href": "/en-US/docs/Web/HTML/Reference/Elements/script/type/importmap"
      },
      {
        "text": "HTMLScriptElement.supports()",
        "href": "/en-US/docs/Web/API/HTMLScriptElement/supports_static"
      },
      {
        "text": "CSSStyleSheet",
        "href": "/en-US/docs/Web/API/CSSStyleSheet"
      },
      {
        "text": "import attributes",
        "href": "/en-US/docs/Web/JavaScript/Reference/Statements/import/with"
      },
      {
        "text": "<script>",
        "href": "/en-US/docs/Web/HTML/Reference/Elements/script"
      },
      {
        "text": "<link>",
        "href": "/en-US/docs/Web/HTML/Reference/Elements/link"
      },
      {
        "text": "rel=\"modulepreload\"",
        "href": "/en-US/docs/Web/HTML/Reference/Attributes/rel/modulepreload"
      },
      {
        "text": "strict mode",
        "href": "/en-US/docs/Web/JavaScript/Reference/Strict_mode"
      },
      {
        "text": "<script> attributes",
        "href": "/en-US/docs/Web/HTML/Reference/Elements/script#attributes"
      },
      {
        "text": "ES6 In Depth: Modules",
        "href": "https://hacks.mozilla.org/2015/08/es6-in-depth-modules/"
      },
      {
        "text": "renaming",
        "href": "https://github.com/mdn/js-examples/tree/main/module-examples/renaming"
      },
      {
        "text": "module-objects",
        "href": "https://github.com/mdn/js-examples/tree/main/module-examples/module-objects"
      },
      {
        "text": "classes",
        "href": "https://github.com/mdn/js-examples/tree/main/module-examples/classes"
      },
      {
        "text": "square.js",
        "href": "https://github.com/mdn/js-examples/blob/main/module-examples/classes/modules/square.js"
      },
      {
        "text": "main.js",
        "href": "https://github.com/mdn/js-examples/blob/main/module-examples/classes/main.js"
      },
      {
        "text": "module-aggregation",
        "href": "https://github.com/mdn/js-examples/tree/main/module-examples/module-aggregation"
      },
      {
        "text": "shapes.js",
        "href": "https://github.com/mdn/js-examples/blob/main/module-examples/module-aggregation/modules/shapes.js"
      },
      {
        "text": "import()",
        "href": "/en-US/docs/Web/JavaScript/Reference/Operators/import"
      },
      {
        "text": "Promise",
        "href": "/en-US/docs/Web/JavaScript/Reference/Global_Objects/Promise"
      },
      {
        "text": "dynamic-module-imports",
        "href": "https://github.com/mdn/js-examples/tree/main/module-examples/dynamic-module-imports"
      },
      {
        "text": "index.html",
        "href": "https://github.com/mdn/js-examples/blob/main/module-examples/dynamic-module-imports/index.html"
      },
      {
        "text": "main.js",
        "href": "https://github.com/mdn/js-examples/blob/main/module-examples/dynamic-module-imports/main.js"
      },
      {
        "text": "document.querySelector()",
        "href": "/en-US/docs/Web/API/Document/querySelector"
      },
      {
        "text": "asynchronous functions",
        "href": "/en-US/docs/Learn_web_development/Extensions/Async_JS/Introducing"
      },
      {
        "text": "top-level-await",
        "href": "https://github.com/mdn/js-examples/tree/main/module-examples/top-level-await"
      },
      {
        "text": "colors.json",
        "href": "https://github.com/mdn/js-examples/blob/main/module-examples/top-level-await/data/colors.json"
      },
      {
        "text": "getColors.js",
        "href": "https://github.com/mdn/js-examples/blob/main/module-examples/top-level-await/modules/getColors.js"
      },
      {
        "text": "colors.json",
        "href": "https://github.com/mdn/js-examples/blob/main/module-examples/top-level-await/data/colors.json"
      },
      {
        "text": "main.js",
        "href": "https://github.com/mdn/js-examples/blob/main/module-examples/top-level-await/main.js"
      },
      {
        "text": "main.js",
        "href": "https://github.com/mdn/js-examples/blob/main/module-examples/top-level-await/main.js"
      },
      {
        "text": "getColors.js",
        "href": "https://github.com/mdn/js-examples/blob/main/module-examples/top-level-await/modules/getColors.js"
      },
      {
        "text": "canvas.js",
        "href": "https://github.com/mdn/js-examples/blob/main/module-examples/top-level-await/modules/canvas.js"
      },
      {
        "text": "hoisted",
        "href": "/en-US/docs/Glossary/Hoisting"
      },
      {
        "text": "directed graph",
        "href": "https://en.wikipedia.org/wiki/Directed_graph"
      },
      {
        "text": "acyclic",
        "href": "https://en.wikipedia.org/wiki/Directed_acyclic_graph"
      },
      {
        "text": "live bindings",
        "href": "/en-US/docs/Web/JavaScript/Reference/Statements/import#imported_values_can_only_be_modified_by_the_exporter"
      },
      {
        "text": "ReferenceError",
        "href": "/en-US/docs/Web/JavaScript/Reference/Errors/Cant_access_lexical_declaration_before_init"
      },
      {
        "text": "fetch",
        "href": "/en-US/docs/Web/API/Fetch_API"
      },
      {
        "text": "node-fetch",
        "href": "https://www.npmjs.com/package/node-fetch"
      },
      {
        "text": "globalThis",
        "href": "/en-US/docs/Web/JavaScript/Reference/Global_Objects/globalThis"
      },
      {
        "text": "JavaScript modules",
        "href": "https://v8.dev/features/modules"
      },
      {
        "text": "ES modules: A cartoon deep-dive",
        "href": "https://hacks.mozilla.org/2018/03/es-modules-a-cartoon-deep-dive/"
      },
      {
        "text": "ES6 in Depth: Modules",
        "href": "https://hacks.mozilla.org/2015/08/es6-in-depth-modules/"
      },
      {
        "text": "Exploring JS, Ch.16: Modules",
        "href": "https://exploringjs.com/es6/ch_modules.html"
      },
      {
        "text": "Previous",
        "href": "/en-US/docs/Web/JavaScript/Guide/Internationalization"
      },
      {
        "text": "Learn how to contribute",
        "href": "/en-US/docs/MDN/Community/Getting_started"
      },
      {
        "text": "MDN contributors",
        "href": "/en-US/docs/Web/JavaScript/Guide/Modules/contributors.txt"
      },
      {
        "text": "View this page on GitHub",
        "href": "https://github.com/mdn/content/blob/main/files/en-us/web/javascript/guide/modules/index.md?plain=1"
      },
      {
        "text": "Report a problem with this content",
        "href": "https://github.com/mdn/content/issues/new?template=page-report.yml&mdn-url=https%3A%2F%2Fdeveloper.mozilla.org%2Fen-US%2Fdocs%2FWeb%2FJavaScript%2FGuide%2FModules&metadata=%3C%21--+Do+not+make+changes+below+this+line+--%3E%0A%3Cdetails%3E%0A%3Csummary%3EPage+report+details%3C%2Fsummary%3E%0A%0A*+Folder%3A+%60en-us%2Fweb%2Fjavascript%2Fguide%2Fmodules%60%0A*+MDN+URL%3A+https%3A%2F%2Fdeveloper.mozilla.org%2Fen-US%2Fdocs%2FWeb%2FJavaScript%2FGuide%2FModules%0A*+GitHub+URL%3A+https%3A%2F%2Fgithub.com%2Fmdn%2Fcontent%2Fblob%2Fmain%2Ffiles%2Fen-us%2Fweb%2Fjavascript%2Fguide%2Fmodules%2Findex.md%0A*+Last+commit%3A+https%3A%2F%2Fgithub.com%2Fmdn%2Fcontent%2Fcommit%2Fcd22b9f18cf2450c0cc488379b8b780f0f343397%0A*+Document+last+modified%3A+2025-07-20T13%3A51%3A13.000Z%0A%0A%3C%2Fdetails%3E"
      }
    ],
    "meta": {
      "description": "This guide gives you all you need to get started with JavaScript module syntax.",
      "keywords": ""
    },
    "summary": "JavaScript modules Previous This guide gives you all you need to get started with JavaScript module syntax",
    "tags": [
      "react",
      "angular",
      "javascript",
      "typescript",
      "css",
      "html",
      "node",
      "webpack",
      "vite",
      "modules"
    ],
    "id": "javascript-modules-Modules-part-1",
    "quality": 100
  },
  {
    "title": "Closures",
    "url": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Guide/Closures",
    "category": "javascript",
    "content": "Closures A closure is the combination of a function bundled together (enclosed) with references to its surrounding state (the lexical environment). In other words, a closure gives a function access to its outer scope. In JavaScript, closures are created every time a function is created, at function creation time. Lexical scoping Consider the following example code: init() creates a local variable called name and a function called displayName(). The displayName() function is an inner function that is defined inside init() and is available only within the body of the init() function. Note that the displayName() function has no local variables of its own. However, since inner functions have access to the variables of outer scopes, displayName() can access the variable name declared in the parent function, init(). If you run this code in your console, you can see that the console.log() statement within the displayName() function successfully displays the value of the name variable, which is declared in its parent function. This is an example of lexical scoping, which describes how a parser resolves variable names when functions are nested. The word lexical refers to the fact that lexical scoping uses the location where a variable is declared within the source code to determine where that variable is available. Nested functions have access to variables declared in their outer scope. Scoping with let and const Traditionally (before ES6), JavaScript variables only had two kinds of scopes: function scope and global scope. Variables declared with var are either function-scoped or global-scoped, depending on whether they are declared within a function or outside a function. This can be tricky, because blocks with curly braces do not create scopes: For people from other languages (e.g., C, Java) where blocks create scopes, the above code should throw an error on the console.log line, because we are outside the scope of x in either block. However, because blocks don't create scopes for var, the var statements here actually create a global variable. There is also a practical example introduced below that illustrates how this can cause actual bugs when combined with closures. In ES6, JavaScript introduced the let and const declarations, which, among other things like temporal dead zones, allow you to create block-scoped variables. In essence, blocks are finally treated as scopes in ES6, but only if you declare variables with let or const. In addition, ES6 introduced modules, which introduced another kind of scope. Closures are able to capture variables in all these scopes, which we will introduce later. Closure Consider the following code example: Running this code has exactly the same effect as the previous example of the init() function above. What's different (and interesting) is that the displayName() inner function is returned from the outer function before being executed. At first glance, it might seem unintuitive that this code still works. In some programming languages, the local variables within a function exist for just the duration of that function's execution. Once makeFunc() finishes executing, you might expect that the name variable would no longer be accessible. However, because the code still works as expected, this is obviously not the case in JavaScript. The reason is that functions in JavaScript form closures. A closure is the combination of a function and the lexical environment within which that function was declared. This environment consists of any variables that were in-scope at the time the closure was created. In this case, myFunc is a reference to the instance of the function displayName that is created when makeFunc is run. The instance of displayName maintains a reference to its lexical environment, within which the variable name exists. For this reason, when myFunc is invoked, the variable name remains available for use, and \"Mozilla\" is passed to console.log. Here's a slightly more interesting examplea makeAdder function: In this example, we have defined a function makeAdder(x), that takes a single argument x, and returns a new function. The function it returns takes a single argument y, and returns the sum of x and y. In essence, makeAdder is a function factory. It creates functions that can add a specific value to their argument. In the above example, the function factory creates two new functionsone that adds five to its argument, and one that adds 10. add5 and add10 both form closures. They share the same function body definition, but store different lexical environments. In add5's lexical environment, x is 5, while in the lexical environment for add10, x is 10. Practical closures Closures are useful because they let you associate data (the lexical environment) with a function that operates on that data. This has obvious parallels to object-oriented programming, where objects allow you to associate data (the object's properties) with one or more methods. Consequently, you can use a closure anywhere that you might normally use an object with only a single method. Situations where you might want to do this are particularly common on the web. Much of the code written in front-end JavaScript is event-based. You define some behavior, and then attach it to an event that is triggered by the user (such as a click or a keypress). The code is attached as a callback (a single function that is executed in response to the event). For instance, suppose we want to add buttons to a page to adjust the text size. One way of doing this is to specify the font-size of the body element (in pixels), and then set the size of the other elements on the page (such as headers) using the relative em unit: Such interactive text size buttons can change the font-size property of the body element, and the adjustments are picked up by other elements on the page thanks to the relative units. Here's the JavaScript: size12, size14, and size16 are now functions that resize the body text to 12, 14, and 16 pixels, respectively. You can attach them to buttons as demonstrated in the following code example. Emulating private methods with closures Languages such as Java allow you to declare methods as private, meaning that they can be called only by other methods in the same class. JavaScript, prior to classes, didn't have a native way of declaring private methods, but it was possible to emulate private methods using closures. Private methods aren't just useful for restricting access to code. They also provide a powerful way of managing your global namespace. The following code illustrates how to use closures to define public functions that can access private functions and variables. Note that these closures follow the Module Design Pattern. In previous examples, each closure had its own lexical environment. Here though, there is a single lexical environment that is shared by the three functions: counter.increment, counter.decrement, and counter.value. The shared lexical environment is created in the body of an anonymous function, which is executed as soon as it has been defined (also known as an IIFE). The lexical environment contains two private items: a variable called privateCounter, and a function called changeBy. You can't access either of these private members from outside the anonymous function. Instead, you indirectly access them using the three public functions that are returned from the anonymous wrapper. Those three public functions form closures that share the same lexical environment. Thanks to JavaScript's lexical scoping, they each have access to the privateCounter variable and the changeBy function. Notice how the two counters maintain their independence from one another. Each closure references a different version of the privateCounter variable through its own closure. Each time one of the counters is called, its lexical environment changes by changing the value of this variable. Changes to the variable value in one closure don't affect the value in the other closure. Note: Using closures in this way provides benefits that are normally associated with object-oriented programming. In particular, data hiding and encapsulation. Closure scope chain A nested function's access to the outer function's scope includes the enclosing scope of the outer functioneffectively creating a chain of function scopes. To demonstrate, consider the following example code. You can also write without anonymous functions: In the example above, there's a series of nested functions, all of which have access to the outer functions' scope. In this context, we can say that closures have access to all outer scopes. Closures can capture variables in block scopes and module scopes as well. For example, the following creates a closure over the block-scoped variable y: Closures over modules can be more interesting. Here, the module exports a pair of getter-setter functions, which close over the module-scoped variable x. Even when x is not directly accessible from other modules, it can be read and written with the functions. Closures can close over imported values as well, which are regarded as live bindings, because when the original value changes, the imported one changes accordingly. Creating closures in loops: A common mistake Prior to the introduction of the let keyword, a common problem with closures occurred when you created them inside a loop. To demonstrate, consider the following example code. The helpText array defines three helpful hints, each associated with the ID of an input field in the document. The loop cycles through these definitions, hooking up an onfocus event to each one that shows the associated help method. If you try this code out, you'll see that it doesn't work as expected. No matter what field you focus on, the message about your age will be displayed. The reason for this is that the functions assigned to onfocus form closures; they consist of the function definition and the captured environment from the setupHelp function's scope. Three closures have been created by the loop, but each one shares the same single lexical environment, which has a variable with changing values (item). This is because the variable item is declared with var and thus has function scope due to hoisting. The value of item.help is determined when the onfocus callbacks are executed. Because the loop has already run its course by that time, the item variable object (shared by all three closures) has been left pointing to the last entry in the helpText list. One solution in this case is to use more closures: in particular, to use a function factory as described earlier: This works as expected. Rather than the callbacks all sharing a single lexical environment, the makeHelpCallback function creates a new lexical environment for each callback, in which help refers to the corresponding string from the helpText array. One other way to write the above using anonymous closures is: If you don't want to use more closures, you can use the let or const keyword: This example uses const instead of var, so every closure binds the block-scoped variable, meaning that no additional closures are required. If you are writing modern JavaScript anyway, you can consider more alternatives to the plain for loop, such as using for...of loop and declaring item as let or const, or using the forEach() method, which both avoid the closure problem. Performance considerations As mentioned previously, each function instance manages its own scope and closure. Therefore, it is unwise to unnecessarily create functions within other functions if closures are not needed for a particular task, as it will negatively affect script performance both in terms of processing speed and memory consumption. For instance, when creating a new object/class, methods should normally be associated to the object's prototype rather than defined into the object constructor. The reason is that whenever the constructor is called, the methods would get reassigned (that is, for every object creation). Consider the following case: Because the previous code does not take advantage of the benefits of using closures in this particular instance, we could instead rewrite it to avoid using closures as follows: However, redefining the prototype is not recommended. The following example instead appends to the existing prototype: In the two previous examples, the inherited prototype can be shared by all objects and the method definitions need not occur at every object creation. See Inheritance and the prototype chain for more. Help improve MDN Learn how to contribute This page was last modified on Aug 6, 2025 by MDN contributors. View this page on GitHub  Report a problem with this content",
    "headings": [
      {
        "level": 1,
        "text": "Closures",
        "id": ""
      },
      {
        "level": 2,
        "text": "Lexical scoping",
        "id": "lexical_scoping"
      },
      {
        "level": 2,
        "text": "Closure",
        "id": "closure"
      },
      {
        "level": 2,
        "text": "Practical closures",
        "id": "practical_closures"
      },
      {
        "level": 2,
        "text": "Emulating private methods with closures",
        "id": "emulating_private_methods_with_closures"
      },
      {
        "level": 2,
        "text": "Closure scope chain",
        "id": "closure_scope_chain"
      },
      {
        "level": 2,
        "text": "Creating closures in loops: A common mistake",
        "id": "creating_closures_in_loops_a_common_mistake"
      },
      {
        "level": 2,
        "text": "Performance considerations",
        "id": "performance_considerations"
      },
      {
        "level": 2,
        "text": "Help improve MDN",
        "id": "feedback"
      },
      {
        "level": 3,
        "text": "Scoping with let and const",
        "id": "scoping_with_let_and_const"
      }
    ],
    "codeBlocks": [
      {
        "language": "text",
        "code": "displayName()"
      },
      {
        "language": "text",
        "code": "displayName()"
      },
      {
        "language": "text",
        "code": "displayName()"
      },
      {
        "language": "text",
        "code": "displayName()"
      },
      {
        "language": "text",
        "code": "console.log()"
      },
      {
        "language": "text",
        "code": "displayName()"
      },
      {
        "language": "text",
        "code": "console.log"
      },
      {
        "language": "text",
        "code": "displayName()"
      },
      {
        "language": "text",
        "code": "displayName"
      },
      {
        "language": "text",
        "code": "displayName"
      },
      {
        "language": "text",
        "code": "console.log"
      },
      {
        "language": "text",
        "code": "makeAdder(x)"
      },
      {
        "language": "text",
        "code": "counter.increment"
      },
      {
        "language": "text",
        "code": "counter.decrement"
      },
      {
        "language": "text",
        "code": "counter.value"
      },
      {
        "language": "text",
        "code": "privateCounter"
      },
      {
        "language": "text",
        "code": "privateCounter"
      },
      {
        "language": "text",
        "code": "privateCounter"
      },
      {
        "language": "text",
        "code": "makeHelpCallback"
      }
    ],
    "links": [
      {
        "text": "temporal dead zones",
        "href": "/en-US/docs/Web/JavaScript/Reference/Statements/let#temporal_dead_zone_tdz"
      },
      {
        "text": "modules",
        "href": "/en-US/docs/Web/JavaScript/Guide/Modules"
      },
      {
        "text": "classes",
        "href": "/en-US/docs/Web/JavaScript/Reference/Classes"
      },
      {
        "text": "private methods",
        "href": "/en-US/docs/Web/JavaScript/Reference/Classes/Private_elements#private_methods"
      },
      {
        "text": "Module Design Pattern",
        "href": "https://www.google.com/search?q=javascript+module+pattern"
      },
      {
        "text": "IIFE",
        "href": "/en-US/docs/Glossary/IIFE"
      },
      {
        "text": "bindings",
        "href": "/en-US/docs/Glossary/Binding"
      },
      {
        "text": "let",
        "href": "/en-US/docs/Web/JavaScript/Reference/Statements/let"
      },
      {
        "text": "let",
        "href": "/en-US/docs/Web/JavaScript/Reference/Statements/let"
      },
      {
        "text": "const",
        "href": "/en-US/docs/Web/JavaScript/Reference/Statements/const"
      },
      {
        "text": "for...of",
        "href": "/en-US/docs/Web/JavaScript/Reference/Statements/for...of"
      },
      {
        "text": "forEach()",
        "href": "/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/forEach"
      },
      {
        "text": "Inheritance and the prototype chain",
        "href": "/en-US/docs/Web/JavaScript/Guide/Inheritance_and_the_prototype_chain"
      },
      {
        "text": "Learn how to contribute",
        "href": "/en-US/docs/MDN/Community/Getting_started"
      },
      {
        "text": "MDN contributors",
        "href": "/en-US/docs/Web/JavaScript/Guide/Closures/contributors.txt"
      },
      {
        "text": "View this page on GitHub",
        "href": "https://github.com/mdn/content/blob/main/files/en-us/web/javascript/guide/closures/index.md?plain=1"
      },
      {
        "text": "Report a problem with this content",
        "href": "https://github.com/mdn/content/issues/new?template=page-report.yml&mdn-url=https%3A%2F%2Fdeveloper.mozilla.org%2Fen-US%2Fdocs%2FWeb%2FJavaScript%2FGuide%2FClosures&metadata=%3C%21--+Do+not+make+changes+below+this+line+--%3E%0A%3Cdetails%3E%0A%3Csummary%3EPage+report+details%3C%2Fsummary%3E%0A%0A*+Folder%3A+%60en-us%2Fweb%2Fjavascript%2Fguide%2Fclosures%60%0A*+MDN+URL%3A+https%3A%2F%2Fdeveloper.mozilla.org%2Fen-US%2Fdocs%2FWeb%2FJavaScript%2FGuide%2FClosures%0A*+GitHub+URL%3A+https%3A%2F%2Fgithub.com%2Fmdn%2Fcontent%2Fblob%2Fmain%2Ffiles%2Fen-us%2Fweb%2Fjavascript%2Fguide%2Fclosures%2Findex.md%0A*+Last+commit%3A+https%3A%2F%2Fgithub.com%2Fmdn%2Fcontent%2Fcommit%2Ff97e095b8c0b44bbc6fdd04d380345d4b1743410%0A*+Document+last+modified%3A+2025-08-06T16%3A34%3A28.000Z%0A%0A%3C%2Fdetails%3E"
      }
    ],
    "meta": {
      "description": "A closure is the combination of a function bundled together (enclosed) with references to its surrounding state (the lexical environment). In other words, a closure gives a function access to its outer scope. In JavaScript, closures are created every time a function is created, at function creation time.",
      "keywords": ""
    },
    "summary": "Closures A closure is the combination of a function bundled together (enclosed) with references to its surrounding state (the lexical environment)",
    "tags": [
      "react",
      "angular",
      "javascript",
      "typescript",
      "html",
      "node",
      "webpack",
      "closures",
      "scoping",
      "closure"
    ],
    "id": "closures-Closures-part-1",
    "quality": 90
  },
  {
    "title": "Inheritance and the prototype chain",
    "url": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Guide/Inheritance_and_the_prototype_chain",
    "category": "javascript",
    "content": "Inheritance and the prototype chain In programming, inheritance refers to passing down characteristics from a parent to a child so that a new piece of code can reuse and build upon the features of an existing one. JavaScript implements inheritance by using objects. Each object has an internal link to another object called its prototype. That prototype object has a prototype of its own, and so on until an object is reached with null as its prototype. By definition, null has no prototype and acts as the final link in this prototype chain. It is possible to mutate any member of the prototype chain or even swap out the prototype at runtime, so concepts like static dispatching do not exist in JavaScript. JavaScript is a bit confusing for developers experienced in class-based languages (like Java or C++), as it is dynamic and does not have static types. While this confusion is often considered to be one of JavaScript's weaknesses, the prototypal inheritance model itself is, in fact, more powerful than the classic model. It is, for example, fairly trivial to build a classic model on top of a prototypal model  which is how classes are implemented. Although classes are now widely adopted and have become a new paradigm in JavaScript, classes do not bring a new inheritance pattern. While classes abstract most of the prototypal mechanism away, understanding how prototypes work under the hood is still useful. Inheritance with the prototype chain Inheriting properties JavaScript objects are dynamic \"bags\" of properties (referred to as own properties). JavaScript objects have a link to a prototype object. When trying to access a property of an object, the property will not only be sought on the object but on the prototype of the object, the prototype of the prototype, and so on until either a property with a matching name is found or the end of the prototype chain is reached. Note: Following the ECMAScript standard, the notation someObject.[[Prototype]] is used to designate the prototype of someObject. The [[Prototype]] internal slot can be accessed and modified with the Object.getPrototypeOf() and Object.setPrototypeOf() functions respectively. This is equivalent to the JavaScript accessor __proto__ which is non-standard but de-facto implemented by many JavaScript engines. To prevent confusion while keeping it succinct, in our notation we will avoid using obj.__proto__ but use obj.[[Prototype]] instead. This corresponds to Object.getPrototypeOf(obj). It should not be confused with the func.prototype property of functions, which instead specifies the [[Prototype]] to be assigned to all instances of objects created by the given function when used as a constructor. We will discuss the prototype property of constructor functions in a later section. There are several ways to specify the [[Prototype]] of an object, which are listed in a later section. For now, we will use the __proto__ syntax for illustration. It's worth noting that the { __proto__: ... } syntax is different from the obj.__proto__ accessor: the former is standard and not deprecated. In an object literal like { a: 1, b: 2, __proto__: c }, the value c (which has to be either null or another object) will become the [[Prototype]] of the object represented by the literal, while the other keys like a and b will become the own properties of the object. This syntax reads very naturally, since [[Prototype]] is just an \"internal property\" of the object. Here is what happens when trying to access a property: Setting a property to an object creates an own property. The only exception to the getting and setting behavior rules is when it's intercepted by a getter or setter. Similarly, you can create longer prototype chains, and a property will be sought on all of them. Inheriting \"methods\" JavaScript does not have \"methods\" in the form that class-based languages define them. In JavaScript, any function can be added to an object in the form of a property. An inherited function acts just as any other property, including property shadowing as shown above (in this case, a form of method overriding). When an inherited function is executed, the value of this points to the inheriting object, not to the prototype object where the function is an own property. Constructors The power of prototypes is that we can reuse a set of properties if they should be present on every instance  especially for methods. Suppose we are to create a series of boxes, where each box is an object that contains a value which can be accessed through a getValue function. A naive implementation would be: This is subpar, because each instance has its own function property that does the same thing, which is redundant and unnecessary. Instead, we can move getValue to the [[Prototype]] of all boxes: This way, all boxes' getValue method will refer to the same function, lowering memory usage. However, manually binding the __proto__ for every object creation is still very inconvenient. This is when we would use a constructor function, which automatically sets the [[Prototype]] for every object manufactured. Constructors are functions called with new. We say that new Box(1) is an instance created from the Box constructor function. Box.prototype is not much different from the boxPrototype object we created previously  it's just a plain object. Every instance created from a constructor function will automatically have the constructor's prototype property as its [[Prototype]]  that is, Object.getPrototypeOf(new Box()) === Box.prototype. Constructor.prototype by default has one own property: constructor, which references the constructor function itself  that is, Box.prototype.constructor === Box. This allows one to access the original constructor from any instance. Note: If a non-primitive is returned from the constructor function, that value will become the result of the new expression. In this case the [[Prototype]] may not be correctly bound  but this should not happen much in practice. The above constructor function can be rewritten in classes as: Classes are syntax sugar over constructor functions, which means you can still manipulate Box.prototype to change the behavior of all instances. However, because classes are designed to be an abstraction over the underlying prototype mechanism, we will use the more-lightweight constructor function syntax for this tutorial to fully demonstrate how prototypes work. Because Box.prototype references the same object as the [[Prototype]] of all instances, we can change the behavior of all instances by mutating Box.prototype. A corollary is, re-assigning Constructor.prototype (Constructor.prototype = ...) is a bad idea for two reasons: The [[Prototype]] of instances created before the reassignment is now referencing a different object from the [[Prototype]] of instances created after the reassignment  mutating one's [[Prototype]] no longer mutates the other. Unless you manually re-set the constructor property, the constructor function can no longer be traced from instance.constructor, which may break user expectation. Some built-in operations will read the constructor property as well, and if it is not set, they may not work as expected. Constructor.prototype is only useful when constructing instances. It has nothing to do with Constructor.[[Prototype]], which is the constructor function's own prototype, which is Function.prototype  that is, Object.getPrototypeOf(Constructor) === Function.prototype. Implicit constructors of literals Some literal syntaxes in JavaScript create instances that implicitly set the [[Prototype]]. For example: We can \"de-sugar\" them into their constructor form. For example, \"array methods\" like map() are simply methods defined on Array.prototype, which is why they are automatically available on all array instances. Warning: There is one misfeature that used to be prevalent  extending Object.prototype or one of the other built-in prototypes. An example of this misfeature is, defining Array.prototype.myMethod = function () {...} and then using myMethod on all array instances. This misfeature is called monkey patching. Doing monkey patching risks forward compatibility, because if the language adds this method in the future but with a different signature, your code will break. It has led to incidents like the SmooshGate, and can be a great nuisance for the language to advance since JavaScript tries to \"not break the web\". The only good reason for extending a built-in prototype is to backport the features of newer JavaScript engines, like Array.prototype.forEach. It may be interesting to note that due to historical reasons, some built-in constructors' prototype property are instances themselves. For example, Number.prototype is a number 0, Array.prototype is an empty array, and RegExp.prototype is /(?:)/. However, this is not the case for user-defined constructors, nor for modern constructors like Map. Building longer inheritance chains The Constructor.prototype property will become the [[Prototype]] of the constructor's instances, as-is  including Constructor.prototype's own [[Prototype]]. By default, Constructor.prototype is a plain object  that is, Object.getPrototypeOf(Constructor.prototype) === Object.prototype. The only exception is Object.prototype itself, whose [[Prototype]] is null  that is, Object.getPrototypeOf(Object.prototype) === null. Therefore, a typical constructor will build the following prototype chain: To build longer prototype chains, we can set the [[Prototype]] of Constructor.prototype via the Object.setPrototypeOf() function. In class terms, this is equivalent to using the extends syntax. You may also see some legacy code using Object.create() to build the inheritance chain. However, because this reassigns the prototype property and removes the constructor property, it can be more error-prone, while performance gains may not be apparent if the constructors haven't created any instances yet. Inspecting prototypes: a deeper dive Let's look at what happens behind the scenes in a bit more detail. In JavaScript, as mentioned above, functions are able to have properties. All functions have a special property named prototype. Please note that the code below is free-standing (it is safe to assume there is no other JavaScript on the webpage other than the below code). For the best learning experience, it is highly recommended that you open a console, navigate to the \"console\" tab, copy-and-paste in the below JavaScript code, and run it by pressing the Enter/Return key. (The console is included in most web browser's Developer Tools. More information is available for Firefox Developer Tools, Chrome DevTools, and Edge DevTools.) As seen above, doSomething() has a default prototype property, as demonstrated by the console. After running this code, the console should have displayed an object that looks similar to this. { constructor:  doSomething(), [[Prototype]]: { constructor:  Object(), hasOwnProperty:  hasOwnProperty(), isPrototypeOf:  isPrototypeOf(), propertyIsEnumerable:  propertyIsEnumerable(), toLocaleString:  toLocaleString(), toString:  toString(), valueOf:  valueOf() } } Note: The Chrome console uses [[Prototype]] to denote the object's prototype, following the spec's terms; Firefox uses prototype. For consistency we will use [[Prototype]]. We can add properties to the prototype of doSomething(), as shown below. This results in: { foo: \"bar\", constructor:  doSomething(), [[Prototype]]: { constructor:  Object(), hasOwnProperty:  hasOwnProperty(), isPrototypeOf:  isPrototypeOf(), propertyIsEnumerable:  propertyIsEnumerable(), toLocaleString:  toLocaleString(), toString:  toString(), valueOf:  valueOf() } } We can now use the new operator to create an instance of doSomething() based on this prototype. To use the new operator, call the function normally except prefix it with new. Calling a function with the new operator returns an object that is an instance of the function. Properties can then be added onto this object. Try the following code: This results in an output similar to the following: { prop: \"some value\", [[Prototype]]: { foo: \"bar\", constructor:  doSomething(), [[Prototype]]: { constructor:  Object(), hasOwnProperty:  hasOwnProperty(), isPrototypeOf:  isPrototypeOf(), propertyIsEnumerable:  propertyIsEnumerable(), toLocaleString:  toLocaleString(), toString:  toString(), valueOf:  valueOf() } } } As seen above, the [[Prototype]] of doSomeInstancing is doSomething.prototype. But, what does this do? When you access a property of doSomeInstancing, the runtime first looks to see if doSomeInstancing has that property. If doSomeInstancing does not have the property, then the runtime looks for the property in doSomeInstancing.[[Prototype]] (a.k.a. doSomething.prototype). If doSomeInstancing.[[Prototype]] has the property being looked for, then that property on doSomeInstancing.[[Prototype]] is used. Otherwise, if doSomeInstancing.[[Prototype]] does not have the property, then doSomeInstancing.[[Prototype]].[[Prototype]] is checked for the property. By default, the [[Prototype]] of any function's prototype property is Object.prototype. So, doSomeInstancing.[[Prototype]].[[Prototype]] (a.k.a. doSomething.prototype.[[Prototype]] (a.k.a. Object.prototype)) is then looked through for the property being searched for. If the property is not found in doSomeInstancing.[[Prototype]].[[Prototype]], then doSomeInstancing.[[Prototype]].[[Prototype]].[[Prototype]] is looked through. However, there is a problem: doSomeInstancing.[[Prototype]].[[Prototype]].[[Prototype]] does not exist, because Object.prototype.[[Prototype]] is null. Then, and only then, after the entire prototype chain of [[Prototype]]'s is looked through, the runtime asserts that the property does not exist and conclude that the value at the property is undefined. Let's try entering some more code into the console: This results in the following: doSomeInstancing.prop: some value doSomeInstancing.foo: bar doSomething.prop: undefined doSomething.foo: undefined doSomething.prototype.prop: undefined doSomething.prototype.foo: bar Different ways of creating and mutating prototype chains We have encountered many ways to create objects and change their prototype chains. We will systematically summarize the different ways, comparing each approach's pros and cons. Objects created with syntax constructs When using the __proto__ key in object initializers, pointing the __proto__ key to something that is not an object only fails silently without throwing an exception. Contrary to the Object.prototype.__proto__ setter, __proto__ in object literal initializers is standardized and optimized, and can even be more performant than Object.create. Declaring extra own properties on the object at creation is more ergonomic than Object.create. With constructor functions Constructor functions have been available since very early JavaScript. Therefore, it is very fast, very standard, and very JIT-optimizable. However, it's also hard to \"do properly\" because methods added this way are enumerable by default, which is inconsistent with the class syntax or how built-in methods behave. Doing longer inheritance chains is also error-prone, as previously demonstrated. With Object.create() Calling Object.create() creates a new object. The [[Prototype]] of this object is the first argument of the function: Similar to the __proto__ key in object initializers, Object.create() allows directly setting the prototype of an object at creation time, which permits the runtime to further optimize the object. It also allows the creation of objects with null prototype, using Object.create(null). The second parameter of Object.create() allows you to precisely specify the attributes of each property in the new object, which can be a double-edged sword: It allows you to create non-enumerable properties, etc., during object creation, which is not possible with object literals. It is much more verbose and error-prone than object literals. It may be slower than object literals, especially when creating many properties. With classes Classes offer the highest readability and maintainability when defining complex inheritance structures. Private elements are a feature with no trivial replacement in prototypal inheritance. However, classes are less optimized than traditional constructor functions and are not supported in older environments. With Object.setPrototypeOf() While all methods above will set the prototype chain at object creation time, Object.setPrototypeOf() allows mutating the [[Prototype]] internal property of an existing object. It can even force a prototype on a prototype-less object created with Object.create(null) or remove the prototype of an object by setting it to null. However, you should set the prototype during creation if possible, because setting the prototype dynamically disrupts all optimizations that engines have made to the prototype chain. It might cause some engines to recompile your code for de-optimization, to make it work according to the specs. With the __proto__ accessor All objects inherit the Object.prototype.__proto__ setter, which can be used to set the [[Prototype]] of an existing object (if the __proto__ key is not overridden on the object). Warning: Object.prototype.__proto__ accessors are non-standard and deprecated. You should almost always use Object.setPrototypeOf instead. Compared to Object.setPrototypeOf, setting __proto__ to something that is not an object fails silently without throwing an exception. It also has slightly better browser support. However, it is non-standard and deprecated. You should almost always use Object.setPrototypeOf instead. Performance The lookup time for properties that are high up on the prototype chain can have a negative impact on the performance, and this may be significant in the code where performance is critical. Additionally, trying to access nonexistent properties will always traverse the full prototype chain. Also, when iterating over the properties of an object, every enumerable property that is on the prototype chain will be enumerated. To check whether an object has a property defined on itself and not somewhere on its prototype chain, it is necessary to use the hasOwnProperty or Object.hasOwn methods. All objects, except those with null as [[Prototype]], inherit hasOwnProperty from Object.prototype  unless it has been overridden further down the prototype chain. To give you a concrete example, let's take the above graph example code to illustrate it: Note: It is not enough to check whether a property is undefined. The property might very well exist, but its value just happens to be set to undefined. Conclusion JavaScript may be a bit confusing for developers coming from Java or C++, as it's all dynamic, all runtime, and it has no static types at all. Everything is either an object (instance) or a function (constructor), and even functions themselves are instances of the Function constructor. Even the \"classes\" as syntax constructs are just constructor functions at runtime. All constructor functions in JavaScript have a special property called prototype, which works with the new operator. The reference to the prototype object is copied to the internal [[Prototype]] property of the new instance. For example, when you do const a1 = new A(), JavaScript (after creating the object in memory and before running function A() with this defined to it) sets a1.[[Prototype]] = A.prototype. When you then access properties of the instance, JavaScript first checks whether they exist on that object directly, and if not, it looks in [[Prototype]]. [[Prototype]] is looked at recursively, i.e., a1.doSomething, Object.getPrototypeOf(a1).doSomething, Object.getPrototypeOf(Object.getPrototypeOf(a1)).doSomething etc., until it's found or Object.getPrototypeOf returns null. This means that all properties defined on prototype are effectively shared by all instances, and you can even later change parts of prototype and have the changes appear in all existing instances. If, in the example above, you do const a1 = new A(); const a2 = new A();, then a1.doSomething would actually refer to Object.getPrototypeOf(a1).doSomething  which is the same as the A.prototype.doSomething you defined, i.e., Object.getPrototypeOf(a1).doSomething === Object.getPrototypeOf(a2).doSomething === A.prototype.doSomething. It is essential to understand the prototypal inheritance model before writing complex code that makes use of it. Also, be aware of the length of the prototype chains in your code and break them up if necessary to avoid possible performance problems. Further, the native prototypes should never be extended unless it is for the sake of compatibility with newer JavaScript features. Help improve MDN Learn how to contribute This page was last modified on Jul 8, 2025 by MDN contributors. View this page on GitHub  Report a problem with this content",
    "headings": [
      {
        "level": 1,
        "text": "Inheritance and the prototype chain",
        "id": ""
      },
      {
        "level": 2,
        "text": "Inheritance with the prototype chain",
        "id": "inheritance_with_the_prototype_chain"
      },
      {
        "level": 2,
        "text": "Constructors",
        "id": "constructors"
      },
      {
        "level": 2,
        "text": "Inspecting prototypes: a deeper dive",
        "id": "inspecting_prototypes_a_deeper_dive"
      },
      {
        "level": 2,
        "text": "Different ways of creating and mutating prototype chains",
        "id": "different_ways_of_creating_and_mutating_prototype_chains"
      },
      {
        "level": 2,
        "text": "Performance",
        "id": "performance"
      },
      {
        "level": 2,
        "text": "Conclusion",
        "id": "conclusion"
      },
      {
        "level": 2,
        "text": "Help improve MDN",
        "id": "feedback"
      },
      {
        "level": 3,
        "text": "Inheriting properties",
        "id": "inheriting_properties"
      },
      {
        "level": 3,
        "text": "Inheriting \"methods\"",
        "id": "inheriting_methods"
      },
      {
        "level": 3,
        "text": "Implicit constructors of literals",
        "id": "implicit_constructors_of_literals"
      },
      {
        "level": 3,
        "text": "Building longer inheritance chains",
        "id": "building_longer_inheritance_chains"
      },
      {
        "level": 3,
        "text": "Objects created with syntax constructs",
        "id": "objects_created_with_syntax_constructs"
      },
      {
        "level": 3,
        "text": "With constructor functions",
        "id": "with_constructor_functions"
      },
      {
        "level": 3,
        "text": "With Object.create()",
        "id": "with_object.create"
      },
      {
        "level": 3,
        "text": "With classes",
        "id": "with_classes"
      },
      {
        "level": 3,
        "text": "With Object.setPrototypeOf()",
        "id": "with_object.setprototypeof"
      },
      {
        "level": 3,
        "text": "With the __proto__ accessor",
        "id": "with_the___proto___accessor"
      }
    ],
    "codeBlocks": [
      {
        "language": "text",
        "code": "someObject.[[Prototype]]"
      },
      {
        "language": "text",
        "code": "[[Prototype]]"
      },
      {
        "language": "text",
        "code": "Object.getPrototypeOf()"
      },
      {
        "language": "text",
        "code": "Object.setPrototypeOf()"
      },
      {
        "language": "text",
        "code": "obj.__proto__"
      },
      {
        "language": "text",
        "code": "obj.[[Prototype]]"
      },
      {
        "language": "text",
        "code": "Object.getPrototypeOf(obj)"
      },
      {
        "language": "text",
        "code": "func.prototype"
      },
      {
        "language": "text",
        "code": "[[Prototype]]"
      },
      {
        "language": "text",
        "code": "[[Prototype]]"
      },
      {
        "language": "text",
        "code": "{ __proto__: ... }"
      },
      {
        "language": "text",
        "code": "obj.__proto__"
      },
      {
        "language": "text",
        "code": "{ a: 1, b: 2, __proto__: c }"
      },
      {
        "language": "text",
        "code": "[[Prototype]]"
      },
      {
        "language": "text",
        "code": "[[Prototype]]"
      },
      {
        "language": "text",
        "code": "[[Prototype]]"
      },
      {
        "language": "text",
        "code": "[[Prototype]]"
      },
      {
        "language": "text",
        "code": "Box.prototype"
      },
      {
        "language": "text",
        "code": "boxPrototype"
      },
      {
        "language": "text",
        "code": "[[Prototype]]"
      },
      {
        "language": "text",
        "code": "Object.getPrototypeOf(new Box()) === Box.prototype"
      },
      {
        "language": "text",
        "code": "Constructor.prototype"
      },
      {
        "language": "text",
        "code": "constructor"
      },
      {
        "language": "text",
        "code": "Box.prototype.constructor === Box"
      },
      {
        "language": "text",
        "code": "[[Prototype]]"
      },
      {
        "language": "text",
        "code": "Box.prototype"
      },
      {
        "language": "text",
        "code": "Box.prototype"
      },
      {
        "language": "text",
        "code": "[[Prototype]]"
      },
      {
        "language": "text",
        "code": "Box.prototype"
      },
      {
        "language": "text",
        "code": "Constructor.prototype"
      },
      {
        "language": "text",
        "code": "Constructor.prototype = ..."
      },
      {
        "language": "text",
        "code": "[[Prototype]]"
      },
      {
        "language": "text",
        "code": "[[Prototype]]"
      },
      {
        "language": "text",
        "code": "[[Prototype]]"
      },
      {
        "language": "text",
        "code": "constructor"
      },
      {
        "language": "text",
        "code": "instance.constructor"
      },
      {
        "language": "text",
        "code": "constructor"
      },
      {
        "language": "text",
        "code": "Constructor.prototype"
      },
      {
        "language": "text",
        "code": "Constructor.[[Prototype]]"
      },
      {
        "language": "text",
        "code": "Function.prototype"
      },
      {
        "language": "text",
        "code": "Object.getPrototypeOf(Constructor) === Function.prototype"
      },
      {
        "language": "text",
        "code": "[[Prototype]]"
      },
      {
        "language": "text",
        "code": "Array.prototype"
      },
      {
        "language": "text",
        "code": "Object.prototype"
      },
      {
        "language": "text",
        "code": "Array.prototype.myMethod = function () {...}"
      },
      {
        "language": "text",
        "code": "Array.prototype.forEach"
      },
      {
        "language": "text",
        "code": "Number.prototype"
      },
      {
        "language": "text",
        "code": "Array.prototype"
      },
      {
        "language": "text",
        "code": "RegExp.prototype"
      },
      {
        "language": "text",
        "code": "Constructor.prototype"
      },
      {
        "language": "text",
        "code": "[[Prototype]]"
      },
      {
        "language": "text",
        "code": "Constructor.prototype"
      },
      {
        "language": "text",
        "code": "[[Prototype]]"
      },
      {
        "language": "text",
        "code": "Constructor.prototype"
      },
      {
        "language": "text",
        "code": "Object.getPrototypeOf(Constructor.prototype) === Object.prototype"
      },
      {
        "language": "text",
        "code": "Object.prototype"
      },
      {
        "language": "text",
        "code": "[[Prototype]]"
      },
      {
        "language": "text",
        "code": "Object.getPrototypeOf(Object.prototype) === null"
      },
      {
        "language": "text",
        "code": "[[Prototype]]"
      },
      {
        "language": "text",
        "code": "Constructor.prototype"
      },
      {
        "language": "text",
        "code": "Object.setPrototypeOf()"
      },
      {
        "language": "text",
        "code": "Object.create()"
      },
      {
        "language": "text",
        "code": "constructor"
      },
      {
        "language": "text",
        "code": "doSomething()"
      },
      {
        "language": "text",
        "code": "{\n  constructor: ƒ doSomething(),\n  [[Prototype]]: {\n    constructor: ƒ Object(),\n    hasOwnProperty: ƒ hasOwnProperty(),\n    isPrototypeOf: ƒ isPrototypeOf(),\n    propertyIsEnumerable: ƒ propertyIsEnumerable(),\n    toLocaleString: ƒ toLocaleString(),\n    toString: ƒ toString(),\n    valueOf: ƒ valueOf()\n  }\n}"
      },
      {
        "language": "text",
        "code": "[[Prototype]]"
      },
      {
        "language": "text",
        "code": "<prototype>"
      },
      {
        "language": "text",
        "code": "[[Prototype]]"
      },
      {
        "language": "text",
        "code": "doSomething()"
      },
      {
        "language": "text",
        "code": "{\n  foo: \"bar\",\n  constructor: ƒ doSomething(),\n  [[Prototype]]: {\n    constructor: ƒ Object(),\n    hasOwnProperty: ƒ hasOwnProperty(),\n    isPrototypeOf: ƒ isPrototypeOf(),\n    propertyIsEnumerable: ƒ propertyIsEnumerable(),\n    toLocaleString: ƒ toLocaleString(),\n    toString: ƒ toString(),\n    valueOf: ƒ valueOf()\n  }\n}"
      },
      {
        "language": "text",
        "code": "doSomething()"
      },
      {
        "language": "text",
        "code": "{\n  prop: \"some value\",\n  [[Prototype]]: {\n    foo: \"bar\",\n    constructor: ƒ doSomething(),\n    [[Prototype]]: {\n      constructor: ƒ Object(),\n      hasOwnProperty: ƒ hasOwnProperty(),\n      isPrototypeOf: ƒ isPrototypeOf(),\n      propertyIsEnumerable: ƒ propertyIsEnumerable(),\n      toLocaleString: ƒ toLocaleString(),\n      toString: ƒ toString(),\n      valueOf: ƒ valueOf()\n    }\n  }\n}"
      },
      {
        "language": "text",
        "code": "[[Prototype]]"
      },
      {
        "language": "text",
        "code": "doSomeInstancing"
      },
      {
        "language": "text",
        "code": "doSomething.prototype"
      },
      {
        "language": "text",
        "code": "doSomeInstancing"
      },
      {
        "language": "text",
        "code": "doSomeInstancing"
      },
      {
        "language": "text",
        "code": "doSomeInstancing"
      },
      {
        "language": "text",
        "code": "doSomeInstancing.[[Prototype]]"
      },
      {
        "language": "text",
        "code": "doSomething.prototype"
      },
      {
        "language": "text",
        "code": "doSomeInstancing.[[Prototype]]"
      },
      {
        "language": "text",
        "code": "doSomeInstancing.[[Prototype]]"
      },
      {
        "language": "text",
        "code": "doSomeInstancing.[[Prototype]]"
      },
      {
        "language": "text",
        "code": "doSomeInstancing.[[Prototype]].[[Prototype]]"
      },
      {
        "language": "text",
        "code": "[[Prototype]]"
      },
      {
        "language": "text",
        "code": "Object.prototype"
      },
      {
        "language": "text",
        "code": "doSomeInstancing.[[Prototype]].[[Prototype]]"
      },
      {
        "language": "text",
        "code": "doSomething.prototype.[[Prototype]]"
      },
      {
        "language": "text",
        "code": "Object.prototype"
      },
      {
        "language": "text",
        "code": "doSomeInstancing.[[Prototype]].[[Prototype]]"
      },
      {
        "language": "text",
        "code": "doSomeInstancing.[[Prototype]].[[Prototype]].[[Prototype]]"
      },
      {
        "language": "text",
        "code": "doSomeInstancing.[[Prototype]].[[Prototype]].[[Prototype]]"
      },
      {
        "language": "text",
        "code": "Object.prototype.[[Prototype]]"
      },
      {
        "language": "text",
        "code": "[[Prototype]]"
      },
      {
        "language": "text",
        "code": "doSomeInstancing.prop:      some value\ndoSomeInstancing.foo:       bar\ndoSomething.prop:           undefined\ndoSomething.foo:            undefined\ndoSomething.prototype.prop: undefined\ndoSomething.prototype.foo:  bar"
      },
      {
        "language": "text",
        "code": "Object.prototype.__proto__"
      },
      {
        "language": "text",
        "code": "Object.create"
      },
      {
        "language": "text",
        "code": "Object.create"
      },
      {
        "language": "text",
        "code": "Object.create()"
      },
      {
        "language": "text",
        "code": "[[Prototype]]"
      },
      {
        "language": "text",
        "code": "Object.create()"
      },
      {
        "language": "text",
        "code": "Object.create(null)"
      },
      {
        "language": "text",
        "code": "Object.create()"
      },
      {
        "language": "text",
        "code": "Object.setPrototypeOf()"
      },
      {
        "language": "text",
        "code": "[[Prototype]]"
      },
      {
        "language": "text",
        "code": "Object.create(null)"
      },
      {
        "language": "text",
        "code": "Object.prototype.__proto__"
      },
      {
        "language": "text",
        "code": "[[Prototype]]"
      },
      {
        "language": "text",
        "code": "Object.prototype.__proto__"
      },
      {
        "language": "text",
        "code": "Object.setPrototypeOf"
      },
      {
        "language": "text",
        "code": "Object.setPrototypeOf"
      },
      {
        "language": "text",
        "code": "Object.setPrototypeOf"
      },
      {
        "language": "text",
        "code": "hasOwnProperty"
      },
      {
        "language": "text",
        "code": "Object.hasOwn"
      },
      {
        "language": "text",
        "code": "[[Prototype]]"
      },
      {
        "language": "text",
        "code": "hasOwnProperty"
      },
      {
        "language": "text",
        "code": "Object.prototype"
      },
      {
        "language": "text",
        "code": "[[Prototype]]"
      },
      {
        "language": "text",
        "code": "const a1 = new A()"
      },
      {
        "language": "text",
        "code": "a1.[[Prototype]] = A.prototype"
      },
      {
        "language": "text",
        "code": "[[Prototype]]"
      },
      {
        "language": "text",
        "code": "[[Prototype]]"
      },
      {
        "language": "text",
        "code": "a1.doSomething"
      },
      {
        "language": "text",
        "code": "Object.getPrototypeOf(a1).doSomething"
      },
      {
        "language": "text",
        "code": "Object.getPrototypeOf(Object.getPrototypeOf(a1)).doSomething"
      },
      {
        "language": "text",
        "code": "Object.getPrototypeOf"
      },
      {
        "language": "text",
        "code": "const a1 = new A(); const a2 = new A();"
      },
      {
        "language": "text",
        "code": "a1.doSomething"
      },
      {
        "language": "text",
        "code": "Object.getPrototypeOf(a1).doSomething"
      },
      {
        "language": "text",
        "code": "A.prototype.doSomething"
      },
      {
        "language": "text",
        "code": "Object.getPrototypeOf(a1).doSomething === Object.getPrototypeOf(a2).doSomething === A.prototype.doSomething"
      }
    ],
    "links": [
      {
        "text": "objects",
        "href": "/en-US/docs/Web/JavaScript/Guide/Data_structures#objects"
      },
      {
        "text": "static dispatching",
        "href": "https://en.wikipedia.org/wiki/Static_dispatch"
      },
      {
        "text": "dynamic",
        "href": "/en-US/docs/Web/JavaScript/Guide/Data_structures#dynamic_and_weak_typing"
      },
      {
        "text": "classes",
        "href": "/en-US/docs/Web/JavaScript/Reference/Classes"
      },
      {
        "text": "Object.getPrototypeOf()",
        "href": "/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/getPrototypeOf"
      },
      {
        "text": "Object.setPrototypeOf()",
        "href": "/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/setPrototypeOf"
      },
      {
        "text": "__proto__",
        "href": "/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/proto"
      },
      {
        "text": "__proto__ syntax",
        "href": "/en-US/docs/Web/JavaScript/Reference/Operators/Object_initializer#prototype_setter"
      },
      {
        "text": "getter or setter",
        "href": "/en-US/docs/Web/JavaScript/Guide/Working_with_objects#defining_getters_and_setters"
      },
      {
        "text": "methods",
        "href": "/en-US/docs/Glossary/Method"
      },
      {
        "text": "this",
        "href": "/en-US/docs/Web/JavaScript/Reference/Operators/this"
      },
      {
        "text": "new",
        "href": "/en-US/docs/Web/JavaScript/Reference/Operators/new"
      },
      {
        "text": "prototype",
        "href": "/en-US/docs/Web/JavaScript/Reference/Global_Objects/Function/prototype"
      },
      {
        "text": "constructor",
        "href": "/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/constructor"
      },
      {
        "text": "classes",
        "href": "/en-US/docs/Web/JavaScript/Reference/Classes"
      },
      {
        "text": "map()",
        "href": "/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/map"
      },
      {
        "text": "SmooshGate",
        "href": "https://developer.chrome.com/blog/smooshgate/"
      },
      {
        "text": "Object.setPrototypeOf()",
        "href": "/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/setPrototypeOf"
      },
      {
        "text": "extends",
        "href": "/en-US/docs/Web/JavaScript/Reference/Classes/extends"
      },
      {
        "text": "Object.create()",
        "href": "/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/create"
      },
      {
        "text": "constructor",
        "href": "/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/constructor"
      },
      {
        "text": "Firefox Developer Tools",
        "href": "https://firefox-source-docs.mozilla.org/devtools-user/index.html"
      },
      {
        "text": "Chrome DevTools",
        "href": "https://developer.chrome.com/docs/devtools/"
      },
      {
        "text": "Edge DevTools",
        "href": "https://learn.microsoft.com/en-us/archive/microsoft-edge/legacy/developer/"
      },
      {
        "text": "object initializers",
        "href": "/en-US/docs/Web/JavaScript/Reference/Operators/Object_initializer"
      },
      {
        "text": "Object.prototype.__proto__",
        "href": "/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/proto"
      },
      {
        "text": "Object.create",
        "href": "/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/create"
      },
      {
        "text": "Object.create",
        "href": "/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/create"
      },
      {
        "text": "Object.create()",
        "href": "/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/create"
      },
      {
        "text": "Private elements",
        "href": "/en-US/docs/Web/JavaScript/Reference/Classes/Private_elements"
      },
      {
        "text": "Object.setPrototypeOf()",
        "href": "/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/setPrototypeOf"
      },
      {
        "text": "Object.prototype.__proto__",
        "href": "/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/proto"
      },
      {
        "text": "hasOwnProperty",
        "href": "/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/hasOwnProperty"
      },
      {
        "text": "Object.hasOwn",
        "href": "/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/hasOwn"
      },
      {
        "text": "hasOwnProperty",
        "href": "/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/hasOwnProperty"
      },
      {
        "text": "undefined",
        "href": "/en-US/docs/Web/JavaScript/Reference/Global_Objects/undefined"
      },
      {
        "text": "Learn how to contribute",
        "href": "/en-US/docs/MDN/Community/Getting_started"
      },
      {
        "text": "MDN contributors",
        "href": "/en-US/docs/Web/JavaScript/Guide/Inheritance_and_the_prototype_chain/contributors.txt"
      },
      {
        "text": "View this page on GitHub",
        "href": "https://github.com/mdn/content/blob/main/files/en-us/web/javascript/guide/inheritance_and_the_prototype_chain/index.md?plain=1"
      },
      {
        "text": "Report a problem with this content",
        "href": "https://github.com/mdn/content/issues/new?template=page-report.yml&mdn-url=https%3A%2F%2Fdeveloper.mozilla.org%2Fen-US%2Fdocs%2FWeb%2FJavaScript%2FGuide%2FInheritance_and_the_prototype_chain&metadata=%3C%21--+Do+not+make+changes+below+this+line+--%3E%0A%3Cdetails%3E%0A%3Csummary%3EPage+report+details%3C%2Fsummary%3E%0A%0A*+Folder%3A+%60en-us%2Fweb%2Fjavascript%2Fguide%2Finheritance_and_the_prototype_chain%60%0A*+MDN+URL%3A+https%3A%2F%2Fdeveloper.mozilla.org%2Fen-US%2Fdocs%2FWeb%2FJavaScript%2FGuide%2FInheritance_and_the_prototype_chain%0A*+GitHub+URL%3A+https%3A%2F%2Fgithub.com%2Fmdn%2Fcontent%2Fblob%2Fmain%2Ffiles%2Fen-us%2Fweb%2Fjavascript%2Fguide%2Finheritance_and_the_prototype_chain%2Findex.md%0A*+Last+commit%3A+https%3A%2F%2Fgithub.com%2Fmdn%2Fcontent%2Fcommit%2Ffad67be4431d8e6c2a89ac880735233aa76c41d4%0A*+Document+last+modified%3A+2025-07-08T13%3A18%3A45.000Z%0A%0A%3C%2Fdetails%3E"
      }
    ],
    "meta": {
      "description": "In programming, inheritance refers to passing down characteristics from a parent to a child so that a new piece of code can reuse and build upon the features of an existing one. JavaScript implements inheritance by using objects. Each object has an internal link to another object called its prototype. That prototype object has a prototype of its own, and so on until an object is reached with null as its prototype. By definition, null has no prototype and acts as the final link in this prototype chain. It is possible to mutate any member of the prototype chain or even swap out the prototype at runtime, so concepts like static dispatching do not exist in JavaScript.",
      "keywords": ""
    },
    "summary": "Inheritance and the prototype chain In programming, inheritance refers to passing down characteristics from a parent to a child so that a new piece of code can reuse and build upon the features of an ...",
    "tags": [
      "javascript",
      "typescript",
      "html",
      "vite",
      "inheritance",
      "prototype",
      "chain",
      "inheriting",
      "constructors"
    ],
    "id": "inheritance-and-the-prototype-chain-Inheritance_an-part-1",
    "quality": 100
  },
  {
    "title": "JavaScript execution model",
    "url": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Execution_model",
    "category": "javascript",
    "content": "JavaScript execution model This page introduces the basic infrastructure of the JavaScript runtime environment. The model is largely theoretical and abstract, without any platform-specific or implementation-specific details. Modern JavaScript engines heavily optimize the described semantics. This page is a reference. It assumes you are already familiar with the execution model of other programming languages, such as C and Java. It makes heavy references to existing concepts in operating systems and programming languages. The engine and the host JavaScript execution requires the cooperation of two pieces of software: the JavaScript engine and the host environment. The JavaScript engine implements the ECMAScript (JavaScript) language, providing the core functionality. It takes source code, parses it, and executes it. However, in order to interact with the outside world, such as to produce any meaningful output, to interface with external resources, or to implement security- or performance-related mechanisms, we need additional environment-specific mechanisms provided by the host environment. For example, the HTML DOM is the host environment when JavaScript is executed in a web browser. Node.js is another host environment that allows JavaScript to be run on the server side. While we focus primarily on the mechanisms defined in ECMAScript in this reference, we will occasionally talk about mechanisms defined in the HTML spec, which is often mimicked by other host environments like Node.js or Deno. This way, we can give a coherent picture of the JavaScript execution model as used on the web and beyond. Agent execution model In the JavaScript specification, each autonomous executor of JavaScript is called an agent, which maintains its facilities for code execution: Heap (of objects): this is just a name to denote a large (mostly unstructured) region of memory. It gets populated as objects get created in the program. Note that in the case of shared memory, each agent has its own heap with its own version of a SharedArrayBuffer object, but the underlying memory represented by the buffer is shared. Queue (of jobs): this is known in HTML (and also commonly) as the event loop which enables asynchronous programming in JavaScript while being single-threaded. It's called a queue because it's generally first-in-first-out: earlier jobs are executed before later ones. Stack (of execution contexts): this is what's known as a call stack and allows transferring control flow by entering and exiting execution contexts like functions. It's called a stack because it's last-in-first-out. Every job enters by pushing a new frame onto the (empty) stack, and exits by emptying the stack. These are three distinct data structures that keep track of different data. We will introduce the queue and the stack in more detail in the following sections. To read more about how heap memory is allocated and freed, see memory management. Each agent is analogous to a thread (note that the underlying implementation may or may not be an actual operating system thread). Each agent can own multiple realms (which 1-to-1 correlate with global objects) that can synchronously access each other, and thus needs to run in a single execution thread. An agent also has a single memory model, indicating whether it's little-endian, whether it can be synchronously blocked, whether atomic operations are lock-free, etc. An agent on the web can be one of the following: A Similar-origin window agent, which contains various Window objects which can potentially reach each other, either directly or by using document.domain. If the window is origin-keyed, then only same-origin windows can reach each other. A Dedicated worker agent containing a single DedicatedWorkerGlobalScope. A Shared worker agent containing a single SharedWorkerGlobalScope. A Service worker agent containing a single ServiceWorkerGlobalScope. A Worklet agent containing a single WorkletGlobalScope. In other words, each worker creates its own agent, while one or more windows may be within the same agentusually a main document and its similar-origin iframes. In Node.js, a similar concept called worker threads is available. The diagram below illustrates the execution model of agents: Realms Each agent owns one or more realms. Each piece of JavaScript code is associated with a realm when it's loaded, which remains the same even when called from another realm. A realm consists of the follow information: A list of intrinsic objects like Array, Array.prototype, etc. Globally declared variables, the value of globalThis, and the global object A cache of template literal arrays, because evaluation of the same tagged template literal expression always causes the tag to receive the same array object On the web, the realm and the global object are 1-to-1 corresponded. The global object is either a Window, a WorkerGlobalScope, or a WorkletGlobalScope. So for example, every iframe executes in a different realm, though it may be in the same agent as the parent window. Realms are usually mentioned when talking about the identities of global objects. For example, we need methods such as Array.isArray() or Error.isError(), because an array constructed in another realm will have a different prototype object than the Array.prototype object in the current realm, so instanceof Array will wrongly return false. Stack and execution contexts We first consider synchronous code execution. Each job enters by calling its associated callback. Code inside this callback may create variables, call functions, or exit. Each function needs to keep track of its own variable environments and where to return to. To handle this, the agent needs a stack to keep track of the execution contexts. A execution context, also known generally as a stack frame, is the smallest unit of execution. It tracks the following information: Code evaluation state The module or script, the function (if applicable), and the currently executing generator that contains this code The current realm Bindings, including: Variables defined with var, let, const, function, class, etc. Private identifiers like #foo which are only valid in the current context this reference Imagine a program consisting of a single job defined by the following code: When the job starts, the first frame is created, where the variables foo, bar, and baz are defined. It calls bar with the argument 7. A second frame is created for the bar call, containing bindings for the parameter x and the local variable y. It first performs the multiplication x * y, then calls foo with the result. A third frame is created for the foo call, containing bindings for the parameter b and the local variable a. It first performs the addition a + b + 11, then returns the result. When foo returns, the top frame element is popped out of the stack, and the call expression foo(x * y) resolves to the return value. It then continues execution, which is just to return this result. When bar returns, the top frame element is popped out of the stack, and the call expression bar(7) resolves to the return value. This initializes baz with the return value. We reach the end of the job's source code, so the stack frame for the entrypoint is popped out of the stack. The stack is empty, so the job is considered completed. Generators and reentry When a frame is popped, it's not necessarily gone forever, because sometimes we need to come back to it. For example, consider a generator function: In this case, calling gen() first creates an execution context which is suspendedno code inside gen gets executed yet. The generator g saves this execution context internally. The current running execution context remains to be the entrypoint. When g.next() is called, the execution context for gen is pushed onto the stack, and the code inside gen is executed until the yield expression. Then, the generator execution context gets suspended and removed from the stack, which returns control back to the entrypoint. When g.next() is called again, the generator execution context is pushed back onto the stack, and the code inside gen resumes from where it left off. Tail calls One mechanism defined in the specification is proper tail call (PTC). A function call is a tail call if the caller does nothing after the call except return the value: In this case, the call to g is a tail call. If a function call is in tail position, the engine is required to discard the current execution context and replace it with the context of the tail call, instead of pushing a new frame for the g() call. This means that tail recursion is not subject to the stack size limits: In reality, discarding the current frame causes debugging problems, because if g() throws an error, f is no longer on the stack and won't appear in the stack trace. Currently, only Safari (JavaScriptCore) implements PTC, and they have invented some specific infrastructure to address the debuggability issue. Closures Another interesting phenomenon related to variable scoping and function calls is closures. Whenever a function is created, it also memorizes internally the variable bindings of the current running execution context. Then, these variable bindings can outlive the execution context. Job queue and event loop An agent is a thread, which means the interpreter can only process one statement at a time. When the code is all synchronous, this is fine because we can always make progress. But if the code needs to perform asynchronous action, then we cannot progress unless that action is completed. However, it would be detrimental to user experience if that halts the whole programthe nature of JavaScript as a web scripting language requires it to be never blocking. Therefore, the code that handles the completion of that asynchronous action is defined as a callback. This callback defines a job, which gets placed into a job queueor, in HTML terminology, an event looponce the action is completed. Every time, the agent pulls a job from the queue and executes it. When the job is executed, it may create more jobs, which are added to the end of the queue. Jobs can also be added via the completion of asynchronous platform mechanisms, such as timers, I/O, and events. A job is considered completed when the stack is empty; then, the next job is pulled from the queue. Jobs might not be pulled with uniform priorityfor example, HTML event loops split jobs into two categories: tasks and microtasks. Microtasks have higher priority and the microtask queue is drained first before the task queue is pulled. For more information, check the HTML microtask guide. If the job queue is empty, the agent waits for more jobs to be added. \"Run-to-completion\" Each job is processed completely before any other job is processed. This offers some nice properties when reasoning about your program, including the fact that whenever a function runs, it cannot be preempted and will run entirely before any other code runs (and can modify data the function manipulates). This differs from C, for instance, where if a function runs in a thread, it may be stopped at any point by the runtime system to run some other code in another thread. For example, consider this example: In this example, we create an already-resolved promise, which means any callback attached to it will be immediately scheduled as jobs. The two callbacks seem to cause a race condition, but actually, the output is fully predictable: 1 and 2 will be logged in order. This is because each job runs to completion before the next one is executed, so the overall order is always i += 1; console.log(i); i += 1; console.log(i); and never i += 1; i += 1; console.log(i); console.log(i);. A downside of this model is that if a job takes too long to complete, the web application is unable to process user interactions like click or scroll. The browser mitigates this with the \"a script is taking too long to run\" dialog. A good practice to follow is to make job processing short and if possible cut down one job into several jobs. Never blocking Another important guarantee offered by the event loop model is that JavaScript execution is never blocking. Handling I/O is typically performed via events and callbacks, so when the application is waiting for an IndexedDB query to return or a fetch() request to return, it can still process other things like user input. The code that executes after the completion of an asynchronous action is always provided as a callback function (for example, the promise then() handler, the callback function in setTimeout(), or the event handler), which defines a job to be added to the job queue once the action completes. Of course, the guarantee of \"never-blocking\" requires the platform API to be inherently asynchronous, but some legacy exceptions exist like alert() or synchronous XHR. It is considered good practice to avoid them to ensure the responsiveness of the application. Agent clusters and memory sharing Multiple agents can communicate via memory sharing, forming an agent cluster. Agents are within the same cluster if and only if they can share memory. There is no built-in mechanism for two agent clusters to exchange any information, so they can be regarded as completely isolated execution models. When creating an agent (such as by spawning a worker), there are some criteria for whether it's in the same cluster as the current agent, or a new cluster is created. For example, the following pairs of global objects are each within the same agent cluster, and thus can share memory with each other: A Window object and a dedicated worker that it created. A worker (of any type) and a dedicated worker it created. A Window object A and the Window object of a same-origin iframe element that A created. A Window object and a same-origin Window object that opened it. A Window object and a worklet that it created. The following pairs of global objects are not within the same agent cluster, and thus cannot share memory: A Window object and a shared worker it created. A worker (of any type) and a shared worker it created. A Window object and a service worker it created. A Window object A and the Window object of an iframe element that A created that cannot be same origin-domain with A. Any two Window objects with no opener or ancestor relationship. This holds even if the two Window objects are same origin. For the exact algorithm, check the HTML specification. Cross-agent communication and memory model As aforementioned, agents communicate via memory sharing. On the web, memory is shared via the postMessage() method. The using web workers guide provides an overview of this. Typically, data is passed by value only (via structured cloning), and therefore does not involve any concurrency complications. To share memory, one must post a SharedArrayBuffer object, which can be simultaneously accessed by multiple agents. Once two agents share access to the same memory via a SharedArrayBuffer, they can synchronize executions via the Atomics object. There are two ways to access shared memory: via normal memory access (which is not atomic) and via atomic memory access. The latter is sequentially consistent (which means there is a strict total ordering of events agreed upon by all agents in the cluster), while the former is unordered (which means no ordering exists); JavaScript does not provide operations with other ordering guarantees. The spec provides the following guidelines for programmers working with shared memory: We recommend programs be kept data race free, i.e., make it so that it is impossible for there to be concurrent non-atomic operations on the same memory location. Data race free programs have interleaving semantics where each step in the evaluation semantics of each agent are interleaved with each other. For data race free programs, it is not necessary to understand the details of the memory model. The details are unlikely to build intuition that will help one to better write ECMAScript. More generally, even if a program is not data race free it may have predictable behavior, so long as atomic operations are not involved in any data races and the operations that race all have the same access size. The simplest way to arrange for atomics not to be involved in races is to ensure that different memory cells are used by atomic and non-atomic operations and that atomic accesses of different sizes are not used to access the same cells at the same time. Effectively, the program should treat shared memory as strongly typed as much as possible. One still cannot depend on the ordering and timing of non-atomic accesses that race, but if memory is treated as strongly typed the racing accesses will not \"tear\" (bits of their values will not be mixed). Concurrency and ensuring forward progress When multiple agents cooperate, the never-blocking guarantee does not always hold. An agent can become blocked, or paused, while waiting for another agent to perform some action. This is different from waiting on a promise in the same agent, because it halts the entire agent and does not allow any other code to run in the meantimein other words, it cannot make forward progress. To prevent deadlocks, there are some strong restrictions on when and which agents can become blocked. Every unblocked agent with a dedicated executing thread eventually makes forward progress. In a set of agents that share an executing thread, one agent eventually makes forward progress. An agent does not cause another agent to become blocked except via explicit APIs that provide blocking. Only certain agents can be blocked. On the web, this includes dedicated workers and shared workers, but not similar-origin windows or service workers. The agent cluster ensures some level of integrity over the activeness of its agents, in the case of external pauses or terminations: An agent may be paused or resumed without its knowledge or cooperation. For example, navigating away from a window may suspend code execution but preserve its state. However, an agent cluster is not allowed to be partially deactivated, to avoid an agent starving because another agent has been deactivated. For example, shared workers are never in the same agent cluster as the creator window or other dedicated workers. This is because a shared worker's lifetime is independent of documents: if a document is deactivated while its dedicated worker holds a lock, the shared worker is blocked from acquiring the lock until the dedicated worker is reactivated, if ever. Meanwhile other workers trying to access the shared worker from other windows will starve. Similarly, an agent may be terminated by factors external to the cluster. For example, operating systems or users killing a browser process, or the browser force-terminating one agent because it's using too many resources. In this case, all the agents in the cluster get terminated. (The spec also allows a second strategy, which is an API that allows at least one remaining member of the cluster to identify the termination and the agent that was terminated, but this is not implemented on the web.) Specifications Specification ECMAScript 2026 Language Specification ECMAScript 2026 Language Specification HTML See also Event loops in the HTML standard What is the Event Loop? in the Node.js docs Help improve MDN Learn how to contribute This page was last modified on Jul 8, 2025 by MDN contributors. View this page on GitHub  Report a problem with this content",
    "headings": [
      {
        "level": 1,
        "text": "JavaScript execution model",
        "id": ""
      },
      {
        "level": 2,
        "text": "The engine and the host",
        "id": "the_engine_and_the_host"
      },
      {
        "level": 2,
        "text": "Agent execution model",
        "id": "agent_execution_model"
      },
      {
        "level": 2,
        "text": "Realms",
        "id": "realms"
      },
      {
        "level": 2,
        "text": "Stack and execution contexts",
        "id": "stack_and_execution_contexts"
      },
      {
        "level": 2,
        "text": "Job queue and event loop",
        "id": "job_queue_and_event_loop"
      },
      {
        "level": 2,
        "text": "Agent clusters and memory sharing",
        "id": "agent_clusters_and_memory_sharing"
      },
      {
        "level": 2,
        "text": "Specifications",
        "id": "specifications"
      },
      {
        "level": 2,
        "text": "See also",
        "id": "see_also"
      },
      {
        "level": 2,
        "text": "Help improve MDN",
        "id": "feedback"
      },
      {
        "level": 3,
        "text": "Generators and reentry",
        "id": "generators_and_reentry"
      },
      {
        "level": 3,
        "text": "Tail calls",
        "id": "tail_calls"
      },
      {
        "level": 3,
        "text": "Closures",
        "id": "closures"
      },
      {
        "level": 3,
        "text": "\"Run-to-completion\"",
        "id": "run-to-completion"
      },
      {
        "level": 3,
        "text": "Never blocking",
        "id": "never_blocking"
      },
      {
        "level": 3,
        "text": "Cross-agent communication and memory model",
        "id": "cross-agent_communication_and_memory_model"
      },
      {
        "level": 3,
        "text": "Concurrency and ensuring forward progress",
        "id": "concurrency_and_ensuring_forward_progress"
      }
    ],
    "codeBlocks": [
      {
        "language": "text",
        "code": "SharedArrayBuffer"
      },
      {
        "language": "text",
        "code": "document.domain"
      },
      {
        "language": "text",
        "code": "DedicatedWorkerGlobalScope"
      },
      {
        "language": "text",
        "code": "SharedWorkerGlobalScope"
      },
      {
        "language": "text",
        "code": "ServiceWorkerGlobalScope"
      },
      {
        "language": "text",
        "code": "WorkletGlobalScope"
      },
      {
        "language": "text",
        "code": "Array.prototype"
      },
      {
        "language": "text",
        "code": "WorkerGlobalScope"
      },
      {
        "language": "text",
        "code": "WorkletGlobalScope"
      },
      {
        "language": "text",
        "code": "Array.isArray()"
      },
      {
        "language": "text",
        "code": "Error.isError()"
      },
      {
        "language": "text",
        "code": "Array.prototype"
      },
      {
        "language": "text",
        "code": "instanceof Array"
      },
      {
        "language": "text",
        "code": "i += 1; console.log(i); i += 1; console.log(i);"
      },
      {
        "language": "text",
        "code": "i += 1; i += 1; console.log(i); console.log(i);"
      },
      {
        "language": "text",
        "code": "setTimeout()"
      },
      {
        "language": "text",
        "code": "postMessage()"
      },
      {
        "language": "text",
        "code": "SharedArrayBuffer"
      },
      {
        "language": "text",
        "code": "SharedArrayBuffer"
      }
    ],
    "links": [
      {
        "text": "ECMAScript (JavaScript) language",
        "href": "/en-US/docs/Web/JavaScript/Reference/JavaScript_technologies_overview#javascript_the_core_language_ecmascript"
      },
      {
        "text": "SharedArrayBuffer",
        "href": "/en-US/docs/Web/JavaScript/Reference/Global_Objects/SharedArrayBuffer"
      },
      {
        "text": "memory management",
        "href": "/en-US/docs/Web/JavaScript/Guide/Memory_management"
      },
      {
        "text": "lock-free",
        "href": "/en-US/docs/Web/JavaScript/Reference/Global_Objects/Atomics/isLockFree"
      },
      {
        "text": "Window",
        "href": "/en-US/docs/Web/API/Window"
      },
      {
        "text": "document.domain",
        "href": "/en-US/docs/Web/API/Document/domain"
      },
      {
        "text": "origin-keyed",
        "href": "/en-US/docs/Web/API/Window/originAgentCluster"
      },
      {
        "text": "DedicatedWorkerGlobalScope",
        "href": "/en-US/docs/Web/API/DedicatedWorkerGlobalScope"
      },
      {
        "text": "SharedWorkerGlobalScope",
        "href": "/en-US/docs/Web/API/SharedWorkerGlobalScope"
      },
      {
        "text": "ServiceWorkerGlobalScope",
        "href": "/en-US/docs/Web/API/ServiceWorkerGlobalScope"
      },
      {
        "text": "WorkletGlobalScope",
        "href": "/en-US/docs/Web/API/WorkletGlobalScope"
      },
      {
        "text": "worker threads",
        "href": "https://nodejs.org/api/worker_threads.html"
      },
      {
        "text": "globalThis",
        "href": "/en-US/docs/Web/JavaScript/Reference/Global_Objects/globalThis"
      },
      {
        "text": "template literal arrays",
        "href": "/en-US/docs/Web/JavaScript/Reference/Template_literals#tagged_templates"
      },
      {
        "text": "Window",
        "href": "/en-US/docs/Web/API/Window"
      },
      {
        "text": "WorkerGlobalScope",
        "href": "/en-US/docs/Web/API/WorkerGlobalScope"
      },
      {
        "text": "WorkletGlobalScope",
        "href": "/en-US/docs/Web/API/WorkletGlobalScope"
      },
      {
        "text": "Array.isArray()",
        "href": "/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/isArray"
      },
      {
        "text": "Error.isError()",
        "href": "/en-US/docs/Web/JavaScript/Reference/Global_Objects/Error/isError"
      },
      {
        "text": "generator",
        "href": "/en-US/docs/Web/JavaScript/Reference/Global_Objects/Generator"
      },
      {
        "text": "Bindings",
        "href": "/en-US/docs/Glossary/Binding"
      },
      {
        "text": "specific infrastructure",
        "href": "https://webkit.org/blog/6240/ecmascript-6-proper-tail-calls-in-webkit/"
      },
      {
        "text": "closures",
        "href": "/en-US/docs/Web/JavaScript/Guide/Closures"
      },
      {
        "text": "HTML microtask guide",
        "href": "/en-US/docs/Web/API/HTML_DOM_API/Microtask_guide"
      },
      {
        "text": "IndexedDB",
        "href": "/en-US/docs/Web/API/IndexedDB_API"
      },
      {
        "text": "fetch()",
        "href": "/en-US/docs/Web/API/Window/fetch"
      },
      {
        "text": "then()",
        "href": "/en-US/docs/Web/JavaScript/Reference/Global_Objects/Promise/then"
      },
      {
        "text": "HTML specification",
        "href": "https://html.spec.whatwg.org/multipage/webappapis.html#integration-with-the-javascript-agent-cluster-formalism"
      },
      {
        "text": "postMessage()",
        "href": "/en-US/docs/Web/API/Window/postMessage"
      },
      {
        "text": "using web workers",
        "href": "/en-US/docs/Web/API/Web_Workers_API/Using_web_workers"
      },
      {
        "text": "structured cloning",
        "href": "/en-US/docs/Web/API/Web_Workers_API/Structured_clone_algorithm"
      },
      {
        "text": "SharedArrayBuffer",
        "href": "/en-US/docs/Web/JavaScript/Reference/Global_Objects/SharedArrayBuffer"
      },
      {
        "text": "Atomics",
        "href": "/en-US/docs/Web/JavaScript/Reference/Global_Objects/Atomics"
      },
      {
        "text": "sequentially consistent",
        "href": "https://en.wikipedia.org/wiki/Sequential_consistency"
      },
      {
        "text": "ECMAScript® 2026 Language Specification",
        "href": "https://tc39.es/ecma262/multipage/executable-code-and-execution-contexts.html"
      },
      {
        "text": "ECMAScript® 2026 Language Specification",
        "href": "https://tc39.es/ecma262/multipage/memory-model.html"
      },
      {
        "text": "HTML",
        "href": "https://html.spec.whatwg.org/multipage/webappapis.html"
      },
      {
        "text": "Event loops",
        "href": "https://html.spec.whatwg.org/multipage/webappapis.html#event-loops"
      },
      {
        "text": "What is the Event Loop?",
        "href": "https://nodejs.org/en/learn/asynchronous-work/event-loop-timers-and-nexttick#what-is-the-event-loop"
      },
      {
        "text": "Learn how to contribute",
        "href": "/en-US/docs/MDN/Community/Getting_started"
      },
      {
        "text": "MDN contributors",
        "href": "/en-US/docs/Web/JavaScript/Reference/Execution_model/contributors.txt"
      },
      {
        "text": "View this page on GitHub",
        "href": "https://github.com/mdn/content/blob/main/files/en-us/web/javascript/reference/execution_model/index.md?plain=1"
      },
      {
        "text": "Report a problem with this content",
        "href": "https://github.com/mdn/content/issues/new?template=page-report.yml&mdn-url=https%3A%2F%2Fdeveloper.mozilla.org%2Fen-US%2Fdocs%2FWeb%2FJavaScript%2FReference%2FExecution_model&metadata=%3C%21--+Do+not+make+changes+below+this+line+--%3E%0A%3Cdetails%3E%0A%3Csummary%3EPage+report+details%3C%2Fsummary%3E%0A%0A*+Folder%3A+%60en-us%2Fweb%2Fjavascript%2Freference%2Fexecution_model%60%0A*+MDN+URL%3A+https%3A%2F%2Fdeveloper.mozilla.org%2Fen-US%2Fdocs%2FWeb%2FJavaScript%2FReference%2FExecution_model%0A*+GitHub+URL%3A+https%3A%2F%2Fgithub.com%2Fmdn%2Fcontent%2Fblob%2Fmain%2Ffiles%2Fen-us%2Fweb%2Fjavascript%2Freference%2Fexecution_model%2Findex.md%0A*+Last+commit%3A+https%3A%2F%2Fgithub.com%2Fmdn%2Fcontent%2Fcommit%2Ffad67be4431d8e6c2a89ac880735233aa76c41d4%0A*+Document+last+modified%3A+2025-07-08T13%3A18%3A45.000Z%0A%0A%3C%2Fdetails%3E"
      }
    ],
    "meta": {
      "description": "This page introduces the basic infrastructure of the JavaScript runtime environment. The model is largely theoretical and abstract, without any platform-specific or implementation-specific details. Modern JavaScript engines heavily optimize the described semantics.",
      "keywords": ""
    },
    "summary": "JavaScript execution model This page introduces the basic infrastructure of the JavaScript runtime environment",
    "tags": [
      "react",
      "angular",
      "javascript",
      "typescript",
      "css",
      "html",
      "node",
      "vite",
      "execution",
      "model"
    ],
    "id": "javascript-execution-model-Execution_model-part-1",
    "quality": 100
  },
  {
    "title": "Fetch API",
    "url": "https://developer.mozilla.org/en-US/docs/Web/API/Fetch_API",
    "category": "javascript",
    "content": "Fetch API Baseline Widely available * This feature is well established and works across many devices and browser versions. Its been available across browsers since March 2017. * Some parts of this feature may have varying levels of support. Learn more See full compatibility Report feedback Note: This feature is available in Web Workers. The Fetch API provides an interface for fetching resources (including across the network). It is a more powerful and flexible replacement for XMLHttpRequest. Concepts and usage The Fetch API uses Request and Response objects (and other things involved with network requests), as well as related concepts such as CORS and the HTTP Origin header semantics. For making a request and fetching a resource, use the fetch() method. It is a global method in both Window and Worker contexts. This makes it available in pretty much any context you might want to fetch resources in. The fetch() method takes one mandatory argument, the path to the resource you want to fetch. It returns a Promise that resolves to the Response to that request  as soon as the server responds with headers  even if the server response is an HTTP error status. You can also optionally pass in an init options object as the second argument (see Request). Once a Response is retrieved, there are a number of methods available to define what the body content is and how it should be handled. You can create a request and response directly using the Request() and Response() constructors, but it's uncommon to do this directly. Instead, these are more likely to be created as results of other API actions (for example, FetchEvent.respondWith() from service workers). Find out more about using the Fetch API features in Using Fetch. Interfaces Window.fetch() and WorkerGlobalScope.fetch() The fetch() method used to fetch a resource. Headers Represents response/request headers, allowing you to query them and take different actions depending on the results. Request Represents a resource request. Response Represents the response to a request. Specifications Specification Fetch# fetch-method Browser compatibility See also Using Fetch Service Worker API HTTP access control (CORS) HTTP Help improve MDN Learn how to contribute This page was last modified on Apr 9, 2025 by MDN contributors. View this page on GitHub  Report a problem with this content",
    "headings": [
      {
        "level": 1,
        "text": "Fetch API",
        "id": ""
      },
      {
        "level": 2,
        "text": "Concepts and usage",
        "id": "concepts_and_usage"
      },
      {
        "level": 2,
        "text": "Interfaces",
        "id": "interfaces"
      },
      {
        "level": 2,
        "text": "Specifications",
        "id": "specifications"
      },
      {
        "level": 2,
        "text": "Browser compatibility",
        "id": "browser_compatibility"
      },
      {
        "level": 2,
        "text": "See also",
        "id": "see_also"
      },
      {
        "level": 2,
        "text": "Help improve MDN",
        "id": "feedback"
      }
    ],
    "codeBlocks": [
      {
        "language": "text",
        "code": "XMLHttpRequest"
      },
      {
        "language": "text",
        "code": "FetchEvent.respondWith()"
      },
      {
        "language": "text",
        "code": "Window.fetch()"
      },
      {
        "language": "text",
        "code": "WorkerGlobalScope.fetch()"
      }
    ],
    "links": [
      {
        "text": "Learn more",
        "href": "/en-US/docs/Glossary/Baseline/Compatibility"
      },
      {
        "text": "Report feedback",
        "href": "https://survey.alchemer.com/s3/7634825/MDN-baseline-feedback?page=%2Fen-US%2Fdocs%2FWeb%2FAPI%2FFetch_API&level=high"
      },
      {
        "text": "Web Workers",
        "href": "/en-US/docs/Web/API/Web_Workers_API"
      },
      {
        "text": "XMLHttpRequest",
        "href": "/en-US/docs/Web/API/XMLHttpRequest"
      },
      {
        "text": "Request",
        "href": "/en-US/docs/Web/API/Request"
      },
      {
        "text": "Response",
        "href": "/en-US/docs/Web/API/Response"
      },
      {
        "text": "fetch()",
        "href": "/en-US/docs/Web/API/Window/fetch"
      },
      {
        "text": "Window",
        "href": "/en-US/docs/Web/API/Window"
      },
      {
        "text": "Worker",
        "href": "/en-US/docs/Web/API/WorkerGlobalScope"
      },
      {
        "text": "Promise",
        "href": "/en-US/docs/Web/JavaScript/Reference/Global_Objects/Promise"
      },
      {
        "text": "Response",
        "href": "/en-US/docs/Web/API/Response"
      },
      {
        "text": "Request",
        "href": "/en-US/docs/Web/API/Request"
      },
      {
        "text": "Response",
        "href": "/en-US/docs/Web/API/Response"
      },
      {
        "text": "Request()",
        "href": "/en-US/docs/Web/API/Request/Request"
      },
      {
        "text": "Response()",
        "href": "/en-US/docs/Web/API/Response/Response"
      },
      {
        "text": "FetchEvent.respondWith()",
        "href": "/en-US/docs/Web/API/FetchEvent/respondWith"
      },
      {
        "text": "Using Fetch",
        "href": "/en-US/docs/Web/API/Fetch_API/Using_Fetch"
      },
      {
        "text": "Window.fetch()",
        "href": "/en-US/docs/Web/API/Window/fetch"
      },
      {
        "text": "WorkerGlobalScope.fetch()",
        "href": "/en-US/docs/Web/API/WorkerGlobalScope/fetch"
      },
      {
        "text": "Headers",
        "href": "/en-US/docs/Web/API/Headers"
      },
      {
        "text": "Request",
        "href": "/en-US/docs/Web/API/Request"
      },
      {
        "text": "Response",
        "href": "/en-US/docs/Web/API/Response"
      },
      {
        "text": "Fetch# fetch-method",
        "href": "https://fetch.spec.whatwg.org/#fetch-method"
      },
      {
        "text": "Using Fetch",
        "href": "/en-US/docs/Web/API/Fetch_API/Using_Fetch"
      },
      {
        "text": "Service Worker API",
        "href": "/en-US/docs/Web/API/Service_Worker_API"
      },
      {
        "text": "HTTP access control (CORS)",
        "href": "/en-US/docs/Web/HTTP/Guides/CORS"
      },
      {
        "text": "HTTP",
        "href": "/en-US/docs/Web/HTTP"
      },
      {
        "text": "Learn how to contribute",
        "href": "/en-US/docs/MDN/Community/Getting_started"
      },
      {
        "text": "MDN contributors",
        "href": "/en-US/docs/Web/API/Fetch_API/contributors.txt"
      },
      {
        "text": "View this page on GitHub",
        "href": "https://github.com/mdn/content/blob/main/files/en-us/web/api/fetch_api/index.md?plain=1"
      },
      {
        "text": "Report a problem with this content",
        "href": "https://github.com/mdn/content/issues/new?template=page-report.yml&mdn-url=https%3A%2F%2Fdeveloper.mozilla.org%2Fen-US%2Fdocs%2FWeb%2FAPI%2FFetch_API&metadata=%3C%21--+Do+not+make+changes+below+this+line+--%3E%0A%3Cdetails%3E%0A%3Csummary%3EPage+report+details%3C%2Fsummary%3E%0A%0A*+Folder%3A+%60en-us%2Fweb%2Fapi%2Ffetch_api%60%0A*+MDN+URL%3A+https%3A%2F%2Fdeveloper.mozilla.org%2Fen-US%2Fdocs%2FWeb%2FAPI%2FFetch_API%0A*+GitHub+URL%3A+https%3A%2F%2Fgithub.com%2Fmdn%2Fcontent%2Fblob%2Fmain%2Ffiles%2Fen-us%2Fweb%2Fapi%2Ffetch_api%2Findex.md%0A*+Last+commit%3A+https%3A%2F%2Fgithub.com%2Fmdn%2Fcontent%2Fcommit%2F31ba9f6da2dd1175250ece8d8d467d523e79b447%0A*+Document+last+modified%3A+2025-04-09T12%3A12%3A12.000Z%0A%0A%3C%2Fdetails%3E"
      }
    ],
    "meta": {
      "description": "The Fetch API provides an interface for fetching resources (including across the network). It is a more powerful and flexible replacement for XMLHttpRequest.",
      "keywords": ""
    },
    "summary": "Fetch API Baseline Widely available * This feature is well established and works across many devices and browser versions. Its been available across browsers since March 2017",
    "tags": [
      "angular",
      "javascript",
      "typescript",
      "html",
      "node",
      "vite",
      "fetch",
      "api",
      "concepts",
      "usage"
    ],
    "id": "fetch-api-Fetch_API-part-1",
    "quality": 90
  }
]